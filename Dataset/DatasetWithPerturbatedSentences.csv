index,project,relativePath,absolutePath,methodName,spanMethod,wholeMethod,body,javaDoc,coverage,tokensPerMethod,javaDocFirstSentence,tokensFirstLine,perturbatedJavaDocSentence
0,dcache,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,hasExpired,175-183,"/**
     * This function checks whether our parent should expunge us.
     */
public boolean hasExpired(){
    Date now = new Date();
    return _whenIShouldExpire != null ? !now.before(_whenIShouldExpire) : false;
}","public boolean hasExpired(){
    Date now = new Date();
    return _whenIShouldExpire != null ? !now.before(_whenIShouldExpire) : false;
}","/**
     * This function checks whether our parent should expunge us.
     */","('hasExpired', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,  This function checks whether our parent should expunge us.,10.0,"['The function checks to see if our parent will expunge us.', 'The function checks if our parent should expunge us.', 'The function checks to see if our parent should take us away.']"
1,matsim-libs,org/matsim/core/replanning/StrategyManager.java,/matsim/src/main/java/org/matsim/core/replanning/StrategyManager.java,addStrategy,109-120,"/**
	 * Adds a strategy to this manager with the specified weight. This weight
	 * compared to the sum of weights of all strategies in this manager defines
	 * the probability this strategy will be used for an agent.
	 *
	 */
public final void addStrategy(final PlanStrategy strategy, final String subpopulation, final double weight){
    delegate.addStrategy(strategy, subpopulation, weight);
}","public final void addStrategy(final PlanStrategy strategy, final String subpopulation, final double weight){
    delegate.addStrategy(strategy, subpopulation, weight);
}","/**
	 * Adds a strategy to this manager with the specified weight. This weight
	 * compared to the sum of weights of all strategies in this manager defines
	 * the probability this strategy will be used for an agent.
	 *
	 */","('addStrategy', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,  Adds a strategy to this manager with the specified weight.,11.0,"['A strategy is added to this manager.', 'This manager has a strategy with a specified weight.', 'A strategy is added to this manager with the specified weight.']"
2,jackson-databind,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,addMixIn,1502-1518,"/**
     * Method to use for adding mix-in annotations to use for augmenting
     * specified class or interface. All annotations from
     * <code>mixinSource</code> are taken to override annotations
     * that <code>target</code> (or its supertypes) has.
     *
     * @param target Class (or interface) whose annotations to effectively override
     * @param mixinSource Class (or interface) whose annotations are to
     *   be ""added"" to target's annotations, overriding as necessary
     *
     * @since 2.5
     */
public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource){
    _mixIns.addLocalDefinition(target, mixinSource);
    return this;
}","public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource){
    _mixIns.addLocalDefinition(target, mixinSource);
    return this;
}","/**
     * Method to use for adding mix-in annotations to use for augmenting
     * specified class or interface. All annotations from
     * <code>mixinSource</code> are taken to override annotations
     * that <code>target</code> (or its supertypes) has.
     *
     * @param target Class (or interface) whose annotations to effectively override
     * @param mixinSource Class (or interface) whose annotations are to
     *   be ""added"" to target's annotations, overriding as necessary
     *
     * @since 2.5
     */","('addMixIn', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,  Method to use for adding mix-in annotations to use for augmenting  specified class or interface.,16.0,"['Adding mix-in annotations is a method to use.', 'Adding mix-in annotations is a method to use for augmenting class or interface.', 'Adding mix-in annotations is a method used for augmenting class or interface.']"
3,matsim-libs,org/matsim/api/core/v01/Id.java,/matsim/src/main/java/org/matsim/api/core/v01/Id.java,compareTo,127-136,"/**
	 * @return <code>0</code> when the two objects being compared are the same objects, other values according to their ids being compared to each other.
	 *
	 * @throws IllegalArgumentException when the two objects being compared have the same id, but are not the same object because this means they must have different generic types
	 */
public int compareTo(Id<T> o) throws IllegalArgumentException{
    return this.toString().compareTo(o.toString());
}","public int compareTo(Id<T> o) throws IllegalArgumentException{
    return this.toString().compareTo(o.toString());
}","/**
	 * @return <code>0</code> when the two objects being compared are the same objects, other values according to their ids being compared to each other.
	 *
	 * @throws IllegalArgumentException when the two objects being compared have the same id, but are not the same object because this means they must have different generic types
	 */","('compareTo', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,"@return <code>0</code> when the two objects being compared are the same objects, other values according to their ids being compared to each other.",32.0,"['When the two objects being compared are the same objects, other values are also compared to each other.', 'When the two objects being compared are the same objects, other values are added to their ids.', 'When the two objects being compared are the same objects, other values are added.']"
4,mybatis-3,org/apache/ibatis/io/VFS.java,/src/main/java/org/apache/ibatis/io/VFS.java,addImplClass,91-101,"/**
   * Adds the specified class to the list of {@link VFS} implementations. Classes added in this
   * manner are tried in the order they are added and before any of the built-in implementations.
   *
   * @param clazz The {@link VFS} implementation class to add.
   */
public static void addImplClass(Class<? extends VFS> clazz){
    if (clazz != null) {
        USER_IMPLEMENTATIONS.add(clazz);
    }
}","public static void addImplClass(Class<? extends VFS> clazz){
    if (clazz != null) {
        USER_IMPLEMENTATIONS.add(clazz);
    }
}","/**
   * Adds the specified class to the list of {@link VFS} implementations. Classes added in this
   * manner are tried in the order they are added and before any of the built-in implementations.
   *
   * @param clazz The {@link VFS} implementation class to add.
   */","('addImplClass', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,  Adds the specified class to the list of {@link VFS} implementations.,15.0,"['The specified class is added to the list of @link VFS implementations.', 'The specified class is added to the list.', 'The specified class is added to the list of VFS implementations.']"
5,openapi-generator,org/openapitools/codegen/validation/ValidationRule.java,/modules/openapi-generator-core/src/main/java/org/openapitools/codegen/validation/ValidationRule.java,empty,87-94,"/**
     * Constructs an empty rule (useful for testing).
     *
     * @return An ""empty"" rule.
     */
 static ValidationRule empty(){
    return new ValidationRule(Severity.ERROR, ""empty"", ""failure message"", (i) -> Fail.empty());
}"," static ValidationRule empty(){
    return new ValidationRule(Severity.ERROR, ""empty"", ""failure message"", (i) -> Fail.empty());
}","/**
     * Constructs an empty rule (useful for testing).
     *
     * @return An ""empty"" rule.
     */","('empty', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,  Constructs an empty rule (useful for testing).,10.0,"['An empty rule is useful for testing.', 'An empty rule is useful in testing.', 'Useful for testing.']"
6,tablesaw,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,xTabCounts,1249-1256,"/**
   * Returns a table with n by m + 1 cells. The first column contains labels, the other cells
   * contains the counts for every unique combination of values from the two specified columns in
   * this table.
   */
public Table xTabCounts(String column1Name, String column2Name){
    return CrossTab.counts(this, categoricalColumn(column1Name), categoricalColumn(column2Name));
}","public Table xTabCounts(String column1Name, String column2Name){
    return CrossTab.counts(this, categoricalColumn(column1Name), categoricalColumn(column2Name));
}","/**
   * Returns a table with n by m + 1 cells. The first column contains labels, the other cells
   * contains the counts for every unique combination of values from the two specified columns in
   * this table.
   */","('xTabCounts', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,Returns a table with n by m + 1 cells.,11.0,"['The table has n by m and 1 cells.', 'A table with n by m and 1 cells is returned.', 'A table with n by m and 1 cells.']"
7,tablesaw,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,row,712-717,"/** Returns a new Row object with its position set to the given zero-based row index. */
public Row row(int rowIndex){
    Row row = new Row(Table.this);
    row.at(rowIndex);
    return row;
}","public Row row(int rowIndex){
    Row row = new Row(Table.this);
    row.at(rowIndex);
    return row;
}",/** Returns a new Row object with its position set to the given zero-based row index. */,"('row', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0, Returns a new Row object with its position set to the given zero-based row index.,16.0,"['A new Row object with its position set to the zero-based row index is returned.', 'A new Row object is returned with its position set to the zero-based row index.', 'A new row object is returned with its position set to the zero-based row index.']"
8,dcache,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,buildChildPath,675-685,"/**
     * Build a child's StatePath, taking into account that a path may be null (this one-liner is
     * repeated fairly often)
     *
     * @param ourPath   our current path, or null if we are the root StateComposite
     * @param childName the name of the child.
     * @return
     */
private StatePath buildChildPath(StatePath ourPath, String childName){
    return ourPath != null ? ourPath.newChild(childName) : new StatePath(childName);
}","private StatePath buildChildPath(StatePath ourPath, String childName){
    return ourPath != null ? ourPath.newChild(childName) : new StatePath(childName);
}","/**
     * Build a child's StatePath, taking into account that a path may be null (this one-liner is
     * repeated fairly often)
     *
     * @param ourPath   our current path, or null if we are the root StateComposite
     * @param childName the name of the child.
     * @return
     */","('buildChildPath', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,"  Build a child's StatePath, taking into account that a path may be null (this one-liner is  repeated fairly often)   @param ourPath our current path, or null if we are the root StateComposite  @param childName the name of the child.",47.0,"[""Take into account that a path may be null and build a child's StatePath."", ""Take into account that a path may be null and build a child's StatePath, naming the child's name."", ""Take into account that a path may be null, and build a child's StatePath, naming the child's name.""]"
9,dcache,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,becomeMortal,202-210,"/**
     * Initialise our expiry time to some point in the future.
     *
     * @param lifetime the time, in seconds.
     */
private void becomeMortal(long lifetime){
    _whenIShouldExpire = new Date(System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(lifetime));
}","private void becomeMortal(long lifetime){
    _whenIShouldExpire = new Date(System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(lifetime));
}","/**
     * Initialise our expiry time to some point in the future.
     *
     * @param lifetime the time, in seconds.
     */","('becomeMortal', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,  Initialise our expiry time to some point in the future.,11.0,"['We should initialise our time in the future.', 'We should initialise our time to the future.', 'We should initialise our time to come.']"
10,shenyu,org/apache/shenyu/common/utils/DateUtils.java,/shenyu-common/src/main/java/org/apache/shenyu/common/utils/DateUtils.java,formatLocalDateTimeFromTimestamp,81-89,"/**
     * Format local date time from timestamp local date time.
     *
     * @param timestamp the timestamp
     * @return the local date time
     */
public static LocalDateTime formatLocalDateTimeFromTimestamp(final Long timestamp){
    return LocalDateTime.ofEpochSecond(timestamp / 1000, 0, ZoneOffset.ofHours(8));
}","public static LocalDateTime formatLocalDateTimeFromTimestamp(final Long timestamp){
    return LocalDateTime.ofEpochSecond(timestamp / 1000, 0, ZoneOffset.ofHours(8));
}","/**
     * Format local date time from timestamp local date time.
     *
     * @param timestamp the timestamp
     * @return the local date time
     */","('formatLocalDateTimeFromTimestamp', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,  Format local date time from timestamp local date time.,10.0,"['The local date time should be formatted from the local timestamp time.', 'The local date time should be formatted with a timestamp.', 'The local date time should be formatted from the local time.']"
12,sonar-cxx,org/sonar/cxx/config/CxxSquidConfiguration.java,/cxx-squid/src/main/java/org/sonar/cxx/config/CxxSquidConfiguration.java,toString,404-413,"/**
   * Returns a string representation of the object: XML/UTF-8 encoded.
   *
   * @return object XML encoded
   */
public String toString(){
    var stream = new ByteArrayOutputStream();
    save(stream);
    return stream.toString(StandardCharsets.UTF_8);
}","public String toString(){
    var stream = new ByteArrayOutputStream();
    save(stream);
    return stream.toString(StandardCharsets.UTF_8);
}","/**
   * Returns a string representation of the object: XML/UTF-8 encoded.
   *
   * @return object XML encoded
   */","('toString', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,Returns a string representation of the object: XML/UTF-8 encoded.,11.0,"['A string representation of the object is returned.', 'A string representation of the object.', 'The object is represented by a string.']"
13,sonar-cxx,org/sonar/cxx/CxxAstScanner.java,/cxx-squid/src/main/java/org/sonar/cxx/CxxAstScanner.java,scanSingleInputFile,66-76,"/**
   * Helper method for testing checks without having to deploy them on a Sonar instance.
   *
   * @param inputFile is the file to be checked
   * @param visitors AST checks and visitors to use
   * @return file checked with measures and issues
   */
public static SourceFile scanSingleInputFile(InputFile inputFile, SquidAstVisitor<Grammar>... visitors){
    return scanSingleInputFileConfig(inputFile, new CxxSquidConfiguration(), visitors);
}","public static SourceFile scanSingleInputFile(InputFile inputFile, SquidAstVisitor<Grammar>... visitors){
    return scanSingleInputFileConfig(inputFile, new CxxSquidConfiguration(), visitors);
}","/**
   * Helper method for testing checks without having to deploy them on a Sonar instance.
   *
   * @param inputFile is the file to be checked
   * @param visitors AST checks and visitors to use
   * @return file checked with measures and issues
   */","('scanSingleInputFile', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,  Helper method for testing checks without having to deploy them on a Sonar instance.,15.0,"['A method for testing checks without having to use a Sonar instance.', 'A method for testing checks without having to deploy them.', 'The method is for testing checks without having to deploy them.']"
14,matsim-libs,org/matsim/contrib/freight/carrier/CarrierUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/carrier/CarrierUtils.java,addShipment,53-60,"/**
	 * Adds an {@link CarrierShipment} to the {@link Carrier}.
	 * @param carrier
	 * @param carrierShipment
	 */
public static void addShipment(Carrier carrier, CarrierShipment carrierShipment){
    carrier.getShipments().put(carrierShipment.getId(), carrierShipment);
}","public static void addShipment(Carrier carrier, CarrierShipment carrierShipment){
    carrier.getShipments().put(carrierShipment.getId(), carrierShipment);
}","/**
	 * Adds an {@link CarrierShipment} to the {@link Carrier}.
	 * @param carrier
	 * @param carrierShipment
	 */","('addShipment', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,  Adds an {@link CarrierShipment} to the {@link Carrier}.,15.0,"['The @link Carrier is now an @link CarrierShipment.', 'The @link Carrier is added to the @link Carrier.', 'Adds an @link CarrierShipment to it.']"
15,matsim-libs,org/matsim/contrib/freight/carrier/CarrierUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/carrier/CarrierUtils.java,addService,36-43,"/**
	 * Adds an {@link CarrierService} to the {@link Carrier}.
	 * @param carrier
	 * @param carrierService
	 */
public static void addService(Carrier carrier, CarrierService carrierService){
    carrier.getServices().put(carrierService.getId(), carrierService);
}","public static void addService(Carrier carrier, CarrierService carrierService){
    carrier.getServices().put(carrierService.getId(), carrierService);
}","/**
	 * Adds an {@link CarrierService} to the {@link Carrier}.
	 * @param carrier
	 * @param carrierService
	 */","('addService', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,  Adds an {@link CarrierService} to the {@link Carrier}.,15.0,"['The @link Carrier Service is added to it.', 'The @link Carrier Service is added.', 'Adds an @link Carrier Service.']"
16,cdk,org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,adjacentLength,210-222,"/**
     * Given vectors for the hypotenuse and adjacent side of a right angled
     * triangle and the length of the opposite side, determine how long the
     * adjacent side size.
     *
     * @param hypotenuse vector for the hypotenuse
     * @param adjacent vector for the adjacent side
     * @param oppositeLength length of the opposite side of a triangle
     * @return length of the adjacent side
     */
 static double adjacentLength(Vector2d hypotenuse, Vector2d adjacent, double oppositeLength){
    return Math.tan(hypotenuse.angle(adjacent)) * oppositeLength;
}","static double adjacentLength(Vector2d hypotenuse, Vector2d adjacent, double oppositeLength){
    return Math.tan(hypotenuse.angle(adjacent)) * oppositeLength;
}","/**
     * Given vectors for the hypotenuse and adjacent side of a right angled
     * triangle and the length of the opposite side, determine how long the
     * adjacent side size.
     *
     * @param hypotenuse vector for the hypotenuse
     * @param adjacent vector for the adjacent side
     * @param oppositeLength length of the opposite side of a triangle
     * @return length of the adjacent side
     */","('adjacentLength', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",30.0,"  Given vectors for the hypotenuse and adjacent side of a right angled  triangle and the length of the opposite side, determine how long the  adjacent side size.",29.0,"['Determine how long the adjacent side of the triangle is by using the vectors for the hypotenuse and adjacent side.', 'Determine how long the adjacent side of the right triangle is by using the vectors for the hypotenuse and adjacent side.', 'Determine how long the adjacent side of the triangle is by using the vectors for the hypotenuse and the length of the opposite side.']"
17,jooby,io/jooby/Environment.java,/jooby/src/main/java/io/jooby/Environment.java,systemProperties,256-264,"/**
   * Creates a {@link Config} object from {@link System#getProperties()}.
   *
   * @return Configuration object.
   */
public static Config systemProperties(){
    return ConfigFactory.parseProperties(System.getProperties(), ConfigParseOptions.defaults().setOriginDescription(""system properties""));
}","public static Config systemProperties(){
    return ConfigFactory.parseProperties(System.getProperties(), ConfigParseOptions.defaults().setOriginDescription(""system properties""));
}","/**
   * Creates a {@link Config} object from {@link System#getProperties()}.
   *
   * @return Configuration object.
   */","('systemProperties', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,  Creates a {@link Config} object from {@link System#getProperties()}.,19.0,"['The @link Config object is created from the @link System#getProperties', 'The @link Config object was created from the @link System#getProperties', 'The @link Config object is created from the @link System#getProperties.']"
18,cdk,org/openscience/cdk/layout/StructureDiagramGenerator.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/StructureDiagramGenerator.java,clearHydrogenCounts,1662-1672,"/**
     * Simple helper function that sets all hydrogen counts to 0.
     *
     * @param container a structure representation
     * @return the input container
     */
private static IAtomContainer clearHydrogenCounts(IAtomContainer container){
    for (IAtom atom : container.atoms()) atom.setImplicitHydrogenCount(0);
    return container;
}","private static IAtomContainer clearHydrogenCounts(IAtomContainer container){
    for (IAtom atom : container.atoms()) atom.setImplicitHydrogenCount(0);
    return container;
}","/**
     * Simple helper function that sets all hydrogen counts to 0.
     *
     * @param container a structure representation
     * @return the input container
     */","('clearHydrogenCounts', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,Simple helper function that sets all hydrogen counts to 0.,11.0,"['The function sets the hydrogen counts to 0.', 'The function sets all hydrogen counts to 0.', 'A simple function sets the hydrogen counts to 0.']"
19,dcache,dmg/util/logback/FilterThresholdSet.java,/modules/cells/src/main/java/dmg/util/logback/FilterThresholdSet.java,hasAppender,104-110,"/**
     * Returns whether the appender is valid is valid for use in a threshold definition.
     */
public synchronized boolean hasAppender(String appender){
    return _appenders.contains(appender) || (_parent != null && _parent.hasAppender(appender));
}","public synchronized boolean hasAppender(String appender){
    return _appenders.contains(appender) || (_parent != null && _parent.hasAppender(appender));
}","/**
     * Returns whether the appender is valid is valid for use in a threshold definition.
     */","('hasAppender', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,  Returns whether the appender is valid is valid for use in a threshold definition.,15.0,"['If the appender is valid, it is valid for use in a threshold definition.', 'If the appender is valid, it is valid in a threshold definition.', 'If the appender is valid, then it is valid for use in a threshold definition.']"
20,liquibase,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,parseDefaultPropertyFileFromFile,799-812,"/**
     * Open a regular property file (not embedded in a resource - use {@link #parseDefaultPropertyFileFromResource}
     * for that) and parse it.
     *
     * @param potentialPropertyFile path and file name to the the property file
     * @throws IOException                 if the file cannot be opened
     * @throws CommandLineParsingException if an error occurs during parsing
     */
private void parseDefaultPropertyFileFromFile(File potentialPropertyFile) throws IOException, CommandLineParsingException{
    try (FileInputStream stream = new FileInputStream(potentialPropertyFile)) {
        parsePropertiesFile(stream);
    }
}","private void parseDefaultPropertyFileFromFile(File potentialPropertyFile) throws IOException, CommandLineParsingException{
    try (FileInputStream stream = new FileInputStream(potentialPropertyFile)) {
        parsePropertiesFile(stream);
    }
}","/**
     * Open a regular property file (not embedded in a resource - use {@link #parseDefaultPropertyFileFromResource}
     * for that) and parse it.
     *
     * @param potentialPropertyFile path and file name to the the property file
     * @throws IOException                 if the file cannot be opened
     * @throws CommandLineParsingException if an error occurs during parsing
     */","('parseDefaultPropertyFileFromFile', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,  Open a regular property file (not embedded in a resource - use {@link #parseDefaultPropertyFileFromResource}  for that) and parse it.,26.0,"['Parse a regular property file if it is not embedded in a resource.', 'You can open a regular property file and use the @link #parseDefaultPropertyFileFromResource for that.', 'You can open a regular property file and use the @link #parseDefaultPropertyFileFromResource to get it to be readable.']"
21,shardingsphere-elasticjob,org/apache/shardingsphere/elasticjob/cloud/console/controller/CloudJobController.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/console/controller/CloudJobController.java,isDisabled,142-151,"/**
     * Check whether the cloud job is disabled or not.
     *
     * @param jobName job name
     * @return true is disabled, otherwise not
     */
public boolean isDisabled(@Param(name = ""jobName"", source = ParamSource.PATH) final String jobName){
    return facadeService.isJobDisabled(jobName);
}","public boolean isDisabled(@Param(name = ""jobName"", source = ParamSource.PATH) final String jobName){
    return facadeService.isJobDisabled(jobName);
}","/**
     * Check whether the cloud job is disabled or not.
     *
     * @param jobName job name
     * @return true is disabled, otherwise not
     */","('isDisabled', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,  Check whether the cloud job is disabled or not.,10.0,"['Check to see if the cloud job is disabled.', 'If the cloud job is disabled, check it out.', 'If the cloud job is disabled, you should check it.']"
22,openapi-generator,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,isNullType,1481-1503,"/**
     * isNullType returns true if the input schema is the 'null' type.
     *
     * The 'null' type is supported in OAS 3.1 and above. It is not supported
     * in OAS 2.0 and OAS 3.0.x.
     *
     * For example, the ""null"" type could be used to specify that a value must
     * either be null or a specified type:
     *
     * OptionalOrder:
     *   oneOf:
     *     - type: 'null'
     *     - $ref: '#/components/schemas/Order'
     *
     * @param schema the OpenAPI schema
     * @return true if the schema is the 'null' type
     */
public static boolean isNullType(Schema schema){
    if (""null"".equals(schema.getType())) {
        return true;
    }
    return false;
}","public static boolean isNullType(Schema schema){
    if (""null"".equals(schema.getType())) {
        return true;
    }
    return false;
}","/**
     * isNullType returns true if the input schema is the 'null' type.
     *
     * The 'null' type is supported in OAS 3.1 and above. It is not supported
     * in OAS 2.0 and OAS 3.0.x.
     *
     * For example, the ""null"" type could be used to specify that a value must
     * either be null or a specified type:
     *
     * OptionalOrder:
     *   oneOf:
     *     - type: 'null'
     *     - $ref: '#/components/schemas/Order'
     *
     * @param schema the OpenAPI schema
     * @return true if the schema is the 'null' type
     */","('isNullType', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,  isNullType returns true if the input schema is the 'null' type.,13.0,"['If the input is a null type, isNullType returns true.', 'If the input is a null type, isNullType will return true.', 'If the input is a null type, isNullType is true.']"
23,cdk,org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,invisibleCarbon,266-277,"/**
     * Checks an atom to see if it is an 'invisible carbon' - that is, it is:
     * a) a carbon atom and b) this carbon should not be shown.
     *
     * @param atom the atom to check
     * @param atomContainer the atom container the atom is part of
     * @param model the renderer model
     * @return true if this atom should not be shown
     */
protected boolean invisibleCarbon(IAtom atom, IAtomContainer atomContainer, RendererModel model){
    return isCarbon(atom) && !showCarbon(atom, atomContainer, model);
}","protected boolean invisibleCarbon(IAtom atom, IAtomContainer atomContainer, RendererModel model){
    return isCarbon(atom) && !showCarbon(atom, atomContainer, model);
}","/**
     * Checks an atom to see if it is an 'invisible carbon' - that is, it is:
     * a) a carbon atom and b) this carbon should not be shown.
     *
     * @param atom the atom to check
     * @param atomContainer the atom container the atom is part of
     * @param model the renderer model
     * @return true if this atom should not be shown
     */","('invisibleCarbon', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,"  Checks an atom to see if it is an 'invisible carbon' - that is, it is:  a) a carbon atom and b) this carbon should not be shown.",34.0,"['If an atom is checked to see if it is an invisible carbon, it should not be shown.', ""If an atom is checked to see if it's an invisible carbon, it should not be shown."", 'If an atom is checked to see if it is an invisible carbon, it should be shown.']"
24,cdk,org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,invisibleHydrogen,254-264,"/**
     * Checks an atom to see if it is an 'invisible hydrogen' - that is, it
     * is a) an (explicit) hydrogen, and b) explicit hydrogens are set to off.
     *
     * @param atom the atom to check
     * @param model the renderer model
     * @return true if this atom should not be shown
     */
protected boolean invisibleHydrogen(IAtom atom, RendererModel model){
    return isHydrogen(atom) && !(Boolean) model.get(ShowExplicitHydrogens.class);
}","protected boolean invisibleHydrogen(IAtom atom, RendererModel model){
    return isHydrogen(atom) && !(Boolean) model.get(ShowExplicitHydrogens.class);
}","/**
     * Checks an atom to see if it is an 'invisible hydrogen' - that is, it
     * is a) an (explicit) hydrogen, and b) explicit hydrogens are set to off.
     *
     * @param atom the atom to check
     * @param model the renderer model
     * @return true if this atom should not be shown
     */","('invisibleHydrogen', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",31.0,"  Checks an atom to see if it is an 'invisible hydrogen' - that is, it  is a) an (explicit) hydrogen, and b) explicit hydrogens are set to off.",36.0,"['An atom is checked to see if it is an invisible hydrogen and if explicit hydrogens are set to off.', 'An atom is checked to see if it is an invisible hydrogen and explicit hydrogens are set to off.', 'An atom is checked to see if it is an invisible hydrogen or explicit hydrogen.']"
25,dataverse,edu/harvard/iq/dataverse/util/StringUtil.java,/src/main/java/edu/harvard/iq/dataverse/util/StringUtil.java,isTrue,80-88,"/**
     * Checks if {@code s} contains a ""truthy"" value.
     * @param s
     * @return {@code true} iff {@code s} is not {@code null} and is ""truthy"" word.
     * @see #TRUE_VALUES
     */
public static boolean isTrue(String s){
    return (s != null) && TRUE_VALUES.contains(s.trim().toLowerCase());
}","public static boolean isTrue(String s){
    return (s != null) && TRUE_VALUES.contains(s.trim().toLowerCase());
}","/**
     * Checks if {@code s} contains a ""truthy"" value.
     * @param s
     * @return {@code true} iff {@code s} is not {@code null} and is ""truthy"" word.
     * @see #TRUE_VALUES
     */","('isTrue', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,"  Checks if {@code s} contains a ""truthy"" value.",14.0,"['If @code s contains a ""truthy"" value, it\'s checked.', 'If @code s contains a ""truthy"" value, I check it.', 'If @code s has a ""truthy"" value, I check it.']"
26,glowstone,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,putDoubleList,977-985,"/**
     * Adds or replaces a list subtag with a list of doubles.
     *
     * @param key the key to write to
     * @param list the list contents as doubles, to convert to double tags
     */
public void putDoubleList(@NonNls String key, List<Double> list){
    putList(key, TagType.DOUBLE, list, DoubleTag::new);
}","public void putDoubleList(@NonNls String key, List<Double> list){
    putList(key, TagType.DOUBLE, list, DoubleTag::new);
}","/**
     * Adds or replaces a list subtag with a list of doubles.
     *
     * @param key the key to write to
     * @param list the list contents as doubles, to convert to double tags
     */","('putDoubleList', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,  Adds or replaces a list subtag with a list of doubles.,12.0,"['A list subtag is replaced with a list of doubles.', 'A list subtag is added or replaced with a list of doubles.', 'A list of doubles is added or replaced.']"
27,liquibase,liquibase/change/ChangeParameterMetaData.java,/liquibase-core/src/main/java/liquibase/change/ChangeParameterMetaData.java,isRequiredFor,262-269,"/**
     * A convenience method for testing the value returned by {@link #getRequiredForDatabase()} against a given database.
     * Returns true if the {@link Database#getShortName()} method is contained in the required databases or the
     * required database list contains the string ""all""
     */
public boolean isRequiredFor(Database database){
    return getRequiredForDatabase().contains(ALL) || getRequiredForDatabase().contains(database.getShortName());
}","public boolean isRequiredFor(Database database){
    return getRequiredForDatabase().contains(ALL) || getRequiredForDatabase().contains(database.getShortName());
}","/**
     * A convenience method for testing the value returned by {@link #getRequiredForDatabase()} against a given database.
     * Returns true if the {@link Database#getShortName()} method is contained in the required databases or the
     * required database list contains the string ""all""
     */","('isRequiredFor', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,  A convenience method for testing the value returned by {@link #getRequiredForDatabase()} against a given database.,22.0,"['A convenience method for testing the value returned by @link #getRequiredForDatabase', 'A method for testing the value returned by @link #getRequiredForDatabase', 'A convenience method for testing the value returned by the link.']"
28,twilio-java,com/twilio/taskrouter/Workflow.java,/src/main/java/com/twilio/taskrouter/Workflow.java,fromJson,55-65,"/**
     * Converts a JSON workflow configuration to a workflow object.
     *
     * @param json JSON for workflow
     * @return a workflow rule target object
     * @throws IOException if unable to create object
     */
public static Workflow fromJson(String json) throws IOException{
    ObjectMapper mapper = new ObjectMapper();
    return mapper.readValue(json, Workflow.class);
}","public static Workflow fromJson(String json) throws IOException{
    ObjectMapper mapper = new ObjectMapper();
    return mapper.readValue(json, Workflow.class);
}","/**
     * Converts a JSON workflow configuration to a workflow object.
     *
     * @param json JSON for workflow
     * @return a workflow rule target object
     * @throws IOException if unable to create object
     */","('fromJson', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,  Converts a JSON workflow configuration to a workflow object.,10.0,"['The configuration is converted to a object.', 'A configuration is converted to a object.', 'A JSON configuration is converted to a object.']"
29,glowstone,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,putLongList,987-995,"/**
     * Adds or replaces a list subtag with a list of longs.
     *
     * @param key the key to write to
     * @param list the list contents as longs, to convert to long tags
     */
public void putLongList(@NonNls String key, List<Long> list){
    putList(key, TagType.LONG, list, LongTag::new);
}","public void putLongList(@NonNls String key, List<Long> list){
    putList(key, TagType.LONG, list, LongTag::new);
}","/**
     * Adds or replaces a list subtag with a list of longs.
     *
     * @param key the key to write to
     * @param list the list contents as longs, to convert to long tags
     */","('putLongList', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,  Adds or replaces a list subtag with a list of longs.,12.0,"['A list subtag is replaced with a list of longs.', 'A list subtag is added or replaced with a list of longs.', 'A list subtag is replaced by a list of longs.']"
30,incubator-shenyu,org/apache/dromara/springboot/starter/client/grpc/ShenyuGrpcClientConfiguration.java,/shenyu-spring-boot-starter/shenyu-spring-boot-starter-client/shenyu-spring-boot-starter-client-grpc/src/main/java/org/apache/dromara/springboot/starter/client/grpc/ShenyuGrpcClientConfiguration.java,grpcContextRefreshedEventListener,53-62,"/**
     * Grpc context refreshed event listener grpc context refreshed event listener.
     *
     * @param clientConfig the client config
     * @return the grpc context refreshed event listener
     */
public GrpcContextRefreshedEventListener grpcContextRefreshedEventListener(final ShenyuClientConfig clientConfig){
    return new GrpcContextRefreshedEventListener(clientConfig.getClient().get(RpcTypeEnum.GRPC.getName()));
}","public GrpcContextRefreshedEventListener grpcContextRefreshedEventListener(final ShenyuClientConfig clientConfig){
    return new GrpcContextRefreshedEventListener(clientConfig.getClient().get(RpcTypeEnum.GRPC.getName()));
}","/**
     * Grpc context refreshed event listener grpc context refreshed event listener.
     *
     * @param clientConfig the client config
     * @return the grpc context refreshed event listener
     */","('grpcContextRefreshedEventListener', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,  Grpc context refreshed event listener grpc context refreshed event listener.,11.0,"['GrPC context refreshed event listener.', 'Grpc context refreshed event listener.', 'GrPC context refreshed the event listener.']"
31,tablesaw,tech/tablesaw/selection/Selection.java,/core/src/main/java/tech/tablesaw/selection/Selection.java,withoutRange,108-117,"/**
   * Returns a Selection containing all values from totalRangeStart to totalRangeEnd, except for
   * those in the range from excludedRangeStart to excludedRangeEnd. Start values are inclusive, end
   * values exclusive.
   */
 static Selection withoutRange(int totalRangeStart, int totalRangeEnd, int excludedRangeStart, int excludedRangeEnd){
    return BitmapBackedSelection.withoutRange(totalRangeStart, totalRangeEnd, excludedRangeStart, excludedRangeEnd);
}"," static Selection withoutRange(int totalRangeStart, int totalRangeEnd, int excludedRangeStart, int excludedRangeEnd){
    return BitmapBackedSelection.withoutRange(totalRangeStart, totalRangeEnd, excludedRangeStart, excludedRangeEnd);
}","/**
   * Returns a Selection containing all values from totalRangeStart to totalRangeEnd, except for
   * those in the range from excludedRangeStart to excludedRangeEnd. Start values are inclusive, end
   * values exclusive.
   */","('withoutRange', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,"  Returns a Selection containing all values from totalRangeStart to totalRangeEnd, except for  those in the range from excludedRangeStart to excludedRangeEnd.",22.0,"['Only those in the range from excludedRangeStart to excludedRangeEnd are returned.', 'All values from totalRangeStart to totalRangeEnd are returned in a selection.', 'Only those in the range from excludedRangeStart to excludedRangeEnd can be returned.']"
32,weblogic-kubernetes-operator,oracle/kubernetes/operator/builders/WatchBuilder.java,/operator/src/main/java/oracle/kubernetes/operator/builders/WatchBuilder.java,createConfigMapWatch,118-130,"/**
   * Creates a web hook object to track config map calls.
   *
   * @param namespace the namespace
   * @return the active web hook
   * @throws ApiException if there is an error on the call that sets up the web hook.
   */
public Watchable<V1ConfigMap> createConfigMapWatch(String namespace) throws ApiException{
    return FACTORY.createWatch(callParams, V1ConfigMap.class, new ListNamespacedConfigMapCall(namespace));
}","public Watchable<V1ConfigMap> createConfigMapWatch(String namespace) throws ApiException{
    return FACTORY.createWatch(callParams, V1ConfigMap.class, new ListNamespacedConfigMapCall(namespace));
}","/**
   * Creates a web hook object to track config map calls.
   *
   * @param namespace the namespace
   * @return the active web hook
   * @throws ApiException if there is an error on the call that sets up the web hook.
   */","('createConfigMapWatch', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,  Creates a web hook object to track config map calls.,11.0,"['A web hook object is created to track map calls.', 'A web hook object is created to track config map calls.', 'A web hook object is created to track calls.']"
33,jeromq,org/zeromq/ZMsg.java,/src/main/java/org/zeromq/ZMsg.java,popString,687-700,"/**
     * Pop a ZFrame and return the toString() representation of it.
     *
     * @return toString version of pop'ed frame, or null if no frame exists.
     */
public String popString(){
    ZFrame frame = pop();
    if (frame == null) {
        return null;
    }
    return frame.toString();
}","public String popString(){
    ZFrame frame = pop();
    if (frame == null) {
        return null;
    }
    return frame.toString();
}","/**
     * Pop a ZFrame and return the toString() representation of it.
     *
     * @return toString version of pop'ed frame, or null if no frame exists.
     */","('popString', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,  Pop a ZFrame and return the toString() representation of it.,13.0,"['Pop a ZFrame and return the representation of it.', 'Return the representation of the ZFrame toString.', 'Return the representation of a ZFrame toString.']"
34,weblogic-kubernetes-operator,oracle/kubernetes/operator/builders/WatchBuilder.java,/operator/src/main/java/oracle/kubernetes/operator/builders/WatchBuilder.java,createServiceWatch,47-56,"/**
   * Creates a web hook object to track service calls.
   *
   * @param namespace the namespace
   * @return the active web hook
   * @throws ApiException if there is an error on the call that sets up the web hook.
   */
public Watchable<V1Service> createServiceWatch(String namespace) throws ApiException{
    return FACTORY.createWatch(callParams, V1Service.class, new ListNamespacedServiceCall(namespace));
}","public Watchable<V1Service> createServiceWatch(String namespace) throws ApiException{
    return FACTORY.createWatch(callParams, V1Service.class, new ListNamespacedServiceCall(namespace));
}","/**
   * Creates a web hook object to track service calls.
   *
   * @param namespace the namespace
   * @return the active web hook
   * @throws ApiException if there is an error on the call that sets up the web hook.
   */","('createServiceWatch', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,  Creates a web hook object to track service calls.,10.0,"['A web hook object is created to track service calls.', 'Tracks service calls with a web hook object.', 'A web hook object is created to track calls.']"
35,liquibase,liquibase/diff/output/changelog/DiffToChangeLog.java,/liquibase-core/src/main/java/liquibase/diff/output/changelog/DiffToChangeLog.java,supportsSortingObjects,487-493,"/**
     * Used by {@link #sortMissingObjects(Collection, Database)} to determine whether to go into the sorting logic.
     */
protected boolean supportsSortingObjects(Database database){
    return (database instanceof AbstractDb2Database) || (database instanceof MSSQLDatabase) || (database instanceof OracleDatabase) || database instanceof PostgresDatabase;
}","protected boolean supportsSortingObjects(Database database){
    return (database instanceof AbstractDb2Database) || (database instanceof MSSQLDatabase) || (database instanceof OracleDatabase) || database instanceof PostgresDatabase;
}","/**
     * Used by {@link #sortMissingObjects(Collection, Database)} to determine whether to go into the sorting logic.
     */","('supportsSortingObjects', {'INSTRUCTION': {'covered': 14, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 4}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,"  Used by {@link #sortMissingObjects(Collection, Database)} to determine whether to go into the sorting logic.",23.0,"['It was used to determine if to go into the sorting logic.', 'It was used to determine whether to go into the sorting logic.', 'To determine whether to go into the sorting logic.']"
36,glowstone,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,putFloatList,967-975,"/**
     * Adds or replaces a list subtag with a list of floats.
     *
     * @param key the key to write to
     * @param list the list contents as floats, to convert to float tags
     */
public void putFloatList(@NonNls String key, List<Float> list){
    putList(key, TagType.FLOAT, list, FloatTag::new);
}","public void putFloatList(@NonNls String key, List<Float> list){
    putList(key, TagType.FLOAT, list, FloatTag::new);
}","/**
     * Adds or replaces a list subtag with a list of floats.
     *
     * @param key the key to write to
     * @param list the list contents as floats, to convert to float tags
     */","('putFloatList', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,  Adds or replaces a list subtag with a list of floats.,12.0,"['A list subtag is replaced with a list of floats.', 'A list subtag is added or replaced with a list of floats.', 'A list of floats is added or replaced.']"
37,twilio-java,com/twilio/taskrouter/WorkflowRuleTarget.java,/src/main/java/com/twilio/taskrouter/WorkflowRuleTarget.java,fromJson,147-157,"/**
     * Converts a JSON workflow configuration to a workflow configuration object.
     *
     * @param json JSON for workflow rule target
     * @return a workflow rule target object
     * @throws IOException if unable to create object
     */
public static WorkflowRuleTarget fromJson(String json) throws IOException{
    ObjectMapper mapper = new ObjectMapper();
    return mapper.readValue(json, WorkflowRuleTarget.class);
}","public static WorkflowRuleTarget fromJson(String json) throws IOException{
    ObjectMapper mapper = new ObjectMapper();
    return mapper.readValue(json, WorkflowRuleTarget.class);
}","/**
     * Converts a JSON workflow configuration to a workflow configuration object.
     *
     * @param json JSON for workflow rule target
     * @return a workflow rule target object
     * @throws IOException if unable to create object
     */","('fromJson', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,  Converts a JSON workflow configuration to a workflow configuration object.,11.0,"['A workflow configuration is converted to a object.', 'A workflows configuration is converted to a object.', 'A workflows configuration is converted to a objects.']"
38,dcache,dmg/util/logback/FilterThresholdSet.java,/modules/cells/src/main/java/dmg/util/logback/FilterThresholdSet.java,remove,151-159,"/**
     * Removes the threshold of the given logger and appender combination in this threshold set. The
     * new effective threshold will be derived from the regular inheritance rules.
     */
public synchronized void remove(LoggerName logger, String appender){
    if (_rules.remove(logger, appender) != null) {
        clearCache();
    }
}","public synchronized void remove(LoggerName logger, String appender){
    if (_rules.remove(logger, appender) != null) {
        clearCache();
    }
}","/**
     * Removes the threshold of the given logger and appender combination in this threshold set. The
     * new effective threshold will be derived from the regular inheritance rules.
     */","('remove', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,  Removes the threshold of the given logger and appender combination in this threshold set.,15.0,"['The threshold of the given combination is removed.', 'The threshold of the given logger and appender combination is removed.', 'The threshold of the given logger and appender combination has been removed.']"
39,weblogic-kubernetes-operator,oracle/kubernetes/operator/helpers/LegalNames.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/LegalNames.java,toExternalServiceName,108-121,"/**
   * Generates the introspector job name based on the given domainUid.
   *
   * @param domainUid domainUid
   * @param serverName WebLogic server name
   * @return String introspector job name
   */
public static String toExternalServiceName(String domainUid, String serverName){
    return toDns1123LegalName(String.format(EXTERNAL_SERVICE_PATTERN, domainUid, serverName, getExternalServiceNameSuffix()));
}","public static String toExternalServiceName(String domainUid, String serverName){
    return toDns1123LegalName(String.format(EXTERNAL_SERVICE_PATTERN, domainUid, serverName, getExternalServiceNameSuffix()));
}","/**
   * Generates the introspector job name based on the given domainUid.
   *
   * @param domainUid domainUid
   * @param serverName WebLogic server name
   * @return String introspector job name
   */","('toExternalServiceName', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,  Generates the introspector job name based on the given domainUid.,11.0,"['The job name is based on the given domainUid.', 'The job name is based on the domainUid.', 'The job name is generated based on the domainUid.']"
40,cdk,org/openscience/cdk/inchi/InChIToStructure.java,/storage/inchi/src/main/java/org/openscience/cdk/inchi/InChIToStructure.java,flip,150-156,"/**
     * Flip the storage order of atoms in a bond.
     * @param bond the bond
     */
private void flip(IBond bond){
    bond.setAtoms(new IAtom[] { bond.getEnd(), bond.getBegin() });
}","private void flip(IBond bond){
    bond.setAtoms(new IAtom[] { bond.getEnd(), bond.getBegin() });
}","/**
     * Flip the storage order of atoms in a bond.
     * @param bond the bond
     */","('flip', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,  Flip the storage order of atoms in a bond.,10.0,"['The storage order of atoms should be changed.', 'The storage order of atoms needs to be changed.', 'The storage order of the atoms should be changed.']"
41,incubator-shenyu,org/apache/shenyu/springboot/starter/client/tars/ShenyuTarsClientConfiguration.java,/shenyu-spring-boot-starter/shenyu-spring-boot-starter-client/shenyu-spring-boot-starter-client-tars/src/main/java/org/apache/shenyu/springboot/starter/client/tars/ShenyuTarsClientConfiguration.java,tarsContextRefreshedEventListener,50-59,"/**
     * Tars context refreshed event listener tars context refreshed event listener.
     *
     * @param clientConfig the client config
     * @return the tars context refreshed event listener
     */
public TarsContextRefreshedEventListener tarsContextRefreshedEventListener(final ShenyuClientConfig clientConfig){
    return new TarsContextRefreshedEventListener(clientConfig.getClient().get(RpcTypeEnum.TARS.getName()));
}","public TarsContextRefreshedEventListener tarsContextRefreshedEventListener(final ShenyuClientConfig clientConfig){
    return new TarsContextRefreshedEventListener(clientConfig.getClient().get(RpcTypeEnum.TARS.getName()));
}","/**
     * Tars context refreshed event listener tars context refreshed event listener.
     *
     * @param clientConfig the client config
     * @return the tars context refreshed event listener
     */","('tarsContextRefreshedEventListener', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,  Tars context refreshed event listener tars context refreshed event listener.,11.0,"['Tars context refreshed event listener.', 'Tars context refreshed the event listener.', 'Tars context refreshed event listener']"
42,cdk,org/openscience/cdk/hash/HashGeneratorMaker.java,/tool/hash/src/main/java/org/openscience/cdk/hash/HashGeneratorMaker.java,encode,257-270,"/**
     * Add a custom encoder to the hash generator which will be built. Although
     * not enforced, the encoder should be stateless and should not modify any
     * passed inputs.
     *
     * @param encoder an atom encoder
     * @return fluent API reference (self)
     * @throws NullPointerException no encoder provided
     */
public HashGeneratorMaker encode(AtomEncoder encoder){
    if (encoder == null)
        throw new NullPointerException(""no encoder provided"");
    customEncoders.add(encoder);
    return this;
}","public HashGeneratorMaker encode(AtomEncoder encoder){
    if (encoder == null)
        throw new NullPointerException(""no encoder provided"");
    customEncoders.add(encoder);
    return this;
}","/**
     * Add a custom encoder to the hash generator which will be built. Although
     * not enforced, the encoder should be stateless and should not modify any
     * passed inputs.
     *
     * @param encoder an atom encoder
     * @return fluent API reference (self)
     * @throws NullPointerException no encoder provided
     */","('encode', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,  Add a custom encoder to the hash generator which will be built.,13.0,"['The generator will be built with a custom encoder.', 'The generator will be built with the help of a custom encoder.', 'The generator will be built with a custom Encoder.']"
43,cdk,org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,failParse,249-261,"/**
     * Abort call when a label could not be parsed. The tokens are cleared
     * and replaced with the original label.
     *
     * @param label  the original label
     * @param tokens the current tokens
     * @return always returns false
     */
private static boolean failParse(String label, List<String> tokens){
    tokens.clear();
    tokens.add(label);
    return false;
}","private static boolean failParse(String label, List<String> tokens){
    tokens.clear();
    tokens.add(label);
    return false;
}","/**
     * Abort call when a label could not be parsed. The tokens are cleared
     * and replaced with the original label.
     *
     * @param label  the original label
     * @param tokens the current tokens
     * @return always returns false
     */","('failParse', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,  Abort call when a label could not be parsed.,10.0,"['A label could not be deciphered.', 'A label could not be read.', 'When a label could not be read.']"
44,weblogic-kubernetes-operator,oracle/kubernetes/operator/work/Fiber.java,/operator/src/main/java/oracle/kubernetes/operator/work/Fiber.java,scheduleOnce,106-115,"/**
   * Use this fiber's executor to schedule an operation for some time in the future.
   * @param timeout the interval before the check should run, in units
   * @param unit the unit of time that defines the interval
   * @param runnable the operation to run
   */
public void scheduleOnce(long timeout, TimeUnit unit, Runnable runnable){
    this.owner.getExecutor().schedule(runnable, timeout, unit);
}","public void scheduleOnce(long timeout, TimeUnit unit, Runnable runnable){
    this.owner.getExecutor().schedule(runnable, timeout, unit);
}","/**
   * Use this fiber's executor to schedule an operation for some time in the future.
   * @param timeout the interval before the check should run, in units
   * @param unit the unit of time that defines the interval
   * @param runnable the operation to run
   */","('scheduleOnce', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,  Use this fiber's executor to schedule an operation for some time in the future.,16.0,"[""Use the fiber's executor to schedule an operation in the future."", ""Use the fiber's executor to plan an operation in the future."", ""Schedule an operation using the fiber's executor.""]"
45,dcache,org/dcache/util/TimeUtils.java,/modules/common/src/main/java/org/dcache/util/TimeUtils.java,appendDuration,369-383,"/**
     * Provide a short, simple human understandable string describing the supplied duration.  The
     * duration is a non-negative value.  The output is appended to the supplied StringBuilder and
     * has the form {@code <number> <space> <units>}, where {@code <number>} is an integer and
     * {@code <units>} is defined by the value of unitFormat.
     */
public static StringBuilder appendDuration(StringBuilder sb, Duration duration, TimeUnitFormat unitFormat){
    return appendDuration(sb, duration.toMillis(), MILLISECONDS, unitFormat);
}","public static StringBuilder appendDuration(StringBuilder sb, Duration duration, TimeUnitFormat unitFormat){
    return appendDuration(sb, duration.toMillis(), MILLISECONDS, unitFormat);
}","/**
     * Provide a short, simple human understandable string describing the supplied duration.  The
     * duration is a non-negative value.  The output is appended to the supplied StringBuilder and
     * has the form {@code <number> <space> <units>}, where {@code <number>} is an integer and
     * {@code <units>} is defined by the value of unitFormat.
     */","('appendDuration', {'INSTRUCTION': {'covered': 31, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",32.0,"  Provide a short, simple human understandable string describing the supplied duration.",13.0,"['A human understandable string describing the supplied duration is provided.', 'A human understandable string describing the supplied duration.', 'A human understandable string describing the duration.']"
46,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaAttributeHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaAttributeHandler.java,findSchemaAttributeEntity,66-82,"/**
     * Find out if the SchemaAttribute object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */
private Optional<EntityDetail> findSchemaAttributeEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, SCHEMA_ATTRIBUTE_TYPE_NAME);
}","private Optional<EntityDetail> findSchemaAttributeEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, SCHEMA_ATTRIBUTE_TYPE_NAME);
}","/**
     * Find out if the SchemaAttribute object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */","('findSchemaAttributeEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Find out if the SchemaAttribute object is already stored in the repository.,13.0,"['Find out if the object is in the repository.', 'If the SchemaAttribute object is already in the repository, you should find it.', ""If the object is already in the repository, you can find out if it's there.""]"
47,cdk,org/openscience/cdk/forcefield/mmff/MmffParamSet.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffParamSet.java,intType,92-104,"/**
     * Obtain the integer MMFF atom type for a given symbolic MMFF type.
     *
     * @param sym Symbolic MMFF type
     * @return integer MMFF type
     */
 int intType(final String sym){
    Integer intType = typeMap.get(sym);
    if (intType == null) {
        return 0;
    }
    return intType;
}","int intType(final String sym){
    Integer intType = typeMap.get(sym);
    if (intType == null) {
        return 0;
    }
    return intType;
}","/**
     * Obtain the integer MMFF atom type for a given symbolic MMFF type.
     *
     * @param sym Symbolic MMFF type
     * @return integer MMFF type
     */","('intType', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Obtain the integer MMFF atom type for a given symbolic MMFF type.,13.0,"['Obtain the MMFF atom type for a symbolic MMFF type.', 'Obtain the MMFF atom type for a symbolic MMFF.', 'Obtain the MMFF atom type for symbolic MMFF types.']"
48,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,findPortImplementationEntity,331-347,"/**
     * Find out if the PortImplementation object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */
public Optional<EntityDetail> findPortImplementationEntity(String userId, String qualifiedName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, PORT_IMPLEMENTATION_TYPE_NAME);
}","public Optional<EntityDetail> findPortImplementationEntity(String userId, String qualifiedName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, PORT_IMPLEMENTATION_TYPE_NAME);
}","/**
     * Find out if the PortImplementation object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */","('findPortImplementationEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Find out if the PortImplementation object is already stored in the repository.,13.0,"['The repository may have the PortImplementation object.', 'If the PortImplementation object is already in the repository, you should find it.', 'If the PortImplementation object is in the repository, you can find out.']"
49,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,findPortAliasEntity,349-365,"/**
     * Find out if the PortAlias object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */
public Optional<EntityDetail> findPortAliasEntity(String userId, String qualifiedName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, PORT_ALIAS_TYPE_NAME);
}","public Optional<EntityDetail> findPortAliasEntity(String userId, String qualifiedName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, PORT_ALIAS_TYPE_NAME);
}","/**
     * Find out if the PortAlias object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */","('findPortAliasEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Find out if the PortAlias object is already stored in the repository.,13.0,"['If the PortAlias object is already in the repository, you should find it.', 'If the PortAlias object is already in the repository, you can find out.', 'If the PortAlias object is already in the repository, you can find out if it is.']"
50,cdk,org/openscience/cdk/hash/Xorshift.java,/tool/hash/src/main/java/org/openscience/cdk/hash/Xorshift.java,next,39-50,"/**
     * Generate the next pseudorandom number for the provided <i>seed</i>.
     *
     * @param seed random number seed
     * @return the next pseudorandom number
     */
 long next(long seed){
    seed = seed ^ seed << 21;
    seed = seed ^ seed >>> 35;
    return seed ^ seed << 4;
}","long next(long seed){
    seed = seed ^ seed << 21;
    seed = seed ^ seed >>> 35;
    return seed ^ seed << 4;
}","/**
     * Generate the next pseudorandom number for the provided <i>seed</i>.
     *
     * @param seed random number seed
     * @return the next pseudorandom number
     */","('next', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Generate the next pseudorandom number for the provided <i>seed</i>.,16.0,"['The next pseudorandom number is provided.', 'Generate the next pseudorandom number.', 'Generate the next pseudorandom number for the seed.']"
52,jackson-databind,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,readerForArrayOf,4145-4159,"/**
     * Factory method for constructing {@link ObjectReader} that will
     * read values of a type {@code List<type>}.
     * Functionally same as:
     *<pre>
     *    readerFor(type[].class);
     *</pre>
     *
     * @since 2.11
     */
public ObjectReader readerForArrayOf(Class<?> type){
    return _newReader(getDeserializationConfig(), _typeFactory.constructArrayType(type), null, null, _injectableValues);
}","public ObjectReader readerForArrayOf(Class<?> type){
    return _newReader(getDeserializationConfig(), _typeFactory.constructArrayType(type), null, null, _injectableValues);
}","/**
     * Factory method for constructing {@link ObjectReader} that will
     * read values of a type {@code List<type>}.
     * Functionally same as:
     *<pre>
     *    readerFor(type[].class);
     *</pre>
     *
     * @since 2.11
     */","('readerForArrayOf', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Factory method for constructing {@link ObjectReader} that will  read values of a type {@code List<type>}.,25.0,"['A factory method for constructing @link ObjectReader that will read values of a type.', 'The method for constructing @link ObjectReader will read values of a type.', 'A method for constructing @link ObjectReader that will read values of a type.']"
53,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaTypeHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaTypeHandler.java,findSchemaTypeEntity,129-145,"/**
     * Find out if the SchemaType object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the schema type to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */
public Optional<EntityDetail> findSchemaTypeEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, SCHEMA_TYPE_TYPE_NAME);
}","public Optional<EntityDetail> findSchemaTypeEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, SCHEMA_TYPE_TYPE_NAME);
}","/**
     * Find out if the SchemaType object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the schema type to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */","('findSchemaTypeEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Find out if the SchemaType object is already stored in the repository.,13.0,"['If the SchemaType object is already in the repository, you should find it.', 'If the SchemaType object is in the repository, you can find out if it is there.', ""If the SchemaType object is in the repository, you can find out if it's there.""]"
54,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineTopicHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineTopicHandler.java,findTopicEntity,98-114,"/**
     * Find out if the Topic object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */
public Optional<EntityDetail> findTopicEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, TOPIC_TYPE_NAME);
}","public Optional<EntityDetail> findTopicEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, TOPIC_TYPE_NAME);
}","/**
     * Find out if the Topic object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */","('findTopicEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Find out if the Topic object is already stored in the repository.,13.0,"['Find out if the object is in the repository.', 'If the object is already in the repository, you should find it.', 'If the object is already in the repository, you can find it.']"
55,jackson-databind,com/fasterxml/jackson/databind/node/ArrayNode.java,/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java,insertPOJO,625-633,"/**
     * Method that will construct a POJONode and
     * insert it at specified position in this array.
     *
     * @return This array node, to allow chaining
     */
public ArrayNode insertPOJO(int index, Object pojo){
    return _insert(index, (pojo == null) ? nullNode() : pojoNode(pojo));
}","public ArrayNode insertPOJO(int index, Object pojo){
    return _insert(index, (pojo == null) ? nullNode() : pojoNode(pojo));
}","/**
     * Method that will construct a POJONode and
     * insert it at specified position in this array.
     *
     * @return This array node, to allow chaining
     */","('insertPOJO', {'INSTRUCTION': {'covered': 9, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Method that will construct a POJONode and  insert it at specified position in this array.,16.0,"['The method will construct a POJONode and place it in this array.', 'A method that will construct a POJONode and insert it in this array.', 'A method that will construct a POJONode and insert it in this array']"
56,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineRelationalDataHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineRelationalDataHandler.java,findDatabaseSchemaEntity,166-182,"/**
     * Find out if the DatabaseSchema object is already stored in the repository.
     * It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the database schema to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */
private Optional<EntityDetail> findDatabaseSchemaEntity(String userId, String qualifiedName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, DEPLOYED_DATABASE_SCHEMA_TYPE_NAME);
}","private Optional<EntityDetail> findDatabaseSchemaEntity(String userId, String qualifiedName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, DEPLOYED_DATABASE_SCHEMA_TYPE_NAME);
}","/**
     * Find out if the DatabaseSchema object is already stored in the repository.
     * It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the database schema to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */","('findDatabaseSchemaEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Find out if the DatabaseSchema object is already stored in the repository.,13.0,"['Find out if the object is in the repository.', 'If the object is already in the repository, you can find it.', 'If the object is already in the repository, you should find it.']"
57,matsim-libs,org/matsim/core/gbl/MatsimRandom.java,/matsim/src/main/java/org/matsim/core/gbl/MatsimRandom.java,prepareRNG,92-101,"/**
	 * Draw some random numbers to better initialize the pseudo-random number generator.
	 *
	 * @param rng the random number generator to initialize.
	 */
private static void prepareRNG(final Random rng){
    for (int i = 0; i < 100; i++) {
        rng.nextDouble();
    }
}","private static void prepareRNG(final Random rng){
    for (int i = 0; i < 100; i++) {
        rng.nextDouble();
    }
}","/**
	 * Draw some random numbers to better initialize the pseudo-random number generator.
	 *
	 * @param rng the random number generator to initialize.
	 */","('prepareRNG', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Draw some random numbers to better initialize the pseudo-random number generator.,12.0,"['The pseudo-random number generator can be better initialize by drawing some random numbers.', 'The pseudo-random number generator needs some random numbers drawn.', 'The pseudo-random number generator can be better initialize by drawing random numbers.']"
58,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineRelationalDataHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineRelationalDataHandler.java,findDatabaseEntity,148-164,"/**
     * Find out if the Database object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the database to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */
private Optional<EntityDetail> findDatabaseEntity(String userId, String qualifiedName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, DATABASE_TYPE_NAME);
}","private Optional<EntityDetail> findDatabaseEntity(String userId, String qualifiedName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, DATABASE_TYPE_NAME);
}","/**
     * Find out if the Database object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the database to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */","('findDatabaseEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Find out if the Database object is already stored in the repository.,13.0,"['If the database object is already in the repository, you should find it.', 'If the database object is already in the repository, you can find it.', 'If the database object is already in the repository, you can find out if it is.']"
59,cdk,org/openscience/cdk/pharmacophore/PharmacophoreQueryAtom.java,/tool/pcore/src/main/java/org/openscience/cdk/pharmacophore/PharmacophoreQueryAtom.java,matches,104-119,"/**
     * Checks whether this query atom matches a target atom.
     * 
     * Currently a query pharmacophore atom will match a target pharmacophore group if the
     * symbols of the two groups match. This is based on the assumption that
     * pharmacophore groups with the same symbol will have the same SMARTS
     * pattern.
     *
     * @param atom A target pharmacophore group
     * @return true if the current query group has the same symbol as the target group
     */
public boolean matches(IAtom atom){
    PharmacophoreAtom patom = PharmacophoreAtom.get(atom);
    return patom.getSymbol().equals(getSymbol());
}","public boolean matches(IAtom atom){
    PharmacophoreAtom patom = PharmacophoreAtom.get(atom);
    return patom.getSymbol().equals(getSymbol());
}","/**
     * Checks whether this query atom matches a target atom.
     * 
     * Currently a query pharmacophore atom will match a target pharmacophore group if the
     * symbols of the two groups match. This is based on the assumption that
     * pharmacophore groups with the same symbol will have the same SMARTS
     * pattern.
     *
     * @param atom A target pharmacophore group
     * @return true if the current query group has the same symbol as the target group
     */","('matches', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Checks whether this query atom matches a target atom.,10.0,"['Does the query atom match the target atom?', 'Does the query atom match a target atom?', 'Does this query match a target atom?']"
60,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineProcessHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineProcessHandler.java,findProcessEntity,148-164,"/**
     * Find out if the Process object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */
public Optional<EntityDetail> findProcessEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, PROCESS_TYPE_NAME);
}","public Optional<EntityDetail> findProcessEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, PROCESS_TYPE_NAME);
}","/**
     * Find out if the Process object is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */","('findProcessEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Find out if the Process object is already stored in the repository.,13.0,"['If the Process object is already in the repository, you should find it.', 'If the process object is already in the repository, you should find it.', 'If the Process object is already in the repository, you should find out.']"
61,dcache,org/dcache/util/QualityValue.java,/modules/dcache/src/main/java/org/dcache/util/QualityValue.java,mapWith,73-83,"/**
     * Provide a new QualityValue with the same quality but with the value mapped to a different
     * type.
     *
     * @param <U>        The new type of the value
     * @param conversion the method to convert to the new type
     * @return The mapped QualityValue.
     */
public QualityValue<U> mapWith(Function<String, U> conversion){
    return new QualityValue(rawValue, conversion.apply(rawValue), quality);
}","public QualityValue<U> mapWith(Function<String, U> conversion){
    return new QualityValue(rawValue, conversion.apply(rawValue), quality);
}","/**
     * Provide a new QualityValue with the same quality but with the value mapped to a different
     * type.
     *
     * @param <U>        The new type of the value
     * @param conversion the method to convert to the new type
     * @return The mapped QualityValue.
     */","('mapWith', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Provide a new QualityValue with the same quality but with the value mapped to a different  type.,18.0,"['Provide a new QualityValue with the same quality but with a different type mapped to it.', 'Provide a new QualityValue with the same quality, but with a different type mapped to it.', 'Provide a new QualityValue with the same quality but with a different type.']"
62,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCollectionHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCollectionHandler.java,findCollectionEntity,92-108,"/**
     * Find out if the Transformation Project object is already stored in the repository as a Collection. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */
public Optional<EntityDetail> findCollectionEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, COLLECTION_TYPE_NAME);
}","public Optional<EntityDetail> findCollectionEntity(String userId, String qualifiedName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    return dataEngineCommonHandler.findEntity(userId, qualifiedName, COLLECTION_TYPE_NAME);
}","/**
     * Find out if the Transformation Project object is already stored in the repository as a Collection. It uses the fully qualified name to retrieve the entity
     *
     * @param userId        the name of the calling user
     * @param qualifiedName the qualifiedName name of the process to be searched
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */","('findCollectionEntity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Find out if the Transformation Project object is already stored in the repository as a Collection.,17.0,"[""If the Transformation Project object is already in the repository, you can find out if it's a Collection."", 'If the Transformation Project object is already in the repository, you can find out if it is a collection.', 'If the Transformation Project object is already in the repository, you can find out if it is a Collection.']"
63,cdk,org/openscience/cdk/silent/Bond.java,/base/silent/src/main/java/org/openscience/cdk/silent/Bond.java,isConnectedTo,506-519,"/**
     * Checks whether a bond is connected to another one.
     * This can only be true if the bonds have an Atom in common.
     *
     * @param bond The bond which is checked to be connect with this one
     * @return true if the bonds share an atom, otherwise false
     */
public boolean isConnectedTo(IBond bond){
    for (IAtom atom : atoms) {
        if (bond.contains(atom))
            return true;
    }
    return false;
}","public boolean isConnectedTo(IBond bond){
    for (IAtom atom : atoms) {
        if (bond.contains(atom))
            return true;
    }
    return false;
}","/**
     * Checks whether a bond is connected to another one.
     * This can only be true if the bonds have an Atom in common.
     *
     * @param bond The bond which is checked to be connect with this one
     * @return true if the bonds share an atom, otherwise false
     */","('isConnectedTo', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Checks whether a bond is connected to another one.,10.0,"['Does it check if a bond is connected to another one.', 'Checks if a bond is connected to another.', 'Does it check if a bond is connected to another.']"
64,weblogic-kubernetes-operator,oracle/kubernetes/weblogic/domain/model/DomainSpec.java,/operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainSpec.java,isIstioEnabled,835-845,"/**
   * Test if the domain is deployed under Istio environment.
   *
   * @return istioEnabled
   */
 boolean isIstioEnabled(){
    return Optional.ofNullable(configuration).map(Configuration::getIstio).map(Istio::getEnabled).orElse(false);
}"," boolean isIstioEnabled(){
    return Optional.ofNullable(configuration).map(Configuration::getIstio).map(Istio::getEnabled).orElse(false);
}","/**
   * Test if the domain is deployed under Istio environment.
   *
   * @return istioEnabled
   */","('isIstioEnabled', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Test if the domain is deployed under Istio environment.,10.0,"['If the domain is deployed under the Istio environment, test it.', 'If the domain is deployed under the Istio environment, you should test it.', 'If the domain is deployed in the Istio environment, you should test it.']"
65,incubator-shenyu,org/apache/shenyu/common/utils/DateUtils.java,/shenyu-common/src/main/java/org/apache/shenyu/common/utils/DateUtils.java,formatLocalDateTimeFromTimestampBySystemTimezone,91-99,"/**
     * Format local date time from timestamp by system time zone.
     *
     * @param timestamp the timestamp
     * @return the local date time
     */
public static LocalDateTime formatLocalDateTimeFromTimestampBySystemTimezone(final Long timestamp){
    return LocalDateTime.ofEpochSecond(timestamp / 1000, 0, OffsetDateTime.now().getOffset());
}","public static LocalDateTime formatLocalDateTimeFromTimestampBySystemTimezone(final Long timestamp){
    return LocalDateTime.ofEpochSecond(timestamp / 1000, 0, OffsetDateTime.now().getOffset());
}","/**
     * Format local date time from timestamp by system time zone.
     *
     * @param timestamp the timestamp
     * @return the local date time
     */","('formatLocalDateTimeFromTimestampBySystemTimezone', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",33.0,  Format local date time from timestamp by system time zone.,11.0,"['Local date time can be formatted by system time zone.', 'The local date time should be formatted by the system time zone.', 'The local date time should be formatted by system time zone.']"
66,jsqlparser,net/sf/jsqlparser/parser/feature/FeatureSet.java,/src/main/java/net/sf/jsqlparser/parser/feature/FeatureSet.java,retainAll,47-56,"/**
     * @param features
     * @return all features within this feature set which are contained in given
     *         set too.
     */
 Set<Feature> retainAll(Collection<Feature> features){
    Set<Feature> f = getFeaturesClone();
    f.retainAll(features);
    return f;
}"," Set<Feature> retainAll(Collection<Feature> features){
    Set<Feature> f = getFeaturesClone();
    f.retainAll(features);
    return f;
}","/**
     * @param features
     * @return all features within this feature set which are contained in given
     *         set too.
     */","('retainAll', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,  @param features  @return all features within this feature set which are contained in given  set too.,19.0,"['All features in this feature set are contained in the given set.', 'All features within this feature set are contained in the given set.', 'All features are contained in the given set.']"
67,matsim-libs,org/matsim/contrib/common/stats/LogDiscretizer.java,/contribs/common/src/main/java/org/matsim/contrib/common/stats/LogDiscretizer.java,discretize,69-78,"/**
     * @param value a value
     * @returns rounds <tt>value</tt> up to the upper bin border.
     */
public double discretize(double value){
    value = checkValue(value);
    double bin = index(value);
    return Math.pow(base, bin);
}","public double discretize(double value){
    value = checkValue(value);
    double bin = index(value);
    return Math.pow(base, bin);
}","/**
     * @param value a value
     * @returns rounds <tt>value</tt> up to the upper bin border.
     */","('discretize', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,  @param value a value  @returns rounds <tt>value</tt> up to the upper bin border.,22.0,"['The value is returned to the upper bin border.', 'The value should be returned up to the upper bin border.', 'The upper bin border is where the value is returned.']"
68,glowstone,net/glowstone/util/SoundUtil.java,/src/main/java/net/glowstone/util/SoundUtil.java,randomReal,86-95,"/**
     * Generates a random float between {@code -range} and {@code range}.
     *
     * @param range the bounds of the random float.
     * @return A randomly generated float.
     */
public static float randomReal(float range){
    ThreadLocalRandom rand = ThreadLocalRandom.current();
    return (2.0F * rand.nextFloat() - 1.0F) * range;
}","public static float randomReal(float range){
    ThreadLocalRandom rand = ThreadLocalRandom.current();
    return (2.0F * rand.nextFloat() - 1.0F) * range;
}","/**
     * Generates a random float between {@code -range} and {@code range}.
     *
     * @param range the bounds of the random float.
     * @return A randomly generated float.
     */","('randomReal', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,  Generates a random float between {@code -range} and {@code range}.,17.0,"['A random float is created between @code -range and @code range.', 'There is a random float between the two.', 'There is a random float between the code range and the code range.']"
69,jackson-databind,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,quotedOr,648-659,"/**
     * Returns either quoted value (with double-quotes) -- if argument non-null
     * String -- or String NULL (no quotes) (if null).
     *
     * @since 2.9
     */
public static String quotedOr(Object str, String forNull){
    if (str == null) {
        return forNull;
    }
    return String.format(""\""%s\"""", str);
}","public static String quotedOr(Object str, String forNull){
    if (str == null) {
        return forNull;
    }
    return String.format(""\""%s\"""", str);
}","/**
     * Returns either quoted value (with double-quotes) -- if argument non-null
     * String -- or String NULL (no quotes) (if null).
     *
     * @since 2.9
     */","('quotedOr', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,  Returns either quoted value (with double-quotes) -- if argument non-null  String -- or String NULL (no quotes) (if null).,26.0,"['If the argument is non-null, the value will be quoted or null.', 'If the argument is non-null, the quoted value will be either null or double-quotes.', 'If the argument is non-null, the quoted value will be either null or quoted.']"
70,matsim-libs,org/matsim/core/population/PopulationUtils.java,/matsim/src/main/java/org/matsim/core/population/PopulationUtils.java,decideOnActivityEndTime,458-463,"/**
	 * Computes the (expected or planned) activity end time, depending on the configured time interpretation.
	 */
public static OptionalTime decideOnActivityEndTime(Activity act, double now, Config config){
    return decideOnActivityEndTime(act, now, config.plans().getActivityDurationInterpretation());
}","public static OptionalTime decideOnActivityEndTime(Activity act, double now, Config config){
    return decideOnActivityEndTime(act, now, config.plans().getActivityDurationInterpretation());
}","/**
	 * Computes the (expected or planned) activity end time, depending on the configured time interpretation.
	 */","('decideOnActivityEndTime', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,"  Computes the (expected or planned) activity end time, depending on the configured time interpretation.",18.0,"['The activity end time is calculated based on the configured time interpretation.', 'Depending on the configured time interpretation, it calculates the expected or planned activity end time.', 'Depending on the configured time interpretation, it calculates the end time for the activity.']"
71,cdk,org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,scale,135-146,"/**
     * Scale a vector by a given factor, the input vector is not modified.
     *
     * @param vector a vector to scale
     * @param factor how much the input vector should be scaled
     * @return scaled vector
     */
 static Vector2d scale(final Tuple2d vector, final double factor){
    final Vector2d cpy = new Vector2d(vector);
    cpy.scale(factor);
    return cpy;
}","static Vector2d scale(final Tuple2d vector, final double factor){
    final Vector2d cpy = new Vector2d(vector);
    cpy.scale(factor);
    return cpy;
}","/**
     * Scale a vector by a given factor, the input vector is not modified.
     *
     * @param vector a vector to scale
     * @param factor how much the input vector should be scaled
     * @return scaled vector
     */","('scale', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,"  Scale a vector by a given factor, the input vector is not modified.",15.0,"['The input is not modified when you scale it by a factor.', 'The input is not modified when you scale it by a given factor.', 'The input is not modified when scales by a given factor.']"
72,cdk,org/openscience/cdk/smiles/smarts/parser/SmartsQueryVisitor.java,/legacy/src/main/java/org/openscience/cdk/smiles/smarts/parser/SmartsQueryVisitor.java,findStereoBond,339-349,"/**
     * Locate a stereo bond adjacent to the {@code atom}.
     *
     * @param atom an atom
     * @return a stereo bond or null if non found
     */
private StereoBond findStereoBond(IAtom atom){
    for (IBond bond : stereoBonds) if (bond.contains(atom))
        return (StereoBond) bond;
    return null;
}","private StereoBond findStereoBond(IAtom atom){
    for (IBond bond : stereoBonds) if (bond.contains(atom))
        return (StereoBond) bond;
    return null;
}","/**
     * Locate a stereo bond adjacent to the {@code atom}.
     *
     * @param atom an atom
     * @return a stereo bond or null if non found
     */","('findStereoBond', {'INSTRUCTION': {'covered': 21, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,  Locate a stereo bond adjacent to the {@code atom}.,13.0,"['There is a stereo bond next to the code atom.', 'There is a stereo bond next to the @code atom.', 'There is a stereo bond next to the atom.']"
73,acs-aem-commons,com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,generateChecksums,65-77,"/**
     * Convenience method for  generateChecksums(session, path, new DefaultChecksumGeneratorOptions()).
     *
     * @param session the session
     * @param path tthe root path to generate checksums for
     * @return the map of abs path ~&gt; checksums
     * @throws RepositoryException
     * @throws IOException
     */
public Map<String, String> generateChecksums(Session session, String path) throws RepositoryException, IOException{
    return generateChecksums(session, path, new DefaultChecksumGeneratorOptions());
}","public Map<String, String> generateChecksums(Session session, String path) throws RepositoryException, IOException{
    return generateChecksums(session, path, new DefaultChecksumGeneratorOptions());
}","/**
     * Convenience method for  generateChecksums(session, path, new DefaultChecksumGeneratorOptions()).
     *
     * @param session the session
     * @param path tthe root path to generate checksums for
     * @return the map of abs path ~&gt; checksums
     * @throws RepositoryException
     * @throws IOException
     */","('generateChecksums', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,"  Convenience method for generateChecksums(session, path, new DefaultChecksumGeneratorOptions()).",15.0,"['The convenience method for generating checks is DefaultChecksumGeneratorOptions.', 'The convenience method for generatingChecksums is DefaultChecksumGeneratorOptions.', 'The convenience method for generatingChecksums.']"
74,cdk,org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,usingDefaultPlacement,269-279,"/**
     * Access the default position of the hydrogen label when the atom has no
     * bonds.
     *
     * @param atom hydrogens will be labelled
     * @return the position
     */
 static HydrogenPosition usingDefaultPlacement(final IAtom atom){
    if (PREFIXED_H.contains(Elements.ofNumber(atom.getAtomicNumber())))
        return Left;
    return Right;
}"," static HydrogenPosition usingDefaultPlacement(final IAtom atom){
    if (PREFIXED_H.contains(Elements.ofNumber(atom.getAtomicNumber())))
        return Left;
    return Right;
}","/**
     * Access the default position of the hydrogen label when the atom has no
     * bonds.
     *
     * @param atom hydrogens will be labelled
     * @return the position
     */","('usingDefaultPlacement', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,  Access the default position of the hydrogen label when the atom has no  bonds.,15.0,"['When the atom has no bonds, access the default position of the hydrogen label.', 'The default position of the hydrogen label is when the atom has no bonds.', 'The default position of the hydrogen label is when the atom has no bonds']"
75,sonar-cxx,org/sonar/cxx/squidbridge/annotations/AnnotationBasedRulesDefinition.java,/cxx-squid-bridge/src/main/java/org/sonar/cxx/squidbridge/annotations/AnnotationBasedRulesDefinition.java,load,69-74,"/**
   * Adds annotated rule classes to an instance of NewRepository. Fails if one the classes has no SQALE annotation.
   */
public static void load(NewRepository repository, String languageKey, Iterable<Class> ruleClasses){
    new AnnotationBasedRulesDefinition(repository, languageKey).addRuleClasses(true, ruleClasses);
}","public static void load(NewRepository repository, String languageKey, Iterable<Class> ruleClasses){
    new AnnotationBasedRulesDefinition(repository, languageKey).addRuleClasses(true, ruleClasses);
}","/**
   * Adds annotated rule classes to an instance of NewRepository. Fails if one the classes has no SQALE annotation.
   */","('load', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,  Adds annotated rule classes to an instance of NewRepository.,10.0,"['Rule classes are added to an instance of NewRepository.', 'Adds annotated rule classes.', 'Adds annotated rule classes to NewRepository.']"
76,matsim-libs,org/matsim/contrib/freight/carrier/CarrierUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/carrier/CarrierUtils.java,addCarrierVehicle,19-26,"/**
	 * Adds an carrierVehicle to the CarrierCapabilites of the Carrier.
	 * @param carrier
	 * @param carrierVehicle
	 */
public static void addCarrierVehicle(Carrier carrier, CarrierVehicle carrierVehicle){
    carrier.getCarrierCapabilities().getCarrierVehicles().put(carrierVehicle.getId(), carrierVehicle);
}","public static void addCarrierVehicle(Carrier carrier, CarrierVehicle carrierVehicle){
    carrier.getCarrierCapabilities().getCarrierVehicles().put(carrierVehicle.getId(), carrierVehicle);
}","/**
	 * Adds an carrierVehicle to the CarrierCapabilites of the Carrier.
	 * @param carrier
	 * @param carrierVehicle
	 */","('addCarrierVehicle', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,  Adds an carrierVehicle to the CarrierCapabilites of the Carrier.,10.0,"['Adds a vehicle to the carrier.', ""Adds a vehicle to the carrier's capabilites."", 'Adds a carrier vehicle to the carrier.']"
77,glowstone,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,iterateCompoundList,572-582,"/**
     * Applies the given function to each compound tag in a compound-list subtag, if that subtag
     * exists.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was iterated over (even if it was empty); false otherwise
     */
public boolean iterateCompoundList(@NonNls String key, Consumer<? super CompoundTag> consumer){
    return readCompoundList(key, compoundTags -> compoundTags.forEach(consumer));
}","public boolean iterateCompoundList(@NonNls String key, Consumer<? super CompoundTag> consumer){
    return readCompoundList(key, compoundTags -> compoundTags.forEach(consumer));
}","/**
     * Applies the given function to each compound tag in a compound-list subtag, if that subtag
     * exists.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was iterated over (even if it was empty); false otherwise
     */","('iterateCompoundList', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,"  Applies the given function to each compound tag in a compound-list subtag, if that subtag  exists.",18.0,"['If there is a compound-list subtag, apply the given function to it.', 'If a compound-list subtag exists, apply the given function to it.', 'If there is a compound-list subtag, apply the given function to each compound tag.']"
78,jeromq,org/zeromq/ZMsg.java,/src/main/java/org/zeromq/ZMsg.java,wrap,115-127,"/**
     * Push frame plus empty frame to front of message, before 1st frame.
     * Message takes ownership of frame, will destroy it when message is sent.
     * @param frame
     */
public ZMsg wrap(ZFrame frame){
    if (frame != null) {
        push(new ZFrame(""""));
        push(frame);
    }
    return this;
}","public ZMsg wrap(ZFrame frame){
    if (frame != null) {
        push(new ZFrame(""""));
        push(frame);
    }
    return this;
}","/**
     * Push frame plus empty frame to front of message, before 1st frame.
     * Message takes ownership of frame, will destroy it when message is sent.
     * @param frame
     */","('wrap', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,"Push frame plus empty frame to front of message, before 1st frame.",14.0,"['Push frame with empty frame to front of message.', 'Before the first frame, push frame plus empty frame to front of message.', 'Before the first frame, push frame plus empty frame to front.']"
79,glowstone,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,readCompoundList,558-570,"/**
     * Applies the given function to a list subtag if it is present and its contents are compound
     * tags. Processes the list as a single object; to process each tag separately, instead use
     * {@link #iterateCompoundList(String, Consumer)}.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */
public boolean readCompoundList(@NonNls String key, Consumer<? super List<CompoundTag>> consumer){
    return readList(key, TagType.COMPOUND, consumer);
}","public boolean readCompoundList(@NonNls String key, Consumer<? super List<CompoundTag>> consumer){
    return readList(key, TagType.COMPOUND, consumer);
}","/**
     * Applies the given function to a list subtag if it is present and its contents are compound
     * tags. Processes the list as a single object; to process each tag separately, instead use
     * {@link #iterateCompoundList(String, Consumer)}.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */","('readCompoundList', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,  Applies the given function to a list subtag if it is present and its contents are compound  tags.,19.0,"['If the function is present and its contents are compound tags, apply it to a list subtag.', 'If the function is present and the contents are compound tags, apply it to a list subtag.', 'If the function is present and its contents are compound tags, apply it to the list subtag.']"
80,glowstone,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,putCompoundList,947-955,"/**
     * Adds or replaces a list subtag with a list of compound tags.
     *
     * @param key the key to write to
     * @param list the list contents as compound tags
     */
public void putCompoundList(@NonNls String key, List<CompoundTag> list){
    put(key, new ListTag<>(TagType.COMPOUND, list));
}","public void putCompoundList(@NonNls String key, List<CompoundTag> list){
    put(key, new ListTag<>(TagType.COMPOUND, list));
}","/**
     * Adds or replaces a list subtag with a list of compound tags.
     *
     * @param key the key to write to
     * @param list the list contents as compound tags
     */","('putCompoundList', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,  Adds or replaces a list subtag with a list of compound tags.,13.0,"['A list subtag is replaced with a list of compound tags.', 'A list subtag is added or replaced with a list of compound tags.', 'A list subtag is replaced by a list of compound tags.']"
81,weblogic-kubernetes-operator,oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,hasNamedServer,135-143,"/**
   * Returns true if one of the servers in the cluster has the specified name.
   *
   * @param serverName the name to look for
   * @return true or false
   */
public boolean hasNamedServer(String serverName){
    return getServerConfigs().stream().anyMatch(c -> serverName.equals(c.getName()));
}","public boolean hasNamedServer(String serverName){
    return getServerConfigs().stream().anyMatch(c -> serverName.equals(c.getName()));
}","/**
   * Returns true if one of the servers in the cluster has the specified name.
   *
   * @param serverName the name to look for
   * @return true or false
   */","('hasNamedServer', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,  Returns true if one of the servers in the cluster has the specified name.,15.0,"['If a server in the cluster has a specified name, this is true.', 'If a server in the cluster has the specified name, it will be true.', 'If a server in the cluster has a specified name, it will be true.']"
82,glowstone,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,readFloatList,596-606,"/**
     * Applies the given function to a list subtag if it is present and its contents are float
     * tags.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */
public boolean readFloatList(@NonNls String key, Consumer<? super List<Float>> consumer){
    return readList(key, TagType.FLOAT, consumer);
}","public boolean readFloatList(@NonNls String key, Consumer<? super List<Float>> consumer){
    return readList(key, TagType.FLOAT, consumer);
}","/**
     * Applies the given function to a list subtag if it is present and its contents are float
     * tags.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */","('readFloatList', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,  Applies the given function to a list subtag if it is present and its contents are float  tags.,19.0,"['If the function is present and its contents are float tags, apply it to a list subtag.', 'If the function is present and the contents are float tags, apply it to a list subtag.', 'If the function is present and the contents are float tags, apply it to the list subtag.']"
83,glowstone,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,readStringList,584-594,"/**
     * Applies the given function to a list subtag if it is present and its contents are string
     * tags.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */
public boolean readStringList(@NonNls String key, Consumer<? super List<String>> consumer){
    return readList(key, TagType.STRING, consumer);
}","public boolean readStringList(@NonNls String key, Consumer<? super List<String>> consumer){
    return readList(key, TagType.STRING, consumer);
}","/**
     * Applies the given function to a list subtag if it is present and its contents are string
     * tags.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */","('readStringList', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,  Applies the given function to a list subtag if it is present and its contents are string  tags.,19.0,"['If the function is present and its contents are string tags, apply it to a list subtag.', 'If the function is present and the contents are string tags, apply it to the list subtag.', 'If the function is present and its contents are string tags, apply it to the list subtag.']"
84,glowstone,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,readDoubleList,608-618,"/**
     * Applies the given function to a list subtag if it is present and its contents are double
     * tags.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */
public boolean readDoubleList(@NonNls String key, Consumer<? super List<Double>> consumer){
    return readList(key, TagType.DOUBLE, consumer);
}","public boolean readDoubleList(@NonNls String key, Consumer<? super List<Double>> consumer){
    return readList(key, TagType.DOUBLE, consumer);
}","/**
     * Applies the given function to a list subtag if it is present and its contents are double
     * tags.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */","('readDoubleList', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,  Applies the given function to a list subtag if it is present and its contents are double  tags.,19.0,"['If the function is present and its contents are double tags, apply it to a list subtag.', 'If the function is present and the contents are double tags, apply it to a list subtag.', 'If the function is present and the contents are double tags, apply it to the list subtag.']"
85,javaparser,com/github/javaparser/serialization/JavaParserJsonDeserializer.java,/javaparser-core-serialization/src/main/java/com/github/javaparser/serialization/JavaParserJsonDeserializer.java,readNonMetaProperties,132-143,"/**
     * Reads properties from json not included in meta model (i.e., RANGE and TOKEN_RANGE).
     * When read, it sets the deserialized value to the node instance.
     * @param name propertyKey name for json value
     * @param jsonValue json value that needs to be deserialized for this propertyKey
     * @param node instance to which the deserialized value will be set to
     * @return true if propertyKey is read from json and set to Node instance
     */
protected boolean readNonMetaProperties(String name, JsonValue jsonValue, Node node){
    return readRange(name, jsonValue, node) || readTokenRange(name, jsonValue, node);
}","protected boolean readNonMetaProperties(String name, JsonValue jsonValue, Node node){
    return readRange(name, jsonValue, node) || readTokenRange(name, jsonValue, node);
}","/**
     * Reads properties from json not included in meta model (i.e., RANGE and TOKEN_RANGE).
     * When read, it sets the deserialized value to the node instance.
     * @param name propertyKey name for json value
     * @param jsonValue json value that needs to be deserialized for this propertyKey
     * @param node instance to which the deserialized value will be set to
     * @return true if propertyKey is read from json and set to Node instance
     */","('readNonMetaProperties', {'INSTRUCTION': {'covered': 15, 'missed': 1}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0,  Reads properties from json not included in meta model (i.,12.0,"[""Reads properties that aren't included in the model."", 'Reads properties that are not included in the meta model.', 'Reads properties that are not included in the model.']"
86,tablesaw,tech/tablesaw/columns/Column.java,/core/src/main/java/tech/tablesaw/columns/Column.java,first,654-658,"/** Returns a column of the same type containing the first {@code numRows} of this column. */
 Column<T> first(final int numRows){
    int newRowCount = Math.min(numRows, size());
    return inRange(0, newRowCount);
}","Column<T> first(final int numRows){
    int newRowCount = Math.min(numRows, size());
    return inRange(0, newRowCount);
}",/** Returns a column of the same type containing the first {@code numRows} of this column. */,"('first', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",34.0, Returns a column of the same type containing the first {@code numRows} of this column.,19.0,"['The first @code numRows of this column is returned.', 'The first @code numRows of the column is returned.', 'A column containing the first @code numRows of this column is returned.']"
87,matsim-libs,org/matsim/utils/objectattributes/ObjectAttributesXmlReader.java,/matsim/src/main/java/org/matsim/utils/objectattributes/ObjectAttributesXmlReader.java,putAttributeConverter,110-119,"/**
	 * Sets the converter for reading attributes of the specified class.
	 *
	 * @param clazz
	 * @param converter
	 * @return the previously registered converter for this class, or <code>null</code> if none was set before.
	 */
public AttributeConverter<?> putAttributeConverter(final Class<?> clazz, final AttributeConverter<?> converter){
    return this.converter.putAttributeConverter(clazz, converter);
}","public AttributeConverter<?> putAttributeConverter(final Class<?> clazz, final AttributeConverter<?> converter){
    return this.converter.putAttributeConverter(clazz, converter);
}","/**
	 * Sets the converter for reading attributes of the specified class.
	 *
	 * @param clazz
	 * @param converter
	 * @return the previously registered converter for this class, or <code>null</code> if none was set before.
	 */","('putAttributeConverter', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,  Sets the converter for reading attributes of the specified class.,11.0,"[""The class's reading attributes are set."", ""The class's reading attributes can be set."", ""The class's reading attributes are converted.""]"
88,cdk,org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,skipLine,270-279,"/**
     * A line is skipped if it is empty or is a comment. MMFF files use '*' to mark comments and '$'
     * for end of file.
     *
     * @param line an input line
     * @return whether to skip this line
     */
private static boolean skipLine(String line){
    return line.isEmpty() || line.charAt(0) == '*' || line.charAt(0) == '$';
}","private static boolean skipLine(String line){
    return line.isEmpty() || line.charAt(0) == '*' || line.charAt(0) == '$';
}","/**
     * A line is skipped if it is empty or is a comment. MMFF files use '*' to mark comments and '$'
     * for end of file.
     *
     * @param line an input line
     * @return whether to skip this line
     */","('skipLine', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,  A line is skipped if it is empty or is a comment.,13.0,"['If a line is empty or a comment, it is skipped.', 'A line is not skipped if it is empty or a comment.', 'A line is not skipped if it is empty.']"
89,logstash-logback-encoder,net/logstash/logback/util/ThreadLocalHolder.java,/src/main/java/net/logstash/logback/util/ThreadLocalHolder.java,recycleInstance,247-260,"/**
     * Recycle the instance before returning it to the pool.
     * Sub-classes may override this method if they wish to implement their own custom logic.
     * 
     * @param instance the instance to recycle
     * @return {@code true} if the instance can be recycled and returned to the pool, {@code false} if not.
     */
protected boolean recycleInstance(T instance){
    if (instance instanceof Lifecycle) {
        return ((Lifecycle) instance).recycle();
    } else {
        return true;
    }
}","protected boolean recycleInstance(T instance){
    if (instance instanceof Lifecycle) {
        return ((Lifecycle) instance).recycle();
    } else {
        return true;
    }
}","/**
     * Recycle the instance before returning it to the pool.
     * Sub-classes may override this method if they wish to implement their own custom logic.
     * 
     * @param instance the instance to recycle
     * @return {@code true} if the instance can be recycled and returned to the pool, {@code false} if not.
     */","('recycleInstance', {'INSTRUCTION': {'covered': 7, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,  Recycle the instance before returning it to the pool.,10.0,"['If you want to return the instance to the pool, recycle it.', 'If you want to return the instance to the pool, recycle it first.', 'Before returning the instance to the pool, recycle it.']"
90,cdk,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,numberOfElements,128-139,"/**
     * Calculate the size of the partition as the sum of the sizes of the cells.
     *
     * @return the number of elements in the partition
     */
public int numberOfElements(){
    int n = 0;
    for (SortedSet<Integer> cell : cells) {
        n += cell.size();
    }
    return n;
}","public int numberOfElements(){
    int n = 0;
    for (SortedSet<Integer> cell : cells) {
        n += cell.size();
    }
    return n;
}","/**
     * Calculate the size of the partition as the sum of the sizes of the cells.
     *
     * @return the number of elements in the partition
     */","('numberOfElements', {'INSTRUCTION': {'covered': 21, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,  Calculate the size of the partition as the sum of the sizes of the cells.,16.0,"['The sum of the sizes of the cells is the size of the partition.', 'The sum of the sizes of the cells should be calculated.', ""The partition's size should be calculated as the sum of the cells' sizes.""]"
91,weblogic-kubernetes-operator,oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,containsServer,365-374,"/**
   * Whether this cluster contains a server with the given server name,
   * including servers that are both configured and dynamic servers.
   *
   * @param serverName server name to be checked
   * @return True if the cluster contains a server with the given server name
   */
 boolean containsServer(@Nonnull String serverName){
    return getServerConfigs().stream().anyMatch(c -> serverName.equals(c.getName()));
}"," boolean containsServer(@Nonnull String serverName){
    return getServerConfigs().stream().anyMatch(c -> serverName.equals(c.getName()));
}","/**
   * Whether this cluster contains a server with the given server name,
   * including servers that are both configured and dynamic servers.
   *
   * @param serverName server name to be checked
   * @return True if the cluster contains a server with the given server name
   */","('containsServer', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,"  Whether this cluster contains a server with the given server name,  including servers that are both configured and dynamic servers.",22.0,"['Whether this cluster contains both configured and dynamic server.', 'Whether this cluster contains a server with a given name that is configured and dynamic.', 'Whether this cluster contains a server with a given name that is configured or dynamic.']"
93,cdk,org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,sum,148-157,"/**
     * Sum the components of two vectors, the input is not modified.
     *
     * @param a first vector
     * @param b second vector
     * @return scaled vector
     */
 static Vector2d sum(final Tuple2d a, final Tuple2d b){
    return new Vector2d(a.x + b.x, a.y + b.y);
}","static Vector2d sum(final Tuple2d a, final Tuple2d b){
    return new Vector2d(a.x + b.x, a.y + b.y);
}","/**
     * Sum the components of two vectors, the input is not modified.
     *
     * @param a first vector
     * @param b second vector
     * @return scaled vector
     */","('sum', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,"  Sum the components of two vectors, the input is not modified.",13.0,"['The input is not modified.', 'The input is not altered.', 'The input is not modified if you divide the components of two.']"
94,dataverse,edu/harvard/iq/dataverse/ingest/IngestUtil.java,/src/main/java/edu/harvard/iq/dataverse/ingest/IngestUtil.java,conflictsWithExistingFilenames,125-133,"/**
     * Given a new proposed label or directoryLabel for a file, check against
     * existing files if a duplicate directoryLabel/label combination would be
     * created.
     */
public static boolean conflictsWithExistingFilenames(String pathPlusFilename, List<FileMetadata> fileMetadatas){
    List<String> filePathsAndNames = getPathsAndFileNames(fileMetadatas);
    return filePathsAndNames.contains(pathPlusFilename);
}","public static boolean conflictsWithExistingFilenames(String pathPlusFilename, List<FileMetadata> fileMetadatas){
    List<String> filePathsAndNames = getPathsAndFileNames(fileMetadatas);
    return filePathsAndNames.contains(pathPlusFilename);
}","/**
     * Given a new proposed label or directoryLabel for a file, check against
     * existing files if a duplicate directoryLabel/label combination would be
     * created.
     */","('conflictsWithExistingFilenames', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,"  Given a new proposed label or directoryLabel for a file, check against  existing files if a duplicate directoryLabel/label combination would be  created.",24.0,"['If a duplicate directoryLabel/label combination would be created, check against existing files.', 'If a duplicate directoryLabel/label combination is created, check against existing files.', 'If a duplicate directorylabel/label combination is created, check against existing files.']"
95,cdk,org/openscience/cdk/layout/CorrectGeometricConfiguration.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/CorrectGeometricConfiguration.java,correct,70-83,"/**
     * Adjust all double bond elements in the provided structure. <b>IMPORTANT:
     * up/down labels should be adjusted before adjust double-bond
     * configurations. coordinates are reflected by this method which can lead
     * to incorrect tetrahedral specification.</b>
     *
     * @param container the structure to adjust
     * @throws IllegalArgumentException an atom had unset coordinates
     */
public static IAtomContainer correct(IAtomContainer container){
    if (container.stereoElements().iterator().hasNext())
        new CorrectGeometricConfiguration(container);
    return container;
}","public static IAtomContainer correct(IAtomContainer container){
    if (container.stereoElements().iterator().hasNext())
        new CorrectGeometricConfiguration(container);
    return container;
}","/**
     * Adjust all double bond elements in the provided structure. <b>IMPORTANT:
     * up/down labels should be adjusted before adjust double-bond
     * configurations. coordinates are reflected by this method which can lead
     * to incorrect tetrahedral specification.</b>
     *
     * @param container the structure to adjust
     * @throws IllegalArgumentException an atom had unset coordinates
     */","('correct', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,  Adjust all double bond elements in the provided structure.,10.0,"['The provided structure has double bond elements.', 'The structure has double bond elements.', 'Double bond elements should be adjusted.']"
96,dataverse,edu/harvard/iq/dataverse/authorization/groups/impl/explicit/ExplicitGroup.java,/src/main/java/edu/harvard/iq/dataverse/authorization/groups/impl/explicit/ExplicitGroup.java,containsIndirectly,348-359,"/**
     * @param req
     * @return {@code true} iff the request if contained in an explicit group that's a member of this group.
     */
private boolean containsIndirectly(DataverseRequest req){
    for (ExplicitGroup ceg : containedExplicitGroups) {
        if (ceg.contains(req)) {
            return true;
        }
    }
    return false;
}","private boolean containsIndirectly(DataverseRequest req){
    for (ExplicitGroup ceg : containedExplicitGroups) {
        if (ceg.contains(req)) {
            return true;
        }
    }
    return false;
}","/**
     * @param req
     * @return {@code true} iff the request if contained in an explicit group that's a member of this group.
     */","('containsIndirectly', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,  @param req  @return {@code true} iff the request if contained in an explicit group that's a member of this group.,27.0,"[""If the request is contained in an explicit group that's a member, it's true."", ""If the request is contained in an explicit group that's a member, it should be true."", ""If the request is contained in an explicit group that's a member, you should return true.""]"
97,glowstone,net/glowstone/util/VariableValueArray.java,/src/main/java/net/glowstone/util/VariableValueArray.java,calculateNeededBits,40-53,"/**
     * Calculates the number of bits that would be needed to store the given value.
     *
     * @param number the value
     * @return The number of bits that would be needed to store the value.
     */
public static int calculateNeededBits(int number){
    int count = 0;
    do {
        count++;
        number >>>= 1;
    } while (number != 0);
    return count;
}","public static int calculateNeededBits(int number){
    int count = 0;
    do {
        count++;
        number >>>= 1;
    } while (number != 0);
    return count;
}","/**
     * Calculates the number of bits that would be needed to store the given value.
     *
     * @param number the value
     * @return The number of bits that would be needed to store the value.
     */","('calculateNeededBits', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",35.0,  Calculates the number of bits that would be needed to store the given value.,15.0,"['The number of bits needed to store the value is calculated.', 'The number of bits needed to store the given value is calculated.', 'The number of bits that would be needed to store the value is calculated.']"
98,cdk,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,parity,978-994,"/**
     * Obtain the parity (winding) of a tetrahedral element. The parity is -1
     * for clockwise (odd), +1 for anticlockwise (even) and 0 for unspecified.
     *
     * @param stereo configuration
     * @return the parity
     */
private int parity(ITetrahedralChirality.Stereo stereo){
    switch(stereo) {
        case CLOCKWISE:
            return -1;
        case ANTI_CLOCKWISE:
            return +1;
        default:
            return 0;
    }
}","private int parity(ITetrahedralChirality.Stereo stereo){
    switch(stereo) {
        case CLOCKWISE:
            return -1;
        case ANTI_CLOCKWISE:
            return +1;
        default:
            return 0;
    }
}","/**
     * Obtain the parity (winding) of a tetrahedral element. The parity is -1
     * for clockwise (odd), +1 for anticlockwise (even) and 0 for unspecified.
     *
     * @param stereo configuration
     * @return the parity
     */","('parity', {'INSTRUCTION': {'covered': 9, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,  Obtain the parity (winding) of a tetrahedral element.,11.0,"['The element has a parity.', 'The element has parity.', 'There is a parity of a element.']"
99,logstash-logback-encoder,net/logstash/logback/stacktrace/StackHasher.java,/src/main/java/net/logstash/logback/stacktrace/StackHasher.java,hexHashes,59-72,"/**
     * Generates and returns Hexadecimal hashes for the error stack and each ancestor {@link Throwable#getCause() cause}.
     * <p>
     * The first queue element is the stack hash for the topmost error, the next one (if any) is it's direct
     * {@link Throwable#getCause() cause} hash, and so on...
     * 
     * @param error the error to generate a hash from
     * @return a Dequeue with hashes
     */
public Deque<String> hexHashes(Throwable error){
    Deque<String> hexHashes = new ArrayDeque<String>();
    hash(error, hexHashes);
    return hexHashes;
}","public Deque<String> hexHashes(Throwable error){
    Deque<String> hexHashes = new ArrayDeque<String>();
    hash(error, hexHashes);
    return hexHashes;
}","/**
     * Generates and returns Hexadecimal hashes for the error stack and each ancestor {@link Throwable#getCause() cause}.
     * <p>
     * The first queue element is the stack hash for the topmost error, the next one (if any) is it's direct
     * {@link Throwable#getCause() cause} hash, and so on...
     * 
     * @param error the error to generate a hash from
     * @return a Dequeue with hashes
     */","('hexHashes', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,  Generates and returns Hexadecimal hashes for the error stack and each ancestor {@link Throwable#getCause() cause}.,23.0,"['The error stack and each descendant of the @link Throwable#getCause> cause are generated and returned.', 'The error stack and each descendant of the @link Throwable#getCause cause are generated and returned.', 'The error stack and each descendant of the @link Throwable#getCause']"
100,jackson-databind,com/fasterxml/jackson/databind/node/ObjectNode.java,/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java,replace,439-457,"/**
     * Method for replacing value of specific property with passed
     * value, and returning value (or null if none).
     *
     * @param propertyName Property of which value to replace
     * @param value Value to set property to, replacing old value if any
     * 
     * @return Old value of the property; null if there was no such property
     *   with value
     * 
     * @since 2.1
     */
public JsonNode replace(String propertyName, JsonNode value){
    if (value == null) {
        value = nullNode();
    }
    return _children.put(propertyName, value);
}","public JsonNode replace(String propertyName, JsonNode value){
    if (value == null) {
        value = nullNode();
    }
    return _children.put(propertyName, value);
}","/**
     * Method for replacing value of specific property with passed
     * value, and returning value (or null if none).
     *
     * @param propertyName Property of which value to replace
     * @param value Value to set property to, replacing old value if any
     * 
     * @return Old value of the property; null if there was no such property
     *   with value
     * 
     * @since 2.1
     */","('replace', {'INSTRUCTION': {'covered': 9, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,"  Method for replacing value of specific property with passed  value, and returning value (or null if none).",21.0,"['The method for replacing value of specific property with passed value is used.', 'The method for replacing value of specific property with passed value and returning value is the same as the method for returning value.', 'The method for replacing value of specific property with passed value and returning value is different from the method for returning value.']"
101,jackson-databind,com/fasterxml/jackson/databind/node/ObjectNode.java,/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java,putIfAbsent,523-552,"/**
     * Method that will set value of specified property if (and only if)
     * it had no set value previously.
     * Note that explicitly set {@code null} is a value.
     * Functionally equivalent to:
     *<code>
     *  if (get(propertyName) == null) {
     *      set(propertyName, value);
     *      return null;
     *  } else {
     *      return get(propertyName);
     *  }
     *</code>
     *
     * @param propertyName Name of property to set
     * @param value Value to set to property (if and only if it had no value previously);
     *  if null, will be converted to a {@link NullNode} first.
     *
     * @return Old value of the property, if any (in which case value was not changed);
     *     null if there was no old value (in which case value is now set)
     *
     * @since 2.13
     */
public JsonNode putIfAbsent(String propertyName, JsonNode value){
    if (value == null) {
        value = nullNode();
    }
    return _children.putIfAbsent(propertyName, value);
}","public JsonNode putIfAbsent(String propertyName, JsonNode value){
    if (value == null) {
        value = nullNode();
    }
    return _children.putIfAbsent(propertyName, value);
}","/**
     * Method that will set value of specified property if (and only if)
     * it had no set value previously.
     * Note that explicitly set {@code null} is a value.
     * Functionally equivalent to:
     *<code>
     *  if (get(propertyName) == null) {
     *      set(propertyName, value);
     *      return null;
     *  } else {
     *      return get(propertyName);
     *  }
     *</code>
     *
     * @param propertyName Name of property to set
     * @param value Value to set to property (if and only if it had no value previously);
     *  if null, will be converted to a {@link NullNode} first.
     *
     * @return Old value of the property, if any (in which case value was not changed);
     *     null if there was no old value (in which case value is now set)
     *
     * @since 2.13
     */","('putIfAbsent', {'INSTRUCTION': {'covered': 9, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,  Method that will set value of specified property if (and only if)  it had no set value previously.,21.0,"['If the property had no set value before, the method will set the value.', 'If the property has no set value before, the method will set the value.', 'If the specified property had no set value before, the method will set the value.']"
102,matsim-libs,org/matsim/core/replanning/StrategyManager.java,/matsim/src/main/java/org/matsim/core/replanning/StrategyManager.java,changeWeightOfStrategy,150-161,"/**
	 * changes the weight of the specified strategy
	 *
	 * @return true if the strategy is part of this manager and the weight could
	 * 		be changed successfully, false otherwise.
	 */
public final boolean changeWeightOfStrategy(final GenericPlanStrategy<Plan, Person> strategy, final String subpopulation, final double newWeight){
    return delegate.changeWeightOfStrategy(strategy, subpopulation, newWeight);
}","public final boolean changeWeightOfStrategy(final GenericPlanStrategy<Plan, Person> strategy, final String subpopulation, final double newWeight){
    return delegate.changeWeightOfStrategy(strategy, subpopulation, newWeight);
}","/**
	 * changes the weight of the specified strategy
	 *
	 * @return true if the strategy is part of this manager and the weight could
	 * 		be changed successfully, false otherwise.
	 */","('changeWeightOfStrategy', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,"  changes the weight of the specified strategy   @return true if the strategy is part of this manager and the weight could  be changed successfully, false otherwise.",29.0,"['If the strategy is part of this manager and the weight can be changed successfully, false.', 'If the strategy is part of the manager and the weight can be changed successfully, false.', 'If the strategy is part of this manager and the weight can be changed successfully, false otherwise.']"
103,matsim-libs,org/matsim/contrib/freight/jsprit/DistanceConstraint.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/jsprit/DistanceConstraint.java,findMinimalDistance,287-300,"/**
	 * Checks if the find possible distance is the minimal one.
	 *
	 * @param minimalAdditionalDistance
	 * @param possibleAdditionalDistance
	 * @return the minimal transport distance
	 */
private double findMinimalDistance(double minimalAdditionalDistance, double possibleAdditionalDistance){
    if (minimalAdditionalDistance == 0)
        minimalAdditionalDistance = possibleAdditionalDistance;
    else if (possibleAdditionalDistance < minimalAdditionalDistance)
        minimalAdditionalDistance = possibleAdditionalDistance;
    return minimalAdditionalDistance;
}","private double findMinimalDistance(double minimalAdditionalDistance, double possibleAdditionalDistance){
    if (minimalAdditionalDistance == 0)
        minimalAdditionalDistance = possibleAdditionalDistance;
    else if (possibleAdditionalDistance < minimalAdditionalDistance)
        minimalAdditionalDistance = possibleAdditionalDistance;
    return minimalAdditionalDistance;
}","/**
	 * Checks if the find possible distance is the minimal one.
	 *
	 * @param minimalAdditionalDistance
	 * @param possibleAdditionalDistance
	 * @return the minimal transport distance
	 */","('findMinimalDistance', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,  Checks if the find possible distance is the minimal one.,11.0,"['The find possible distance is checked.', ""If the find is minimal, it's checked."", 'If the find distance is minimal, it is checked.']"
104,jackson-databind,com/fasterxml/jackson/databind/node/POJONode.java,/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java,binaryValue,36-48,"/**
     * As it is possible that some implementations embed byte[] as POJONode
     * (despite optimal being {@link BinaryNode}), let's add support for exposing
     * binary data here too.
     */
public byte[] binaryValue() throws IOException{
    if (_value instanceof byte[]) {
        return (byte[]) _value;
    }
    return super.binaryValue();
}","public byte[] binaryValue() throws IOException{
    if (_value instanceof byte[]) {
        return (byte[]) _value;
    }
    return super.binaryValue();
}","/**
     * As it is possible that some implementations embed byte[] as POJONode
     * (despite optimal being {@link BinaryNode}), let's add support for exposing
     * binary data here too.
     */","('binaryValue', {'INSTRUCTION': {'covered': 8, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,"  As it is possible that some implementations embed byte[] as POJONode  (despite optimal being {@link BinaryNode}), let's add support for exposing  binary data here too.",35.0,"['There is a chance that some implementations will add support for exposing data here.', 'There is a chance that some implementations will add support for exposing data here too.', 'There is a chance that some implementations will add support for exposing the data here.']"
105,cdk,org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,extent,293-303,"/**
     * Calculate the angular extent of a vector (0-2 radians) anti clockwise from
     * east {1,0}.
     *
     * @param vector a vector
     * @return the extent (radians)
     */
 static double extent(Vector2d vector){
    double radians = Math.atan2(vector.y, vector.x);
    return radians < 0 ? TAU + radians : radians;
}","static double extent(Vector2d vector){
    double radians = Math.atan2(vector.y, vector.x);
    return radians < 0 ? TAU + radians : radians;
}","/**
     * Calculate the angular extent of a vector (0-2 radians) anti clockwise from
     * east {1,0}.
     *
     * @param vector a vector
     * @return the extent (radians)
     */","('extent', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,"Calculate the angular extent of a vector (0-2 radians) anti clockwise from  east {1,0}.",19.0,"['The angle of a radians is calculated from east to west.', 'The angle of a radians is calculated from the east to the west.', 'The angle of a radians is calculated from east to east.']"
106,soul,org/apache/shenyu/admin/controller/PluginHandleController.java,/shenyu-admin/src/main/java/org/apache/shenyu/admin/controller/PluginHandleController.java,deletePluginHandles,118-126,"/**
     * batch delete some plugin handles by some id list.
     * @param ids plugin handle id list.
     * @return {@linkplain ShenyuAdminResult}
     */
public ShenyuAdminResult deletePluginHandles(@RequestBody @NotEmpty final List<@NotBlank String> ids){
    return ShenyuAdminResult.success(ShenyuResultMessage.DELETE_SUCCESS, pluginHandleService.deletePluginHandles(ids));
}","public ShenyuAdminResult deletePluginHandles(@RequestBody @NotEmpty final List<@NotBlank String> ids){
    return ShenyuAdminResult.success(ShenyuResultMessage.DELETE_SUCCESS, pluginHandleService.deletePluginHandles(ids));
}","/**
     * batch delete some plugin handles by some id list.
     * @param ids plugin handle id list.
     * @return {@linkplain ShenyuAdminResult}
     */","('deletePluginHandles', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,  batch delete some plugin handles by some id list.,10.0,"['Some handles by an id list should be deleted.', 'Some handles are deleted by some id list.', 'Some handles by an id list are deleted.']"
107,cdk,org/openscience/cdk/fingerprint/MACCSFingerprinter.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/MACCSFingerprinter.java,createPattern,307-319,"/**
     * Create a pattern for the provided SMARTS - if the SMARTS is '?' a pattern
     * is not created.
     *
     * @param smarts  a smarts pattern
     * @param builder chem object builder
     * @return the pattern to match
     */
private Pattern createPattern(String smarts, IChemObjectBuilder builder) throws IOException{
    SmartsPattern ptrn = SmartsPattern.create(smarts, builder);
    ptrn.setPrepare(false);
    return ptrn;
}","private Pattern createPattern(String smarts, IChemObjectBuilder builder) throws IOException{
    SmartsPattern ptrn = SmartsPattern.create(smarts, builder);
    ptrn.setPrepare(false);
    return ptrn;
}","/**
     * Create a pattern for the provided SMARTS - if the SMARTS is '?' a pattern
     * is not created.
     *
     * @param smarts  a smarts pattern
     * @param builder chem object builder
     * @return the pattern to match
     */","('createPattern', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,  Create a pattern for the provided SMARTS - if the SMARTS is '?' a pattern  is not created.,21.0,"[""A pattern is not created if the SMARTS is '?'"", ""If the SMARTS is '?' a pattern is not created."", ""If the SMARTS is '?', a pattern is not created.""]"
108,tablesaw,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,appendRow,1098-1112,"/**
   * Appends an empty row and returns a Row object indexed to the newly added row so values can be
   * set.
   *
   * <p>Intended usage:
   *
   * <p>for (int i = 0; ...) { Row row = table.appendRow(); row.setString(""name"", ""Bob"");
   * row.setFloat(""IQ"", 123.4f); ...etc. }
   */
public Row appendRow(){
    for (final Column<?> column : columnList) {
        column.appendMissing();
    }
    return row(rowCount() - 1);
}","public Row appendRow(){
    for (final Column<?> column : columnList) {
        column.appendMissing();
    }
    return row(rowCount() - 1);
}","/**
   * Appends an empty row and returns a Row object indexed to the newly added row so values can be
   * set.
   *
   * <p>Intended usage:
   *
   * <p>for (int i = 0; ...) { Row row = table.appendRow(); row.setString(""name"", ""Bob"");
   * row.setFloat(""IQ"", 123.4f); ...etc. }
   */","('appendRow', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,  Appends an empty row and returns a Row object indexed to the newly added row so values can be  set.,21.0,"['Appends an empty row and returns a Row object that can be used to set values.', 'Appends an empty row and returns a Row object that is related to the new row.', 'Appends an empty row and returns a Row object that is related to the newly added row.']"
109,cdk,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,hasCommonAtom,900-910,"/**
     * Determines if two bonds have at least one atom in common.
     *
     * @param  atom  first bondA1
     * @param  bondB  second bondA1
     * @return    the symbol of the common atom or """" if
     *            the 2 bonds have no common atom
     */
private static boolean hasCommonAtom(IBond bondA, IBond bondB){
    return bondA.contains(bondB.getBegin()) || bondA.contains(bondB.getEnd());
}","private static boolean hasCommonAtom(IBond bondA, IBond bondB){
    return bondA.contains(bondB.getBegin()) || bondA.contains(bondB.getEnd());
}","/**
     * Determines if two bonds have at least one atom in common.
     *
     * @param  atom  first bondA1
     * @param  bondB  second bondA1
     * @return    the symbol of the common atom or """" if
     *            the 2 bonds have no common atom
     */","('hasCommonAtom', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",36.0,  Determines if two bonds have at least one atom in common.,12.0,"[""If two bonds have at least one atom in common, it's determined."", 'If two bonds have at least one atom in common, it is determined.', ""If two bonds have at least one atom in common, it's a good sign.""]"
110,shardingsphere-elasticjob,org/apache/shardingsphere/elasticjob/cloud/scheduler/mesos/SupportedExtractionType.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/scheduler/mesos/SupportedExtractionType.java,isExtraction,45-58,"/**
     * Check whether the url is supported to extract or not.
     *
     * @param appURL app url
     * @return true is the url supported, otherwise not
     */
public static boolean isExtraction(final String appURL){
    for (String each : EXTRACTION_TYPES) {
        if (appURL.endsWith(each)) {
            return true;
        }
    }
    return false;
}","public static boolean isExtraction(final String appURL){
    for (String each : EXTRACTION_TYPES) {
        if (appURL.endsWith(each)) {
            return true;
        }
    }
    return false;
}","/**
     * Check whether the url is supported to extract or not.
     *
     * @param appURL app url
     * @return true is the url supported, otherwise not
     */","('isExtraction', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,  Check whether the url is supported to extract or not.,11.0,"['Check to see if the url is supported to extract.', 'Check if the url is supported to extract.', 'Check to see if the url supports to extract.']"
111,anserini,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,computeQueryDocumentScoreWithSimilarity,673-689,"/**
   * Computes the score of a document with respect to a query given a scoring function. Assumes Anserini's default
   * analyzer.
   *
   * @param reader index reader
   * @param docid docid of the document to score
   * @param q query
   * @param similarity scoring function
   * @return the score of the document with respect to the query
   * @throws IOException if error encountered during query
   */
public static float computeQueryDocumentScoreWithSimilarity(IndexReader reader, String docid, String q, Similarity similarity) throws IOException{
    return computeQueryDocumentScoreWithSimilarityAndAnalyzer(reader, docid, q, similarity, IndexCollection.DEFAULT_ANALYZER);
}","public static float computeQueryDocumentScoreWithSimilarity(IndexReader reader, String docid, String q, Similarity similarity) throws IOException{
    return computeQueryDocumentScoreWithSimilarityAndAnalyzer(reader, docid, q, similarity, IndexCollection.DEFAULT_ANALYZER);
}","/**
   * Computes the score of a document with respect to a query given a scoring function. Assumes Anserini's default
   * analyzer.
   *
   * @param reader index reader
   * @param docid docid of the document to score
   * @param q query
   * @param similarity scoring function
   * @return the score of the document with respect to the query
   * @throws IOException if error encountered during query
   */","('computeQueryDocumentScoreWithSimilarity', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,  Computes the score of a document with respect to a query given a scoring function.,16.0,"['The score of a document is computed with respect to a query.', 'The score of a document is computed by using a scoring function.', 'The score of a document is computed with respect to the query given.']"
112,cdk,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,isDiscrete,141-154,"/**
     * Checks that all the cells are singletons - that is, they only have one
     * element. A discrete partition is equivalent to a permutation.
     *
     * @return true if all the cells are discrete
     */
public boolean isDiscrete(){
    for (SortedSet<Integer> cell : cells) {
        if (cell.size() != 1) {
            return false;
        }
    }
    return true;
}","public boolean isDiscrete(){
    for (SortedSet<Integer> cell : cells) {
        if (cell.size() != 1) {
            return false;
        }
    }
    return true;
}","/**
     * Checks that all the cells are singletons - that is, they only have one
     * element. A discrete partition is equivalent to a permutation.
     *
     * @return true if all the cells are discrete
     */","('isDiscrete', {'INSTRUCTION': {'covered': 18, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,"  Checks that all the cells are singletons - that is, they only have one  element.",17.0,"['The cells only have one element.', ""The cells only have one element, so it's important to check that."", ""The cells only have one element, so it's important to check them.""]"
113,cdk,org/openscience/cdk/formula/MolecularFormula.java,/base/data/src/main/java/org/openscience/cdk/formula/MolecularFormula.java,contains,133-149,"/**
     *  True, if the MolecularFormula contains the given IIsotope object and not
     *  the instance. The method looks for other isotopes which has the same
     *  symbol, natural abundance and exact mass.
     *
     * @param  isotope  The IIsotope this MolecularFormula is searched for
     * @return          True, if the MolecularFormula contains the given isotope object
     */
public boolean contains(IIsotope isotope){
    for (IIsotope thisIsotope : isotopes()) {
        if (isTheSame(thisIsotope, isotope)) {
            return true;
        }
    }
    return false;
}","public boolean contains(IIsotope isotope){
    for (IIsotope thisIsotope : isotopes()) {
        if (isTheSame(thisIsotope, isotope)) {
            return true;
        }
    }
    return false;
}","/**
     *  True, if the MolecularFormula contains the given IIsotope object and not
     *  the instance. The method looks for other isotopes which has the same
     *  symbol, natural abundance and exact mass.
     *
     * @param  isotope  The IIsotope this MolecularFormula is searched for
     * @return          True, if the MolecularFormula contains the given isotope object
     */","('contains', {'INSTRUCTION': {'covered': 21, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,"  True, if the MolecularFormula contains the given IIsotope object and not  the instance.",15.0,"[""If the MolecularFormula contains the IIsotope object, it's true."", 'If the MolecularFormula contains the IIsotope object, it is true.', 'If the MolecularFormula contains the IIsotope object, then it is true.']"
114,openapi-generator,org/openapitools/codegen/templating/HandlebarsEngineAdapter.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/templating/HandlebarsEngineAdapter.java,handlesFile,119-129,"/**
     * Determine if the adapter handles compilation of the file
     *
     * @param filename The template filename
     * @return True if the file should be compiled by this adapter, else false.
     */
public boolean handlesFile(String filename){
    return Arrays.stream(canCompileFromExtensions).anyMatch(suffix -> !suffix.equalsIgnoreCase(filename) && filename.endsWith(suffix));
}","public boolean handlesFile(String filename){
    return Arrays.stream(canCompileFromExtensions).anyMatch(suffix -> !suffix.equalsIgnoreCase(filename) && filename.endsWith(suffix));
}","/**
     * Determine if the adapter handles compilation of the file
     *
     * @param filename The template filename
     * @return True if the file should be compiled by this adapter, else false.
     */","('handlesFile', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,"  Determine if the adapter handles compilation of the file   @param filename The template filename  @return True if the file should be compiled by this adapter, else false.",31.0,"['If the file should be compiled by this adapter, then the template filename should be true.', 'If the file should be compiled by this adapter, the template filename should be true.', 'If the file should be compiled by this adapter, the template filename should be false.']"
115,cucumber-reporting,net/masterthought/cucumber/reducers/ReportFeatureWithRetestMerger.java,/src/main/java/net/masterthought/cucumber/reducers/ReportFeatureWithRetestMerger.java,isBackground,83-91,"/**
     * @return true when element from elements array with index=elementInd is a background.
     */
 boolean isBackground(int elementInd, Element[] elements){
    return elementInd >= 0 && elements != null && elementInd < elements.length && elements[elementInd].isBackground();
}","boolean isBackground(int elementInd, Element[] elements){
    return elementInd >= 0 && elements != null && elementInd < elements.length && elements[elementInd].isBackground();
}","/**
     * @return true when element from elements array with index=elementInd is a background.
     */","('isBackground', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,  @return true when element from elements array with index=elementInd is a background.,14.0,"['When element from elements array with index is a background, return true.', 'When element from elements array is a background, return true.', ""When element from elements array with index is a background, it's true.""]"
116,cdk,org/openscience/cdk/Reaction.java,/base/data/src/main/java/org/openscience/cdk/Reaction.java,addMapping,411-424,"/**
     * Adds a mapping between the reactant and product side to this
     * Reaction.
     *
     * @param mapping Mapping to add.
     * @see   #mappings
     */
public void addMapping(IMapping mapping){
    if (mappingCount + 1 >= map.length)
        growMappingArray();
    map[mappingCount] = mapping;
    mappingCount++;
    notifyChanged();
}","public void addMapping(IMapping mapping){
    if (mappingCount + 1 >= map.length)
        growMappingArray();
    map[mappingCount] = mapping;
    mappingCount++;
    notifyChanged();
}","/**
     * Adds a mapping between the reactant and product side to this
     * Reaction.
     *
     * @param mapping Mapping to add.
     * @see   #mappings
     */","('addMapping', {'INSTRUCTION': {'covered': 23, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,  Adds a mapping between the reactant and product side to this  Reaction.,13.0,"['There is a mapping between the reactant and product side.', 'A mapping between the reactant and product side is added.', 'The reactant and product side are mapped.']"
117,jackson-databind,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,readerForListOf,4161-4175,"/**
     * Factory method for constructing {@link ObjectReader} that will
     * read or update instances of a type {@code List<type>}.
     * Functionally same as:
     *<pre>
     *    readerFor(new TypeReference&lt;List&lt;type&gt;&gt;() { });
     *</pre>
     *
     * @since 2.11
     */
public ObjectReader readerForListOf(Class<?> type){
    return _newReader(getDeserializationConfig(), _typeFactory.constructCollectionType(List.class, type), null, null, _injectableValues);
}","public ObjectReader readerForListOf(Class<?> type){
    return _newReader(getDeserializationConfig(), _typeFactory.constructCollectionType(List.class, type), null, null, _injectableValues);
}","/**
     * Factory method for constructing {@link ObjectReader} that will
     * read or update instances of a type {@code List<type>}.
     * Functionally same as:
     *<pre>
     *    readerFor(new TypeReference&lt;List&lt;type&gt;&gt;() { });
     *</pre>
     *
     * @since 2.11
     */","('readerForListOf', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,  Factory method for constructing {@link ObjectReader} that will  read or update instances of a type {@code List<type>}.,27.0,"['A factory method for constructing @link ObjectReader that will read or update instances of a type.', 'The factory method for constructing @link ObjectReader will read or update instances of a type.', 'The method for constructing @link ObjectReader will read or update instances of a type.']"
118,dataverse,edu/harvard/iq/dataverse/GlobalId.java,/src/main/java/edu/harvard/iq/dataverse/GlobalId.java,asString,110-121,"/**
     * Returns {@code this}' string representation. Differs from {@link #toString}
     * which can also contain debug data, if needed.
     * 
     * @return The string representation of this global id.
     */
public String asString(){
    if (protocol == null || authority == null || identifier == null) {
        return """";
    }
    return protocol + "":"" + authority + ""/"" + identifier;
}","public String asString(){
    if (protocol == null || authority == null || identifier == null) {
        return """";
    }
    return protocol + "":"" + authority + ""/"" + identifier;
}","/**
     * Returns {@code this}' string representation. Differs from {@link #toString}
     * which can also contain debug data, if needed.
     * 
     * @return The string representation of this global id.
     */","('asString', {'INSTRUCTION': {'covered': 17, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,  Returns {@code this}' string representation.,10.0,"['The string representation is returned.', 'This is the string representation.', 'This string representation is returned.']"
119,anserini,io/anserini/search/SimpleImpactSearcher.java,/src/main/java/io/anserini/search/SimpleImpactSearcher.java,documentContents,317-332,"/**
     * Returns the ""contents"" field of a document based on an internal Lucene docid.
     * The method is named to be consistent with Lucene's {@link IndexReader#document(int)}, contra Java's standard
     * method naming conventions.
     *
     * @param ldocid internal Lucene docid
     * @return the ""contents"" field the document
     */
public String documentContents(int ldocid){
    try {
        return reader.document(ldocid).get(IndexArgs.CONTENTS);
    } catch (Exception e) {
        return null;
    }
}","public String documentContents(int ldocid){
    try {
        return reader.document(ldocid).get(IndexArgs.CONTENTS);
    } catch (Exception e) {
        return null;
    }
}","/**
     * Returns the ""contents"" field of a document based on an internal Lucene docid.
     * The method is named to be consistent with Lucene's {@link IndexReader#document(int)}, contra Java's standard
     * method naming conventions.
     *
     * @param ldocid internal Lucene docid
     * @return the ""contents"" field the document
     */","('documentContents', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,"  Returns the ""contents"" field of a document based on an internal Lucene docid.",16.0,"['The ""contents"" field of a document is returned.', 'The ""contents"" field is based on an internal Lucene docid.', 'The ""contents"" field is based on an internal docid.']"
120,cdk,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,removeElement,206-218,"/**
     * Removes all isotopes from a given element in the MolecularFormula.
     *
     * @param  formula   IMolecularFormula molecularFormula
     * @param  element   The IElement of the IIsotopes to be removed
     * @return           The molecularFormula with the isotopes removed
     */
public static IMolecularFormula removeElement(IMolecularFormula formula, IElement element){
    for (IIsotope isotope : getIsotopes(formula, element)) {
        formula.removeIsotope(isotope);
    }
    return formula;
}","public static IMolecularFormula removeElement(IMolecularFormula formula, IElement element){
    for (IIsotope isotope : getIsotopes(formula, element)) {
        formula.removeIsotope(isotope);
    }
    return formula;
}","/**
     * Removes all isotopes from a given element in the MolecularFormula.
     *
     * @param  formula   IMolecularFormula molecularFormula
     * @param  element   The IElement of the IIsotopes to be removed
     * @return           The molecularFormula with the isotopes removed
     */","('removeElement', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,  Removes all isotopes from a given element in the MolecularFormula.,11.0,"['A given element has all of its isotopes removed.', 'A given element is removed from the MolecularFormula.', 'A given element has all of the elements removed from it.']"
121,matsim-libs,org/matsim/core/utils/geometry/GeometryUtils.java,/matsim/src/main/java/org/matsim/core/utils/geometry/GeometryUtils.java,findIntersectingLinks,55-66,"/**
	 * Method to find all links in {@link Network} that intersect a given {@link Link}.  Convenience method that
	 * only uses MATSim objects.
	 * 
	 * @param link
	 * @param network
	 * @return
	 */
public static List<Link> findIntersectingLinks(Link link, final Network network){
    LineString segment = GeometryUtils.createGeotoolsLineString(link);
    return GeometryUtils.findIntersectingLinks(segment, network);
}","public static List<Link> findIntersectingLinks(Link link, final Network network){
    LineString segment = GeometryUtils.createGeotoolsLineString(link);
    return GeometryUtils.findIntersectingLinks(segment, network);
}","/**
	 * Method to find all links in {@link Network} that intersect a given {@link Link}.  Convenience method that
	 * only uses MATSim objects.
	 * 
	 * @param link
	 * @param network
	 * @return
	 */","('findIntersectingLinks', {'INSTRUCTION': {'covered': 55, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,  Method to find all links in {@link Network} that intersect a given {@link Link}.,21.0,"['A method to find links that intersect a given one.', 'There is a method to find links that intersect a given one.', 'There is a method to find links in the @link Network.']"
122,anserini,io/anserini/search/SimpleImpactSearcher.java,/src/main/java/io/anserini/search/SimpleImpactSearcher.java,documentRaw,346-361,"/**
     * Returns the ""raw"" field of a document based on an internal Lucene docid.
     * The method is named to be consistent with Lucene's {@link IndexReader#document(int)}, contra Java's standard
     * method naming conventions.
     *
     * @param ldocid internal Lucene docid
     * @return the ""raw"" field the document
     */
public String documentRaw(int ldocid){
    try {
        return reader.document(ldocid).get(IndexArgs.RAW);
    } catch (Exception e) {
        return null;
    }
}","public String documentRaw(int ldocid){
    try {
        return reader.document(ldocid).get(IndexArgs.RAW);
    } catch (Exception e) {
        return null;
    }
}","/**
     * Returns the ""raw"" field of a document based on an internal Lucene docid.
     * The method is named to be consistent with Lucene's {@link IndexReader#document(int)}, contra Java's standard
     * method naming conventions.
     *
     * @param ldocid internal Lucene docid
     * @return the ""raw"" field the document
     */","('documentRaw', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",37.0,"  Returns the ""raw"" field of a document based on an internal Lucene docid.",16.0,"['The ""raw"" field of the document is returned.', 'The ""raw"" field of a document is returned.', 'The ""raw"" field is based on an internal docid.']"
123,acs-aem-commons,com/adobe/acs/commons/replication/status/impl/JcrPackageReplicationStatusEventHandler.java,/bundle/src/main/java/com/adobe/acs/commons/replication/status/impl/JcrPackageReplicationStatusEventHandler.java,containsJcrPackagePath,353-371,"/**
     * Checks if the given path looks like a Jcr Package path.
     *
     * Provides a very fast, String-based, in-memory check to weed out most false positives and avoid
     * resolving the path to a Jcr Package and ensure it is valid.
     *
     * @param path
     * @return true if at least one path looks like a Jcr Package path
     */
private boolean containsJcrPackagePath(final String path){
    if (StringUtils.startsWith(path, ""/etc/packages/"") && StringUtils.endsWith(path, "".zip"")) {
        return true;
    }
    return false;
}","private boolean containsJcrPackagePath(final String path){
    if (StringUtils.startsWith(path, ""/etc/packages/"") && StringUtils.endsWith(path, "".zip"")) {
        return true;
    }
    return false;
}","/**
     * Checks if the given path looks like a Jcr Package path.
     *
     * Provides a very fast, String-based, in-memory check to weed out most false positives and avoid
     * resolving the path to a Jcr Package and ensure it is valid.
     *
     * @param path
     * @return true if at least one path looks like a Jcr Package path
     */","('containsJcrPackagePath', {'INSTRUCTION': {'covered': 10, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,  Checks if the given path looks like a Jcr Package path.,12.0,"[""If the path looks like a Jcr Package path, it's time to check it."", ""If the path looks like a package path, it's time to check it."", ""If the path looks like a package path, it's time to check it out.""]"
125,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,createPortAlias,100-118,"/**
     * Create the port alias and attach it to the process.
     *
     * @param userId             the name of the calling user
     * @param portAlias          the port alias values
     * @param processGUID        the unique identifier of the process
     * @param externalSourceName the unique name of the external source
     *
     * @return unique identifier of the port alias in the repository
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */
public String createPortAlias(String userId, PortAlias portAlias, String processGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    return createPort(userId, portAlias, PORT_ALIAS_TYPE_NAME, processGUID, externalSourceName);
}","public String createPortAlias(String userId, PortAlias portAlias, String processGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    return createPort(userId, portAlias, PORT_ALIAS_TYPE_NAME, processGUID, externalSourceName);
}","/**
     * Create the port alias and attach it to the process.
     *
     * @param userId             the name of the calling user
     * @param portAlias          the port alias values
     * @param processGUID        the unique identifier of the process
     * @param externalSourceName the unique name of the external source
     *
     * @return unique identifier of the port alias in the repository
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */","('createPortAlias', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,  Create the port alias and attach it to the process.,11.0,"['Attach the port to the process.', 'Attach the port alias to the process.', 'Attach the port to the process by creating it.']"
127,dcache,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,updateEarliestChildExpiryDate,109-124,"/**
     * Possibly update our belief of the earliest time that a Mortal child StateComponent will
     * expire.  It is safe to call this method with all child Dates: it will update the
     * _earliestChildExpiry Date correctly.
     *
     * @param newDate the expiry Date of a Mortal child StateComponent
     */
private void updateEarliestChildExpiryDate(Date newDate){
    if (newDate == null) {
        return;
    }
    if (_earliestChildExpiry == null || newDate.before(_earliestChildExpiry)) {
        _earliestChildExpiry = newDate;
    }
}","private void updateEarliestChildExpiryDate(Date newDate){
    if (newDate == null) {
        return;
    }
    if (_earliestChildExpiry == null || newDate.before(_earliestChildExpiry)) {
        _earliestChildExpiry = newDate;
    }
}","/**
     * Possibly update our belief of the earliest time that a Mortal child StateComponent will
     * expire.  It is safe to call this method with all child Dates: it will update the
     * _earliestChildExpiry Date correctly.
     *
     * @param newDate the expiry Date of a Mortal child StateComponent
     */","('updateEarliestChildExpiryDate', {'INSTRUCTION': {'covered': 14, 'missed': 1}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,  Possibly update our belief of the earliest time that a Mortal child StateComponent will  expire.,16.0,"[""It is possible that we will update our belief that a child's StateComponent will end."", ""It is possible that we will update our belief that a child's StateComponent will end sooner than we thought."", ""It is possible that we will update our belief that a child's StateComponent will end sooner than previously thought.""]"
128,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,computeDisplayName,209-220,"/**
     * Will return the name of the last folder in pathName. Takes root folder into account.
     * When called with argument ""/folder"", return value is ""folder"".
     * When called with argument ""/"", return value is ""/""
     *
     * @param pathName path
     *
     * @return folder name
     */
private String computeDisplayName(String pathName){
    return new File(pathName).getName().length() < 1 ? pathName : new File(pathName).getName();
}","private String computeDisplayName(String pathName){
    return new File(pathName).getName().length() < 1 ? pathName : new File(pathName).getName();
}","/**
     * Will return the name of the last folder in pathName. Takes root folder into account.
     * When called with argument ""/folder"", return value is ""folder"".
     * When called with argument ""/"", return value is ""/""
     *
     * @param pathName path
     *
     * @return folder name
     */","('computeDisplayName', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,  Will return the name of the last folder in pathName.,11.0,"['The name of the last folder will be returned.', 'Will return the name of the last folder.', ""Will return the last folder's name.""]"
129,cdk,org/openscience/cdk/ChemObject.java,/base/data/src/main/java/org/openscience/cdk/ChemObject.java,addListener,119-135,"/**
     *  Use this to add yourself to this IChemObject as a listener. In order to do
     *  so, you must implement the ChemObjectListener Interface.
     *
     *@param  col  the ChemObjectListener
     *@see         #removeListener
     */
public void addListener(IChemObjectListener col){
    List<IChemObjectListener> listeners = lazyChemObjectListeners();
    if (!listeners.contains(col)) {
        listeners.add(col);
    }
}","public void addListener(IChemObjectListener col){
    List<IChemObjectListener> listeners = lazyChemObjectListeners();
    if (!listeners.contains(col)) {
        listeners.add(col);
    }
}","/**
     *  Use this to add yourself to this IChemObject as a listener. In order to do
     *  so, you must implement the ChemObjectListener Interface.
     *
     *@param  col  the ChemObjectListener
     *@see         #removeListener
     */","('addListener', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,  Use this to add yourself to this IChemObject as a listener.,12.0,"['You can add yourself to this IChem object.', 'You can add yourself to this IChem object as a listener.', 'Add yourself to this IChem object.']"
130,soul,org/apache/shenyu/springboot/starter/client/apache/dubbo/ShenyuApacheDubboClientConfiguration.java,/shenyu-spring-boot-starter/shenyu-spring-boot-starter-client/shenyu-spring-boot-starter-client-apache-dubbo/src/main/java/org/apache/shenyu/springboot/starter/client/apache/dubbo/ShenyuApacheDubboClientConfiguration.java,apacheDubboServiceBeanListener,36-47,"/**
     * Apache dubbo service bean listener apache dubbo service bean listener.
     *
     * @param clientConfig the client config
     * @param shenyuClientRegisterRepository the shenyu client register repository
     * @return the apache dubbo service bean listener
     */
public ApacheDubboServiceBeanListener apacheDubboServiceBeanListener(final ShenyuClientConfig clientConfig, final ShenyuClientRegisterRepository shenyuClientRegisterRepository){
    return new ApacheDubboServiceBeanListener(clientConfig.getClient().get(RpcTypeEnum.DUBBO.getName()), shenyuClientRegisterRepository);
}","public ApacheDubboServiceBeanListener apacheDubboServiceBeanListener(final ShenyuClientConfig clientConfig, final ShenyuClientRegisterRepository shenyuClientRegisterRepository){
    return new ApacheDubboServiceBeanListener(clientConfig.getClient().get(RpcTypeEnum.DUBBO.getName()), shenyuClientRegisterRepository);
}","/**
     * Apache dubbo service bean listener apache dubbo service bean listener.
     *
     * @param clientConfig the client config
     * @param shenyuClientRegisterRepository the shenyu client register repository
     * @return the apache dubbo service bean listener
     */","('apacheDubboServiceBeanListener', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,  Apache dubbo service bean listener apache dubbo service bean listener.,11.0,"['The apache dubbo service bean listener listens.', 'The apache dubbo service bean listener is on.', 'The apache dubbo service bean listens.']"
131,soul,org/apache/shenyu/springboot/starter/client/tars/ShenyuTarsClientConfiguration.java,/shenyu-spring-boot-starter/shenyu-spring-boot-starter-client/shenyu-spring-boot-starter-client-tars/src/main/java/org/apache/shenyu/springboot/starter/client/tars/ShenyuTarsClientConfiguration.java,tarsServiceBeanPostProcessor,38-48,"/**
     * Tars service bean post processor sofa service bean post processor.
     *
     * @param clientConfig the client config
     * @param shenyuClientRegisterRepository the shenyuClientRegisterRepository
     * @return the tars service bean post processor
     */
public TarsServiceBeanPostProcessor tarsServiceBeanPostProcessor(final ShenyuClientConfig clientConfig, final ShenyuClientRegisterRepository shenyuClientRegisterRepository){
    return new TarsServiceBeanPostProcessor(clientConfig.getClient().get(RpcTypeEnum.TARS.getName()), shenyuClientRegisterRepository);
}","public TarsServiceBeanPostProcessor tarsServiceBeanPostProcessor(final ShenyuClientConfig clientConfig, final ShenyuClientRegisterRepository shenyuClientRegisterRepository){
    return new TarsServiceBeanPostProcessor(clientConfig.getClient().get(RpcTypeEnum.TARS.getName()), shenyuClientRegisterRepository);
}","/**
     * Tars service bean post processor sofa service bean post processor.
     *
     * @param clientConfig the client config
     * @param shenyuClientRegisterRepository the shenyuClientRegisterRepository
     * @return the tars service bean post processor
     */","('tarsServiceBeanPostProcessor', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,  Tars service bean post processor sofa service bean post processor.,11.0,"['Tars service bean post processor.', 'Tars bean post processor is on the sofa.', 'Tars bean post processor.']"
132,weblogic-kubernetes-operator,oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,checkUpdateDynamicClusterSizeJsonResult,118-133,"/**
   * Checks the JSON result from the dynamic cluster size update REST request.
   *
   * @param jsonResult The JSON String result from the dynamic server cluster size update REST
   *     request
   * @return true if the result means the update was successful, false otherwise
   */
 static boolean checkUpdateDynamicClusterSizeJsonResult(String jsonResult){
    final String expectedResult = ""{}"";
    boolean result = false;
    if (expectedResult.equals(jsonResult)) {
        result = true;
    }
    return result;
}"," static boolean checkUpdateDynamicClusterSizeJsonResult(String jsonResult){
    final String expectedResult = ""{}"";
    boolean result = false;
    if (expectedResult.equals(jsonResult)) {
        result = true;
    }
    return result;
}","/**
   * Checks the JSON result from the dynamic cluster size update REST request.
   *
   * @param jsonResult The JSON String result from the dynamic server cluster size update REST
   *     request
   * @return true if the result means the update was successful, false otherwise
   */","('checkUpdateDynamicClusterSizeJsonResult', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,  Checks the JSON result from the dynamic cluster size update REST request.,13.0,"['The result of the dynamic cluster size update is checked.', 'The result is checked from the dynamic cluster size update.', 'The result is checked from the dynamic cluster size update request.']"
134,soul,org/apache/shenyu/springboot/starter/client/sofa/ShenyuSofaClientConfiguration.java,/shenyu-spring-boot-starter/shenyu-spring-boot-starter-client/shenyu-spring-boot-starter-client-sofa/src/main/java/org/apache/shenyu/springboot/starter/client/sofa/ShenyuSofaClientConfiguration.java,sofaServiceBeanPostProcessor,37-47,"/**
     * Sofa service bean post processor sofa service bean post processor.
     *
     * @param clientConfig the client config
     * @param shenyuClientRegisterRepository the shenyuClientRegisterRepository
     * @return the sofa service bean post processor
     */
public SofaServiceBeanPostProcessor sofaServiceBeanPostProcessor(final ShenyuClientConfig clientConfig, final ShenyuClientRegisterRepository shenyuClientRegisterRepository){
    return new SofaServiceBeanPostProcessor(clientConfig.getClient().get(RpcTypeEnum.SOFA.getName()), shenyuClientRegisterRepository);
}","public SofaServiceBeanPostProcessor sofaServiceBeanPostProcessor(final ShenyuClientConfig clientConfig, final ShenyuClientRegisterRepository shenyuClientRegisterRepository){
    return new SofaServiceBeanPostProcessor(clientConfig.getClient().get(RpcTypeEnum.SOFA.getName()), shenyuClientRegisterRepository);
}","/**
     * Sofa service bean post processor sofa service bean post processor.
     *
     * @param clientConfig the client config
     * @param shenyuClientRegisterRepository the shenyuClientRegisterRepository
     * @return the sofa service bean post processor
     */","('sofaServiceBeanPostProcessor', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,  Sofa service bean post processor sofa service bean post processor.,11.0,"['The sofa has a bean post processor.', 'The bean post processor is on the sofa.', 'The bean post processor is used for sofa service.']"
135,soul,org/apache/shenyu/springboot/starter/client/springmvc/ShenyuSpringMvcClientConfiguration.java,/shenyu-spring-boot-starter/shenyu-spring-boot-starter-client/shenyu-spring-boot-starter-client-springmvc/src/main/java/org/apache/shenyu/springboot/starter/client/springmvc/ShenyuSpringMvcClientConfiguration.java,springHttpClientBeanPostProcessor,37-48,"/**
     * Spring http client bean post processor spring mvc client bean post processor.
     *
     * @param clientConfig the client config
     * @param shenyuClientRegisterRepository the shenyu client register repository
     * @return the spring mvc client bean post processor
     */
public SpringMvcClientBeanPostProcessor springHttpClientBeanPostProcessor(final ShenyuClientConfig clientConfig, final ShenyuClientRegisterRepository shenyuClientRegisterRepository){
    return new SpringMvcClientBeanPostProcessor(clientConfig.getClient().get(RpcTypeEnum.HTTP.getName()), shenyuClientRegisterRepository);
}","public SpringMvcClientBeanPostProcessor springHttpClientBeanPostProcessor(final ShenyuClientConfig clientConfig, final ShenyuClientRegisterRepository shenyuClientRegisterRepository){
    return new SpringMvcClientBeanPostProcessor(clientConfig.getClient().get(RpcTypeEnum.HTTP.getName()), shenyuClientRegisterRepository);
}","/**
     * Spring http client bean post processor spring mvc client bean post processor.
     *
     * @param clientConfig the client config
     * @param shenyuClientRegisterRepository the shenyu client register repository
     * @return the spring mvc client bean post processor
     */","('springHttpClientBeanPostProcessor', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,  Spring http client bean post processor spring mvc client bean post processor.,13.0,"['Spring client bean post processor.', 'Spring is when the client bean post processor is used.', 'Spring is when the mvc client bean post processor is used.']"
136,soul,org/apache/dromara/springboot/starter/client/grpc/ShenyuGrpcClientConfiguration.java,/shenyu-spring-boot-starter/shenyu-spring-boot-starter-client/shenyu-spring-boot-starter-client-grpc/src/main/java/org/apache/dromara/springboot/starter/client/grpc/ShenyuGrpcClientConfiguration.java,grpcServiceBeanPostProcessor,40-51,"/**
     * Grpc service bean post processor grpc client bean post processor.
     *
     * @param clientConfig the client config
     * @param shenyuClientRegisterRepository the shenyu client register repository
     * @return the grpc client bean post processor
     */
public GrpcClientBeanPostProcessor grpcServiceBeanPostProcessor(final ShenyuClientConfig clientConfig, final ShenyuClientRegisterRepository shenyuClientRegisterRepository){
    return new GrpcClientBeanPostProcessor(clientConfig.getClient().get(RpcTypeEnum.GRPC.getName()), shenyuClientRegisterRepository);
}","public GrpcClientBeanPostProcessor grpcServiceBeanPostProcessor(final ShenyuClientConfig clientConfig, final ShenyuClientRegisterRepository shenyuClientRegisterRepository){
    return new GrpcClientBeanPostProcessor(clientConfig.getClient().get(RpcTypeEnum.GRPC.getName()), shenyuClientRegisterRepository);
}","/**
     * Grpc service bean post processor grpc client bean post processor.
     *
     * @param clientConfig the client config
     * @param shenyuClientRegisterRepository the shenyu client register repository
     * @return the grpc client bean post processor
     */","('grpcServiceBeanPostProcessor', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,  Grpc service bean post processor grpc client bean post processor.,11.0,"['Grpc client bean post processor.', 'Grpc service bean post processor.', 'The bean post processor is provided by grpc.']"
137,soul,org/apache/shenyu/springboot/starter/client/motan/ShenyuMotanClientConfiguration.java,/shenyu-spring-boot-starter/shenyu-spring-boot-starter-client/shenyu-spring-boot-starter-client-motan/src/main/java/org/apache/shenyu/springboot/starter/client/motan/ShenyuMotanClientConfiguration.java,tarsServiceBeanPostProcessor,37-47,"/**
     * Motan service bean post processor sofa service bean post processor.
     *
     * @param clientConfig the client config
     * @param shenyuClientRegisterRepository the shenyuClientRegisterRepository
     * @return the tars service bean post processor
     */
public MotanServiceBeanPostProcessor tarsServiceBeanPostProcessor(final ShenyuClientConfig clientConfig, final ShenyuClientRegisterRepository shenyuClientRegisterRepository){
    return new MotanServiceBeanPostProcessor(clientConfig.getClient().get(RpcTypeEnum.MOTAN.getName()), shenyuClientRegisterRepository);
}","public MotanServiceBeanPostProcessor tarsServiceBeanPostProcessor(final ShenyuClientConfig clientConfig, final ShenyuClientRegisterRepository shenyuClientRegisterRepository){
    return new MotanServiceBeanPostProcessor(clientConfig.getClient().get(RpcTypeEnum.MOTAN.getName()), shenyuClientRegisterRepository);
}","/**
     * Motan service bean post processor sofa service bean post processor.
     *
     * @param clientConfig the client config
     * @param shenyuClientRegisterRepository the shenyuClientRegisterRepository
     * @return the tars service bean post processor
     */","('tarsServiceBeanPostProcessor', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,  Motan service bean post processor sofa service bean post processor.,11.0,"['Motan service bean post processor.', 'Motan bean post processor.', 'Motan service bean post processor is on the sofa.']"
138,openapi-generator,org/openapitools/codegen/DefaultCodegen.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java,toDefaultValue,1959-1975,"/**
     * Return the default value of the property
     *
     * Return null if you do NOT want a default value.
     * Any non-null value will cause {{#defaultValue} check to pass.
     *
     * @param schema Property schema
     * @return string presentation of the default value of the property
     */
public String toDefaultValue(Schema schema){
    if (schema.getDefault() != null) {
        return schema.getDefault().toString();
    }
    return getPropertyDefaultValue(schema);
}","public String toDefaultValue(Schema schema){
    if (schema.getDefault() != null) {
        return schema.getDefault().toString();
    }
    return getPropertyDefaultValue(schema);
}","/**
     * Return the default value of the property
     *
     * Return null if you do NOT want a default value.
     * Any non-null value will cause {{#defaultValue} check to pass.
     *
     * @param schema Property schema
     * @return string presentation of the default value of the property
     */","('toDefaultValue', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,  Return the default value of the property   Return null if you do NOT want a default value.,18.0,"[""If you don't want a default value, return null."", ""If you don't want a default value, return it null."", ""If you don't want a default value, return the property back to its default value.""]"
139,jeromq,org/zeromq/ZMsg.java,/src/main/java/org/zeromq/ZMsg.java,newStringMsg,365-380,"/**
     * Create a new ZMsg from one or more Strings
     *
     * @param strings
     *      Strings to add as frames.
     * @return
     *      ZMsg object
     */
public static ZMsg newStringMsg(String... strings){
    ZMsg msg = new ZMsg();
    for (String data : strings) {
        msg.addString(data);
    }
    return msg;
}","public static ZMsg newStringMsg(String... strings){
    ZMsg msg = new ZMsg();
    for (String data : strings) {
        msg.addString(data);
    }
    return msg;
}","/**
     * Create a new ZMsg from one or more Strings
     *
     * @param strings
     *      Strings to add as frames.
     * @return
     *      ZMsg object
     */","('newStringMsg', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,  Create a new ZMsg from one or more Strings   @param strings  Strings to add as frames.,18.0,"['To add frames, create a new ZMsg from one or more strings.', 'To add frames, create a new ZMsg from one or more Strings.', 'To create a new ZMsg, use one or more strings to add frames.']"
140,cdk,org/openscience/cdk/renderer/generators/standard/AtomSymbol.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AtomSymbol.java,center,233-244,"/**
     * Convenience function to center an atom symbol on a specified point. The
     * centering depends on the symbol alignment.
     *
     * @param x x-axis location
     * @param y y-axis location
     * @return the centered symbol (new instance)
     */
 AtomSymbol center(double x, double y){
    Point2D center = getAlignmentCenter();
    return translate(x - center.getX(), y - center.getY());
}","AtomSymbol center(double x, double y){
    Point2D center = getAlignmentCenter();
    return translate(x - center.getX(), y - center.getY());
}","/**
     * Convenience function to center an atom symbol on a specified point. The
     * centering depends on the symbol alignment.
     *
     * @param x x-axis location
     * @param y y-axis location
     * @return the centered symbol (new instance)
     */","('center', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,  Convenience function to center an atom symbol on a specified point.,12.0,"['A convenience function is used to center an atom symbol.', 'A convenience function is used to center a symbol.', 'The atom symbol is centered on a point.']"
141,tablesaw,tech/tablesaw/util/StringUtils.java,/core/src/main/java/tech/tablesaw/util/StringUtils.java,removeZeroDecimal,526-540,"/**
   * Removes all trailing zero decimals from the given String, assuming all decimals are zero and
   * any zero decimals actually exist.
   *
   * <p>A {@code null} input String returns {@code null}.
   *
   * @param str the String to handle, may be null
   * @return string without trailing zero decimals
   */
public static String removeZeroDecimal(final String str){
    if (Strings.isNullOrEmpty(str)) {
        return str;
    }
    return ZERO_DECIMAL_PATTERN.matcher(str).replaceFirst(EMPTY);
}","public static String removeZeroDecimal(final String str){
    if (Strings.isNullOrEmpty(str)) {
        return str;
    }
    return ZERO_DECIMAL_PATTERN.matcher(str).replaceFirst(EMPTY);
}","/**
   * Removes all trailing zero decimals from the given String, assuming all decimals are zero and
   * any zero decimals actually exist.
   *
   * <p>A {@code null} input String returns {@code null}.
   *
   * @param str the String to handle, may be null
   * @return string without trailing zero decimals
   */","('removeZeroDecimal', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,"  Removes all trailing zero decimals from the given String, assuming all decimals are zero and  any zero decimals actually exist.",22.0,"['Assume all decimals are zero and any zero decimals actually exist and remove all trailing zero decimals from the given string.', 'Assume all decimals are zero and any zero decimals actually exist, and remove all trailing zero decimals from the given string.', 'Assume all decimals are zero and any zero decimals actually exist and remove all trailing zero decimals from the given String.']"
142,soul,org/apache/shenyu/springboot/starter/client/alibaba/dubbo/ShenyuAlibabaDubboClientConfiguration.java,/shenyu-spring-boot-starter/shenyu-spring-boot-starter-client/shenyu-spring-boot-starter-client-alibaba-dubbo/src/main/java/org/apache/shenyu/springboot/starter/client/alibaba/dubbo/ShenyuAlibabaDubboClientConfiguration.java,alibabaDubboServiceBeanListener,36-47,"/**
     * Alibaba dubbo service bean listener alibaba dubbo service bean listener.
     *
     * @param clientConfig the client config
     * @param shenyuClientRegisterRepository the shenyu client register repository
     * @return the alibaba dubbo service bean listener
     */
public AlibabaDubboServiceBeanListener alibabaDubboServiceBeanListener(final ShenyuClientConfig clientConfig, final ShenyuClientRegisterRepository shenyuClientRegisterRepository){
    return new AlibabaDubboServiceBeanListener(clientConfig.getClient().get(RpcTypeEnum.DUBBO.getName()), shenyuClientRegisterRepository);
}","public AlibabaDubboServiceBeanListener alibabaDubboServiceBeanListener(final ShenyuClientConfig clientConfig, final ShenyuClientRegisterRepository shenyuClientRegisterRepository){
    return new AlibabaDubboServiceBeanListener(clientConfig.getClient().get(RpcTypeEnum.DUBBO.getName()), shenyuClientRegisterRepository);
}","/**
     * Alibaba dubbo service bean listener alibaba dubbo service bean listener.
     *
     * @param clientConfig the client config
     * @param shenyuClientRegisterRepository the shenyu client register repository
     * @return the alibaba dubbo service bean listener
     */","('alibabaDubboServiceBeanListener', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",38.0,  Alibaba dubbo service bean listener alibaba dubbo service bean listener.,11.0,"['Dubbo service bean listener from China.', 'The dubbo service bean listener is from China.', 'Dubbo service bean listener.']"
143,glowstone,net/glowstone/entity/GlowPlayer.java,/src/main/java/net/glowstone/entity/GlowPlayer.java,sendItemChange,3121-3131,"/**
     * Sends a {@link SetWindowSlotMessage} to update the contents of an inventory slot.
     *
     * @param slot the slot ID
     * @param item the new contents
     */
public void sendItemChange(int slot, ItemStack item){
    if (invMonitor != null) {
        session.send(new SetWindowSlotMessage(invMonitor.getId(), slot, item));
    }
}","public void sendItemChange(int slot, ItemStack item){
    if (invMonitor != null) {
        session.send(new SetWindowSlotMessage(invMonitor.getId(), slot, item));
    }
}","/**
     * Sends a {@link SetWindowSlotMessage} to update the contents of an inventory slot.
     *
     * @param slot the slot ID
     * @param item the new contents
     */","('sendItemChange', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,  Sends a {@link SetWindowSlotMessage} to update the contents of an inventory slot.,16.0,"['The contents of an inventory slot can be updated with a @link SetWindowSlotMessage.', 'The contents of an inventory slot can be updated by sending a @link SetWindowSlotMessage.', 'To update the contents of an inventory slot, you must send a @link SetWindowSlotMessage.']"
144,tablesaw,tech/tablesaw/api/StringColumn.java,/core/src/main/java/tech/tablesaw/api/StringColumn.java,unique,364-373,"/**
   * Returns a new Column containing all the unique values in this column
   *
   * @return a column with unique values.
   */
public StringColumn unique(){
    List<String> strings = new ArrayList<>(lookupTable.asSet());
    return StringColumn.create(name() + "" Unique values"", strings);
}","public StringColumn unique(){
    List<String> strings = new ArrayList<>(lookupTable.asSet());
    return StringColumn.create(name() + "" Unique values"", strings);
}","/**
   * Returns a new Column containing all the unique values in this column
   *
   * @return a column with unique values.
   */","('unique', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,  Returns a new Column containing all the unique values in this column   @return a column with unique values.,20.0,"['Return a column with all the unique values in it.', 'Return a column with all the unique values.', 'A column with unique values is returned.']"
145,cdk,org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,norm,385-402,"/**
     * Normalise dashes in-case a user has entered one by accident.
     *
     * @param c character
     * @return normalised character
     */
private static char norm(char c){
    switch(c) {
        case '\u002d':
        case '\u2012':
        case '\u2013':
        case '\u2014':
        case '\u2212':
            return '-';
        default:
            return c;
    }
}","private static char norm(char c){
    switch(c) {
        case '\u002d':
        case '\u2012':
        case '\u2013':
        case '\u2014':
        case '\u2212':
            return '-';
        default:
            return c;
    }
}","/**
     * Normalise dashes in-case a user has entered one by accident.
     *
     * @param c character
     * @return normalised character
     */","('norm', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,  Normalise dashes in-case a user has entered one by accident.,11.0,"['If a user accidentally enters a dash, normalise it.', ""If a user accidentally enters one of the dashes, it's a good idea to normalise them."", ""If a user accidentally enters a dash, it's best to normalise it.""]"
146,cdk,org/openscience/cdk/Bond.java,/base/data/src/main/java/org/openscience/cdk/Bond.java,atoms,158-174,"/**
     * Returns the Iterator to atoms making up this bond.
     * Iterator.remove() is not implemented.
     *
     * @return An Iterator to atoms participating in this bond
     * @see #setAtoms
     */
public Iterable<IAtom> atoms(){
    return new Iterable<IAtom>() {

        @Override
        public Iterator<IAtom> iterator() {
            return new AtomsIterator();
        }
    };
}","public Iterable<IAtom> atoms(){
    return new Iterable<IAtom>() {

        @Override
        public Iterator<IAtom> iterator() {
            return new AtomsIterator();
        }
    };
}","/**
     * Returns the Iterator to atoms making up this bond.
     * Iterator.remove() is not implemented.
     *
     * @return An Iterator to atoms participating in this bond
     * @see #setAtoms
     */","('atoms', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,  Returns the Iterator to atoms making up this bond.,10.0,"['This bond is made up of atoms.', 'The Iterator is returned to the atoms.', 'This bond is created by the Iterator to atoms.']"
147,glowstone,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,readInt,404-418,"/**
     * Applies the given function to an integer subtag if it is present.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */
public boolean readInt(@NonNls String key, IntConsumer consumer){
    if (isInt(key)) {
        consumer.accept(getInt(key));
        return true;
    }
    return false;
}","public boolean readInt(@NonNls String key, IntConsumer consumer){
    if (isInt(key)) {
        consumer.accept(getInt(key));
        return true;
    }
    return false;
}","/**
     * Applies the given function to an integer subtag if it is present.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */","('readInt', {'INSTRUCTION': {'covered': 11, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,  Applies the given function to an integer subtag if it is present.,13.0,"['If the function is present, apply it to the subtag.', 'If it is present, apply the given function to the subtag.', 'If the function is present, apply it to the subtag of the function.']"
148,jackson-databind,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,readerForUpdating,4096-4110,"/**
     * Factory method for constructing {@link ObjectReader} that will
     * update given Object (usually Bean, but can be a Collection or Map
     * as well, but NOT an array) with JSON data. Deserialization occurs
     * normally except that the root-level value in JSON is not used for
     * instantiating a new object; instead give updateable object is used
     * as root.
     * Runtime type of value object is used for locating deserializer,
     * unless overridden by other factory methods of {@link ObjectReader}
     */
public ObjectReader readerForUpdating(Object valueToUpdate){
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","public ObjectReader readerForUpdating(Object valueToUpdate){
    JavaType t = _typeFactory.constructType(valueToUpdate.getClass());
    return _newReader(getDeserializationConfig(), t, valueToUpdate, null, _injectableValues);
}","/**
     * Factory method for constructing {@link ObjectReader} that will
     * update given Object (usually Bean, but can be a Collection or Map
     * as well, but NOT an array) with JSON data. Deserialization occurs
     * normally except that the root-level value in JSON is not used for
     * instantiating a new object; instead give updateable object is used
     * as root.
     * Runtime type of value object is used for locating deserializer,
     * unless overridden by other factory methods of {@link ObjectReader}
     */","('readerForUpdating', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,"  Factory method for constructing {@link ObjectReader} that will  update given Object (usually Bean, but can be a Collection or Map  as well, but NOT an array) with JSON data.",37.0,"['The method for constructing @link ObjectReader that will update given object is a factory method.', 'Factory method for constructing @link ObjectReader that will update given object, but not an array of data.', 'Factory method for constructing @link ObjectReader that will update given object, but not an array with data.']"
149,cdk,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,addSingletonCell,309-319,"/**
     * Add a new singleton cell to the end of the partition containing only
     * this element.
     *
     * @param element the element to add in its own cell
     */
public void addSingletonCell(int element){
    SortedSet<Integer> cell = new TreeSet<Integer>();
    cell.add(element);
    this.cells.add(cell);
}","public void addSingletonCell(int element){
    SortedSet<Integer> cell = new TreeSet<Integer>();
    cell.add(element);
    this.cells.add(cell);
}","/**
     * Add a new singleton cell to the end of the partition containing only
     * this element.
     *
     * @param element the element to add in its own cell
     */","('addSingletonCell', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,  Add a new singleton cell to the end of the partition containing only  this element.,16.0,"['Add a new singleton cell to the partition.', 'Add a new singleton cell to the end of the partition.', 'Add a new cell to the end of the partition.']"
150,weblogic-kubernetes-operator,oracle/kubernetes/operator/helpers/CallBuilder.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/CallBuilder.java,withAuthentication,2151-2162,"/**
   * Create AccessTokenAuthentication component for authenticating user represented by
   * the given token.
   * @param accessToken - User's Bearer token
   * @return - this CallBuilder instance
   */
public CallBuilder withAuthentication(String accessToken){
    if (!isNullOrEmpty(accessToken)) {
        this.helper = new ClientPool().withApiClient(createApiClient(accessToken));
    }
    return this;
}","public CallBuilder withAuthentication(String accessToken){
    if (!isNullOrEmpty(accessToken)) {
        this.helper = new ClientPool().withApiClient(createApiClient(accessToken));
    }
    return this;
}","/**
   * Create AccessTokenAuthentication component for authenticating user represented by
   * the given token.
   * @param accessToken - User's Bearer token
   * @return - this CallBuilder instance
   */","('withAuthentication', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,  Create AccessTokenAuthentication component for authenticating user represented by  the given token.,12.0,"['The AccessTokenAuthentication component is used toauthenticate user represented by the given token.', 'AccessTokenAuthentication component is used to authenticating user represented by a token.', 'The AccessTokenAuthentication component is used toauthenticate user represented by the token.']"
151,cdk,org/openscience/cdk/Reaction.java,/base/data/src/main/java/org/openscience/cdk/Reaction.java,mappings,168-183,"/**
     * Returns the mappings between the reactant and the product side.
     *
     * @return An Iterator to the Mappings.
     * @see    #addMapping
     */
public Iterable<IMapping> mappings(){
    return new Iterable<IMapping>() {

        @Override
        public Iterator<IMapping> iterator() {
            return new MappingIterator();
        }
    };
}","public Iterable<IMapping> mappings(){
    return new Iterable<IMapping>() {

        @Override
        public Iterator<IMapping> iterator() {
            return new MappingIterator();
        }
    };
}","/**
     * Returns the mappings between the reactant and the product side.
     *
     * @return An Iterator to the Mappings.
     * @see    #addMapping
     */","('mappings', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,  Returns the mappings between the reactant and the product side.,11.0,"['The mappings are between the reactant and the product.', 'The maps are between the reactant and the product.', 'The mappings between the reactant and the product side are returned.']"
152,glowstone,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,readFloat,372-386,"/**
     * Applies the given function to a float subtag if it is present.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */
public boolean readFloat(@NonNls String key, FloatConsumer consumer){
    if (isFloat(key)) {
        consumer.accept(getFloat(key));
        return true;
    }
    return false;
}","public boolean readFloat(@NonNls String key, FloatConsumer consumer){
    if (isFloat(key)) {
        consumer.accept(getFloat(key));
        return true;
    }
    return false;
}","/**
     * Applies the given function to a float subtag if it is present.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */","('readFloat', {'INSTRUCTION': {'covered': 11, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",39.0,  Applies the given function to a float subtag if it is present.,13.0,"['If the function is present, apply it to the float subtag.', 'If the function is present, apply it to a float subtag.', 'If it is present, apply the function to the float subtag.']"
153,tablesaw,tech/tablesaw/columns/Column.java,/core/src/main/java/tech/tablesaw/columns/Column.java,last,660-664,"/** Returns a column of the same type containing the last {@code numRows} of this column. */
 Column<T> last(final int numRows){
    int newRowCount = Math.min(numRows, size());
    return inRange(size() - newRowCount, size());
}"," Column<T> last(final int numRows){
    int newRowCount = Math.min(numRows, size());
    return inRange(size() - newRowCount, size());
}",/** Returns a column of the same type containing the last {@code numRows} of this column. */,"('last', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0, Returns a column of the same type containing the last {@code numRows} of this column.,19.0,"['The last @code numRows of this column is returned.', 'The last @code numRows of the column is returned.', 'The last @code numRows of this column is returned by this column.']"
155,jackson-databind,com/fasterxml/jackson/databind/ObjectWriter.java,/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java,_newSequenceWriter,248-262,"/**
     * Overridable factory method called by {@link #writeValues(OutputStream)}
     * method (and its various overrides), and initializes it as necessary.
     * 
     * @since 2.5
     */
protected SequenceWriter _newSequenceWriter(boolean wrapInArray, JsonGenerator gen, boolean managedInput) throws IOException{
    return new SequenceWriter(_serializerProvider(), _configureGenerator(gen), managedInput, _prefetch).init(wrapInArray);
}","protected SequenceWriter _newSequenceWriter(boolean wrapInArray, JsonGenerator gen, boolean managedInput) throws IOException{
    return new SequenceWriter(_serializerProvider(), _configureGenerator(gen), managedInput, _prefetch).init(wrapInArray);
}","/**
     * Overridable factory method called by {@link #writeValues(OutputStream)}
     * method (and its various overrides), and initializes it as necessary.
     * 
     * @since 2.5
     */","('_newSequenceWriter', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,"  Overridable factory method called by {@link #writeValues(OutputStream)}  method (and its various overrides), and initializes it as necessary.",28.0,"['A ridiculous factory method called by @link #writeValues(OutputStream) method and its various overrides, and initializes it as necessary.', 'A ridiculous factory method called by @link #writeValues(OutputStream) method and its various overrides is needed.', 'A ridiculous factory method called by @link #writeValues(OutputStream) method and its various overrides, and isInitialized as necessary.']"
156,openapi-generator,org/openapitools/codegen/DefaultCodegen.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java,handleMethodResponse,3816-3829,"/**
     * Set op's returnBaseType, returnType, examples etc.
     *
     * @param operation      endpoint Operation
     * @param schemas        a map of the schemas in the openapi spec
     * @param op             endpoint CodegenOperation
     * @param methodResponse the default ApiResponse for the endpoint
     */
protected void handleMethodResponse(Operation operation, Map<String, Schema> schemas, CodegenOperation op, ApiResponse methodResponse){
    handleMethodResponse(operation, schemas, op, methodResponse, Collections.emptyMap());
}","protected void handleMethodResponse(Operation operation, Map<String, Schema> schemas, CodegenOperation op, ApiResponse methodResponse){
    handleMethodResponse(operation, schemas, op, methodResponse, Collections.emptyMap());
}","/**
     * Set op's returnBaseType, returnType, examples etc.
     *
     * @param operation      endpoint Operation
     * @param schemas        a map of the schemas in the openapi spec
     * @param op             endpoint CodegenOperation
     * @param methodResponse the default ApiResponse for the endpoint
     */","('handleMethodResponse', {'INSTRUCTION': {'covered': 211, 'missed': 4}, 'BRANCH': {'covered': 32, 'missed': 6}, 'LINE': {'covered': 45, 'missed': 1}, 'COMPLEXITY': {'covered': 14, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,"  Set op's returnBaseType, returnType, examples etc.",10.0,"['Set the returnBaseType, returnType, examples.', 'Set the returnBaseType, returnType, examples and so on.', 'Set the returnBaseType, returnType, examples, and so on.']"
157,tablesaw,tech/tablesaw/api/QuerySupport.java,/core/src/main/java/tech/tablesaw/api/QuerySupport.java,neither,26-33,"/**
   * Returns a selection for all records that match neither of the given functions. In other words,
   * if either (or both) of sel1 or sel2 is {@code true}, the record as a whole is {@code false}.
   */
public static Function<Table, Selection> neither(Function<Table, Selection> sel1, Function<Table, Selection> sel2){
    return new Not(either(sel1, sel2));
}","public static Function<Table, Selection> neither(Function<Table, Selection> sel1, Function<Table, Selection> sel2){
    return new Not(either(sel1, sel2));
}","/**
   * Returns a selection for all records that match neither of the given functions. In other words,
   * if either (or both) of sel1 or sel2 is {@code true}, the record as a whole is {@code false}.
   */","('neither', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,  Returns a selection for all records that match neither of the given functions.,14.0,"[""A selection is returned for records that don't match the functions."", ""A selection is returned for all records that don't match the functions."", 'A selection is returned for records that do not match the functions.']"
158,dataverse,edu/harvard/iq/dataverse/Dataset.java,/src/main/java/edu/harvard/iq/dataverse/Dataset.java,isLockedFor,164-176,"/**
     * Checks whether {@code this} dataset is locked for a given reason.
     * @param reason the reason we test for.
     * @return {@code true} iff the data set is locked for {@code reason}.
     */
public boolean isLockedFor(DatasetLock.Reason reason){
    for (DatasetLock l : getLocks()) {
        if (l.getReason() == reason) {
            return true;
        }
    }
    return false;
}","public boolean isLockedFor(DatasetLock.Reason reason){
    for (DatasetLock l : getLocks()) {
        if (l.getReason() == reason) {
            return true;
        }
    }
    return false;
}","/**
     * Checks whether {@code this} dataset is locked for a given reason.
     * @param reason the reason we test for.
     * @return {@code true} iff the data set is locked for {@code reason}.
     */","('isLockedFor', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,  Checks whether {@code this} dataset is locked for a given reason.,15.0,"['The dataset is locked for a reason.', ""If the dataset is locked for a reason, it's checked."", ""If the dataset is locked for a given reason, it's checked.""]"
159,logstash-logback-encoder,net/logstash/logback/composite/AbstractPatternJsonProvider.java,/src/main/java/net/logstash/logback/composite/AbstractPatternJsonProvider.java,initializeNodeWriter,95-105,"/**
     * Parses the pattern into a {@link NodeWriter}.
     * 
     * @return a {@link NodeWriter}
     * @throws JsonPatternException thrown in case of invalid pattern
     */
private NodeWriter<Event> initializeNodeWriter() throws JsonPatternException{
    AbstractJsonPatternParser<Event> parser = createParser(this.jsonFactory);
    parser.setOmitEmptyFields(omitEmptyFields);
    return parser.parse(pattern);
}","private NodeWriter<Event> initializeNodeWriter() throws JsonPatternException{
    AbstractJsonPatternParser<Event> parser = createParser(this.jsonFactory);
    parser.setOmitEmptyFields(omitEmptyFields);
    return parser.parse(pattern);
}","/**
     * Parses the pattern into a {@link NodeWriter}.
     * 
     * @return a {@link NodeWriter}
     * @throws JsonPatternException thrown in case of invalid pattern
     */","('initializeNodeWriter', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,  Parses the pattern into a {@link NodeWriter}.,11.0,"['Parses the pattern into a script.', 'Parses the pattern into a writing program.', 'Parses the pattern into a new one.']"
160,glowstone,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,readBooleanNegated,524-536,"/**
     * Applies the given function to a byte subtag if it is present, converting it to boolean and
     * negating it first.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */
public boolean readBooleanNegated(@NonNls String key, Consumer<? super Boolean> consumer){
    return readTag(key, ByteTag.class, byteVal -> consumer.accept(byteVal == 0));
}","public boolean readBooleanNegated(@NonNls String key, Consumer<? super Boolean> consumer){
    return readTag(key, ByteTag.class, byteVal -> consumer.accept(byteVal == 0));
}","/**
     * Applies the given function to a byte subtag if it is present, converting it to boolean and
     * negating it first.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */","('readBooleanNegated', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,"  Applies the given function to a byte subtag if it is present, converting it to boolean and  negating it first.",22.0,"['If the function is present, apply it to a subtag and convert it to a string.', 'If the function is present, apply it to a byte subtag and convert it to a boolean.', 'If the function is present, apply it to a byte subtag and convert it to a string.']"
161,glowstone,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,readBoolean,498-509,"/**
     * Applies the given function to a byte subtag if it is present, converting it to boolean first.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */
public boolean readBoolean(@NonNls String key, Consumer<? super Boolean> consumer){
    return readTag(key, ByteTag.class, byteVal -> consumer.accept(byteVal != 0));
}","public boolean readBoolean(@NonNls String key, Consumer<? super Boolean> consumer){
    return readTag(key, ByteTag.class, byteVal -> consumer.accept(byteVal != 0));
}","/**
     * Applies the given function to a byte subtag if it is present, converting it to boolean first.
     *
     * @param key the key to look up
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */","('readBoolean', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,"  Applies the given function to a byte subtag if it is present, converting it to boolean first.",19.0,"['If the function is present, apply it to a byte subtag.', 'If the function is present, apply it to a subtag and convert it to a string.', 'If the function is present, apply it to a byte subtag and convert it to a boolean first.']"
162,weblogic-kubernetes-operator,oracle/kubernetes/weblogic/domain/model/DomainSpec.java,/operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainSpec.java,isUseOnlineUpdate,822-833,"/**
   * Test if the MII domain wants to use online update.
   *
   * @return true if using online update
   */
 boolean isUseOnlineUpdate(){
    return Optional.ofNullable(configuration).map(Configuration::getModel).map(Model::getOnlineUpdate).map(OnlineUpdate::getEnabled).orElse(false);
}"," boolean isUseOnlineUpdate(){
    return Optional.ofNullable(configuration).map(Configuration::getModel).map(Model::getOnlineUpdate).map(OnlineUpdate::getEnabled).orElse(false);
}","/**
   * Test if the MII domain wants to use online update.
   *
   * @return true if using online update
   */","('isUseOnlineUpdate', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,  Test if the MII domain wants to use online update.,11.0,"['If the MII domain wants to use online update, test it.', 'If the MII domain wants to use an online update, test it.', 'If the MII domain wants to use online update, you should test it.']"
163,tablesaw,tech/tablesaw/api/QuerySupport.java,/core/src/main/java/tech/tablesaw/api/QuerySupport.java,notBoth,35-43,"/**
   * Returns a selection for all records that don't match both of the given functions. In other
   * words, if both sel1 and sel2 are true, the record as a whole is false, and if either (or both)
   * of sel1 or sel2 is {@code false}, the record as a whole is {@code true}.
   */
public static Function<Table, Selection> notBoth(Function<Table, Selection> sel1, Function<Table, Selection> sel2){
    return new Not(both(sel1, sel2));
}","public static Function<Table, Selection> notBoth(Function<Table, Selection> sel1, Function<Table, Selection> sel2){
    return new Not(both(sel1, sel2));
}","/**
   * Returns a selection for all records that don't match both of the given functions. In other
   * words, if both sel1 and sel2 are true, the record as a whole is false, and if either (or both)
   * of sel1 or sel2 is {@code false}, the record as a whole is {@code true}.
   */","('notBoth', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",40.0,  Returns a selection for all records that don't match both of the given functions.,16.0,"[""A selection is returned for records that don't match the functions."", ""A selection is returned for all records that don't match the functions."", ""A selection is returned for all records that don't match the function.""]"
164,egeria,org/odpi/openmetadata/accessservices/assetlineage/listeners/AssetLineageOMRSTopicListener.java,/open-metadata-implementation/access-services/asset-lineage/asset-lineage-server/src/main/java/org/odpi/openmetadata/accessservices/assetlineage/listeners/AssetLineageOMRSTopicListener.java,publishEntityEvent,295-308,"/**
     * @param entityDetail     the entity object that may be published
     * @param lineageEventType lineage event type
     *
     * @throws JsonProcessingException    exception parsing the event json
     * @throws UserNotAuthorizedException the requesting user is not authorized to issue this request.
     * @throws PropertyServerException    there is a problem retrieving information from the property server.
     */
private void publishEntityEvent(EntityDetail entityDetail, AssetLineageEventType lineageEventType) throws JsonProcessingException, OCFCheckedExceptionBase{
    if (publisher.isEntityEligibleForPublishing(entityDetail)) {
        publisher.publishLineageEntityEvent(converter.createLineageEntity(entityDetail), lineageEventType);
    }
}","private void publishEntityEvent(EntityDetail entityDetail, AssetLineageEventType lineageEventType) throws JsonProcessingException, OCFCheckedExceptionBase{
    if (publisher.isEntityEligibleForPublishing(entityDetail)) {
        publisher.publishLineageEntityEvent(converter.createLineageEntity(entityDetail), lineageEventType);
    }
}","/**
     * @param entityDetail     the entity object that may be published
     * @param lineageEventType lineage event type
     *
     * @throws JsonProcessingException    exception parsing the event json
     * @throws UserNotAuthorizedException the requesting user is not authorized to issue this request.
     * @throws PropertyServerException    there is a problem retrieving information from the property server.
     */","('publishEntityEvent', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,  @param entityDetail the entity object that may be published  @param lineageEventType lineage event type   @throws JsonProcessingException exception parsing the event json  @throws UserNotAuthorizedException the requesting user is not authorized to issue this request.,38.0,"['The requesting user is not authorized to issue this request.', 'The requesting user is not authorized to issue this request, so the JsonProcessingException is thrown.', 'The requesting user is not authorized to issue this request and the JsonProcessingExceptionException is thrown.']"
167,anserini,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,document,492-507,"/**
   * Returns the Lucene {@link Document} based on a collection docid. The method is named to be consistent with Lucene's
   * {@link IndexReader#document(int)}, contra Java's standard method naming conventions.
   *
   * @param reader index reader
   * @param docid collection docid
   * @return corresponding Lucene {@link Document}
   */
public static Document document(IndexReader reader, String docid){
    try {
        return reader.document(IndexReaderUtils.convertDocidToLuceneDocid(reader, docid));
    } catch (Exception e) {
        return null;
    }
}","public static Document document(IndexReader reader, String docid){
    try {
        return reader.document(IndexReaderUtils.convertDocidToLuceneDocid(reader, docid));
    } catch (Exception e) {
        return null;
    }
}","/**
   * Returns the Lucene {@link Document} based on a collection docid. The method is named to be consistent with Lucene's
   * {@link IndexReader#document(int)}, contra Java's standard method naming conventions.
   *
   * @param reader index reader
   * @param docid collection docid
   * @return corresponding Lucene {@link Document}
   */","('document', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,  Returns the Lucene {@link Document} based on a collection docid.,14.0,"['The document is based on a collection docid.', 'The document is returned based on a collection docid.', 'The document is returned based on the collection docid.']"
168,cdk,org/openscience/cdk/io/MDLV3000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV3000Writer.java,findIdx,132-145,"/**
     * Access the index of Obj->Int map, if the entry isn't found we return -1.
     *
     * @param idxs index map
     * @param obj the object
     * @param <T> the object type
     * @return index or -1 if not found
     */
private static Integer findIdx(Map<T, Integer> idxs, T obj){
    Integer idx = idxs.get(obj);
    if (idx == null)
        return -1;
    return idx;
}","private static Integer findIdx(Map<T, Integer> idxs, T obj){
    Integer idx = idxs.get(obj);
    if (idx == null)
        return -1;
    return idx;
}","/**
     * Access the index of Obj->Int map, if the entry isn't found we return -1.
     *
     * @param idxs index map
     * @param obj the object
     * @param <T> the object type
     * @return index or -1 if not found
     */","('findIdx', {'INSTRUCTION': {'covered': 9, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,"Access the index of Obj->Int map, if the entry isn't found we return -1.",19.0,"[""If the entry isn't found, we return -1."", ""If the entry isn't found we return -1."", ""If the entry isn't found, we return a -1.""]"
169,jooby,io/jooby/Value.java,/jooby/src/main/java/io/jooby/Value.java,intValue,87-98,"/**
   * Convert this value to int (if possible).
   *
   * @return Int value.
   */
 int intValue(){
    try {
        return Integer.parseInt(value());
    } catch (NumberFormatException x) {
        throw new TypeMismatchException(name(), int.class, x);
    }
}"," int intValue(){
    try {
        return Integer.parseInt(value());
    } catch (NumberFormatException x) {
        throw new TypeMismatchException(name(), int.class, x);
    }
}","/**
   * Convert this value to int (if possible).
   *
   * @return Int value.
   */","('intValue', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,  Convert this value to int (if possible).,10.0,"['If possible, convert this value to int.', 'If possible, convert the value to int.', 'If possible, convert this to int.']"
170,jackson-databind,com/fasterxml/jackson/databind/node/TextNode.java,/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java,valueOf,27-45,"/**
     * Factory method that should be used to construct instances.
     * For some common cases, can reuse canonical instances: currently
     * this is the case for empty Strings, in future possible for
     * others as well. If null is passed, will return null.
     *
     * @return Resulting {@link TextNode} object, if <b>v</b>
     *   is NOT null; null if it is.
     */
public static TextNode valueOf(String v){
    if (v == null) {
        return null;
    }
    if (v.isEmpty()) {
        return EMPTY_STRING_NODE;
    }
    return new TextNode(v);
}","public static TextNode valueOf(String v){
    if (v == null) {
        return null;
    }
    if (v.isEmpty()) {
        return EMPTY_STRING_NODE;
    }
    return new TextNode(v);
}","/**
     * Factory method that should be used to construct instances.
     * For some common cases, can reuse canonical instances: currently
     * this is the case for empty Strings, in future possible for
     * others as well. If null is passed, will return null.
     *
     * @return Resulting {@link TextNode} object, if <b>v</b>
     *   is NOT null; null if it is.
     */","('valueOf', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,  Factory method that should be used to construct instances.,10.0,"['The factory method should be used to build instances.', 'The factory method should be used to construct instances.', 'The factory method should be used to make instances.']"
171,weblogic-kubernetes-operator,oracle/kubernetes/operator/helpers/ConfigMapHelper.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/ConfigMapHelper.java,readIntrospectionVersionStep,924-935,"/**
   * Reads the introspector config map for the specified domain, populating the following packet entries.
   *   INTROSPECTION_STATE_LABEL          the value of the domain's 'introspectVersion' when this map was created
   *
   * @param ns the namespace of the domain
   * @param domainUid the unique domain ID
   * @return a step to do the processing.
   */
public static Step readIntrospectionVersionStep(String ns, String domainUid){
    String configMapName = getIntrospectorConfigMapName(domainUid);
    return new CallBuilder().readConfigMapAsync(configMapName, ns, domainUid, new ReadIntrospectionVersionStep());
}","public static Step readIntrospectionVersionStep(String ns, String domainUid){
    String configMapName = getIntrospectorConfigMapName(domainUid);
    return new CallBuilder().readConfigMapAsync(configMapName, ns, domainUid, new ReadIntrospectionVersionStep());
}","/**
   * Reads the introspector config map for the specified domain, populating the following packet entries.
   *   INTROSPECTION_STATE_LABEL          the value of the domain's 'introspectVersion' when this map was created
   *
   * @param ns the namespace of the domain
   * @param domainUid the unique domain ID
   * @return a step to do the processing.
   */","('readIntrospectionVersionStep', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,"  Reads the introspector config map for the specified domain, populating the following packet entries.",16.0,"['After reading the introspector config map for the specified domain, populate the following packet entries.', 'After reading the introspector config map for the specified domain, you can populate the following packet entries.', 'After reading the introspector config map for the specified domain, you can enter the packet entries.']"
172,shardingsphere-elasticjob,org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,/elasticjob-lite/elasticjob-lite-core/src/main/java/org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,isAllStarted,66-74,"/**
     * Judge whether job's sharding items are all started.
     *
     * @return job's sharding items are all started or not
     */
public boolean isAllStarted(){
    return jobNodeStorage.isJobNodeExisted(GuaranteeNode.STARTED_ROOT) && configService.load(false).getShardingTotalCount() == jobNodeStorage.getJobNodeChildrenKeys(GuaranteeNode.STARTED_ROOT).size();
}","public boolean isAllStarted(){
    return jobNodeStorage.isJobNodeExisted(GuaranteeNode.STARTED_ROOT) && configService.load(false).getShardingTotalCount() == jobNodeStorage.getJobNodeChildrenKeys(GuaranteeNode.STARTED_ROOT).size();
}","/**
     * Judge whether job's sharding items are all started.
     *
     * @return job's sharding items are all started or not
     */","('isAllStarted', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,  Judge whether job's sharding items are all started.,10.0,"[""If the job's sharding items are all started, you should judge it."", ""If the job's sharding items are all started, then judge."", ""If the job's sharding items are all started, then you should judge it.""]"
173,shardingsphere-elasticjob,org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,/elasticjob-lite/elasticjob-lite-core/src/main/java/org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,isAllCompleted,109-117,"/**
     * Judge whether job's sharding items are all completed.
     *
     * @return job's sharding items are all completed or not
     */
public boolean isAllCompleted(){
    return jobNodeStorage.isJobNodeExisted(GuaranteeNode.COMPLETED_ROOT) && configService.load(false).getShardingTotalCount() <= jobNodeStorage.getJobNodeChildrenKeys(GuaranteeNode.COMPLETED_ROOT).size();
}","public boolean isAllCompleted(){
    return jobNodeStorage.isJobNodeExisted(GuaranteeNode.COMPLETED_ROOT) && configService.load(false).getShardingTotalCount() <= jobNodeStorage.getJobNodeChildrenKeys(GuaranteeNode.COMPLETED_ROOT).size();
}","/**
     * Judge whether job's sharding items are all completed.
     *
     * @return job's sharding items are all completed or not
     */","('isAllCompleted', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,  Judge whether job's sharding items are all completed.,10.0,"[""If the job's shards are complete, judge it."", ""If the job's shards are complete, judge."", ""If the job's sharding items are all completed, judge.""]"
174,openapi-generator,org/openapitools/codegen/validation/ValidationRule.java,/modules/openapi-generator-core/src/main/java/org/openapitools/codegen/validation/ValidationRule.java,error,113-126,"/**
     * Create an instance of a {@link ValidationRule} which should result in an error should the evaluate of this rule fail.
     *
     * @param failureMessage The message to be displayed in the event of a test failure (intended to be user-facing).
     * @param fn The test condition to be applied as a part of this rule, when this function returns <code>true</code>,
     *             the evaluated instance will be considered ""valid"" according to this rule.
     * @param <T> The type of the object being evaluated.
     *
     * @return A new instance of a {@link ValidationRule}
     */
public static ValidationRule error(String failureMessage, Function<T, Result> fn){
    return new ValidationRule(Severity.ERROR, null, failureMessage, (Function<Object, Result>) fn);
}","public static ValidationRule error(String failureMessage, Function<T, Result> fn){
    return new ValidationRule(Severity.ERROR, null, failureMessage, (Function<Object, Result>) fn);
}","/**
     * Create an instance of a {@link ValidationRule} which should result in an error should the evaluate of this rule fail.
     *
     * @param failureMessage The message to be displayed in the event of a test failure (intended to be user-facing).
     * @param fn The test condition to be applied as a part of this rule, when this function returns <code>true</code>,
     *             the evaluated instance will be considered ""valid"" according to this rule.
     * @param <T> The type of the object being evaluated.
     *
     * @return A new instance of a {@link ValidationRule}
     */","('error', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,  Create an instance of a {@link ValidationRule} which should result in an error should the evaluate of this rule fail.,24.0,"['An error should be created if the evaluate of the rule fails.', 'If the evaluate of this rule fails, you should create an instance of the @link ValidationRule which should result in an error.', 'If the evaluate of this rule fails, you should create an instance of the @link validation rule which should result in an error.']"
175,incubator-shenyu,org/apache/shenyu/admin/controller/ShenyuDictController.java,/shenyu-admin/src/main/java/org/apache/shenyu/admin/controller/ShenyuDictController.java,deleteShenyuDicts,126-136,"/**
     * batch delete some shenyu dicts by some id list.
     *
     * @param ids shenyu dict id list.
     * @return {@linkplain ShenyuAdminResult}
     */
public ShenyuAdminResult deleteShenyuDicts(@RequestBody @NotEmpty final List<@NotBlank String> ids){
    Integer deleteCount = shenyuDictService.deleteShenyuDicts(ids);
    return ShenyuAdminResult.success(ShenyuResultMessage.DELETE_SUCCESS, deleteCount);
}","public ShenyuAdminResult deleteShenyuDicts(@RequestBody @NotEmpty final List<@NotBlank String> ids){
    Integer deleteCount = shenyuDictService.deleteShenyuDicts(ids);
    return ShenyuAdminResult.success(ShenyuResultMessage.DELETE_SUCCESS, deleteCount);
}","/**
     * batch delete some shenyu dicts by some id list.
     *
     * @param ids shenyu dict id list.
     * @return {@linkplain ShenyuAdminResult}
     */","('deleteShenyuDicts', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,  batch delete some shenyu dicts by some id list.,10.0,"['Some shenyu dicts should be deleted by some id list.', 'Some shenyu dicts can be deleted by some id list.', 'Some shenyu dicts can be deleted by some id lists.']"
176,cucumber-reporting,net/masterthought/cucumber/json/Hook.java,/src/main/java/net/masterthought/cucumber/json/Hook.java,hasContent,43-58,"/**
     * Checks if the hook has content meaning as it has at least attachment or result with error message.
     *
     * @return <code>true</code> if the hook has content otherwise <code>false</code>
     */
public boolean hasContent(){
    if (embeddings.length > 0) {
        // assuming that if the embedding exists then it is not empty
        return true;
    }
    if (StringUtils.isNotBlank(result.getErrorMessage())) {
        return true;
    }
    // TODO: hook with 'output' should be treated as empty or not?
    return false;
}","public boolean hasContent(){
    if (embeddings.length > 0) {
        // assuming that if the embedding exists then it is not empty
        return true;
    }
    if (StringUtils.isNotBlank(result.getErrorMessage())) {
        return true;
    }
    // TODO: hook with 'output' should be treated as empty or not?
    return false;
}","/**
     * Checks if the hook has content meaning as it has at least attachment or result with error message.
     *
     * @return <code>true</code> if the hook has content otherwise <code>false</code>
     */","('hasContent', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,  Checks if the hook has content meaning as it has at least attachment or result with error message.,19.0,"['If the hook has at least an attachment or result with an error message, it is checked.', ""If the hook has at least an attachment or result with an error message, it's checked."", 'If the hook has at least an attachment or an error message, it is checked.']"
177,jeromq,org/zeromq/ZCertStore.java,/src/main/java/org/zeromq/ZCertStore.java,containsPublicKey,174-184,"/**
     * Check if a public key is in the certificate store.
     * @param publicKey needs to be a 32 byte array representing the public key
     */
public boolean containsPublicKey(byte[] publicKey){
    Utils.checkArgument(publicKey.length == 32, ""publickey needs to have a size of 32 bytes. got only "" + publicKey.length);
    return containsPublicKey(ZMQ.Curve.z85Encode(publicKey));
}","public boolean containsPublicKey(byte[] publicKey){
    Utils.checkArgument(publicKey.length == 32, ""publickey needs to have a size of 32 bytes. got only "" + publicKey.length);
    return containsPublicKey(ZMQ.Curve.z85Encode(publicKey));
}","/**
     * Check if a public key is in the certificate store.
     * @param publicKey needs to be a 32 byte array representing the public key
     */","('containsPublicKey', {'INSTRUCTION': {'covered': 24, 'missed': 1}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",41.0,  Check if a public key is in the certificate store.,11.0,"['The certificate store has a public key.', 'If the public key is in the store, you should check it.', 'If the public key is in the store, you should check it out.']"
179,sonar-cxx,org/sonar/cxx/checks/metrics/TooManyStatementsPerLineCheck.java,/cxx-checks/src/main/java/org/sonar/cxx/checks/metrics/TooManyStatementsPerLineCheck.java,isGeneratedNodeExcluded,56-64,"/**
   * Exclude subsequent generated nodes, if they are consecutive and on the same line.
   */
private static boolean isGeneratedNodeExcluded(AstNode astNode){
    var prev = astNode.getPreviousAstNode();
    return prev != null && prev.getTokenLine() == astNode.getTokenLine() && prev.isCopyBookOrGeneratedNode();
}","private static boolean isGeneratedNodeExcluded(AstNode astNode){
    var prev = astNode.getPreviousAstNode();
    return prev != null && prev.getTokenLine() == astNode.getTokenLine() && prev.isCopyBookOrGeneratedNode();
}","/**
   * Exclude subsequent generated nodes, if they are consecutive and on the same line.
   */","('isGeneratedNodeExcluded', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,"  Exclude subsequent generated nodes, if they are consecutive and on the same line.",15.0,"['If they are on the same line, exclude subsequent generated nodes.', 'If they are consecutive and on the same line, exclude subsequent generated nodes.', 'If they are consecutive and on the same line, exclude the generated nodes.']"
180,cdk,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,otherIndex,326-336,"/**
     * Given an index of an atom in the query get the index of the other atom in
     * the double bond.
     *
     * @param i query atom index
     * @return the other atom index involved in a double bond
     */
private int otherIndex(int i){
    IDoubleBondStereochemistry element = (IDoubleBondStereochemistry) queryElements[i];
    return queryMap.get(element.getStereoBond().getOther(query.getAtom(i)));
}","private int otherIndex(int i){
    IDoubleBondStereochemistry element = (IDoubleBondStereochemistry) queryElements[i];
    return queryMap.get(element.getStereoBond().getOther(query.getAtom(i)));
}","/**
     * Given an index of an atom in the query get the index of the other atom in
     * the double bond.
     *
     * @param i query atom index
     * @return the other atom index involved in a double bond
     */","('otherIndex', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,  Given an index of an atom in the query get the index of the other atom in  the double bond.,21.0,"['The double bond has an index of the other atom in it.', ""The double bond's index of the other atom in the query is what you get."", ""The double bond's index of the other atom in the query is used to calculate it.""]"
182,cdk,org/openscience/cdk/silent/AdductFormula.java,/base/silent/src/main/java/org/openscience/cdk/silent/AdductFormula.java,isotopes,173-187,"/**
     *  Returns an Iterator for looping over all isotopes in this adduct formula.
     *
     * @return    An Iterator with the isotopes in this adduct formula
     */
public Iterable<IIsotope> isotopes(){
    return new Iterable<IIsotope>() {

        @Override
        public Iterator<IIsotope> iterator() {
            return isotopesList().iterator();
        }
    };
}","public Iterable<IIsotope> isotopes(){
    return new Iterable<IIsotope>() {

        @Override
        public Iterator<IIsotope> iterator() {
            return isotopesList().iterator();
        }
    };
}","/**
     *  Returns an Iterator for looping over all isotopes in this adduct formula.
     *
     * @return    An Iterator with the isotopes in this adduct formula
     */","('isotopes', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,  Returns an Iterator for looping over all isotopes in this adduct formula.,13.0,"['In this adduct formula, returns an Iterator for looping over all isotopes.', 'This adduct formula returns an Iterator for looping over all the isotopes.', 'In this adduct formula, returns an Iterator for looping over all the isotopes.']"
183,weblogic-kubernetes-operator,oracle/kubernetes/operator/ServerStatusReader.java,/operator/src/main/java/oracle/kubernetes/operator/ServerStatusReader.java,createServerStatusReaderStep,61-74,"/**
   * Creates asynchronous step to read WebLogic server state from a particular pod.
   *
   * @param info the domain presence
   * @param pod The pod
   * @param serverName Server name
   * @param timeoutSeconds Timeout in seconds
   * @return Created step
   */
private static Step createServerStatusReaderStep(DomainPresenceInfo info, V1Pod pod, String serverName, long timeoutSeconds){
    return new ServerStatusReaderStep(info, pod, serverName, timeoutSeconds, new ServerHealthStep(serverName, pod, null));
}","private static Step createServerStatusReaderStep(DomainPresenceInfo info, V1Pod pod, String serverName, long timeoutSeconds){
    return new ServerStatusReaderStep(info, pod, serverName, timeoutSeconds, new ServerHealthStep(serverName, pod, null));
}","/**
   * Creates asynchronous step to read WebLogic server state from a particular pod.
   *
   * @param info the domain presence
   * @param pod The pod
   * @param serverName Server name
   * @param timeoutSeconds Timeout in seconds
   * @return Created step
   */","('createServerStatusReaderStep', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,  Creates asynchronous step to read WebLogic server state from a particular pod.,13.0,"['A step is created to read the state of the server.', 'A step is created to read the server state.', 'A step is created to read the server state from a particular Pod.']"
184,cdk,org/openscience/cdk/silent/Bond.java,/base/silent/src/main/java/org/openscience/cdk/silent/Bond.java,contains,305-318,"/**
     * Returns true if the given atom participates in this bond.
     *
     * @param atom The atom to be tested if it participates in this bond
     * @return true if the atom participates in this bond
     */
public boolean contains(IAtom atom){
    if (atoms == null)
        return false;
    for (IAtom localAtom : atoms) {
        if (localAtom.equals(atom))
            return true;
    }
    return false;
}","public boolean contains(IAtom atom){
    if (atoms == null)
        return false;
    for (IAtom localAtom : atoms) {
        if (localAtom.equals(atom))
            return true;
    }
    return false;
}","/**
     * Returns true if the given atom participates in this bond.
     *
     * @param atom The atom to be tested if it participates in this bond
     * @return true if the atom participates in this bond
     */","('contains', {'INSTRUCTION': {'covered': 28, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,  Returns true if the given atom participates in this bond.,11.0,"[""If the atom participates in the bond, it's true."", 'If the atom participates in the bond, this is true.', 'If the atom participates in the bond, it is true.']"
185,cdk,org/openscience/cdk/fingerprint/model/Bayesian.java,/tool/model/src/main/java/org/openscience/cdk/fingerprint/model/Bayesian.java,deserialise,530-541,"/**
     * Converts a given string into a Bayesian model instance, or throws an exception if it is not valid.
     * 
     * @param str string containing the serialised model
     * @return instantiated model that can be used for predictions
     */
public static Bayesian deserialise(String str) throws IOException{
    BufferedReader rdr = new BufferedReader(new StringReader(str));
    Bayesian model = deserialise(rdr);
    rdr.close();
    return model;
}","public static Bayesian deserialise(String str) throws IOException{
    BufferedReader rdr = new BufferedReader(new StringReader(str));
    Bayesian model = deserialise(rdr);
    rdr.close();
    return model;
}","/**
     * Converts a given string into a Bayesian model instance, or throws an exception if it is not valid.
     * 
     * @param str string containing the serialised model
     * @return instantiated model that can be used for predictions
     */","('deserialise', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",42.0,"  Converts a given string into a Bayesian model instance, or throws an exception if it is not valid.",20.0,"['If the string is not valid, it can be converted into a model instance.', 'If a string is not valid, it can be converted into a model instance.', 'If a string is not valid, it can be converted into a model instance or thrown an exception.']"
186,tablesaw,tech/tablesaw/table/TableSlice.java,/core/src/main/java/tech/tablesaw/table/TableSlice.java,mappedRowNumber,255-268,"/**
   * Maps the view row number to the row number on the underlying source table.
   *
   * @param rowNumber the row number in the view.
   * @return the matching row number in the underlying table.
   */
public int mappedRowNumber(int rowNumber){
    if (isSorted()) {
        return sortOrder[rowNumber];
    } else if (hasSelection()) {
        return selection.get(rowNumber);
    }
    return rowNumber;
}","public int mappedRowNumber(int rowNumber){
    if (isSorted()) {
        return sortOrder[rowNumber];
    } else if (hasSelection()) {
        return selection.get(rowNumber);
    }
    return rowNumber;
}","/**
   * Maps the view row number to the row number on the underlying source table.
   *
   * @param rowNumber the row number in the view.
   * @return the matching row number in the underlying table.
   */","('mappedRowNumber', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",43.0,  Maps the view row number to the row number on the underlying source table.,15.0,"['The view row number is mapped to the underlying source table.', 'The view row number is mapped to the row number on the underlying source table.', 'The view row number is mapped to the row number in the underlying source table.']"
187,cucumber-reporting,net/masterthought/cucumber/util/Util.java,/src/main/java/net/masterthought/cucumber/util/Util.java,eliminateEmptyHooks,85-95,"/**
     * Helper method that removes empty hooks from passed array and packs it into new collection.
     *
     * @param hooks hooks to be reduced
     * @return no empty hooks
     */
public static List<Hook> eliminateEmptyHooks(Hook[] hooks){
    return Arrays.asList(hooks).stream().filter(Hook::hasContent).collect(Collectors.toList());
}","public static List<Hook> eliminateEmptyHooks(Hook[] hooks){
    return Arrays.asList(hooks).stream().filter(Hook::hasContent).collect(Collectors.toList());
}","/**
     * Helper method that removes empty hooks from passed array and packs it into new collection.
     *
     * @param hooks hooks to be reduced
     * @return no empty hooks
     */","('eliminateEmptyHooks', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",43.0,  Helper method that removes empty hooks from passed array and packs it into new collection.,16.0,"['The method packs empty hooks into a new collection.', 'The method removes empty hooks from the array and packs them into a new collection.', 'The method removes empty hooks from the array and puts them in a new collection.']"
188,liquibase,liquibase/sqlgenerator/SqlGeneratorFactory.java,/liquibase-core/src/main/java/liquibase/sqlgenerator/SqlGeneratorFactory.java,generateStatementsVolatile,223-234,"/**
     * Return true if the SqlStatement class queries the database in any way to determine Statements to execute.
     * If the statement queries the database, it cannot be used in updateSql type operations
     */
public boolean generateStatementsVolatile(SqlStatement statement, Database database){
    for (SqlGenerator generator : getGenerators(statement, database)) {
        if (generator.generateStatementsIsVolatile(database)) {
            return true;
        }
    }
    return false;
}","public boolean generateStatementsVolatile(SqlStatement statement, Database database){
    for (SqlGenerator generator : getGenerators(statement, database)) {
        if (generator.generateStatementsIsVolatile(database)) {
            return true;
        }
    }
    return false;
}","/**
     * Return true if the SqlStatement class queries the database in any way to determine Statements to execute.
     * If the statement queries the database, it cannot be used in updateSql type operations
     */","('generateStatementsVolatile', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",43.0,  Return true if the SqlStatement class queries the database in any way to determine Statements to execute.,18.0,"['If the SqlStatement class queries the database to determine statements to execute, return true.', 'If the SqlStatement class queries the database to determine Statements to execute, return true.', 'If the SqlStatement class queries the database to determine statements to execute, then return true.']"
190,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCollectionHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCollectionHandler.java,addCollectionMembershipRelationship,110-130,"/**
     * Create CollectionMembership relationships between a Process asset and a Collection. Verifies that the
     * relationship is not present before creating it
     *
     * @param userId             the name of the calling user
     * @param processGUID        the unique identifier of the process
     * @param collectionGUID     the unique identifier of the collection
     * @param externalSourceName the unique name of the external source
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */
public void addCollectionMembershipRelationship(String userId, String processGUID, String collectionGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    dataEngineCommonHandler.upsertExternalRelationship(userId, processGUID, collectionGUID, REFERENCEABLE_TO_COLLECTION_TYPE_NAME, COLLECTION_TYPE_NAME, externalSourceName, null);
}","public void addCollectionMembershipRelationship(String userId, String processGUID, String collectionGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    dataEngineCommonHandler.upsertExternalRelationship(userId, processGUID, collectionGUID, REFERENCEABLE_TO_COLLECTION_TYPE_NAME, COLLECTION_TYPE_NAME, externalSourceName, null);
}","/**
     * Create CollectionMembership relationships between a Process asset and a Collection. Verifies that the
     * relationship is not present before creating it
     *
     * @param userId             the name of the calling user
     * @param processGUID        the unique identifier of the process
     * @param collectionGUID     the unique identifier of the collection
     * @param externalSourceName the unique name of the external source
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */","('addCollectionMembershipRelationship', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",43.0,  Create CollectionMembership relationships between a Process asset and a Collection.,11.0,"['CollectionMembership relationships are created between a Process asset and a collection.', 'CollectionMembership relationships are created between a Process asset and a Collection.', 'CollectionMembership relationships are created between Process asset and a collection.']"
191,jackson-databind,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,isRecordType,286-294,"/**
     * Helper method for detecting Java14-added new {@code Record} types
     *
     * @since 2.12
     */
public static boolean isRecordType(Class<?> cls){
    Class<?> parent = cls.getSuperclass();
    return (parent != null) && ""java.lang.Record"".equals(parent.getName());
}","public static boolean isRecordType(Class<?> cls){
    Class<?> parent = cls.getSuperclass();
    return (parent != null) && ""java.lang.Record"".equals(parent.getName());
}","/**
     * Helper method for detecting Java14-added new {@code Record} types
     *
     * @since 2.12
     */","('isRecordType', {'INSTRUCTION': {'covered': 12, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",43.0,Helper method for detecting Java14-added new {@code Record} types   @since 2.,16.0,"['New @code Record types have been added since 2.', 'New @code Record types have been added to the method.', 'New @code Record types were added to the method.']"
192,cdk,org/openscience/cdk/graph/invariant/InChINumbersTools.java,/storage/inchi/src/main/java/org/openscience/cdk/graph/invariant/InChINumbersTools.java,exch,193-204,"/**
     * Exchange the elements at index i with that at index j.
     *
     * @param values an array of values
     * @param i an index
     * @param j another index
     */
private static void exch(long[] values, int i, int j){
    long k = values[i];
    values[i] = values[j];
    values[j] = k;
}","private static void exch(long[] values, int i, int j){
    long k = values[i];
    values[i] = values[j];
    values[j] = k;
}","/**
     * Exchange the elements at index i with that at index j.
     *
     * @param values an array of values
     * @param i an index
     * @param j another index
     */","('exch', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",43.0,  Exchange the elements at index i with that at index j.,12.0,"['The elements should be exchanged at index i and index j.', 'The elements should be exchanged at index j.', 'The elements should be exchanged at index i and j.']"
193,jackson-databind,com/fasterxml/jackson/databind/ObjectReader.java,/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java,_newIterator,326-337,"/**
     * Factory method used to create {@link MappingIterator} instances;
     * either default, or custom subtype.
     * 
     * @since 2.5
     */
protected MappingIterator<T> _newIterator(JsonParser p, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean parserManaged){
    return new MappingIterator<T>(_valueType, p, ctxt, deser, parserManaged, _valueToUpdate);
}","protected MappingIterator<T> _newIterator(JsonParser p, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean parserManaged){
    return new MappingIterator<T>(_valueType, p, ctxt, deser, parserManaged, _valueToUpdate);
}","/**
     * Factory method used to create {@link MappingIterator} instances;
     * either default, or custom subtype.
     * 
     * @since 2.5
     */","('_newIterator', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,"  Factory method used to create {@link MappingIterator} instances;  either default, or custom subtype.",19.0,"['The factory method creates @link MappingIterator instances.', 'The factory method created @link MappingIterator instances.', 'Factory method used to create instances.']"
194,shardingsphere-elasticjob,org/apache/shardingsphere/elasticjob/cloud/scheduler/statistics/StatisticManager.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/scheduler/statistics/StatisticManager.java,findTaskRunningStatisticsWeekly,225-235,"/**
     * Get the collection of task statistics in the most recent week.
     * 
     * @return Collection of running task statistics data objects
     */
public List<TaskRunningStatistics> findTaskRunningStatisticsWeekly(){
    if (!isRdbConfigured()) {
        return Collections.emptyList();
    }
    return rdbRepository.findTaskRunningStatistics(StatisticTimeUtils.getStatisticTime(StatisticInterval.DAY, -7));
}","public List<TaskRunningStatistics> findTaskRunningStatisticsWeekly(){
    if (!isRdbConfigured()) {
        return Collections.emptyList();
    }
    return rdbRepository.findTaskRunningStatistics(StatisticTimeUtils.getStatisticTime(StatisticInterval.DAY, -7));
}","/**
     * Get the collection of task statistics in the most recent week.
     * 
     * @return Collection of running task statistics data objects
     */","('findTaskRunningStatisticsWeekly', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,  Get the collection of task statistics in the most recent week.,12.0,"['The collection of task statistics can be found in the most recent week.', 'The collection of task statistics is in the most recent week.', 'The collection of task statistics can be found in the last week.']"
195,shardingsphere-elasticjob,org/apache/shardingsphere/elasticjob/cloud/scheduler/statistics/StatisticManager.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/scheduler/statistics/StatisticManager.java,findJobRunningStatisticsWeekly,237-247,"/**
     * Get the collection of job statistics in the most recent week.
     * 
     * @return collection of running task statistics data objects
     */
public List<JobRunningStatistics> findJobRunningStatisticsWeekly(){
    if (!isRdbConfigured()) {
        return Collections.emptyList();
    }
    return rdbRepository.findJobRunningStatistics(StatisticTimeUtils.getStatisticTime(StatisticInterval.DAY, -7));
}","public List<JobRunningStatistics> findJobRunningStatisticsWeekly(){
    if (!isRdbConfigured()) {
        return Collections.emptyList();
    }
    return rdbRepository.findJobRunningStatistics(StatisticTimeUtils.getStatisticTime(StatisticInterval.DAY, -7));
}","/**
     * Get the collection of job statistics in the most recent week.
     * 
     * @return collection of running task statistics data objects
     */","('findJobRunningStatisticsWeekly', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,  Get the collection of job statistics in the most recent week.,12.0,"['You can get the job statistics in the most recent week.', 'You can get the job statistics from the most recent week.', 'You can get the job statistics in the last week.']"
196,cdk,org/openscience/cdk/group/Permutation.java,/tool/group/src/main/java/org/openscience/cdk/group/Permutation.java,firstIndexOfDifference,140-151,"/**
     * Find an r such that this[r] != other[r].
     * @param other the other permutation to compare with
     * @return the first point at which the two permutations differ
     */
public int firstIndexOfDifference(Permutation other){
    int r = 0;
    while ((r < values.length) && values[r] == other.get(r)) {
        r++;
    }
    return r;
}","public int firstIndexOfDifference(Permutation other){
    int r = 0;
    while ((r < values.length) && values[r] == other.get(r)) {
        r++;
    }
    return r;
}","/**
     * Find an r such that this[r] != other[r].
     * @param other the other permutation to compare with
     * @return the first point at which the two permutations differ
     */","('firstIndexOfDifference', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,  Find an r such that this[r] != other[r].,16.0,"['Find an r such that this is the case.', 'Find an r such that this is the other.', 'Find a r such that this is the other.']"
197,openapi-generator,org/openapitools/codegen/validation/ValidationRule.java,/modules/openapi-generator-core/src/main/java/org/openapitools/codegen/validation/ValidationRule.java,warn,128-142,"/**
     * Create an instance of a {@link ValidationRule} which should result in a warning should the evaluate of this rule fail.
     *
     * @param description A description to help differentiate this rule from others (not intended to be user-facing).
     * @param failureMessage The message to be displayed in the event of a test failure (intended to be user-facing).
     * @param fn The test condition to be applied as a part of this rule, when this function returns <code>true</code>,
     *             the evaluated instance will be considered ""valid"" according to this rule.
     * @param <T> The type of the object being evaluated.
     *
     * @return A new instance of a {@link ValidationRule}
     */
public static ValidationRule warn(String description, String failureMessage, Function<T, Result> fn){
    return new ValidationRule(Severity.WARNING, description, failureMessage, (Function<Object, Result>) fn);
}","public static ValidationRule warn(String description, String failureMessage, Function<T, Result> fn){
    return new ValidationRule(Severity.WARNING, description, failureMessage, (Function<Object, Result>) fn);
}","/**
     * Create an instance of a {@link ValidationRule} which should result in a warning should the evaluate of this rule fail.
     *
     * @param description A description to help differentiate this rule from others (not intended to be user-facing).
     * @param failureMessage The message to be displayed in the event of a test failure (intended to be user-facing).
     * @param fn The test condition to be applied as a part of this rule, when this function returns <code>true</code>,
     *             the evaluated instance will be considered ""valid"" according to this rule.
     * @param <T> The type of the object being evaluated.
     *
     * @return A new instance of a {@link ValidationRule}
     */","('warn', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,  Create an instance of a {@link ValidationRule} which should result in a warning should the evaluate of this rule fail.,24.0,"['Should the evaluate of this rule fail, you should create an instance of the @link ValidationRule which should result in a warning.', 'Should the evaluate of this rule fail, you should create an instance of the @link validation rule which should result in a warning.', 'Should the evaluate of this rule fail, you should create an instance of the @link validation rule.']"
198,cdk,org/openscience/cdk/tools/diff/AtomDiff.java,/misc/diff/src/main/java/org/openscience/cdk/tools/diff/AtomDiff.java,diff,45-59,"/**
     * Compare two {@link IChemObject} classes and return the difference as a {@link String}.
     *
     * @param first  the first of the two classes to compare
     * @param second the second of the two classes to compare
     * @return a {@link String} representation of the difference between the first and second {@link IChemObject}.
     */
public static String diff(IChemObject first, IChemObject second){
    IDifference diff = difference(first, second);
    if (diff == null) {
        return """";
    } else {
        return diff.toString();
    }
}","public static String diff(IChemObject first, IChemObject second){
    IDifference diff = difference(first, second);
    if (diff == null) {
        return """";
    } else {
        return diff.toString();
    }
}","/**
     * Compare two {@link IChemObject} classes and return the difference as a {@link String}.
     *
     * @param first  the first of the two classes to compare
     * @param second the second of the two classes to compare
     * @return a {@link String} representation of the difference between the first and second {@link IChemObject}.
     */","('diff', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,  Compare two {@link IChemObject} classes and return the difference as a {@link String}.,20.0,"['The difference between the two classes can be returned as a @link String.', 'You can compare two classes and return the difference as a @link String.', 'You can compare two classes and return a different result.']"
199,cdk,org/openscience/cdk/formula/MolecularFormulaRange.java,/tool/formula/src/main/java/org/openscience/cdk/formula/MolecularFormulaRange.java,isotopes,157-170,"/**
     *  Returns an Iterator for looping over all isotopes in this MolecularFormulaExpand.
     *
     * @return    An Iterator with the isotopes in this MolecularFormulaExpand
     */
public Iterable<IIsotope> isotopes(){
    return new Iterable<IIsotope>() {

        @Override
        public Iterator<IIsotope> iterator() {
            return isotopesMax.keySet().iterator();
        }
    };
}","public Iterable<IIsotope> isotopes(){
    return new Iterable<IIsotope>() {

        @Override
        public Iterator<IIsotope> iterator() {
            return isotopesMax.keySet().iterator();
        }
    };
}","/**
     *  Returns an Iterator for looping over all isotopes in this MolecularFormulaExpand.
     *
     * @return    An Iterator with the isotopes in this MolecularFormulaExpand
     */","('isotopes', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,  Returns an Iterator for looping over all isotopes in this MolecularFormulaExpand.,12.0,"['The Iterator is used to loop over all the isotopes.', 'The Iterator is used to loop over all the isotopes in the MolecularFormulaExpand.', 'The Iterator is returned for looping over all the isotopes.']"
200,incubator-shenyu,org/apache/shenyu/springboot/starter/client/springcloud/ShenyuSpringCloudClientConfiguration.java,/shenyu-spring-boot-starter/shenyu-spring-boot-starter-client/shenyu-spring-boot-starter-client-springcloud/src/main/java/org/apache/shenyu/springboot/starter/client/springcloud/ShenyuSpringCloudClientConfiguration.java,springCloudClientBeanPostProcessor,38-51,"/**
     * Spring cloud client bean post processor spring cloud client bean post processor.
     *
     * @param clientConfig the client config
     * @param shenyuClientRegisterRepository the shenyu client register repository
     * @param env the env
     * @return the spring cloud client bean post processor
     */
public SpringCloudClientBeanPostProcessor springCloudClientBeanPostProcessor(final ShenyuClientConfig clientConfig, final ShenyuClientRegisterRepository shenyuClientRegisterRepository, final Environment env){
    return new SpringCloudClientBeanPostProcessor(clientConfig.getClient().get(RpcTypeEnum.SPRING_CLOUD.getName()), shenyuClientRegisterRepository, env);
}","public SpringCloudClientBeanPostProcessor springCloudClientBeanPostProcessor(final ShenyuClientConfig clientConfig, final ShenyuClientRegisterRepository shenyuClientRegisterRepository, final Environment env){
    return new SpringCloudClientBeanPostProcessor(clientConfig.getClient().get(RpcTypeEnum.SPRING_CLOUD.getName()), shenyuClientRegisterRepository, env);
}","/**
     * Spring cloud client bean post processor spring cloud client bean post processor.
     *
     * @param clientConfig the client config
     * @param shenyuClientRegisterRepository the shenyu client register repository
     * @param env the env
     * @return the spring cloud client bean post processor
     */","('springCloudClientBeanPostProcessor', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,  Spring cloud client bean post processor spring cloud client bean post processor.,13.0,"['Spring cloud client bean post processor.', 'The spring cloud client bean post processor is used.', 'The spring cloud client bean post processor can be used.']"
201,dataverse,edu/harvard/iq/dataverse/DatasetVersion.java,/src/main/java/edu/harvard/iq/dataverse/DatasetVersion.java,isInReview,279-289,"/**
     * The only time a dataset can be in review is when it is in draft.
     * @return if the dataset is being reviewed
     */
public boolean isInReview(){
    if (versionState != null && versionState.equals(VersionState.DRAFT)) {
        return getDataset().isLockedFor(DatasetLock.Reason.InReview);
    } else {
        return false;
    }
}","public boolean isInReview(){
    if (versionState != null && versionState.equals(VersionState.DRAFT)) {
        return getDataset().isLockedFor(DatasetLock.Reason.InReview);
    } else {
        return false;
    }
}","/**
     * The only time a dataset can be in review is when it is in draft.
     * @return if the dataset is being reviewed
     */","('isInReview', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,  The only time a dataset can be in review is when it is in draft.,16.0,"['The only time a dataset can be reviewed is when it is in the draft.', 'The only time a dataset can be reviewed is when it is in draft.', ""The only time a dataset can be reviewed is when it's in the draft.""]"
202,weblogic-kubernetes-operator,oracle/kubernetes/operator/helpers/KubernetesUtils.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/KubernetesUtils.java,mapEquals,28-37,"/**
   * Returns true if the two maps of values match. A null map is considered to match an empty map.
   *
   * @param first  the first map to compare
   * @param second the second map to compare
   * @return true if the maps match.
   */
 static boolean mapEquals(Map<K, V> first, Map<K, V> second){
    return Objects.equals(first, second) || (isNullOrEmpty(first) && isNullOrEmpty(second));
}"," static boolean mapEquals(Map<K, V> first, Map<K, V> second){
    return Objects.equals(first, second) || (isNullOrEmpty(first) && isNullOrEmpty(second));
}","/**
   * Returns true if the two maps of values match. A null map is considered to match an empty map.
   *
   * @param first  the first map to compare
   * @param second the second map to compare
   * @return true if the maps match.
   */","('mapEquals', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",44.0,  Returns true if the two maps of values match.,10.0,"['If the two maps of values match, this is true.', ""If the two maps of values match, it's true."", 'If the two maps of values match, then this is true.']"
203,dataverse,edu/harvard/iq/dataverse/util/BitSet.java,/src/main/java/edu/harvard/iq/dataverse/util/BitSet.java,allIndices,30-39,"/**
	 * Returns all the indices a bit set may have. Can be used for 
	 * cheap for-each loops (i.e. no boxing/unboxing).
	 * @return All the indices a BitSet has [0..63]
	 */
public static short[] allIndices(){
    short[] retVal = new short[64];
    for (short s = 0; s < 64; s++) retVal[s] = s;
    return retVal;
}","public static short[] allIndices(){
    short[] retVal = new short[64];
    for (short s = 0; s < 64; s++) retVal[s] = s;
    return retVal;
}","/**
	 * Returns all the indices a bit set may have. Can be used for 
	 * cheap for-each loops (i.e. no boxing/unboxing).
	 * @return All the indices a BitSet has [0..63]
	 */","('allIndices', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,  Returns all the indices a bit set may have.,10.0,"['A bit set may have all the indices.', 'A bit set may have all the indices returned.', 'A bit set may have all of the indices returned.']"
204,cdk,org/openscience/cdk/tools/manipulator/MolecularFormulaSetManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaSetManipulator.java,validCorrelation,150-164,"/**
     * In the minimal IMolecularFormula must contain all those IElement found in the
     * minimal IMolecularFormula.
     *
     * @param formulaMax  A IMolecularFormula which contains the maximal representation of the Elements
     * @param formulaMin  A IMolecularFormula which contains the minimal representation of the Elements
     * @return            True, if the correlation is valid
     */
private static boolean validCorrelation(IMolecularFormula formulaMin, IMolecularFormula formulamax){
    for (IElement element : MolecularFormulaManipulator.elements(formulaMin)) {
        if (!MolecularFormulaManipulator.containsElement(formulamax, element))
            return false;
    }
    return true;
}","private static boolean validCorrelation(IMolecularFormula formulaMin, IMolecularFormula formulamax){
    for (IElement element : MolecularFormulaManipulator.elements(formulaMin)) {
        if (!MolecularFormulaManipulator.containsElement(formulamax, element))
            return false;
    }
    return true;
}","/**
     * In the minimal IMolecularFormula must contain all those IElement found in the
     * minimal IMolecularFormula.
     *
     * @param formulaMax  A IMolecularFormula which contains the maximal representation of the Elements
     * @param formulaMin  A IMolecularFormula which contains the minimal representation of the Elements
     * @return            True, if the correlation is valid
     */","('validCorrelation', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,  In the minimal IMolecularFormula must contain all those IElement found in the  minimal IMolecularFormula.,15.0,"['The minimal IMolecularFormula must contain all the I Elements.', 'The minimal IMolecularFormula must have all the I Elements.', 'The minimal IMolecularFormula must have all of the I Elements.']"
205,acs-aem-commons,com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,isDispatcherTransportURI,142-153,"/**
     * Checks if the agent has a valid transport URI set.
     *
     * @param agent Agent to check
     * @return true if the Agent's transport URI is in the proper form
     */
private boolean isDispatcherTransportURI(final Agent agent){
    final String transportURI = agent.getConfiguration().getTransportURI();
    return (StringUtils.startsWith(transportURI, HTTP) || StringUtils.startsWith(transportURI, HTTPS));
}","private boolean isDispatcherTransportURI(final Agent agent){
    final String transportURI = agent.getConfiguration().getTransportURI();
    return (StringUtils.startsWith(transportURI, HTTP) || StringUtils.startsWith(transportURI, HTTPS));
}","/**
     * Checks if the agent has a valid transport URI set.
     *
     * @param agent Agent to check
     * @return true if the Agent's transport URI is in the proper form
     */","('isDispatcherTransportURI', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,  Checks if the agent has a valid transport URI set.,11.0,"[""If the agent has a valid transport set, it's checked."", 'If the agent has a valid transport set, it is checked.', 'If the agent has a valid transport set, the check is done.']"
207,tablesaw,tech/tablesaw/analytic/AnalyticQueryEngine.java,/core/src/main/java/tech/tablesaw/analytic/AnalyticQueryEngine.java,addColumns,128-138,"/**
   * Creates empty columns that will be filled in when the analytic aggregate or numbering functions
   * are executed.
   */
private void addColumns(){
    this.destination.addColumns(query.getArgumentList().createEmptyDestinationColumns(query.getTable().rowCount()).toArray(new Column<?>[0]));
}","private void addColumns(){
    this.destination.addColumns(query.getArgumentList().createEmptyDestinationColumns(query.getTable().rowCount()).toArray(new Column<?>[0]));
}","/**
   * Creates empty columns that will be filled in when the analytic aggregate or numbering functions
   * are executed.
   */","('addColumns', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,  Creates empty columns that will be filled in when the analytic aggregate or numbering functions  are executed.,18.0,"['When analytic aggregate or numbering functions are executed, empty columns are created.', 'When the analytic aggregate or numbering functions are executed, empty columns are created.', 'When the analytic aggregate or numbering functions are executed, the empty columns will be filled.']"
208,cdk,org/openscience/cdk/AtomContainerSet.java,/base/data/src/main/java/org/openscience/cdk/AtomContainerSet.java,replaceAtomContainer,134-147,"/**
     * Replace the AtomContainer at a specific position (array has to be large enough).
     *
     * @param position   position in array for AtomContainer
     * @param container  the replacement AtomContainer
     */
public void replaceAtomContainer(int position, IAtomContainer container){
    IAtomContainer old = atomContainers[position];
    old.removeListener(this);
    atomContainers[position] = container;
    container.addListener(this);
    notifyChanged();
}","public void replaceAtomContainer(int position, IAtomContainer container){
    IAtomContainer old = atomContainers[position];
    old.removeListener(this);
    atomContainers[position] = container;
    container.addListener(this);
    notifyChanged();
}","/**
     * Replace the AtomContainer at a specific position (array has to be large enough).
     *
     * @param position   position in array for AtomContainer
     * @param container  the replacement AtomContainer
     */","('replaceAtomContainer', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,  Replace the AtomContainer at a specific position (array has to be large enough).,16.0,"['Thearray has to be large enough to replace the AtomContainer.', 'Thearray has to be large enough to replace the AtomContainer at a specific position.', 'The AtomContainer needs to be replaced at a specific position.']"
209,cdk,org/openscience/cdk/tools/manipulator/MolecularFormulaSetManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaSetManipulator.java,contains,166-184,"/**
     *  True, if the IMolecularFormulaSet contains the given IMolecularFormula but not
     *  as object. It compare according contains the same number and type of Isotopes.
     *  It is not based on compare objects.
     *
     * @param formulaSet   The IMolecularFormulaSet
     * @param  formula     The IMolecularFormula this IMolecularFormulaSet is searched for
     * @return             True, if the IMolecularFormulaSet contains the given formula
     *
     * @see                IMolecularFormulaSet#contains(IMolecularFormula)
     */
public static boolean contains(IMolecularFormulaSet formulaSet, IMolecularFormula formula){
    for (IMolecularFormula fm : formulaSet.molecularFormulas()) {
        if (MolecularFormulaManipulator.compare(fm, formula)) {
            return true;
        }
    }
    return false;
}","public static boolean contains(IMolecularFormulaSet formulaSet, IMolecularFormula formula){
    for (IMolecularFormula fm : formulaSet.molecularFormulas()) {
        if (MolecularFormulaManipulator.compare(fm, formula)) {
            return true;
        }
    }
    return false;
}","/**
     *  True, if the IMolecularFormulaSet contains the given IMolecularFormula but not
     *  as object. It compare according contains the same number and type of Isotopes.
     *  It is not based on compare objects.
     *
     * @param formulaSet   The IMolecularFormulaSet
     * @param  formula     The IMolecularFormula this IMolecularFormulaSet is searched for
     * @return             True, if the IMolecularFormulaSet contains the given formula
     *
     * @see                IMolecularFormulaSet#contains(IMolecularFormula)
     */","('contains', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,"  True, if the IMolecularFormulaSet contains the given IMolecularFormula but not  as object.",14.0,"['If the IMolecularFormulaSet contains the given IMolecularFormula, it is not an object.', ""If the IMolecularFormulaSet contains the given IMolecularFormula but not as an object, that's true."", 'If the IMolecularFormulaSet contains the given IMolecularFormula but not as an object, it is true.']"
210,shardingsphere-elasticjob,org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,/elasticjob-lite/elasticjob-lite-core/src/main/java/org/apache/shardingsphere/elasticjob/lite/internal/guarantee/GuaranteeService.java,isRegisterStartSuccess,51-64,"/**
     * Judge whether current sharding items are all register start success.
     *
     * @param shardingItems current sharding items
     * @return current sharding items are all start success or not
     */
public boolean isRegisterStartSuccess(final Collection<Integer> shardingItems){
    for (int each : shardingItems) {
        if (!jobNodeStorage.isJobNodeExisted(GuaranteeNode.getStartedNode(each))) {
            return false;
        }
    }
    return true;
}","public boolean isRegisterStartSuccess(final Collection<Integer> shardingItems){
    for (int each : shardingItems) {
        if (!jobNodeStorage.isJobNodeExisted(GuaranteeNode.getStartedNode(each))) {
            return false;
        }
    }
    return true;
}","/**
     * Judge whether current sharding items are all register start success.
     *
     * @param shardingItems current sharding items
     * @return current sharding items are all start success or not
     */","('isRegisterStartSuccess', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,  Judge whether current sharding items are all register start success.,11.0,"['If current items are all register start success, judge.', 'If current shards are all register start success, judge.', ""If current items are all register start success, then you're right.""]"
211,cdk,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,assign,104-117,"/**
     * Assign non-planar, up and down labels to indicate tetrahedral configuration. Currently all
     * existing directional labels are removed before assigning new labels.
     *
     * @param container the structure to assign labels to
     * @return a container with assigned labels (currently the same as the input)
     * @throws IllegalArgumentException an atom had no 2D coordinates or labels could not be
     *                                  assigned to a tetrahedral centre
     */
public static IAtomContainer assign(final IAtomContainer container){
    GraphUtil.EdgeToBondMap edgeToBond = GraphUtil.EdgeToBondMap.withSpaceFor(container);
    new NonplanarBonds(container, GraphUtil.toAdjList(container, edgeToBond), edgeToBond);
    return container;
}","public static IAtomContainer assign(final IAtomContainer container){
    GraphUtil.EdgeToBondMap edgeToBond = GraphUtil.EdgeToBondMap.withSpaceFor(container);
    new NonplanarBonds(container, GraphUtil.toAdjList(container, edgeToBond), edgeToBond);
    return container;
}","/**
     * Assign non-planar, up and down labels to indicate tetrahedral configuration. Currently all
     * existing directional labels are removed before assigning new labels.
     *
     * @param container the structure to assign labels to
     * @return a container with assigned labels (currently the same as the input)
     * @throws IllegalArgumentException an atom had no 2D coordinates or labels could not be
     *                                  assigned to a tetrahedral centre
     */","('assign', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",45.0,"  Assign non-planar, up and down labels to indicate tetrahedral configuration.",12.0,"['The non-planar, up and down labels are used to indicate the configuration.', 'The non-planar, up and down labels should be assigned.', 'The non-planar, up and down labels should be assigned to indicate the configuration.']"
212,anserini,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,documentRaw,538-553,"/**
   * Returns the ""raw"" field of a document based on a collection docid. The method is named to be consistent with
   * Lucene's {@link IndexReader#document(int)}, contra Java's standard method naming conventions.
   *
   * @param reader index reader
   * @param docid collection docid
   * @return the ""raw"" field the document
   */
public static String documentRaw(IndexReader reader, String docid){
    try {
        return reader.document(convertDocidToLuceneDocid(reader, docid)).get(IndexArgs.RAW);
    } catch (Exception e) {
        return null;
    }
}","public static String documentRaw(IndexReader reader, String docid){
    try {
        return reader.document(convertDocidToLuceneDocid(reader, docid)).get(IndexArgs.RAW);
    } catch (Exception e) {
        return null;
    }
}","/**
   * Returns the ""raw"" field of a document based on a collection docid. The method is named to be consistent with
   * Lucene's {@link IndexReader#document(int)}, contra Java's standard method naming conventions.
   *
   * @param reader index reader
   * @param docid collection docid
   * @return the ""raw"" field the document
   */","('documentRaw', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,"  Returns the ""raw"" field of a document based on a collection docid.",15.0,"['The ""raw"" field of the document is returned.', 'The ""raw"" field of a document is returned.', 'The document\'s ""raw"" field is returned.']"
213,tablesaw,tech/tablesaw/joining/DataFrameJoiner.java,/core/src/main/java/tech/tablesaw/joining/DataFrameJoiner.java,buildIndexesForJoinColumns,336-339,"/** Build a reverse index for every join column in the table. */
private List<Index> buildIndexesForJoinColumns(List<Integer> joinColumnIndexes, Table table){
    return joinColumnIndexes.stream().map(c -> indexFor(table, c)).collect(Collectors.toList());
}","private List<Index> buildIndexesForJoinColumns(List<Integer> joinColumnIndexes, Table table){
    return joinColumnIndexes.stream().map(c -> indexFor(table, c)).collect(Collectors.toList());
}",/** Build a reverse index for every join column in the table. */,"('buildIndexesForJoinColumns', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0, Build a reverse index for every join column in the table.,12.0,"['Every join column in the table needs a reverse index.', 'Every join column in the table needs a reverse index built.', 'Every join column in the table has to have a reverse index built.']"
214,cdk,org/openscience/cdk/renderer/RendererModel.java,/display/render/src/main/java/org/openscience/cdk/renderer/RendererModel.java,addCDKChangeListener,379-392,"/**
     * Adds a change listener to the list of listeners.
     *
     * @param listener
     *            The listener added to the list
     */
public void addCDKChangeListener(ICDKChangeListener listener){
    if (listeners == null) {
        listeners = new ArrayList<ICDKChangeListener>();
    }
    if (!listeners.contains(listener)) {
        listeners.add(listener);
    }
}","public void addCDKChangeListener(ICDKChangeListener listener){
    if (listeners == null) {
        listeners = new ArrayList<ICDKChangeListener>();
    }
    if (!listeners.contains(listener)) {
        listeners.add(listener);
    }
}","/**
     * Adds a change listener to the list of listeners.
     *
     * @param listener
     *            The listener added to the list
     */","('addCDKChangeListener', {'INSTRUCTION': {'covered': 14, 'missed': 5}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,  Adds a change listener to the list of listeners.,10.0,"['A change listener is added to the list.', 'The change listener is added to the list.', 'A change listener is added to the list of others.']"
215,jackson-databind,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,isProxyType,233-255,"/**
     * Helper method used to weed out dynamic Proxy types; types that do
     * not expose concrete method API that we could use to figure out
     * automatic Bean (property) based serialization.
     */
public static boolean isProxyType(Class<?> type){
    String name = type.getName();
    if (name.startsWith(""net.sf.cglib.proxy."") || name.startsWith(""org.hibernate.proxy."")) {
        return true;
    }
    return false;
}","public static boolean isProxyType(Class<?> type){
    String name = type.getName();
    if (name.startsWith(""net.sf.cglib.proxy."") || name.startsWith(""org.hibernate.proxy."")) {
        return true;
    }
    return false;
}","/**
     * Helper method used to weed out dynamic Proxy types; types that do
     * not expose concrete method API that we could use to figure out
     * automatic Bean (property) based serialization.
     */","('isProxyType', {'INSTRUCTION': {'covered': 13, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,  Helper method used to weed out dynamic Proxy types; types that do  not expose concrete method API that we could use to figure out  automatic Bean (property) based serialization.,33.0,"['The method used to weed out dynamic Proxy types is a helpers method.', 'The method used to weed out dynamic Proxy types is called a helpers method.', 'The method used to weed out dynamic Proxy types is called the Helper method.']"
216,cdk,org/openscience/cdk/signature/MoleculeSignature.java,/descriptor/signature/src/main/java/org/openscience/cdk/signature/MoleculeSignature.java,fromSignatureString,171-184,"/**
     * Builder for molecules (rather, for atom containers) from signature
     * strings.
     *
     * @param signatureString the signature string to use
     * @param coBuilder {@link IChemObjectBuilder} to build the returned atom container from
     * @return an atom container
     */
public static IAtomContainer fromSignatureString(String signatureString, IChemObjectBuilder coBuilder){
    ColoredTree tree = AtomSignature.parse(signatureString);
    MoleculeFromSignatureBuilder builder = new MoleculeFromSignatureBuilder(coBuilder);
    builder.makeFromColoredTree(tree);
    return builder.getAtomContainer();
}","public static IAtomContainer fromSignatureString(String signatureString, IChemObjectBuilder coBuilder){
    ColoredTree tree = AtomSignature.parse(signatureString);
    MoleculeFromSignatureBuilder builder = new MoleculeFromSignatureBuilder(coBuilder);
    builder.makeFromColoredTree(tree);
    return builder.getAtomContainer();
}","/**
     * Builder for molecules (rather, for atom containers) from signature
     * strings.
     *
     * @param signatureString the signature string to use
     * @param coBuilder {@link IChemObjectBuilder} to build the returned atom container from
     * @return an atom container
     */","('fromSignatureString', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,"  Builder for molecules (rather, for atom containers) from signature  strings.",14.0,"['Molecules and atom containers can be built from signature strings.', 'Molecules and atom containers are built from signature strings.', 'For atom containers, signature strings are used as a builder.']"
217,anserini,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,documentContents,555-570,"/**
   * Returns the ""contents"" field of a document based on a collection docid. The method is named to be consistent with
   * Lucene's {@link IndexReader#document(int)}, contra Java's standard method naming conventions.
   *
   * @param reader index reader
   * @param docid collection docid
   * @return the ""contents"" field the document
   */
public static String documentContents(IndexReader reader, String docid){
    try {
        return reader.document(convertDocidToLuceneDocid(reader, docid)).get(IndexArgs.CONTENTS);
    } catch (Exception e) {
        return null;
    }
}","public static String documentContents(IndexReader reader, String docid){
    try {
        return reader.document(convertDocidToLuceneDocid(reader, docid)).get(IndexArgs.CONTENTS);
    } catch (Exception e) {
        return null;
    }
}","/**
   * Returns the ""contents"" field of a document based on a collection docid. The method is named to be consistent with
   * Lucene's {@link IndexReader#document(int)}, contra Java's standard method naming conventions.
   *
   * @param reader index reader
   * @param docid collection docid
   * @return the ""contents"" field the document
   */","('documentContents', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,"  Returns the ""contents"" field of a document based on a collection docid.",15.0,"['The ""contents"" field is returned when the document is based on a collection docid.', 'The ""contents"" field of the document is returned.', 'The ""contents"" field of a document is returned.']"
218,cdk,org/openscience/cdk/group/Permutation.java,/tool/group/src/main/java/org/openscience/cdk/group/Permutation.java,isIdentity,98-110,"/**
     * Check to see if this permutation is the identity permutation.
     *
     * @return true if for all i, p[i] = i
     */
public boolean isIdentity(){
    for (int i = 0; i < this.values.length; i++) {
        if (this.values[i] != i) {
            return false;
        }
    }
    return true;
}","public boolean isIdentity(){
    for (int i = 0; i < this.values.length; i++) {
        if (this.values[i] != i) {
            return false;
        }
    }
    return true;
}","/**
     * Check to see if this permutation is the identity permutation.
     *
     * @return true if for all i, p[i] = i
     */","('isIdentity', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,  Check to see if this permutation is the identity permutation.,11.0,"['If this permutation is the identity permutation, you should check it.', 'If this permutation is the identity permutation, check it.', 'If this permutation is the identity permutation, check it out.']"
219,metrics,io/dropwizard/metrics5/UniformSnapshot.java,/metrics-core/src/main/java/io/dropwizard/metrics5/UniformSnapshot.java,dump,164-176,"/**
     * Writes the values of the snapshot to the given stream.
     *
     * @param output an output stream
     */
public void dump(OutputStream output){
    try (PrintWriter out = new PrintWriter(new OutputStreamWriter(output, UTF_8))) {
        for (long value : values) {
            out.printf(""%d%n"", value);
        }
    }
}","public void dump(OutputStream output){
    try (PrintWriter out = new PrintWriter(new OutputStreamWriter(output, UTF_8))) {
        for (long value : values) {
            out.printf(""%d%n"", value);
        }
    }
}","/**
     * Writes the values of the snapshot to the given stream.
     *
     * @param output an output stream
     */","('dump', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,  Writes the values of the snapshot to the given stream.,11.0,"['The values of the snapshot are written.', 'The values are written to the stream.', 'Writes the values of the snapshot to the stream.']"
220,matsim-libs,org/matsim/vehicles/MatsimVehicleWriter.java,/matsim/src/main/java/org/matsim/vehicles/MatsimVehicleWriter.java,writeFile,49-60,"/**
	 * Writes the vehicles in the current default format
	 * (currently vehicleDefinitions_v2.0.dtd).
	 */
public void writeFile(String filename){
    log.info(Gbl.aboutToWrite(""vehicles"", filename));
    try {
        delegate.writeFile(filename);
    } catch (IOException e) {
        e.printStackTrace();
    }
}","public void writeFile(String filename){
    log.info(Gbl.aboutToWrite(""vehicles"", filename));
    try {
        delegate.writeFile(filename);
    } catch (IOException e) {
        e.printStackTrace();
    }
}","/**
	 * Writes the vehicles in the current default format
	 * (currently vehicleDefinitions_v2.0.dtd).
	 */","('writeFile', {'INSTRUCTION': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 4, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,Writes the vehicles in the current default format  (currently vehicleDefinitions_v2.,12.0,"['The current format of the vehicles is vehicleDefinitions_v2.', 'Writes the vehicles in the default format.', 'The current format for vehicles is vehicleDefinitions_v2.']"
221,cdk,org/openscience/cdk/renderer/AtomContainerRenderer.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/AtomContainerRenderer.java,calculateScaleForBondLength,256-270,"/**
     * Given a bond length for a model, calculate the scale that will transform
     * this length to the on screen bond length in RendererModel.
     *
     * @param modelBondLength the average bond length of the model
     * @return the scale necessary to transform this to a screen bond
     */
public double calculateScaleForBondLength(double modelBondLength){
    if (Double.isNaN(modelBondLength) || modelBondLength == 0) {
        return DEFAULT_SCALE;
    } else {
        return rendererModel.getParameter(BondLength.class).getValue() / modelBondLength;
    }
}","public double calculateScaleForBondLength(double modelBondLength){
    if (Double.isNaN(modelBondLength) || modelBondLength == 0) {
        return DEFAULT_SCALE;
    } else {
        return rendererModel.getParameter(BondLength.class).getValue() / modelBondLength;
    }
}","/**
     * Given a bond length for a model, calculate the scale that will transform
     * this length to the on screen bond length in RendererModel.
     *
     * @param modelBondLength the average bond length of the model
     * @return the scale necessary to transform this to a screen bond
     */","('calculateScaleForBondLength', {'INSTRUCTION': {'covered': 18, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,"  Given a bond length for a model, calculate the scale that will transform  this length to the on screen bond length in RendererModel.",25.0,"['If you give a bond length for a model, calculate the scale that will transform it to the on screen bond length.', 'If you give a bond length for a model, calculate the scale that will transform it to the screen bond length.', 'If you give a bond length for a model, calculate the scale that will transform it to a screen bond.']"
222,openapi-generator,org/openapitools/codegen/DefaultCodegen.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java,toEnumValue,754-768,"/**
     * Return the enum value in the language specified format
     * e.g. status becomes ""status""
     *
     * @param value    enum variable name
     * @param datatype data type
     * @return the sanitized value for enum
     */
public String toEnumValue(String value, String datatype){
    if (""number"".equalsIgnoreCase(datatype) || ""boolean"".equalsIgnoreCase(datatype)) {
        return value;
    } else {
        return ""\"""" + escapeText(value) + ""\"""";
    }
}","public String toEnumValue(String value, String datatype){
    if (""number"".equalsIgnoreCase(datatype) || ""boolean"".equalsIgnoreCase(datatype)) {
        return value;
    } else {
        return ""\"""" + escapeText(value) + ""\"""";
    }
}","/**
     * Return the enum value in the language specified format
     * e.g. status becomes ""status""
     *
     * @param value    enum variable name
     * @param datatype data type
     * @return the sanitized value for enum
     */","('toEnumValue', {'INSTRUCTION': {'covered': 21, 'missed': 2}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,  Return the enum value in the language specified format  e.,11.0,"['Return the value in the specified format.', 'Return the value in the format specified.', 'Return the value in the language specified.']"
224,cdk,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,length,1490-1502,"/**
     * Determine the length of the line excluding trailing whitespace.
     *
     * @param str a string
     * @return the length when trailing white space is removed
     */
 static int length(final String str){
    int i = str.length() - 1;
    while (i >= 0 && str.charAt(i) == ' ') {
        i--;
    }
    return i + 1;
}","static int length(final String str){
    int i = str.length() - 1;
    while (i >= 0 && str.charAt(i) == ' ') {
        i--;
    }
    return i + 1;
}","/**
     * Determine the length of the line excluding trailing whitespace.
     *
     * @param str a string
     * @return the length when trailing white space is removed
     */","('length', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,  Determine the length of the line excluding trailing whitespace.,10.0,"['The length of the line should be determined.', 'Determine the length of the line.', 'The length of the line should be known.']"
225,acs-aem-commons,com/adobe/acs/commons/replication/status/impl/ReplicationStatusManagerImpl.java,/bundle/src/main/java/com/adobe/acs/commons/replication/status/impl/ReplicationStatusManagerImpl.java,addReplicationStatusMixin,193-205,"/**
     * Adds the cq:ReplicationStatus mixin if the node doesnt already have it or does have it as its jcr:supertype
     * already.
     *
     * @param node the node obj
     * @throws RepositoryException
     */
private void addReplicationStatusMixin(final Node node) throws RepositoryException{
    if (!this.hasMixin(node, ReplicationStatus.NODE_TYPE) && node.canAddMixin(ReplicationStatus.NODE_TYPE)) {
        node.addMixin(ReplicationStatus.NODE_TYPE);
    }
}","private void addReplicationStatusMixin(final Node node) throws RepositoryException{
    if (!this.hasMixin(node, ReplicationStatus.NODE_TYPE) && node.canAddMixin(ReplicationStatus.NODE_TYPE)) {
        node.addMixin(ReplicationStatus.NODE_TYPE);
    }
}","/**
     * Adds the cq:ReplicationStatus mixin if the node doesnt already have it or does have it as its jcr:supertype
     * already.
     *
     * @param node the node obj
     * @throws RepositoryException
     */","('addReplicationStatusMixin', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,  Adds the cq:ReplicationStatus mixin if the node doesnt already have it or does have it as its jcr:supertype  already.,24.0,"['The cq:ReplicationStatus mixin is added if the node has it or if it is already a jcr:supertype.', 'The cq:ReplicationStatus mixin is added if the nodes has it or if it is already a jcr:supertype.', 'The cq:ReplicationStatus mixin is added if the node already has it or if it is a jcr:supertype.']"
227,cdk,org/openscience/cdk/hash/stereo/DoubleBond3DParity.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/DoubleBond3DParity.java,toVector,93-102,"/**
     * Create a vector by specifying the source and destination coordinates.
     *
     * @param src  start point of the vector
     * @param dest end point of the vector
     * @return a new vector
     */
private static double[] toVector(Point3d src, Point3d dest){
    return new double[] { dest.x - src.x, dest.y - src.y, dest.z - src.z };
}","private static double[] toVector(Point3d src, Point3d dest){
    return new double[] { dest.x - src.x, dest.y - src.y, dest.z - src.z };
}","/**
     * Create a vector by specifying the source and destination coordinates.
     *
     * @param src  start point of the vector
     * @param dest end point of the vector
     * @return a new vector
     */","('toVector', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,  Create a vector by specifying the source and destination coordinates.,11.0,"['The source and destination coordinates can be specified to create a vector.', 'The source and destination coordinates are needed to create a vector.', 'The source and destination coordinates are required to create a vector.']"
228,weblogic-kubernetes-operator,oracle/kubernetes/operator/helpers/LegalNames.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/LegalNames.java,isDns1123Required,195-210,"/**
   * Returns true if the value in the field is required to be DNS-1123 legal.
   *
   * @param fieldName Name of the field to be checked
   * @return true if the value needs to be DNS1123 legal, false otherwise
   */
public static boolean isDns1123Required(String fieldName){
    if (fieldName != null) {
        for (String dns1123Field : getDns1123Fields()) {
            if (dns1123Field.equalsIgnoreCase(fieldName)) {
                return true;
            }
        }
    }
    return false;
}","public static boolean isDns1123Required(String fieldName){
    if (fieldName != null) {
        for (String dns1123Field : getDns1123Fields()) {
            if (dns1123Field.equalsIgnoreCase(fieldName)) {
                return true;
            }
        }
    }
    return false;
}","/**
   * Returns true if the value in the field is required to be DNS-1123 legal.
   *
   * @param fieldName Name of the field to be checked
   * @return true if the value needs to be DNS1123 legal, false otherwise
   */","('isDns1123Required', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",46.0,Returns true if the value in the field is required to be DNS-1123 legal.,15.0,"[""If the value in the field is required to be legal, it's true."", 'If the value in the field is required to be legal, returns true.', 'If the value in the field is required to be legal, it will be true.']"
229,matsim-libs,org/matsim/utils/objectattributes/attributable/AttributesUtils.java,/matsim/src/main/java/org/matsim/utils/objectattributes/attributable/AttributesUtils.java,copyTo,31-39,"/**
	 * Adds the mappings from ""from"" to ""to"". Nothing is done to copy the Object themselves,
	 * which should be fine for 99.9% of the usecases of Attributes (value objects)
	 */
public static void copyTo(Attributes from, Attributes to){
    for (var entry : from.getAsMap().entrySet()) {
        to.putAttribute(entry.getKey(), entry.getValue());
    }
}","public static void copyTo(Attributes from, Attributes to){
    for (var entry : from.getAsMap().entrySet()) {
        to.putAttribute(entry.getKey(), entry.getValue());
    }
}","/**
	 * Adds the mappings from ""from"" to ""to"". Nothing is done to copy the Object themselves,
	 * which should be fine for 99.9% of the usecases of Attributes (value objects)
	 */","('copyTo', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,"  Adds the mappings from ""from"" to ""to"".",12.0,"['The mappings are added from ""from"" to ""to"".', 'The mappings are changed from ""from"" to ""to"".', 'Adds the mappings from ""from"" to ""to"".']"
230,dcache,org/dcache/auth/Subjects.java,/modules/common/src/main/java/org/dcache/auth/Subjects.java,isExemptFromNamespaceChecks,70-82,"/**
     * Return true if the subject is root or has the special ExemptFromNamespaceChecks principal.
     *
     * @param subject The identity of the user.
     * @return if the user is except from namespace checks.
     * @see #isRoot(javax.security.auth.Subject)
     */
public static boolean isExemptFromNamespaceChecks(Subject subject){
    return subject.getPrincipals().stream().anyMatch(p -> p instanceof UidPrincipal && ((UidPrincipal) p).getUid() == 0 || p instanceof ExemptFromNamespaceChecks);
}","public static boolean isExemptFromNamespaceChecks(Subject subject){
    return subject.getPrincipals().stream().anyMatch(p -> p instanceof UidPrincipal && ((UidPrincipal) p).getUid() == 0 || p instanceof ExemptFromNamespaceChecks);
}","/**
     * Return true if the subject is root or has the special ExemptFromNamespaceChecks principal.
     *
     * @param subject The identity of the user.
     * @return if the user is except from namespace checks.
     * @see #isRoot(javax.security.auth.Subject)
     */","('isExemptFromNamespaceChecks', {'INSTRUCTION': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,  Return true if the subject is root or has the special ExemptFromNamespaceChecks principal.,14.0,"['If the subject is root, return true.', 'If the subject is root, return it as true.', 'Return true if the subject is root or ExemptFromNamespaceChecks principal.']"
231,cdk,org/openscience/cdk/hash/stereo/DoubleBondElementEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/DoubleBondElementEncoderFactory.java,findOther,119-132,"/**
     * Finds a vertex in 'vs' which is not 'u' or 'x'.
     * .
     * @param vs fixed size array of 3 elements
     * @param u  a vertex in 'vs'
     * @param x  another vertex in 'vs'
     * @return the other vertex
     */
private static int findOther(int[] vs, int u, int x){
    for (int v : vs) {
        if (v != u && v != x)
            return v;
    }
    throw new IllegalArgumentException(""vs[] did not contain another vertex"");
}","private static int findOther(int[] vs, int u, int x){
    for (int v : vs) {
        if (v != u && v != x)
            return v;
    }
    throw new IllegalArgumentException(""vs[] did not contain another vertex"");
}","/**
     * Finds a vertex in 'vs' which is not 'u' or 'x'.
     * .
     * @param vs fixed size array of 3 elements
     * @param u  a vertex in 'vs'
     * @param x  another vertex in 'vs'
     * @return the other vertex
     */","('findOther', {'INSTRUCTION': {'covered': 24, 'missed': 5}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,  Finds a vertex in 'vs' which is not 'u' or 'x'.,17.0,"[""It is found that the 'v' is not 'u' or 'x'."", ""It is found that the 'u' and 'x' are not in the same place."", ""It is found that the 'u' and 'x' are not the same thing in 'vs'.""]"
232,jackson-databind,com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java,/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java,_collectIgnorals,935-948,"/**
     * Helper method called to add explicitly ignored properties to a list
     * of known ignored properties; this helps in proper reporting of
     * errors.
     */
protected void _collectIgnorals(String name){
    if (!_forSerialization && (name != null)) {
        if (_ignoredPropertyNames == null) {
            _ignoredPropertyNames = new HashSet<String>();
        }
        _ignoredPropertyNames.add(name);
    }
}","protected void _collectIgnorals(String name){
    if (!_forSerialization && (name != null)) {
        if (_ignoredPropertyNames == null) {
            _ignoredPropertyNames = new HashSet<String>();
        }
        _ignoredPropertyNames.add(name);
    }
}","/**
     * Helper method called to add explicitly ignored properties to a list
     * of known ignored properties; this helps in proper reporting of
     * errors.
     */","('_collectIgnorals', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,  Helper method called to add explicitly ignored properties to a list  of known ignored properties; this helps in proper reporting of  errors.,24.0,"['Adding explicitly ignored properties to a list helps in reporting errors.', 'Adding explicitly ignored properties to a list of known ignored properties helps in reporting errors.', 'Adding explicitly ignored properties to a list helps in proper reporting of errors.']"
234,matsim-libs,org/matsim/core/network/algorithms/NetworkSimplifier.java,/matsim/src/main/java/org/matsim/core/network/algorithms/NetworkSimplifier.java,bothLinksAreShorterThanThreshold,293-308,"/**
	 * Quick check to see whether <i>both</i> the links are shorter than the 
	 * given threshold.
	 * @param linkA
	 * @param linkB
	 * @param thresholdLength
	 * @return true if <i>both</i> links are shorter than the given threshold, 
	 * false otherwise. 
	 */
private boolean bothLinksAreShorterThanThreshold(Link linkA, Link linkB, double thresholdLength){
    boolean hasTwoShortLinks = false;
    if (linkA.getLength() < thresholdLength && linkB.getLength() < thresholdLength) {
        hasTwoShortLinks = true;
    }
    return hasTwoShortLinks;
}","private boolean bothLinksAreShorterThanThreshold(Link linkA, Link linkB, double thresholdLength){
    boolean hasTwoShortLinks = false;
    if (linkA.getLength() < thresholdLength && linkB.getLength() < thresholdLength) {
        hasTwoShortLinks = true;
    }
    return hasTwoShortLinks;
}","/**
	 * Quick check to see whether <i>both</i> the links are shorter than the 
	 * given threshold.
	 * @param linkA
	 * @param linkB
	 * @param thresholdLength
	 * @return true if <i>both</i> links are shorter than the given threshold, 
	 * false otherwise. 
	 */","('bothLinksAreShorterThanThreshold', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,  Quick check to see whether <i>both</i> the links are shorter than the   given threshold.,21.0,"['Check to see if the links are shorter than the threshold.', 'You can check to see if the links are shorter than the threshold.', 'Check to see if the links are longer than the threshold.']"
235,matsim-libs,org/matsim/core/network/algorithms/NetworkSimplifier.java,/matsim/src/main/java/org/matsim/core/network/algorithms/NetworkSimplifier.java,eitherLinkIsShorterThanThreshold,310-325,"/**
	 * Quick check to see whether <i>either</i> the links are shorter than the 
	 * given threshold.
	 * @param linkA
	 * @param linkB
	 * @param thresholdLength
	 * @return true if <i>either</i> links are shorter than the given threshold, 
	 * false otherwise. 
	 */
private boolean eitherLinkIsShorterThanThreshold(Link linkA, Link linkB, double thresholdLength){
    boolean hasShortLink = false;
    if (linkA.getLength() < thresholdLength || linkB.getLength() < thresholdLength) {
        hasShortLink = true;
    }
    return hasShortLink;
}","private boolean eitherLinkIsShorterThanThreshold(Link linkA, Link linkB, double thresholdLength){
    boolean hasShortLink = false;
    if (linkA.getLength() < thresholdLength || linkB.getLength() < thresholdLength) {
        hasShortLink = true;
    }
    return hasShortLink;
}","/**
	 * Quick check to see whether <i>either</i> the links are shorter than the 
	 * given threshold.
	 * @param linkA
	 * @param linkB
	 * @param thresholdLength
	 * @return true if <i>either</i> links are shorter than the given threshold, 
	 * false otherwise. 
	 */","('eitherLinkIsShorterThanThreshold', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,  Quick check to see whether <i>either</i> the links are shorter than the   given threshold.,21.0,"['Check to see if the links are shorter than the threshold.', 'Check to see if the links are longer than the threshold.', 'Check to see whether the links are shorter than the threshold.']"
236,matsim-libs,org/matsim/core/utils/misc/Time.java,/matsim/src/main/java/org/matsim/core/utils/misc/Time.java,convertHHMMInteger,227-238,"/**
	 * Converts a number like 1634 to the time value of 16:34:00.
	 * 
	 * @param hhmm the time-representing number to convert.
	 * @return the time as seconds after midnight.
	 */
public static double convertHHMMInteger(int hhmm){
    int h = hhmm / 100;
    int m = hhmm - (h * 100);
    double seconds = Math.abs(h) * 3600 + m * 60;
    return seconds;
}","public static double convertHHMMInteger(int hhmm){
    int h = hhmm / 100;
    int m = hhmm - (h * 100);
    double seconds = Math.abs(h) * 3600 + m * 60;
    return seconds;
}","/**
	 * Converts a number like 1634 to the time value of 16:34:00.
	 * 
	 * @param hhmm the time-representing number to convert.
	 * @return the time as seconds after midnight.
	 */","('convertHHMMInteger', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,Converts a number like 1634 to the time value of 16:34:00.,12.0,"['1634 is converted to the time value of 16:44.', 'The number 1634 is converted to the time value.', 'The number 1634 is converted to the time value of 16:44.']"
237,cdk,org/openscience/cdk/ChemObject.java,/base/data/src/main/java/org/openscience/cdk/ChemObject.java,removeListener,150-167,"/**
     *  Use this to remove a ChemObjectListener from the ListenerList of this
     *  IChemObject. It will then not be notified of change in this object anymore.
     *
     *@param  col  The ChemObjectListener to be removed
     *@see         #addListener
     */
public void removeListener(IChemObjectListener col){
    if (chemObjectListeners == null) {
        return;
    }
    List<IChemObjectListener> listeners = lazyChemObjectListeners();
    if (listeners.contains(col)) {
        listeners.remove(col);
    }
}","public void removeListener(IChemObjectListener col){
    if (chemObjectListeners == null) {
        return;
    }
    List<IChemObjectListener> listeners = lazyChemObjectListeners();
    if (listeners.contains(col)) {
        listeners.remove(col);
    }
}","/**
     *  Use this to remove a ChemObjectListener from the ListenerList of this
     *  IChemObject. It will then not be notified of change in this object anymore.
     *
     *@param  col  The ChemObjectListener to be removed
     *@see         #addListener
     */","('removeListener', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,  Use this to remove a ChemObjectListener from the ListenerList of this  IChemObject.,13.0,"['This can be used to remove a ChemObjectListener from the Listener List.', 'This can be used to remove a ChemObjectListener from the Listener list.', 'This will remove a ChemObjectListener from the Listener List.']"
238,cdk,org/openscience/cdk/qsar/descriptors/atomic/IPAtomicHOSEDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/IPAtomicHOSEDescriptor.java,familyHalogen,162-171,"/**
     * Looking if the Atom belongs to the halogen family.
     *
     * @param  atom  The IAtom
     * @return       True, if it belongs
     */
private boolean familyHalogen(IAtom atom){
    String symbol = atom.getSymbol();
    return symbol.equals(""F"") || symbol.equals(""Cl"") || symbol.equals(""Br"") || symbol.equals(""I"");
}","private boolean familyHalogen(IAtom atom){
    String symbol = atom.getSymbol();
    return symbol.equals(""F"") || symbol.equals(""Cl"") || symbol.equals(""Br"") || symbol.equals(""I"");
}","/**
     * Looking if the Atom belongs to the halogen family.
     *
     * @param  atom  The IAtom
     * @return       True, if it belongs
     */","('familyHalogen', {'INSTRUCTION': {'covered': 22, 'missed': 1}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,  Looking if the Atom belongs to the halogen family.,10.0,"['Is the atom a part of the halogen family?', 'Is the Atom a part of the halogen family?', 'Is the Atom a member of the halogen family?']"
239,cdk,org/openscience/cdk/silent/BioPolymer.java,/base/silent/src/main/java/org/openscience/cdk/silent/BioPolymer.java,removeStrand,241-253,"/**
     * Removes a particular strand, specified by its name.
     *
     * @param name name of the strand to remove
     */
public void removeStrand(String name){
    if (strands.containsKey(name)) {
        Strand strand = (Strand) strands.get(name);
        this.remove(strand);
        strands.remove(name);
    }
}","public void removeStrand(String name){
    if (strands.containsKey(name)) {
        Strand strand = (Strand) strands.get(name);
        this.remove(strand);
        strands.remove(name);
    }
}","/**
     * Removes a particular strand, specified by its name.
     *
     * @param name name of the strand to remove
     */","('removeStrand', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,"  Removes a particular strand, specified by its name.",10.0,"['A strand is removed by its name.', 'The strand is removed by its name.', 'A strand is removed if it is specified by its name.']"
240,seata,io/seata/common/util/NumberUtils.java,/common/src/main/java/io/seata/common/util/NumberUtils.java,toInt,25-44,"/**
     * <p>Convert a <code>String</code> to an <code>int</code>, returning a
     * default value if the conversion fails.</p>
     *
     * <p>If the string is <code>null</code>, the default value is returned.</p>
     *
     * @param str          the string to convert, may be null
     * @param defaultValue the default value
     * @return the int represented by the string, or the default if conversion fails
     */
public static int toInt(final String str, final int defaultValue){
    if (str == null) {
        return defaultValue;
    }
    try {
        return Integer.parseInt(str);
    } catch (NumberFormatException nfe) {
        return defaultValue;
    }
}","public static int toInt(final String str, final int defaultValue){
    if (str == null) {
        return defaultValue;
    }
    try {
        return Integer.parseInt(str);
    } catch (NumberFormatException nfe) {
        return defaultValue;
    }
}","/**
     * <p>Convert a <code>String</code> to an <code>int</code>, returning a
     * default value if the conversion fails.</p>
     *
     * <p>If the string is <code>null</code>, the default value is returned.</p>
     *
     * @param str          the string to convert, may be null
     * @param defaultValue the default value
     * @return the int represented by the string, or the default if conversion fails
     */","('toInt', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,"  <p>Convert a <code>String</code> to an <code>int</code>, returning a  default value if the conversion fails.",31.0,"['If the conversion fails, return a default value.', 'If the conversion fails, you can return a default value.', 'If the conversion fails, return a default value for the code>String/code>.']"
241,matsim-libs,org/matsim/core/router/TripRouter.java,/matsim/src/main/java/org/matsim/core/router/TripRouter.java,insertTrip,226-250,"/**
	 * Inserts a trip between two activities in the sequence of plan elements
	 * returned by the {@link Plan#getPlanElements()} method of a plan. Note
	 * that the plan will be modified only if the returned list is the internal
	 * reference!
	 * <p></p>
	 * Note that this methods returns a unique solution because it expects the activity object references as arguments, which are unique.
	 *
	 * @param plan the plan to modify
	 * @param origin the activity to use as origin. It must be a member of the list of plan elements.
	 * @param trip the trip to insert
	 * @param destination the destination activity. It must be a member of the list.
	 * @return the ""old trip"": the sequence of plan elements originally existing between the origin and the destination
	 */
public static List<PlanElement> insertTrip(final Plan plan, final Activity origin, final List<? extends PlanElement> trip, final Activity destination){
    return insertTrip(plan.getPlanElements(), origin, trip, destination);
}","public static List<PlanElement> insertTrip(final Plan plan, final Activity origin, final List<? extends PlanElement> trip, final Activity destination){
    return insertTrip(plan.getPlanElements(), origin, trip, destination);
}","/**
	 * Inserts a trip between two activities in the sequence of plan elements
	 * returned by the {@link Plan#getPlanElements()} method of a plan. Note
	 * that the plan will be modified only if the returned list is the internal
	 * reference!
	 * <p></p>
	 * Note that this methods returns a unique solution because it expects the activity object references as arguments, which are unique.
	 *
	 * @param plan the plan to modify
	 * @param origin the activity to use as origin. It must be a member of the list of plan elements.
	 * @param trip the trip to insert
	 * @param destination the destination activity. It must be a member of the list.
	 * @return the ""old trip"": the sequence of plan elements originally existing between the origin and the destination
	 */","('insertTrip', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,  Inserts a trip between two activities in the sequence of plan elements  returned by the {@link Plan#getPlanElements()} method of a plan.,29.0,"['A trip between two activities is included in the sequence of plan elements.', 'A trip between two activities is included in the sequence of plan elements returned by the @link Plan#getPlanElements method of a plan.', 'A trip between two activities is included in the sequence of plan elements returned by the @link Plan#getPlanElements() method of a plan.']"
242,cdk,org/openscience/cdk/Polymer.java,/base/data/src/main/java/org/openscience/cdk/Polymer.java,removeMonomer,129-141,"/**
     * Removes a particular monomer, specified by its name.
     *
     * @param name The name of the monomer to remove
     */
public void removeMonomer(String name){
    if (monomers.containsKey(name)) {
        Monomer monomer = (Monomer) monomers.get(name);
        this.remove(monomer);
        monomers.remove(name);
    }
}","public void removeMonomer(String name){
    if (monomers.containsKey(name)) {
        Monomer monomer = (Monomer) monomers.get(name);
        this.remove(monomer);
        monomers.remove(name);
    }
}","/**
     * Removes a particular monomer, specified by its name.
     *
     * @param name The name of the monomer to remove
     */","('removeMonomer', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",47.0,"  Removes a particular monomer, specified by its name.",10.0,"['A particular monomer is removed.', 'Removes a particular class of molecule.', 'Removes a particular type of molecule.']"
243,dcache,org/dcache/util/AtomicCounter.java,/modules/common/src/main/java/org/dcache/util/AtomicCounter.java,awaitChangeUntil,45-76,"/**
     * Waits for the counter to change to a value different from
     * <code>value</code>.
     * <p>
     * The method returns when one of the following happens:
     * <p>
     * * The current counter value is different from the
     * <code>value</code> argument; or
     * <p>
     * * Some other thread invokes the <code>increment</code> method for this AtomicCounter; or
     * <p>
     * * Some other thread interrupts the current thread; or
     * <p>
     * * The specified deadline elapses; or
     * <p>
     * * A ""spurious wakeup"" occurs.
     *
     * @param value    the value to wait for the counter to change away from
     * @param deadline the absolute time to wait until
     * @return true if the counter has a different value than {@code value}upon return
     * @throw InterruptedException if the current thread is interrupted
     */
public boolean awaitChangeUntil(int value, Date deadline) throws InterruptedException{
    _lock.lock();
    try {
        inLock();
        return _counter != value || _updated.awaitUntil(deadline);
    } finally {
        _lock.unlock();
    }
}","public boolean awaitChangeUntil(int value, Date deadline) throws InterruptedException{
    _lock.lock();
    try {
        inLock();
        return _counter != value || _updated.awaitUntil(deadline);
    } finally {
        _lock.unlock();
    }
}","/**
     * Waits for the counter to change to a value different from
     * <code>value</code>.
     * <p>
     * The method returns when one of the following happens:
     * <p>
     * * The current counter value is different from the
     * <code>value</code> argument; or
     * <p>
     * * Some other thread invokes the <code>increment</code> method for this AtomicCounter; or
     * <p>
     * * Some other thread interrupts the current thread; or
     * <p>
     * * The specified deadline elapses; or
     * <p>
     * * A ""spurious wakeup"" occurs.
     *
     * @param value    the value to wait for the counter to change away from
     * @param deadline the absolute time to wait until
     * @return true if the counter has a different value than {@code value}upon return
     * @throw InterruptedException if the current thread is interrupted
     */","('awaitChangeUntil', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,  Waits for the counter to change to a value different from  <code>value</code>.,19.0,"['Waits for the counter to change to a different value.', 'Waits for the counter to change to a new value.', 'Waits for the counter to change to something else.']"
244,dcache,org/dcache/resilience/data/FileOperationMap.java,/modules/dcache-resilience/src/main/java/org/dcache/resilience/data/FileOperationMap.java,scan,874-884,"/**
     * <p>""File operation sweep:"" the main queue update sequence (run by the consumer).</p>
     */
public void scan(){
    long start = System.currentTimeMillis();
    terminalOperationProcessor.processTerminated();
    waitingOperationProcessor.processWaiting();
    long end = System.currentTimeMillis();
    counters.recordFileOpSweep(end, end - start);
}","public void scan(){
    long start = System.currentTimeMillis();
    terminalOperationProcessor.processTerminated();
    waitingOperationProcessor.processWaiting();
    long end = System.currentTimeMillis();
    counters.recordFileOpSweep(end, end - start);
}","/**
     * <p>""File operation sweep:"" the main queue update sequence (run by the consumer).</p>
     */","('scan', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,"  <p>""File operation sweep:"" the main queue update sequence (run by the consumer).",21.0,"['The main queue update sequence is run by the consumer.', 'The main queue update sequence runs by the consumer.', 'The main queue update sequence is run by consumers.']"
245,weblogic-kubernetes-operator,oracle/kubernetes/weblogic/domain/model/MonitoringExporterConfiguration.java,/operator/src/main/java/oracle/kubernetes/weblogic/domain/model/MonitoringExporterConfiguration.java,matchesYaml,58-67,"/**
   * Returns true if the specified YAML string matches this configuration, ignoring unknown fields
   * and field ordering. Note that ordering of elements in arrays is considered significant for this comparison.
   * @param yaml a monitoring exporter configuration to compare to this object.
   */
public boolean matchesYaml(String yaml){
    final String thisJson = toJson();
    final String otherJson = createFromYaml(yaml).toJson();
    return JsonParser.parseString(thisJson).equals(JsonParser.parseString(otherJson));
}","public boolean matchesYaml(String yaml){
    final String thisJson = toJson();
    final String otherJson = createFromYaml(yaml).toJson();
    return JsonParser.parseString(thisJson).equals(JsonParser.parseString(otherJson));
}","/**
   * Returns true if the specified YAML string matches this configuration, ignoring unknown fields
   * and field ordering. Note that ordering of elements in arrays is considered significant for this comparison.
   * @param yaml a monitoring exporter configuration to compare to this object.
   */","('matchesYaml', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,"  Returns true if the specified YAML string matches this configuration, ignoring unknown fields  and field ordering.",18.0,"['If the specified YAML string matches the configuration, returns true.', 'If the specified YAML string matches this configuration, returns true.', 'If the specified YAML string matches this configuration, it will be true.']"
246,weblogic-kubernetes-operator,oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,containsCluster,335-351,"/**
   * Whether the WebLogic domain contains a cluster with the given cluster name.
   *
   * @param clusterName cluster name to be checked
   * @return True if the WebLogic domain contains a cluster with the given cluster name
   */
public synchronized boolean containsCluster(String clusterName){
    if (clusterName != null) {
        for (WlsClusterConfig clusterConfig : configuredClusters) {
            if (clusterConfig.getClusterName().equals(clusterName)) {
                return true;
            }
        }
    }
    return false;
}","public synchronized boolean containsCluster(String clusterName){
    if (clusterName != null) {
        for (WlsClusterConfig clusterConfig : configuredClusters) {
            if (clusterConfig.getClusterName().equals(clusterName)) {
                return true;
            }
        }
    }
    return false;
}","/**
   * Whether the WebLogic domain contains a cluster with the given cluster name.
   *
   * @param clusterName cluster name to be checked
   * @return True if the WebLogic domain contains a cluster with the given cluster name
   */","('containsCluster', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,  Whether the WebLogic domain contains a cluster with the given cluster name.,13.0,"['Whether the WebLogic domain has a cluster with a given name.', 'Whether the WebLogic domain has a cluster with a name.', 'Whether the WebLogic domain contains a cluster.']"
247,jeromq,org/zeromq/timer/ZTicket.java,/src/main/java/org/zeromq/timer/ZTicket.java,timeout,160-173,"/**
     * Returns the time in millisecond until the next ticket.
     * @return the time in millisecond until the next ticket.
     */
public long timeout(){
    if (tickets.isEmpty()) {
        return -1;
    }
    sortIfNeeded();
    Ticket first = tickets.get(0);
    return first.start - now() + first.delay;
}","public long timeout(){
    if (tickets.isEmpty()) {
        return -1;
    }
    sortIfNeeded();
    Ticket first = tickets.get(0);
    return first.start - now() + first.delay;
}","/**
     * Returns the time in millisecond until the next ticket.
     * @return the time in millisecond until the next ticket.
     */","('timeout', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,  Returns the time in millisecond until the next ticket.,10.0,"['The time is returned until the next ticket.', 'The time is returned in a second until the next ticket.', 'The time is returned in a second.']"
248,cdk,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,nAdjacentCentres,996-1007,"/**
     * Obtain the number of centres adjacent to the atom at the index, i.
     *
     * @param i atom index
     * @return number of adjacent centres
     */
private int nAdjacentCentres(int i){
    int n = 0;
    for (IAtom atom : tetrahedralElements[i].getLigands()) if (tetrahedralElements[atomToIndex.get(atom)] != null)
        n++;
    return n;
}","private int nAdjacentCentres(int i){
    int n = 0;
    for (IAtom atom : tetrahedralElements[i].getLigands()) if (tetrahedralElements[atomToIndex.get(atom)] != null)
        n++;
    return n;
}","/**
     * Obtain the number of centres adjacent to the atom at the index, i.
     *
     * @param i atom index
     * @return number of adjacent centres
     */","('nAdjacentCentres', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,"  Obtain the number of centres adjacent to the atom at the index, i.",15.0,"['The number of centres next to the atom is obtained at the index.', 'The number of centres next to the atom is obtained.', 'The number of centres next to the atom is known.']"
249,acs-aem-commons,com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,/bundle/src/main/java/com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,disableIndex,474-485,"/**
     * Disables an index, so it's no longer updated by Oak.
     *
     * @param oakIndex the index
     * @throws PersistenceException
     */
public void disableIndex(@Nonnull Resource oakIndex) throws PersistenceException{
    final ModifiableValueMap oakIndexProperties = oakIndex.adaptTo(ModifiableValueMap.class);
    oakIndexProperties.put(PN_TYPE, DISABLED);
    log.info(""Disabled index at {}"", oakIndex.getPath());
}","public void disableIndex(@Nonnull Resource oakIndex) throws PersistenceException{
    final ModifiableValueMap oakIndexProperties = oakIndex.adaptTo(ModifiableValueMap.class);
    oakIndexProperties.put(PN_TYPE, DISABLED);
    log.info(""Disabled index at {}"", oakIndex.getPath());
}","/**
     * Disables an index, so it's no longer updated by Oak.
     *
     * @param oakIndex the index
     * @throws PersistenceException
     */","('disableIndex', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,"  Disables an index, so it's no longer updated by Oak.",13.0,"[""Oak has disabled an index, so it's no longer updated."", ""Oak has disabled an index so it's no longer updated."", 'Oak no longer updates an index because it was disabled.']"
250,weblogic-kubernetes-operator,oracle/kubernetes/operator/helpers/ConfigMapSplitter.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/ConfigMapSplitter.java,addToSplitResult,74-87,"/**
   * Adds the specified data entry to one or more split results, recording its location if it is not wholly
   * in the first split result.
   * @param entry a data entry
   */
private void addToSplitResult(DataEntry entry){
    while (entry.getRemainingLength() > 0) {
        remainingRoom -= entry.addToMap(current, remainingRoom);
        if (remainingRoom == 0) {
            recordSplitResult();
            startSplitResult();
        }
    }
}","private void addToSplitResult(DataEntry entry){
    while (entry.getRemainingLength() > 0) {
        remainingRoom -= entry.addToMap(current, remainingRoom);
        if (remainingRoom == 0) {
            recordSplitResult();
            startSplitResult();
        }
    }
}","/**
   * Adds the specified data entry to one or more split results, recording its location if it is not wholly
   * in the first split result.
   * @param entry a data entry
   */","('addToSplitResult', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,"  Adds the specified data entry to one or more split results, recording its location if it is not wholly  in the first split result.",26.0,"[""If the data entry is not wholly in the first split result, it's added to one or more other results."", 'If the data entry is not wholly in the first split result, it is added to one or more of the other results.', ""If the data entry is not wholly in the first split result, it's added to one or more of the other results.""]"
251,weblogic-kubernetes-operator,oracle/kubernetes/operator/helpers/DomainPresenceInfo.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/DomainPresenceInfo.java,deleteServerServiceFromEvent,379-394,"/**
   * Given the service associated with a server service-deleted event, removes the service if it is
   * not older than the one recorded.
   *
   * @param serverName the name of the associated server
   * @param event the service associated with the event
   * @return true if the service was actually removed
   */
 boolean deleteServerServiceFromEvent(String serverName, V1Service event){
    if (serverName == null) {
        return false;
    }
    V1Service deletedService = getSko(serverName).getService().getAndAccumulate(event, this::getNewerCurrentOrNull);
    return deletedService != null;
}","boolean deleteServerServiceFromEvent(String serverName, V1Service event){
    if (serverName == null) {
        return false;
    }
    V1Service deletedService = getSko(serverName).getService().getAndAccumulate(event, this::getNewerCurrentOrNull);
    return deletedService != null;
}","/**
   * Given the service associated with a server service-deleted event, removes the service if it is
   * not older than the one recorded.
   *
   * @param serverName the name of the associated server
   * @param event the service associated with the event
   * @return true if the service was actually removed
   */","('deleteServerServiceFromEvent', {'INSTRUCTION': {'covered': 18, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,"  Given the service associated with a server service-deleted event, removes the service if it is  not older than the one recorded.",23.0,"['If the service is older than the one recorded, it is removed.', 'If the service is not older than the one recorded, it is removed.', ""If the service isn't older than the one recorded, it's removed.""]"
252,dcache,org/dcache/util/URIs.java,/modules/common/src/main/java/org/dcache/util/URIs.java,optionalPortWithDefault,56-64,"/**
     * Obtain an optional port number based on supplied URI.  Use the defined port number, if the
     * URI defines one; otherwise use the default port number for URI's schema, if one is known.
     * Otherwise return an empty Optional.
     */
public static Optional<Integer> optionalPortWithDefault(URI uri){
    int port = portWithDefault(uri, null, -1);
    return port > -1 ? Optional.of(port) : Optional.<Integer>empty();
}","public static Optional<Integer> optionalPortWithDefault(URI uri){
    int port = portWithDefault(uri, null, -1);
    return port > -1 ? Optional.of(port) : Optional.<Integer>empty();
}","/**
     * Obtain an optional port number based on supplied URI.  Use the defined port number, if the
     * URI defines one; otherwise use the default port number for URI's schema, if one is known.
     * Otherwise return an empty Optional.
     */","('optionalPortWithDefault', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",48.0,  Obtain an optional port number based on supplied URI.,10.0,"['You can get an optional port number.', 'The port number can be obtained based on the supplied URI.', 'You can get an optional port number based on the supplied URI.']"
253,cucumber-reporting,net/masterthought/cucumber/Trends.java,/src/main/java/net/masterthought/cucumber/Trends.java,fillMissingSteps,206-219,"/**
     * Since pending and undefined steps were added later
     * there is need to fill missing data for those statuses.
     */
private void fillMissingSteps(){
    passedFeatures = fillMissingArray(passedFeatures);
    passedScenarios = fillMissingArray(passedScenarios);
    passedSteps = fillMissingArray(passedSteps);
    skippedSteps = fillMissingArray(skippedSteps);
    pendingSteps = fillMissingArray(pendingSteps);
    undefinedSteps = fillMissingArray(undefinedSteps);
}","private void fillMissingSteps(){
    passedFeatures = fillMissingArray(passedFeatures);
    passedScenarios = fillMissingArray(passedScenarios);
    passedSteps = fillMissingArray(passedSteps);
    skippedSteps = fillMissingArray(skippedSteps);
    pendingSteps = fillMissingArray(pendingSteps);
    undefinedSteps = fillMissingArray(undefinedSteps);
}","/**
     * Since pending and undefined steps were added later
     * there is need to fill missing data for those statuses.
     */","('fillMissingSteps', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",49.0,  Since pending and undefined steps were added later  there is need to fill missing data for those statuses.,19.0,"['There is a need to fill in missing data for the statuses after pending and undefined steps were added.', 'There is a need to fill in missing data for the statuses that were added later.', 'There is a need to fill in missing data for the statuses after pending and undefined steps are added.']"
254,dataverse,edu/harvard/iq/dataverse/authorization/providers/oauth2/OAuth2LoginBackingBean.java,/src/main/java/edu/harvard/iq/dataverse/authorization/providers/oauth2/OAuth2LoginBackingBean.java,linkFor,72-82,"/**
     * Generate the OAuth2 Provider URL to be used in the login page link for the provider.
     * @param idpId Unique ID for the provider (used to lookup in authn service bean)
     * @param redirectPage page part of URL where we should be redirected after login (e.g. ""dataverse.xhtml"")
     * @return A generated link for the OAuth2 provider login
     */
public String linkFor(String idpId, String redirectPage){
    AbstractOAuth2AuthenticationProvider idp = authenticationSvc.getOAuth2Provider(idpId);
    String state = createState(idp, toOption(redirectPage));
    return idp.buildAuthzUrl(state, systemConfig.getOAuth2CallbackUrl());
}","public String linkFor(String idpId, String redirectPage){
    AbstractOAuth2AuthenticationProvider idp = authenticationSvc.getOAuth2Provider(idpId);
    String state = createState(idp, toOption(redirectPage));
    return idp.buildAuthzUrl(state, systemConfig.getOAuth2CallbackUrl());
}","/**
     * Generate the OAuth2 Provider URL to be used in the login page link for the provider.
     * @param idpId Unique ID for the provider (used to lookup in authn service bean)
     * @param redirectPage page part of URL where we should be redirected after login (e.g. ""dataverse.xhtml"")
     * @return A generated link for the OAuth2 provider login
     */","('linkFor', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",49.0,Generate the OAuth2 Provider URL to be used in the login page link for the provider.,17.0,"['The login page link for the provider will use the OAuth2 Provider URL.', 'The login page link for the provider will be used if the OAuth2 Provider URL is generated.', 'The login page link for the provider will be used if the OAuth2 Provider URL is Generated.']"
255,cdk,org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,allHeavyAtomsPlaced,604-617,"/**
     *  True is all the atoms in the given AtomContainer have been placed.
     *
     * @param  ac  The AtomContainer to be searched
     * @return     True is all the atoms in the given AtomContainer have been placed
     */
public boolean allHeavyAtomsPlaced(IAtomContainer ac){
    for (int i = 0; i < ac.getAtomCount(); i++) {
        if (isUnplacedHeavyAtom(ac.getAtom(i))) {
            return false;
        }
    }
    return true;
}","public boolean allHeavyAtomsPlaced(IAtomContainer ac){
    for (int i = 0; i < ac.getAtomCount(); i++) {
        if (isUnplacedHeavyAtom(ac.getAtom(i))) {
            return false;
        }
    }
    return true;
}","/**
     *  True is all the atoms in the given AtomContainer have been placed.
     *
     * @param  ac  The AtomContainer to be searched
     * @return     True is all the atoms in the given AtomContainer have been placed
     */","('allHeavyAtomsPlaced', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",49.0,  True is all the atoms in the given AtomContainer have been placed.,13.0,"['All the atoms have been placed in the given container.', 'The atoms in the container have been placed.', 'All the atoms have been placed in the container.']"
256,cdk,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,containsElement,190-204,"/**
     * True, if the MolecularFormula contains the given element as IIsotope object.
     *
     * @param  formula   IMolecularFormula molecularFormula
     * @param  element   The element this MolecularFormula is searched for
     * @return           True, if the MolecularFormula contains the given element object
     */
public static boolean containsElement(IMolecularFormula formula, IElement element){
    for (IIsotope isotope : formula.isotopes()) {
        if (element.getSymbol().equals(isotope.getSymbol()))
            return true;
    }
    return false;
}","public static boolean containsElement(IMolecularFormula formula, IElement element){
    for (IIsotope isotope : formula.isotopes()) {
        if (element.getSymbol().equals(isotope.getSymbol()))
            return true;
    }
    return false;
}","/**
     * True, if the MolecularFormula contains the given element as IIsotope object.
     *
     * @param  formula   IMolecularFormula molecularFormula
     * @param  element   The element this MolecularFormula is searched for
     * @return           True, if the MolecularFormula contains the given element object
     */","('containsElement', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",49.0,"  True, if the MolecularFormula contains the given element as IIsotope object.",13.0,"[""If the element is an IIsotope object, it's true."", 'The given element is an IIsotope object.', 'If the element is an IIsotope object, it is true.']"
257,cdk,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,buildRGraph,437-455,"/**
     * Builds the CDKRGraph ( resolution graph ), from two atomContainer
     * (description of the two molecules to compare)
     * This is the interface point between the CDK model and
     * the generic MCSS algorithm based on the RGRaph.
     *
     * @param  sourceGraph  Description of the first molecule
     * @param  targetGraph  Description of the second molecule
     * @param shouldMatchBonds
     * @return     the rGraph
     * @throws CDKException
     */
public static CDKRGraph buildRGraph(IAtomContainer sourceGraph, IAtomContainer targetGraph, boolean shouldMatchBonds) throws CDKException{
    CDKRGraph rGraph = new CDKRGraph();
    nodeConstructor(rGraph, sourceGraph, targetGraph, shouldMatchBonds);
    arcConstructor(rGraph, sourceGraph, targetGraph);
    return rGraph;
}","public static CDKRGraph buildRGraph(IAtomContainer sourceGraph, IAtomContainer targetGraph, boolean shouldMatchBonds) throws CDKException{
    CDKRGraph rGraph = new CDKRGraph();
    nodeConstructor(rGraph, sourceGraph, targetGraph, shouldMatchBonds);
    arcConstructor(rGraph, sourceGraph, targetGraph);
    return rGraph;
}","/**
     * Builds the CDKRGraph ( resolution graph ), from two atomContainer
     * (description of the two molecules to compare)
     * This is the interface point between the CDK model and
     * the generic MCSS algorithm based on the RGRaph.
     *
     * @param  sourceGraph  Description of the first molecule
     * @param  targetGraph  Description of the second molecule
     * @param shouldMatchBonds
     * @return     the rGraph
     * @throws CDKException
     */","('buildRGraph', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",49.0,"  Builds the CDKRGraph ( resolution graph ), from two atomContainer  (description of the two molecules to compare)  This is the interface point between the CDK model and  the generic MCSS algorithm based on the RGRaph.",39.0,"['The interface point between the CDK model and the generic MCSS algorithm is built from two atomContainers.', 'The interface point between the CDK model and the generic MCSS algorithm is the resolution graph.', 'The interface point between the CDK model and the generic MCSS algorithm is built from two atomContainer.']"
258,shardingsphere-elasticjob,org/apache/shardingsphere/elasticjob/restful/wrapper/QueryParameterMap.java,/elasticjob-infra/elasticjob-restful/src/main/java/org/apache/shardingsphere/elasticjob/restful/wrapper/QueryParameterMap.java,toSingleValueMap,98-105,"/**
     * Convert to a single value map, abandon values except the first of each parameter.
     *
     * @return single value map
     */
public Map<String, String> toSingleValueMap(){
    return queryMap.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().get(0)));
}","public Map<String, String> toSingleValueMap(){
    return queryMap.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().get(0)));
}","/**
     * Convert to a single value map, abandon values except the first of each parameter.
     *
     * @return single value map
     */","('toSingleValueMap', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,"  Convert to a single value map, abandon values except the first of each parameter.",16.0,"['Abandon values except the first one, if you want to convert to a single value map.', 'Abandon values except the first one, if you want to convert to a single map.', 'Abandon values except the first one, if you want to convert a single value map.']"
259,glowstone,net/glowstone/util/Position.java,/src/main/java/net/glowstone/util/Position.java,hasMoved,76-86,"/**
     * Gets whether there has been a position change between the two Locations.
     *
     * @param first The initial location.
     * @param second The final location.
     * @return A boolean.
     */
public static boolean hasMoved(Location first, Location second){
    return first.getX() != second.getX() || first.getY() != second.getY() || first.getZ() != second.getZ();
}","public static boolean hasMoved(Location first, Location second){
    return first.getX() != second.getX() || first.getY() != second.getY() || first.getZ() != second.getZ();
}","/**
     * Gets whether there has been a position change between the two Locations.
     *
     * @param first The initial location.
     * @param second The final location.
     * @return A boolean.
     */","('hasMoved', {'INSTRUCTION': {'covered': 20, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,  Gets whether there has been a position change between the two Locations.,13.0,"['Is there a position change between the two locations?', 'Does that mean there has been a position change between the two locations?', 'Does that mean there has been a position change?']"
261,cdk,org/openscience/cdk/SingleElectron.java,/base/data/src/main/java/org/openscience/cdk/SingleElectron.java,clone,143-157,"/**
     * Clones this SingleElectron object, including a clone of the atom for which the
     * SingleElectron is defined.
     *
     * @return    The cloned object
     */
public Object clone() throws CloneNotSupportedException{
    SingleElectron clone = (SingleElectron) super.clone();
    if (atom != null) {
        clone.atom = (IAtom) ((IAtom) atom).clone();
    }
    return clone;
}","public Object clone() throws CloneNotSupportedException{
    SingleElectron clone = (SingleElectron) super.clone();
    if (atom != null) {
        clone.atom = (IAtom) ((IAtom) atom).clone();
    }
    return clone;
}","/**
     * Clones this SingleElectron object, including a clone of the atom for which the
     * SingleElectron is defined.
     *
     * @return    The cloned object
     */","('clone', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,"  Clones this SingleElectron object, including a clone of the atom for which the  SingleElectron is defined.",18.0,"['Clones this SingleElectron object, including a clone of the atom for which the SingleElectron is defined.', 'Clones the SingleElectron object and the atom for which it is defined.', 'Clones the SingleElectron object, including a clone of the atom for which it is defined.']"
262,liquibase,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,parseDefaultPropertyFileFromResource,782-797,"/**
     * Open a property file that is embedded as a Java resource and parse it.
     *
     * @param potentialPropertyFile location and file name of the property file
     * @throws IOException                 if the file cannot be opened
     * @throws CommandLineParsingException if an error occurs during parsing
     */
private void parseDefaultPropertyFileFromResource(File potentialPropertyFile) throws IOException, CommandLineParsingException{
    try (InputStream resourceAsStream = getClass().getClassLoader().getResourceAsStream(potentialPropertyFile.getAbsolutePath())) {
        if (resourceAsStream != null) {
            parsePropertiesFile(resourceAsStream);
        }
    }
}","private void parseDefaultPropertyFileFromResource(File potentialPropertyFile) throws IOException, CommandLineParsingException{
    try (InputStream resourceAsStream = getClass().getClassLoader().getResourceAsStream(potentialPropertyFile.getAbsolutePath())) {
        if (resourceAsStream != null) {
            parsePropertiesFile(resourceAsStream);
        }
    }
}","/**
     * Open a property file that is embedded as a Java resource and parse it.
     *
     * @param potentialPropertyFile location and file name of the property file
     * @throws IOException                 if the file cannot be opened
     * @throws CommandLineParsingException if an error occurs during parsing
     */","('parseDefaultPropertyFileFromResource', {'INSTRUCTION': {'covered': 10, 'missed': 3}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,  Open a property file that is embedded as a Java resource and parse it.,15.0,"['You can open a property file that is embedded in a Java resource.', 'You can open a property file that is embedded with a Java resource.', 'You can open a property file that is embedded as a Java resource.']"
263,weblogic-kubernetes-operator,oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,toTopology,434-445,"/**
   * Returns the topology equivalent of the domain configuration, as a map. It may be converted to
   * YAML or JSON via an object mapper.
   *
   * @return a map containing the topology
   */
public Map<String, Object> toTopology(){
    Map<String, Object> topology = new HashMap<>();
    topology.put(""domainValid"", ""true"");
    topology.put(""domain"", createDomainTopology());
    return topology;
}","public Map<String, Object> toTopology(){
    Map<String, Object> topology = new HashMap<>();
    topology.put(""domainValid"", ""true"");
    topology.put(""domain"", createDomainTopology());
    return topology;
}","/**
   * Returns the topology equivalent of the domain configuration, as a map. It may be converted to
   * YAML or JSON via an object mapper.
   *
   * @return a map containing the topology
   */","('toTopology', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,"  Returns the topology equivalent of the domain configuration, as a map.",13.0,"['The equivalent of the domain configuration is returned.', 'The equivalent of the domain configuration is returned as a map.', 'The map shows the equivalent of the domain configuration.']"
265,javaparser,com/github/javaparser/generator/core/utils/CodeUtils.java,/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/utils/CodeUtils.java,castValue,32-56,"/**
	 * Cast the value if the current type doesn't match the required type.
	 * <br>
	 * Given the following example:
	 * <code>
	 *     int withoutCast = 1;
	 *     double withCast = (double) 1;
	 * </code>
	 * The variable withoutCast doesn't need to be casted, since we have int as required type and int as value type.
	 * While in the variable withCast we have double as required type and int as value type.
	 *
	 * @param value           The value to be returned.
	 * @param requiredType    The expected type to be casted if needed.
	 * @param valueType       The type of the value to be returned.
	 *
	 * @return The value casted if needed.
	 */
public static String castValue(String value, Type requiredType, String valueType){
    String requiredTypeName = requiredType.asString();
    if (requiredTypeName.equals(valueType))
        return value;
    else
        return String.format(""(%s) %s"", requiredTypeName, value);
}","public static String castValue(String value, Type requiredType, String valueType){
    String requiredTypeName = requiredType.asString();
    if (requiredTypeName.equals(valueType))
        return value;
    else
        return String.format(""(%s) %s"", requiredTypeName, value);
}","/**
	 * Cast the value if the current type doesn't match the required type.
	 * <br>
	 * Given the following example:
	 * <code>
	 *     int withoutCast = 1;
	 *     double withCast = (double) 1;
	 * </code>
	 * The variable withoutCast doesn't need to be casted, since we have int as required type and int as value type.
	 * While in the variable withCast we have double as required type and int as value type.
	 *
	 * @param value           The value to be returned.
	 * @param requiredType    The expected type to be casted if needed.
	 * @param valueType       The type of the value to be returned.
	 *
	 * @return The value casted if needed.
	 */","('castValue', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",50.0,  Cast the value if the current type doesn't match the required type.,14.0,"[""If the current type doesn't match the required type, cast the value."", 'If the current type does not match the required type, cast the value.', ""If the current type doesn't match the required one, cast the value.""]"
266,egeria,org/odpi/openmetadata/accessservices/assetcatalog/server/spring/AssetCatalogEntityResource.java,/open-metadata-implementation/access-services/asset-catalog/asset-catalog-spring/src/main/java/org/odpi/openmetadata/accessservices/assetcatalog/server/spring/AssetCatalogEntityResource.java,searchByType,176-191,"/**
     * Return a list of assets matching the search criteria without the full context
     *
     * @param serverName       unique identifier for requested server.
     * @param userId           the unique identifier for the user
     * @param searchCriteria   a string expression of the characteristics of the required assets
     * @param searchParameters constrains to make the assets's search results more precise
     * @return list of properties used to narrow the search
     */
public AssetListResponse searchByType(@PathVariable(""serverName"") String serverName, @PathVariable(""userId"") String userId, @RequestParam(""searchCriteria"") @NotBlank String searchCriteria, @RequestBody SearchParameters searchParameters){
    return assetService.searchByType(serverName, userId, searchCriteria, searchParameters);
}","public AssetListResponse searchByType(@PathVariable(""serverName"") String serverName, @PathVariable(""userId"") String userId, @RequestParam(""searchCriteria"") @NotBlank String searchCriteria, @RequestBody SearchParameters searchParameters){
    return assetService.searchByType(serverName, userId, searchCriteria, searchParameters);
}","/**
     * Return a list of assets matching the search criteria without the full context
     *
     * @param serverName       unique identifier for requested server.
     * @param userId           the unique identifier for the user
     * @param searchCriteria   a string expression of the characteristics of the required assets
     * @param searchParameters constrains to make the assets's search results more precise
     * @return list of properties used to narrow the search
     */","('searchByType', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,  Return a list of assets matching the search criteria without the full context   @param serverName unique identifier for requested server.,22.0,"['Return a list of assets matching the search criteria without the full context.', 'A list of assets matching the search criteria can be returned.', 'A list of assets matching the search criteria can be returned without the full context.']"
267,logstash-logback-encoder,net/logstash/logback/pattern/AbstractJsonPatternParser.java,/src/main/java/net/logstash/logback/pattern/AbstractJsonPatternParser.java,buildLayout,212-227,"/**
     * Initialize a PatternLayout with the supplied format and throw an {@link IllegalArgumentException}
     * if the format is invalid.
     * 
     * @param format the pattern layout format
     * @return a configured and started {@link PatternLayoutAdapter} instance around the supplied format
     * @throws IllegalArgumentException if the supplied format is not a valid PatternLayout
     */
protected PatternLayoutAdapter<Event> buildLayout(String format){
    PatternLayoutAdapter<Event> adapter = new PatternLayoutAdapter<>(createLayout());
    adapter.setPattern(format);
    adapter.setContext(context);
    adapter.start();
    return adapter;
}","protected PatternLayoutAdapter<Event> buildLayout(String format){
    PatternLayoutAdapter<Event> adapter = new PatternLayoutAdapter<>(createLayout());
    adapter.setPattern(format);
    adapter.setContext(context);
    adapter.start();
    return adapter;
}","/**
     * Initialize a PatternLayout with the supplied format and throw an {@link IllegalArgumentException}
     * if the format is invalid.
     * 
     * @param format the pattern layout format
     * @return a configured and started {@link PatternLayoutAdapter} instance around the supplied format
     * @throws IllegalArgumentException if the supplied format is not a valid PatternLayout
     */","('buildLayout', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,  Initialize a PatternLayout with the supplied format and throw an {@link IllegalArgumentException}  if the format is invalid.,21.0,"['If the format is invalid, throw an @link IllegalArgumentException if the pattern is created.', 'If the format is invalid, throw a @link IllegalArgumentException if the pattern is created.', 'If the format is invalid, throw an @link IllegalArgumentException if the pattern is created with it.']"
268,liquibase,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,printHelp,1143-1155,"/**
     * If any errors have been found, print the list of errors first, then print the command line help text.
     *
     * @param errorMessages List of error messages
     * @param stream        the output stream to write the text to
     */
protected void printHelp(List<String> errorMessages, PrintStream stream){
    stream.println(coreBundle.getString(""errors""));
    for (String message : errorMessages) {
        stream.println(""  "" + message);
    }
    stream.println();
}","protected void printHelp(List<String> errorMessages, PrintStream stream){
    stream.println(coreBundle.getString(""errors""));
    for (String message : errorMessages) {
        stream.println(""  "" + message);
    }
    stream.println();
}","/**
     * If any errors have been found, print the list of errors first, then print the command line help text.
     *
     * @param errorMessages List of error messages
     * @param stream        the output stream to write the text to
     */","('printHelp', {'INSTRUCTION': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,"  If any errors have been found, print the list of errors first, then print the command line help text.",22.0,"['Print the list of errors first, then the command line help text.', 'Print the list of errors first, then the command line help text if there are any errors.', 'Print the list of errors first, then the command line help text if there are any.']"
269,acs-aem-commons,com/adobe/acs/commons/httpcache/config/impl/HttpCacheConfigImpl.java,/bundle/src/main/java/com/adobe/acs/commons/httpcache/config/impl/HttpCacheConfigImpl.java,matches,385-401,"/**
     * Matching the given data with the set of compiled patterns.
     *
     * @param patterns
     * @param data
     * @return
     */
private boolean matches(List<Pattern> patterns, String data){
    for (Pattern pattern : patterns) {
        final Matcher matcher = pattern.matcher(data);
        if (matcher.matches()) {
            return true;
        }
    }
    return false;
}","private boolean matches(List<Pattern> patterns, String data){
    for (Pattern pattern : patterns) {
        final Matcher matcher = pattern.matcher(data);
        if (matcher.matches()) {
            return true;
        }
    }
    return false;
}","/**
     * Matching the given data with the set of compiled patterns.
     *
     * @param patterns
     * @param data
     * @return
     */","('matches', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,  Matching the given data with the set of compiled patterns.,11.0,"['Matching the data with the compiled patterns.', 'Matching the data with the patterns.', 'Matching the data with the compiled patterns']"
270,cdk,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,readUInt,1671-1685,"/**
     * Read an unsigned int value from the given index with the expected number
     * of digits.
     *
     * @param line   input line
     * @param index  start index
     * @param digits number of digits (max)
     * @return an unsigned int
     */
private static int readUInt(final String line, int index, int digits){
    int result = 0;
    while (digits-- > 0) result = (result * 10) + toInt(line.charAt(index++));
    return result;
}","private static int readUInt(final String line, int index, int digits){
    int result = 0;
    while (digits-- > 0) result = (result * 10) + toInt(line.charAt(index++));
    return result;
}","/**
     * Read an unsigned int value from the given index with the expected number
     * of digits.
     *
     * @param line   input line
     * @param index  start index
     * @param digits number of digits (max)
     * @return an unsigned int
     */","('readUInt', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,  Read an unsigned int value from the given index with the expected number  of digits.,16.0,"['The expected number of digits is what the unsigned int value is for.', 'The expected number of digits is what the unsigned int value from the given index should tell you.', 'The expected number of digits is what the unsigned int value from the index is supposed to tell you.']"
271,cdk,org/openscience/cdk/isomorphism/CompatibilityMatrix.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/CompatibilityMatrix.java,markRow,102-111,"/**
     * Mark all values in row i allowing it to be reset later.
     *
     * @param i       row index
     * @param marking the marking to store (should be negative)
     */
 void markRow(int i, int marking){
    for (int j = (i * mCols), end = j + mCols; j < end; j++) if (data[j] > 0)
        data[j] = marking;
}","void markRow(int i, int marking){
    for (int j = (i * mCols), end = j + mCols; j < end; j++) if (data[j] > 0)
        data[j] = marking;
}","/**
     * Mark all values in row i allowing it to be reset later.
     *
     * @param i       row index
     * @param marking the marking to store (should be negative)
     */","('markRow', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,  Mark all values in row i allowing it to be reset later.,13.0,"['I allow the values in row to be reset later.', 'I allow the values to be reset later.', 'I allow the values to be reset later on.']"
272,metrics,io/dropwizard/metrics5/ScheduledReporter.java,/metrics-core/src/main/java/io/dropwizard/metrics5/ScheduledReporter.java,report,248-259,"/**
     * Report the current values of all metrics in the registry.
     */
public void report(){
    synchronized (this) {
        report(registry.getGauges(filter), registry.getCounters(filter), registry.getHistograms(filter), registry.getMeters(filter), registry.getTimers(filter));
    }
}","public void report(){
    synchronized (this) {
        report(registry.getGauges(filter), registry.getCounters(filter), registry.getHistograms(filter), registry.getMeters(filter), registry.getTimers(filter));
    }
}","/**
     * Report the current values of all metrics in the registry.
     */","('report', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",51.0,  Report the current values of all metrics in the registry.,11.0,"['The current values of all metrics should be reported.', 'The current values of all the metrics should be reported.', 'The current values of all metrics are reported.']"
273,cdk,org/openscience/cdk/isomorphism/Ullmann.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/Ullmann.java,findSubstructure,122-133,"/**
     * Create a pattern which can be used to find molecules which contain the
     * {@code query} structure.
     *
     * @param query the substructure to find
     * @return a pattern for finding the {@code query}
     */
public static Pattern findSubstructure(IAtomContainer query){
    boolean isQuery = query instanceof IQueryAtomContainer;
    return new Ullmann(query, isQuery ? AtomMatcher.forQuery() : AtomMatcher.forElement(), isQuery ? BondMatcher.forQuery() : BondMatcher.forOrder());
}","public static Pattern findSubstructure(IAtomContainer query){
    boolean isQuery = query instanceof IQueryAtomContainer;
    return new Ullmann(query, isQuery ? AtomMatcher.forQuery() : AtomMatcher.forElement(), isQuery ? BondMatcher.forQuery() : BondMatcher.forOrder());
}","/**
     * Create a pattern which can be used to find molecules which contain the
     * {@code query} structure.
     *
     * @param query the substructure to find
     * @return a pattern for finding the {@code query}
     */","('findSubstructure', {'INSTRUCTION': {'covered': 14, 'missed': 4}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",52.0,  Create a pattern which can be used to find molecules which contain the  {@code query} structure.,20.0,"['The @code query structure can be found by creating a pattern.', 'The @code query structure can be found in a pattern.', 'The @code query structure can be found in a pattern created.']"
274,acs-aem-commons,com/adobe/acs/commons/mcp/form/FieldComponent.java,/bundle/src/main/java/com/adobe/acs/commons/mcp/form/FieldComponent.java,buildComponentResource,144-158,"/**
     * If your component needs child nodes then override this method, call the
     * superclass implementation, and then use addChildren to add additional
     * nodes to it.
     *
     * @return
     */
public Resource buildComponentResource(){
    purgeEmptyMetadata();
    AbstractResourceImpl res = new AbstractResourceImpl(path, resourceType, resourceSuperType, componentMetadata);
    if (sling != null) {
        res.setResourceResolver(sling.getRequest().getResourceResolver());
    }
    return res;
}","public Resource buildComponentResource(){
    purgeEmptyMetadata();
    AbstractResourceImpl res = new AbstractResourceImpl(path, resourceType, resourceSuperType, componentMetadata);
    if (sling != null) {
        res.setResourceResolver(sling.getRequest().getResourceResolver());
    }
    return res;
}","/**
     * If your component needs child nodes then override this method, call the
     * superclass implementation, and then use addChildren to add additional
     * nodes to it.
     *
     * @return
     */","('buildComponentResource', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",52.0,"  If your component needs child nodes then override this method, call the  superclass implementation, and then use addChildren to add additional  nodes to it.",27.0,"['If your component needs more than one child, you can use add Children to add additional children to it.', 'If your component needs more than one child, then you can use add Children to add additional children to it.', 'If your component needs more than one child, you can use add Children to add additional children.']"
275,matsim-libs,org/matsim/contrib/freight/utils/FreightUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/utils/FreightUtils.java,copyShipments,250-262,"/**
	 * Copy all shipments from the existing carrier to the new carrier with
	 * shipments.
	 *
	 * @param carrierWS the ""new"" carrier with Shipments
	 * @param carrier   the already existing carrier
	 */
private static void copyShipments(Carrier carrierWS, Carrier carrier){
    for (CarrierShipment carrierShipment : carrier.getShipments().values()) {
        log.debug(""Copy CarrierShipment: "" + carrierShipment.toString());
        CarrierUtils.addShipment(carrierWS, carrierShipment);
    }
}","private static void copyShipments(Carrier carrierWS, Carrier carrier){
    for (CarrierShipment carrierShipment : carrier.getShipments().values()) {
        log.debug(""Copy CarrierShipment: "" + carrierShipment.toString());
        CarrierUtils.addShipment(carrierWS, carrierShipment);
    }
}","/**
	 * Copy all shipments from the existing carrier to the new carrier with
	 * shipments.
	 *
	 * @param carrierWS the ""new"" carrier with Shipments
	 * @param carrier   the already existing carrier
	 */","('copyShipments', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",52.0,  Copy all shipments from the existing carrier to the new carrier with  shipments.,14.0,"['All shipments from the old carrier to the new carrier should be copied.', 'All shipments from the old carrier to the new one should be copied.', 'All shipments from the old carrier to the new carrier should be duplicated.']"
276,glowstone,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,isList,842-855,"/**
     * Test whether the subtag with the given key is of {@link List} type.
     *
     * @param key the key to look up
     * @param type the {@link TagType} of the list's elements
     * @return true if the subtag exists and is a {@link List}; false otherwise
     */
public boolean isList(@NonNls String key, TagType type){
    if (!is(key, ListTag.class)) {
        return false;
    }
    ListTag tag = getTag(key, ListTag.class);
    return tag.getChildType() == type;
}","public boolean isList(@NonNls String key, TagType type){
    if (!is(key, ListTag.class)) {
        return false;
    }
    ListTag tag = getTag(key, ListTag.class);
    return tag.getChildType() == type;
}","/**
     * Test whether the subtag with the given key is of {@link List} type.
     *
     * @param key the key to look up
     * @param type the {@link TagType} of the list's elements
     * @return true if the subtag exists and is a {@link List}; false otherwise
     */","('isList', {'INSTRUCTION': {'covered': 20, 'missed': 1}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",52.0,  Test whether the subtag with the given key is of {@link List} type.,17.0,"['If the subtag is of @link List type, test it.', 'If the subtag is of @link List type, you must test it.', 'If the subtag is of @link List type, you should test it.']"
277,seata,io/seata/tm/api/GlobalTransactionContext.java,/tm/src/main/java/io/seata/tm/api/GlobalTransactionContext.java,reload,67-81,"/**
     * Reload GlobalTransaction instance according to the given XID
     *
     * @param xid the xid
     * @return reloaded transaction instance.
     * @throws TransactionException the transaction exception
     */
public static GlobalTransaction reload(String xid) throws TransactionException{
    return new DefaultGlobalTransaction(xid, GlobalStatus.UnKnown, GlobalTransactionRole.Launcher) {

        @Override
        public void begin(int timeout, String name) throws TransactionException {
            throw new IllegalStateException(""Never BEGIN on a RELOADED GlobalTransaction. "");
        }
    };
}","public static GlobalTransaction reload(String xid) throws TransactionException{
    return new DefaultGlobalTransaction(xid, GlobalStatus.UnKnown, GlobalTransactionRole.Launcher) {

        @Override
        public void begin(int timeout, String name) throws TransactionException {
            throw new IllegalStateException(""Never BEGIN on a RELOADED GlobalTransaction. "");
        }
    };
}","/**
     * Reload GlobalTransaction instance according to the given XID
     *
     * @param xid the xid
     * @return reloaded transaction instance.
     * @throws TransactionException the transaction exception
     */","('reload', {'INSTRUCTION': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",52.0,  Reload GlobalTransaction instance according to the given XID   @param xid the xid  @return reloaded transaction instance.,19.0,"['The GlobalTransaction instance can be reloaded according to the given XID.', 'Return reloaded transaction instance according to the given XID.', 'The transaction instance can be reloaded according to the given XID.']"
278,dcache,org/dcache/services/info/base/StatePath.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StatePath.java,childPath,377-392,"/**
     * Build a new StatePath that points to the same location from the immediate child's
     * point-of-view.  For example, if the current path is characterised as <tt>aa.bb.cc</tt>, then
     * the returned StatePath is characterised by <tt>bb.cc</tt>.
     * <p>
     * If the path has no children of children, null is returned.
     *
     * @return the path for the child element, or null if there is no child.
     */
public StatePath childPath(){
    if (_elements == null || _elements.size() <= 1) {
        return null;
    }
    return new StatePath(_elements.subList(1, _elements.size()), _elements.size() - 1);
}","public StatePath childPath(){
    if (_elements == null || _elements.size() <= 1) {
        return null;
    }
    return new StatePath(_elements.subList(1, _elements.size()), _elements.size() - 1);
}","/**
     * Build a new StatePath that points to the same location from the immediate child's
     * point-of-view.  For example, if the current path is characterised as <tt>aa.bb.cc</tt>, then
     * the returned StatePath is characterised by <tt>bb.cc</tt>.
     * <p>
     * If the path has no children of children, null is returned.
     *
     * @return the path for the child element, or null if there is no child.
     */","('childPath', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",52.0,  Build a new StatePath that points to the same location from the immediate child's  point-of-view.,17.0,"[""A new StatePath should point to the same location from the child's point-of-view."", ""A new StatePath should point to the same location as the child's point-of-view."", ""A new StatePath should point to the same location from the child's point of view.""]"
279,tablesaw,tech/tablesaw/analytic/AnalyticQueryEngine.java,/core/src/main/java/tech/tablesaw/analytic/AnalyticQueryEngine.java,validateColumn,114-126,"/**
   * Checks to make sure the given aggregate function is compatible with the type of the source
   * column.
   */
private void validateColumn(FunctionMetaData function, Column<?> sourceColumn){
    if (!function.isCompatibleColumn(sourceColumn.type())) {
        throw new IllegalArgumentException(""Function: "" + function.functionName() + "" Is not compatible with column type: "" + sourceColumn.type());
    }
}","private void validateColumn(FunctionMetaData function, Column<?> sourceColumn){
    if (!function.isCompatibleColumn(sourceColumn.type())) {
        throw new IllegalArgumentException(""Function: "" + function.functionName() + "" Is not compatible with column type: "" + sourceColumn.type());
    }
}","/**
   * Checks to make sure the given aggregate function is compatible with the type of the source
   * column.
   */","('validateColumn', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",52.0,  Checks to make sure the given aggregate function is compatible with the type of the source  column.,18.0,"['Check to make sure the aggregate function is compatible with the source column.', 'Checks to make sure the aggregate function is compatible with the source column.', 'Checks to make sure the aggregate function is compatible with the source column']"
280,cdk,org/openscience/cdk/group/Permutation.java,/tool/group/src/main/java/org/openscience/cdk/group/Permutation.java,invert,212-223,"/**
     * Invert the permutation, so that for all i : inv[p[i]] = i.
     *
     * @return the inverse of this permutation
     */
public Permutation invert(){
    Permutation inversion = new Permutation(values.length);
    for (int i = 0; i < values.length; i++) {
        inversion.values[this.values[i]] = i;
    }
    return inversion;
}","public Permutation invert(){
    Permutation inversion = new Permutation(values.length);
    for (int i = 0; i < values.length; i++) {
        inversion.values[this.values[i]] = i;
    }
    return inversion;
}","/**
     * Invert the permutation, so that for all i : inv[p[i]] = i.
     *
     * @return the inverse of this permutation
     */","('invert', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,"  Invert the permutation, so that for all i : inv[p[i]] = i.",20.0,"['For all, Invert the permutation.', 'Invert the permutation so that it is for all of us.', 'Invert the permutation so that it is for all.']"
281,jackson-databind,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,backticked,793-803,"/**
     * Returns either {@code `text`} (backtick-quoted) or {@code [null]}.
     *
     * @since 2.9
     */
public static String backticked(String text){
    if (text == null) {
        return ""[null]"";
    }
    return new StringBuilder(text.length() + 2).append('`').append(text).append('`').toString();
}","public static String backticked(String text){
    if (text == null) {
        return ""[null]"";
    }
    return new StringBuilder(text.length() + 2).append('`').append(text).append('`').toString();
}","/**
     * Returns either {@code `text`} (backtick-quoted) or {@code [null]}.
     *
     * @since 2.9
     */","('backticked', {'INSTRUCTION': {'covered': 17, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,  Returns either {@code `text`} (backtick-quoted) or {@code [null]}.,21.0,"['Either @code text or @code [null] returns.', 'Either @code text or @code [null] is returned.', 'Either @code text or @code [null] will be returned.']"
282,jackson-databind,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,apostrophed,805-815,"/**
     * Returns either {@code 'text'} (single-quoted) or {@code [null]}.
     *
     * @since 2.9
     */
public static String apostrophed(String text){
    if (text == null) {
        return ""[null]"";
    }
    return new StringBuilder(text.length() + 2).append('\'').append(text).append('\'').toString();
}","public static String apostrophed(String text){
    if (text == null) {
        return ""[null]"";
    }
    return new StringBuilder(text.length() + 2).append('\'').append(text).append('\'').toString();
}","/**
     * Returns either {@code 'text'} (single-quoted) or {@code [null]}.
     *
     * @since 2.9
     */","('apostrophed', {'INSTRUCTION': {'covered': 17, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,  Returns either {@code 'text'} (single-quoted) or {@code [null]}.,20.0,"[""Either @code 'text' or @code 'null' returns."", ""Either @code 'text' or @code [null] returns."", ""Either @code 'text' or @code [null] will be returned.""]"
283,matsim-libs,org/matsim/contrib/sumo/SumoNetworkHandler.java,/contribs/sumo/src/main/java/org/matsim/contrib/sumo/SumoNetworkHandler.java,read,78-87,"/**
     * Creates a new sumo handler by reading data from xml file.
     */
 static SumoNetworkHandler read(File file) throws ParserConfigurationException, SAXException, IOException{
    SAXParserFactory factory = SAXParserFactory.newInstance();
    SAXParser saxParser = factory.newSAXParser();
    SumoNetworkHandler sumoHandler = new SumoNetworkHandler();
    saxParser.parse(file, sumoHandler);
    return sumoHandler;
}"," static SumoNetworkHandler read(File file) throws ParserConfigurationException, SAXException, IOException{
    SAXParserFactory factory = SAXParserFactory.newInstance();
    SAXParser saxParser = factory.newSAXParser();
    SumoNetworkHandler sumoHandler = new SumoNetworkHandler();
    saxParser.parse(file, sumoHandler);
    return sumoHandler;
}","/**
     * Creates a new sumo handler by reading data from xml file.
     */","('read', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,  Creates a new sumo handler by reading data from xml file.,12.0,"['A new sumo handler is created by reading data.', 'A new sumo handler is created by reading the data.', 'A new sumo handler is created by reading the data from the file.']"
284,cdk,org/openscience/cdk/smarts/SmartsFragmentExtractor.java,/tool/smarts/src/main/java/org/openscience/cdk/smarts/SmartsFragmentExtractor.java,chooseRingNumber,321-335,"/**
     * Select the lowest ring number for use in SMARTS.
     *
     * @return ring number
     * @throws IllegalStateException all ring numbers are used
     */
private int chooseRingNumber(){
    for (int i = 1; i < rnums.length; i++) {
        if (rnums[i] == 0) {
            rnums[i] = 1;
            return i;
        }
    }
    throw new IllegalStateException(""No more ring numbers available!"");
}","private int chooseRingNumber(){
    for (int i = 1; i < rnums.length; i++) {
        if (rnums[i] == 0) {
            rnums[i] = 1;
            return i;
        }
    }
    throw new IllegalStateException(""No more ring numbers available!"");
}","/**
     * Select the lowest ring number for use in SMARTS.
     *
     * @return ring number
     * @throws IllegalStateException all ring numbers are used
     */","('chooseRingNumber', {'INSTRUCTION': {'covered': 21, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,  Select the lowest ring number for use in SMARTS.,10.0,"['The lowest ring number is used in SMARTS.', 'You can use the lowest ring number in SMARTS.', 'You can use the lowest ring number.']"
286,cdk,org/openscience/cdk/ringsearch/cyclebasis/SimpleCycle.java,/legacy/src/main/java/org/openscience/cdk/ringsearch/cyclebasis/SimpleCycle.java,weight,86-98,"/**
     * Returns the sum of the weights of all edges in this cycle.
     *
     * @return the sum of the weights of all edges in this cycle
     */
public double weight(){
    double result = 0;
    Iterator edgeIterator = edgeSet().iterator();
    while (edgeIterator.hasNext()) {
        result += ((Edge) edgeIterator.next()).getWeight();
    }
    return result;
}","public double weight(){
    double result = 0;
    Iterator edgeIterator = edgeSet().iterator();
    while (edgeIterator.hasNext()) {
        result += ((Edge) edgeIterator.next()).getWeight();
    }
    return result;
}","/**
     * Returns the sum of the weights of all edges in this cycle.
     *
     * @return the sum of the weights of all edges in this cycle
     */","('weight', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,  Returns the sum of the weights of all edges in this cycle.,13.0,"['The sum of the weights of all edges is returned.', 'The sum of the weights of the edges is returned.', 'The weights of all edges are returned.']"
287,metrics,io/dropwizard/metrics5/health/HealthCheckRegistry.java,/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/HealthCheckRegistry.java,addListener,68-80,"/**
     * Adds a {@link HealthCheckRegistryListener} to a collection of listeners that will be notified on health check
     * registration. Listeners will be notified in the order in which they are added. The listener will be notified of all
     * existing health checks when it first registers.
     *
     * @param listener listener to add
     */
public void addListener(HealthCheckRegistryListener listener){
    listeners.add(listener);
    for (Map.Entry<String, HealthCheck> entry : healthChecks.entrySet()) {
        listener.onHealthCheckAdded(entry.getKey(), entry.getValue());
    }
}","public void addListener(HealthCheckRegistryListener listener){
    listeners.add(listener);
    for (Map.Entry<String, HealthCheck> entry : healthChecks.entrySet()) {
        listener.onHealthCheckAdded(entry.getKey(), entry.getValue());
    }
}","/**
     * Adds a {@link HealthCheckRegistryListener} to a collection of listeners that will be notified on health check
     * registration. Listeners will be notified in the order in which they are added. The listener will be notified of all
     * existing health checks when it first registers.
     *
     * @param listener listener to add
     */","('addListener', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,  Adds a {@link HealthCheckRegistryListener} to a collection of listeners that will be notified on health check  registration.,21.0,"['A collection of listeners that will be notified on health check registration has been added.', 'A collection of listeners that will be notified on health check registration have been added.', 'A collection of listeners that will be notified on health check registration is added.']"
288,metrics,io/dropwizard/metrics5/MetricRegistry.java,/metrics-core/src/main/java/io/dropwizard/metrics5/MetricRegistry.java,addListener,395-409,"/**
     * Adds a {@link MetricRegistryListener} to a collection of listeners that will be notified on
     * metric creation.  Listeners will be notified in the order in which they are added.
     * <p>
     * <b>N.B.:</b> The listener will be notified of all existing metrics when it first registers.
     *
     * @param listener the listener that will be notified
     */
public void addListener(MetricRegistryListener listener){
    listeners.add(listener);
    for (Map.Entry<MetricName, Metric> entry : metrics.entrySet()) {
        notifyListenerOfAddedMetric(listener, entry.getValue(), entry.getKey());
    }
}","public void addListener(MetricRegistryListener listener){
    listeners.add(listener);
    for (Map.Entry<MetricName, Metric> entry : metrics.entrySet()) {
        notifyListenerOfAddedMetric(listener, entry.getValue(), entry.getKey());
    }
}","/**
     * Adds a {@link MetricRegistryListener} to a collection of listeners that will be notified on
     * metric creation.  Listeners will be notified in the order in which they are added.
     * <p>
     * <b>N.B.:</b> The listener will be notified of all existing metrics when it first registers.
     *
     * @param listener the listener that will be notified
     */","('addListener', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",53.0,  Adds a {@link MetricRegistryListener} to a collection of listeners that will be notified on  metric creation.,20.0,"['A @link MetricRegistryListener is added to a collection that will be notified when a metric is created.', 'A @link MetricRegistryListener is added to a collection of listeners that will be notified when a metric is created.', 'A @link MetricRegistryListener is added to a collection that will be notified of metric creation.']"
289,json-schema-validator,com/networknt/schema/CollectorContext.java,/src/main/java/com/networknt/schema/CollectorContext.java,combineWithCollector,104-116,"/**
     * Combines data with Collector identified by the given name.
     *
     * @param name String
     * @param data Object
     */
public void combineWithCollector(String name, Object data){
    Object object = collectorMap.get(name);
    if (object instanceof Collector<?>) {
        Collector<?> collector = (Collector<?>) object;
        collector.combine(data);
    }
}","public void combineWithCollector(String name, Object data){
    Object object = collectorMap.get(name);
    if (object instanceof Collector<?>) {
        Collector<?> collector = (Collector<?>) object;
        collector.combine(data);
    }
}","/**
     * Combines data with Collector identified by the given name.
     *
     * @param name String
     * @param data Object
     */","('combineWithCollector', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,  Combines data with Collector identified by the given name.,10.0,"['The data is combined with the collector.', 'The data is combined with a collector.', 'The data is combined with the Collector identified by the name.']"
290,metrics,io/dropwizard/metrics5/graphite/PickledGraphite.java,/metrics-graphite/src/main/java/io/dropwizard/metrics5/graphite/PickledGraphite.java,send,194-213,"/**
     * Convert the metric to a python tuple of the form:
     * <p>
     * (timestamp, (name, value))
     * <p>
     * And add it to the list of metrics. If we reach the batch size, write them out.
     *
     * @param name      the name of the metric
     * @param value     the value of the metric
     * @param timestamp the timestamp of the metric
     * @throws IOException if there was an error sending the metric
     */
public void send(String name, String value, long timestamp) throws IOException{
    metrics.add(new MetricTuple(sanitize(name), timestamp, sanitize(value)));
    if (metrics.size() >= batchSize) {
        writeMetrics();
    }
}","public void send(String name, String value, long timestamp) throws IOException{
    metrics.add(new MetricTuple(sanitize(name), timestamp, sanitize(value)));
    if (metrics.size() >= batchSize) {
        writeMetrics();
    }
}","/**
     * Convert the metric to a python tuple of the form:
     * <p>
     * (timestamp, (name, value))
     * <p>
     * And add it to the list of metrics. If we reach the batch size, write them out.
     *
     * @param name      the name of the metric
     * @param value     the value of the metric
     * @param timestamp the timestamp of the metric
     * @throws IOException if there was an error sending the metric
     */","('send', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,"  Convert the metric to a python tuple of the form:  <p>  (timestamp, (name, value))  <p>  And add it to the list of metrics.",35.0,"['Add the metric to the list of metrics by converting it to a python form.', 'Add it to the list of metrics by converting the metric to a python form.', 'Add the metric to the list of metrics by converting the metric to a python form.']"
291,mybatis-3,org/apache/ibatis/io/VFS.java,/src/main/java/org/apache/ibatis/io/VFS.java,list,212-226,"/**
   * Recursively list the full resource path of all the resources that are children of all the
   * resources found at the specified path.
   *
   * @param path The path of the resource(s) to list.
   * @return A list containing the names of the child resources.
   * @throws IOException If I/O errors occur
   */
public List<String> list(String path) throws IOException{
    List<String> names = new ArrayList<>();
    for (URL url : getResources(path)) {
        names.addAll(list(url, path));
    }
    return names;
}","public List<String> list(String path) throws IOException{
    List<String> names = new ArrayList<>();
    for (URL url : getResources(path)) {
        names.addAll(list(url, path));
    }
    return names;
}","/**
   * Recursively list the full resource path of all the resources that are children of all the
   * resources found at the specified path.
   *
   * @param path The path of the resource(s) to list.
   * @return A list containing the names of the child resources.
   * @throws IOException If I/O errors occur
   */","('list', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,  Recursively list the full resource path of all the resources that are children of all the  resources found at the specified path.,23.0,"['List the full resource path of all the resources that are children of all the resources found there.', 'List the full resource path of all the resources that are children of all the resources found at the specified path.', 'List the full resource path of all the resources that are children of all the resources found at the path.']"
292,cdk,org/openscience/cdk/io/MDLRXNWriter.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLRXNWriter.java,write,177-194,"/**
     * Writes a IChemObject to the MDL RXN file formated output.
     * It can only output ChemObjects of type Reaction
     *
     * @param object class must be of type Molecule or MoleculeSet.
     *
     * @see org.openscience.cdk.ChemFile
     */
public void write(IChemObject object) throws CDKException{
    if (object instanceof IReactionSet) {
        writeReactionSet((IReactionSet) object);
    } else if (object instanceof IReaction) {
        writeReaction((IReaction) object);
    } else {
        throw new CDKException(""Only supported is writing ReactionSet, Reaction objects."");
    }
}","public void write(IChemObject object) throws CDKException{
    if (object instanceof IReactionSet) {
        writeReactionSet((IReactionSet) object);
    } else if (object instanceof IReaction) {
        writeReaction((IReaction) object);
    } else {
        throw new CDKException(""Only supported is writing ReactionSet, Reaction objects."");
    }
}","/**
     * Writes a IChemObject to the MDL RXN file formated output.
     * It can only output ChemObjects of type Reaction
     *
     * @param object class must be of type Molecule or MoleculeSet.
     *
     * @see org.openscience.cdk.ChemFile
     */","('write', {'INSTRUCTION': {'covered': 17, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,  Writes a IChemObject to the MDL RXN file formated output.,11.0,"['The IChem object was written to the MDL RXN file.', 'The IChem object is written to the MDL RXN file.', 'Writes a IChem object to the MDL file.']"
293,cdk,org/openscience/cdk/isomorphism/UllmannState.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/UllmannState.java,hasCandidate,219-230,"/**
     * Check if there are any feasible mappings left for the query vertex n. We
     * scan the compatibility matrix to see if any value is > 0.
     *
     * @param n query vertex
     * @return a candidate is present
     */
private boolean hasCandidate(int n){
    for (int j = (n * matrix.mCols), end = (j + matrix.mCols); j < end; j++) if (matrix.get(j))
        return true;
    return false;
}","private boolean hasCandidate(int n){
    for (int j = (n * matrix.mCols), end = (j + matrix.mCols); j < end; j++) if (matrix.get(j))
        return true;
    return false;
}","/**
     * Check if there are any feasible mappings left for the query vertex n. We
     * scan the compatibility matrix to see if any value is > 0.
     *
     * @param n query vertex
     * @return a candidate is present
     */","('hasCandidate', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,  Check if there are any feasible mappings left for the query vertex n.,14.0,"['If there are any feasible mappings left, check them out.', 'Check to see if there are any feasible mappings left.', 'If there are any feasible mappings left for the query, check them out.']"
294,cdk,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,findAtomByPosition,624-637,"/**
     * Helper method that locates an atom based on its InChI atom table
     * position, which has been set as ID.
     * @param container input container
     * @param position InChI atom table position
     * @return atom on the position
     */
private IAtom findAtomByPosition(IAtomContainer container, int position){
    String pos = String.valueOf(position);
    for (IAtom atom : container.atoms()) {
        if (atom.getID().equals(pos))
            return atom;
    }
    return null;
}","private IAtom findAtomByPosition(IAtomContainer container, int position){
    String pos = String.valueOf(position);
    for (IAtom atom : container.atoms()) {
        if (atom.getID().equals(pos))
            return atom;
    }
    return null;
}","/**
     * Helper method that locates an atom based on its InChI atom table
     * position, which has been set as ID.
     * @param container input container
     * @param position InChI atom table position
     * @return atom on the position
     */","('findAtomByPosition', {'INSTRUCTION': {'covered': 22, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,"  Helper method that locates an atom based on its InChI atom table  position, which has been set as ID.",21.0,"['A method that locates an atom based on its table position has been created.', 'A method that locates an atom based on its table position has been set as ID.', 'A method that locates an atom based on its table position is called a helpers method.']"
295,glowstone,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,readList,538-556,"/**
     * Applies the given function to a list subtag if it is present, converting it to a list of
     * values first.
     *
     * @param <T> the type to convert the list entries to
     * @param key the key to look up
     * @param type the type that the list entries must be
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */
public boolean readList(@NonNls String key, TagType type, Consumer<? super List<T>> consumer){
    if (isList(key, type)) {
        consumer.accept(getList(key, type));
        return true;
    }
    return false;
}","public boolean readList(@NonNls String key, TagType type, Consumer<? super List<T>> consumer){
    if (isList(key, type)) {
        consumer.accept(getList(key, type));
        return true;
    }
    return false;
}","/**
     * Applies the given function to a list subtag if it is present, converting it to a list of
     * values first.
     *
     * @param <T> the type to convert the list entries to
     * @param key the key to look up
     * @param type the type that the list entries must be
     * @param consumer the function to apply
     * @return true if the tag exists and was passed to the consumer; false otherwise
     */","('readList', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,"  Applies the given function to a list subtag if it is present, converting it to a list of  values first.",22.0,"['If the function is present, convert it to a list of values first.', 'If the function is present, apply it to a list subtag and convert it to a list of values.', 'If the function is present, convert it to a list of values.']"
296,cdk,org/openscience/cdk/silent/RingSet.java,/base/silent/src/main/java/org/openscience/cdk/silent/RingSet.java,add,120-134,"/**
     * Adds all rings of another RingSet if they are not already part of this ring set.
     *
     * If you want to add a single ring to the set use {@link #addAtomContainer(org.openscience.cdk.interfaces.IAtomContainer)}
     *
     * @param   ringSet  the ring set to be united with this one.
     */
public void add(IRingSet ringSet){
    for (int f = 0; f < ringSet.getAtomContainerCount(); f++) {
        if (!contains(ringSet.getAtomContainer(f))) {
            addAtomContainer(ringSet.getAtomContainer(f));
        }
    }
}","public void add(IRingSet ringSet){
    for (int f = 0; f < ringSet.getAtomContainerCount(); f++) {
        if (!contains(ringSet.getAtomContainer(f))) {
            addAtomContainer(ringSet.getAtomContainer(f));
        }
    }
}","/**
     * Adds all rings of another RingSet if they are not already part of this ring set.
     *
     * If you want to add a single ring to the set use {@link #addAtomContainer(org.openscience.cdk.interfaces.IAtomContainer)}
     *
     * @param   ringSet  the ring set to be united with this one.
     */","('add', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,  Adds all rings of another RingSet if they are not already part of this ring set.,17.0,"['If they are not part of the ring set, add them.', 'If they are not part of the ring set, add all of them.', 'If they are not part of this ring set, add all of them.']"
297,anserini,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,convertLuceneDocidToDocid,757-774,"/**
   * Converts a Lucene internal docid to a collection docid.
   *
   * @param reader index reader
   * @param docid Lucene internal docid
   * @return corresponding collection docid, or <code>null</code> if not found.
   */
public static String convertLuceneDocidToDocid(IndexReader reader, int docid){
    if (docid >= reader.maxDoc())
        return null;
    try {
        return reader.document(docid).get(IndexArgs.ID);
    } catch (IOException e) {
        return null;
    }
}","public static String convertLuceneDocidToDocid(IndexReader reader, int docid){
    if (docid >= reader.maxDoc())
        return null;
    try {
        return reader.document(docid).get(IndexArgs.ID);
    } catch (IOException e) {
        return null;
    }
}","/**
   * Converts a Lucene internal docid to a collection docid.
   *
   * @param reader index reader
   * @param docid Lucene internal docid
   * @return corresponding collection docid, or <code>null</code> if not found.
   */","('convertLuceneDocidToDocid', {'INSTRUCTION': {'covered': 12, 'missed': 3}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,  Converts a Lucene internal docid to a collection docid.,10.0,"['A collection docid is converted to a Lucene internal docid.', 'A collection docid is converted to an internal docid.', 'A collection docid is converted to a internal docid.']"
298,dataverse,edu/harvard/iq/dataverse/authorization/providers/builtin/BuiltinAuthenticationProvider.java,/src/main/java/edu/harvard/iq/dataverse/authorization/providers/builtin/BuiltinAuthenticationProvider.java,verifyPassword,85-97,"/**
     * Validates that the passed password is indeed the password of the user.
     * @param userIdInProvider
     * @param password
     * @return {@code true} if the password matches the user's password; {@code false} otherwise.
     */
public Boolean verifyPassword(String userIdInProvider, String password){
    BuiltinUser biUser = bean.findByUserName(userIdInProvider);
    if (biUser == null)
        return null;
    return PasswordEncryption.getVersion(biUser.getPasswordEncryptionVersion()).check(password, biUser.getEncryptedPassword());
}","public Boolean verifyPassword(String userIdInProvider, String password){
    BuiltinUser biUser = bean.findByUserName(userIdInProvider);
    if (biUser == null)
        return null;
    return PasswordEncryption.getVersion(biUser.getPasswordEncryptionVersion()).check(password, biUser.getEncryptedPassword());
}","/**
     * Validates that the passed password is indeed the password of the user.
     * @param userIdInProvider
     * @param password
     * @return {@code true} if the password matches the user's password; {@code false} otherwise.
     */","('verifyPassword', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,  Validates that the passed password is indeed the password of the user.,13.0,"['The password of the user is verified.', 'The password of the user is confirmed.', 'The password of the user is confirmed by this.']"
300,cdk,org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,has2DCoordinates,292-304,"/**
     * Check if all atoms in the bond list have 2D coordinates. There is some
     * redundant checking but the list will typically be short.
     *
     * @param bonds the bonds to check
     * @return whether all atoms have 2D coordinates
     */
private static boolean has2DCoordinates(List<IBond> bonds){
    for (IBond bond : bonds) {
        if (bond.getBegin().getPoint2d() == null || bond.getEnd().getPoint2d() == null)
            return false;
    }
    return true;
}","private static boolean has2DCoordinates(List<IBond> bonds){
    for (IBond bond : bonds) {
        if (bond.getBegin().getPoint2d() == null || bond.getEnd().getPoint2d() == null)
            return false;
    }
    return true;
}","/**
     * Check if all atoms in the bond list have 2D coordinates. There is some
     * redundant checking but the list will typically be short.
     *
     * @param bonds the bonds to check
     * @return whether all atoms have 2D coordinates
     */","('has2DCoordinates', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,Check if all atoms in the bond list have 2D coordinates.,12.0,"['The bond list has 2D coordinates.', 'If the atoms in the bond list have 2D coordinates, check them out.', 'If the atoms in the bond list have 2D coordinates, check them.']"
301,matsim-libs,org/matsim/analysis/LegHistogram.java,/matsim/src/main/java/org/matsim/analysis/LegHistogram.java,write,132-143,"/**
	 * Writes the gathered data tab-separated into a text file.
	 *
	 * @param filename The name of a file where to write the gathered data.
	 */
public void write(final String filename){
    try (OutputStream stream = IOUtils.getOutputStream(IOUtils.getFileUrl(filename), false)) {
        write(new PrintStream(stream));
    } catch (IOException e) {
        throw new UncheckedIOException(e);
    }
}","public void write(final String filename){
    try (OutputStream stream = IOUtils.getOutputStream(IOUtils.getFileUrl(filename), false)) {
        write(new PrintStream(stream));
    } catch (IOException e) {
        throw new UncheckedIOException(e);
    }
}","/**
	 * Writes the gathered data tab-separated into a text file.
	 *
	 * @param filename The name of a file where to write the gathered data.
	 */","('write', {'INSTRUCTION': {'covered': 150, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 20, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,  Writes the gathered data tab-separated into a text file.,10.0,"['The data tab is written into a text file.', 'The data tab is separated into a text file.', 'Writes the data into a text file.']"
302,cdk,org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,has3DCoordinates,306-318,"/**
     * Check if all atoms in the bond list have 3D coordinates. There is some
     * redundant checking but the list will typically be short.
     *
     * @param bonds the bonds to check
     * @return whether all atoms have 2D coordinates
     */
private static boolean has3DCoordinates(List<IBond> bonds){
    for (IBond bond : bonds) {
        if (bond.getBegin().getPoint3d() == null || bond.getEnd().getPoint3d() == null)
            return false;
    }
    return true;
}","private static boolean has3DCoordinates(List<IBond> bonds){
    for (IBond bond : bonds) {
        if (bond.getBegin().getPoint3d() == null || bond.getEnd().getPoint3d() == null)
            return false;
    }
    return true;
}","/**
     * Check if all atoms in the bond list have 3D coordinates. There is some
     * redundant checking but the list will typically be short.
     *
     * @param bonds the bonds to check
     * @return whether all atoms have 2D coordinates
     */","('has3DCoordinates', {'INSTRUCTION': {'covered': 21, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,Check if all atoms in the bond list have 3D coordinates.,12.0,"['The bond list has 3D coordinates.', 'If the atoms in the bond list have 3D coordinates, you should check them.', 'If the atoms in the bond list have 3D coordinates, you should check it.']"
303,tablesaw,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,sampleX,553-565,"/**
   * Returns a table consisting of randomly selected records from this table. The sample size is
   * based on the given proportion
   *
   * @param proportion The proportion to go in the sample
   */
public Table sampleX(double proportion){
    Preconditions.checkArgument(proportion <= 1 && proportion >= 0, ""The sample proportion must be between 0 and 1"");
    int tableSize = (int) Math.round(rowCount() * proportion);
    return where(selectNRowsAtRandom(tableSize, rowCount()));
}","public Table sampleX(double proportion){
    Preconditions.checkArgument(proportion <= 1 && proportion >= 0, ""The sample proportion must be between 0 and 1"");
    int tableSize = (int) Math.round(rowCount() * proportion);
    return where(selectNRowsAtRandom(tableSize, rowCount()));
}","/**
   * Returns a table consisting of randomly selected records from this table. The sample size is
   * based on the given proportion
   *
   * @param proportion The proportion to go in the sample
   */","('sampleX', {'INSTRUCTION': {'covered': 27, 'missed': 1}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",54.0,  Returns a table consisting of randomly selected records from this table.,12.0,"['A table consisting of randomly selected records is returned.', 'A table with randomly selected records is returned.', 'A table with randomly selected records.']"
304,dcache,org/dcache/auth/Subjects.java,/modules/common/src/main/java/org/dcache/auth/Subjects.java,hasUid,100-112,"/**
     * Returns true if and only if the subject has the given user ID.
     */
public static boolean hasUid(Subject subject, long uid){
    Set<UidPrincipal> principals = subject.getPrincipals(UidPrincipal.class);
    for (UidPrincipal principal : principals) {
        if (principal.getUid() == uid) {
            return true;
        }
    }
    return false;
}","public static boolean hasUid(Subject subject, long uid){
    Set<UidPrincipal> principals = subject.getPrincipals(UidPrincipal.class);
    for (UidPrincipal principal : principals) {
        if (principal.getUid() == uid) {
            return true;
        }
    }
    return false;
}","/**
     * Returns true if and only if the subject has the given user ID.
     */","('hasUid', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,  Returns true if and only if the subject has the given user ID.,14.0,"['If the subject has a user ID, this is true.', ""If the subject has a user ID, it's true."", 'If the subject has a user ID, it is true.']"
305,cdk,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,isMajorIsotope,571-585,"/**
     * Utility to determine if the specified mass is the major isotope for the given atomic number.
     *
     * @param number atomic number
     * @param mass   atomic mass
     * @return the mass is the major mass for the atomic number
     */
private boolean isMajorIsotope(int number, int mass){
    try {
        IIsotope isotope = Isotopes.getInstance().getMajorIsotope(number);
        return isotope != null && isotope.getMassNumber().equals(mass);
    } catch (IOException e) {
        return false;
    }
}","private boolean isMajorIsotope(int number, int mass){
    try {
        IIsotope isotope = Isotopes.getInstance().getMajorIsotope(number);
        return isotope != null && isotope.getMassNumber().equals(mass);
    } catch (IOException e) {
        return false;
    }
}","/**
     * Utility to determine if the specified mass is the major isotope for the given atomic number.
     *
     * @param number atomic number
     * @param mass   atomic mass
     * @return the mass is the major mass for the atomic number
     */","('isMajorIsotope', {'INSTRUCTION': {'covered': 15, 'missed': 4}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 2, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,  Utility to determine if the specified mass is the major isotope for the given atomic number.,17.0,"[""If the specified mass is the major isotope for the given atomic number, it's a utility."", 'If the specified mass is the major isotope for the given atomic number, the utility is to determine.', 'If the specified mass is the major isotope for the given atomic number, the utility is needed.']"
306,sonar-cxx,org/sonar/cxx/preprocessor/CppGrammarImpl.java,/cxx-squid/src/main/java/org/sonar/cxx/preprocessor/CppGrammarImpl.java,toplevelDefinitionGrammar,128-153,"/**
   * The root note is not 'preprocessing-file' but a collection of rules that
   * process lines (ending with 'new-line' in grammar).
   */
private static void toplevelDefinitionGrammar(LexerfulGrammarBuilder b){
    b.rule(preprocessorLine).is(b.firstOf(// control-line, # include
    includeLine, // control-line, ppImport
    ppImport, // control-line, # define
    defineLine, // control-line, # undef
    undefLine, // control-line, # line
    lineLine, // control-line, # error
    errorLine, // control-line, # pragma
    pragmaLine, // control-line, # warning
    warningLine, // if-section, if-group, # if
    ifLine, // if-section, if-group, # ifdef/ifndef
    ifdefLine, // if-section, elif-group, #elif
    elifLine, // if-section, else-group, #else
    elseLine, // if-section, endif-line, #endif
    endifLine, miscLine, // ... module ...
    ppModule));
}","private static void toplevelDefinitionGrammar(LexerfulGrammarBuilder b){
    b.rule(preprocessorLine).is(b.firstOf(// control-line, # include
    includeLine, // control-line, ppImport
    ppImport, // control-line, # define
    defineLine, // control-line, # undef
    undefLine, // control-line, # line
    lineLine, // control-line, # error
    errorLine, // control-line, # pragma
    pragmaLine, // control-line, # warning
    warningLine, // if-section, if-group, # if
    ifLine, // if-section, if-group, # ifdef/ifndef
    ifdefLine, // if-section, elif-group, #elif
    elifLine, // if-section, else-group, #else
    elseLine, // if-section, endif-line, #endif
    endifLine, miscLine, // ... module ...
    ppModule));
}","/**
   * The root note is not 'preprocessing-file' but a collection of rules that
   * process lines (ending with 'new-line' in grammar).
   */","('toplevelDefinitionGrammar', {'INSTRUCTION': {'covered': 64, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,  The root note is not 'preprocessing-file' but a collection of rules that  process lines (ending with 'new-line' in grammar).,24.0,"['The root note is a collection of rules that process lines.', 'A collection of rules that process lines is what the root note is about.', ""The root note is a collection of rules that process lines, ending with 'new-line'.""]"
307,dcache,org/dcache/auth/Subjects.java,/modules/common/src/main/java/org/dcache/auth/Subjects.java,hasGid,114-126,"/**
     * Returns true if and only if the subject has the given group ID.
     */
public static boolean hasGid(Subject subject, long gid){
    Set<GidPrincipal> principals = subject.getPrincipals(GidPrincipal.class);
    for (GidPrincipal principal : principals) {
        if (principal.getGid() == gid) {
            return true;
        }
    }
    return false;
}","public static boolean hasGid(Subject subject, long gid){
    Set<GidPrincipal> principals = subject.getPrincipals(GidPrincipal.class);
    for (GidPrincipal principal : principals) {
        if (principal.getGid() == gid) {
            return true;
        }
    }
    return false;
}","/**
     * Returns true if and only if the subject has the given group ID.
     */","('hasGid', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,  Returns true if and only if the subject has the given group ID.,14.0,"['If the subject has a group ID, this is true.', ""If the subject has a group ID, it's true."", 'If the subject has a group ID, it will be true.']"
308,matsim-libs,org/matsim/contrib/common/stats/LogDiscretizer.java,/contribs/common/src/main/java/org/matsim/contrib/common/stats/LogDiscretizer.java,binWidth,80-91,"/**
     * @param value a value
     * @return the width of the bin of <tt>value</tt>. The width of the 0-th bin is 1.
     */
public double binWidth(double value){
    double bin = index(value);
    if (bin == 0)
        return Math.pow(base, bin);
    else
        return Math.pow(base, bin) - Math.pow(base, bin - 1);
}","public double binWidth(double value){
    double bin = index(value);
    if (bin == 0)
        return Math.pow(base, bin);
    else
        return Math.pow(base, bin) - Math.pow(base, bin - 1);
}","/**
     * @param value a value
     * @return the width of the bin of <tt>value</tt>. The width of the 0-th bin is 1.
     */","('binWidth', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,  @param value a value  @return the width of the bin of <tt>value</tt>.,21.0,"['Return the width of the bin if you have a value.', 'Return the width of the bin if the value is a value.', 'Return the width of the bin if the value isparamed.']"
309,matsim-libs,org/matsim/core/scoring/EventsToScore.java,/matsim/src/main/java/org/matsim/core/scoring/EventsToScore.java,finish,116-128,"/**
	 * Finishes the calculation of the plans' scores and assigns the new scores
	 * to the plans if desired.
	 */
public void finish(){
    if (iteration == -1) {
        throw new RuntimeException(""Please initialize me before the iteration starts."");
    }
    controlerListenerManager.fireControlerAfterMobsimEvent(iteration, isLastIteration);
    scoringFunctionsForPopulation.finishScoringFunctions();
    newScoreAssigner.assignNewScores(this.iteration, scoringFunctionsForPopulation, population);
    finished = true;
}","public void finish(){
    if (iteration == -1) {
        throw new RuntimeException(""Please initialize me before the iteration starts."");
    }
    controlerListenerManager.fireControlerAfterMobsimEvent(iteration, isLastIteration);
    scoringFunctionsForPopulation.finishScoringFunctions();
    newScoreAssigner.assignNewScores(this.iteration, scoringFunctionsForPopulation, population);
    finished = true;
}","/**
	 * Finishes the calculation of the plans' scores and assigns the new scores
	 * to the plans if desired.
	 */","('finish', {'INSTRUCTION': {'covered': 27, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,  Finishes the calculation of the plans' scores and assigns the new scores  to the plans if desired.,19.0,"['If you want, assign the new scores to the plans.', 'If you want, you can assign the new scores to the plans.', 'If you want, assign the new scores to the plans if you want.']"
310,tablesaw,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,reorderColumns,305-320,"/**
   * Return a new table (shallow copy) that contains all the columns in this table, in the order
   * given in the argument. Throw an IllegalArgument exception if the number of names given does not
   * match the number of columns in this table. NOTE: This does not make a copy of the columns, so
   * they are shared between the two tables.
   *
   * @param columnNames a column name or array of names
   */
public Table reorderColumns(String... columnNames){
    Preconditions.checkArgument(columnNames.length == columnCount());
    Table table = Table.create(name);
    for (String name : columnNames) {
        table.addColumns(column(name));
    }
    return table;
}","public Table reorderColumns(String... columnNames){
    Preconditions.checkArgument(columnNames.length == columnCount());
    Table table = Table.create(name);
    for (String name : columnNames) {
        table.addColumns(column(name));
    }
    return table;
}","/**
   * Return a new table (shallow copy) that contains all the columns in this table, in the order
   * given in the argument. Throw an IllegalArgument exception if the number of names given does not
   * match the number of columns in this table. NOTE: This does not make a copy of the columns, so
   * they are shared between the two tables.
   *
   * @param columnNames a column name or array of names
   */","('reorderColumns', {'INSTRUCTION': {'covered': 41, 'missed': 1}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,"  Return a new table (shallow copy) that contains all the columns in this table, in the order  given in the argument.",25.0,"['Return a new table that has all the columns in the same order as the argument.', 'Return a new table with all the columns in the order they were written in in the argument.', 'Return a new table that has all the columns in the same order.']"
311,cdk,org/openscience/cdk/modeling/builder3d/MMFF94BasedParameterSetReader.java,/tool/forcefield/src/main/java/org/openscience/cdk/modeling/builder3d/MMFF94BasedParameterSetReader.java,massNumber,562-574,"/**
     * Mass number for a atom with a given atomic number and exact mass.
     *
     * @param atomicNumber atomic number
     * @param exactMass    exact mass
     * @return the mass number (or null) if no mass number was found
     * @throws IOException isotope configuration could not be loaded
     */
private Integer massNumber(int atomicNumber, double exactMass) throws IOException{
    String symbol = PeriodicTable.getSymbol(atomicNumber);
    IIsotope isotope = Isotopes.getInstance().getIsotope(symbol, exactMass, 0.001);
    return isotope != null ? isotope.getMassNumber() : null;
}","private Integer massNumber(int atomicNumber, double exactMass) throws IOException{
    String symbol = PeriodicTable.getSymbol(atomicNumber);
    IIsotope isotope = Isotopes.getInstance().getIsotope(symbol, exactMass, 0.001);
    return isotope != null ? isotope.getMassNumber() : null;
}","/**
     * Mass number for a atom with a given atomic number and exact mass.
     *
     * @param atomicNumber atomic number
     * @param exactMass    exact mass
     * @return the mass number (or null) if no mass number was found
     * @throws IOException isotope configuration could not be loaded
     */","('massNumber', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",55.0,  Mass number for a atom with a given atomic number and exact mass.,14.0,"['The mass number is the atomic number for the atom.', 'A mass number for an atom with an atomic number.', 'The mass number is the atomic number and the mass is the exact mass.']"
312,cdk,org/openscience/cdk/geometry/cip/CIPTool.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/CIPTool.java,order,235-247,"/**
     * Reorders the {@link ILigand} objects in the array according to the CIP rules.
     *
     * @param ligands Array of {@link ILigand}s to be reordered.
     * @return        Reordered array of {@link ILigand}s.
     */
public static ILigand[] order(ILigand[] ligands){
    ILigand[] newLigands = new ILigand[ligands.length];
    System.arraycopy(ligands, 0, newLigands, 0, ligands.length);
    Arrays.sort(newLigands, cipRule);
    return newLigands;
}","public static ILigand[] order(ILigand[] ligands){
    ILigand[] newLigands = new ILigand[ligands.length];
    System.arraycopy(ligands, 0, newLigands, 0, ligands.length);
    Arrays.sort(newLigands, cipRule);
    return newLigands;
}","/**
     * Reorders the {@link ILigand} objects in the array according to the CIP rules.
     *
     * @param ligands Array of {@link ILigand}s to be reordered.
     * @return        Reordered array of {@link ILigand}s.
     */","('order', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",56.0,  Reorders the {@link ILigand} objects in the array according to the CIP rules.,17.0,"['The objects in the array should be ordered according to the rules.', 'The @link ILigand objects should be ordered according to the rules.', 'The @link ILigand objects are to be ordered according to the rules.']"
313,shardingsphere-elasticjob,org/apache/shardingsphere/elasticjob/cloud/console/controller/CloudOperationController.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/console/controller/CloudOperationController.java,sandbox,94-105,"/**
     * Get sandbox of the cloud job by app name.
     *
     * @param appName application name
     * @return sandbox info
     * @throws JsonParseException parse json exception
     */
public Collection<Map<String, String>> sandbox(@Param(name = ""appName"", source = ParamSource.QUERY) final String appName) throws JsonParseException{
    Preconditions.checkArgument(!Strings.isNullOrEmpty(appName), ""Lack param 'appName'"");
    return mesosStateService.sandbox(appName);
}","public Collection<Map<String, String>> sandbox(@Param(name = ""appName"", source = ParamSource.QUERY) final String appName) throws JsonParseException{
    Preconditions.checkArgument(!Strings.isNullOrEmpty(appName), ""Lack param 'appName'"");
    return mesosStateService.sandbox(appName);
}","/**
     * Get sandbox of the cloud job by app name.
     *
     * @param appName application name
     * @return sandbox info
     * @throws JsonParseException parse json exception
     */","('sandbox', {'INSTRUCTION': {'covered': 11, 'missed': 1}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",56.0,  Get sandbox of the cloud job by app name.,10.0,"['The cloud job can be accessed by app name.', 'You can get the cloud job by app name.', 'The cloud job can be accessed by name.']"
314,cucumber-reporting,net/masterthought/cucumber/reducers/ReportFeatureWithRetestMerger.java,/src/main/java/net/masterthought/cucumber/reducers/ReportFeatureWithRetestMerger.java,find,93-106,"/**
     * @return an index of an element which is indicated as similar by rules
     * defined in the ELEMENT_COMPARATOR. The comparator indicates that
     * an element is found in the elements list with the same Id (for scenario)
     * as target element has or it's on the same line (for background).
     */
 int find(Element[] elements, Element target){
    for (int i = 0; i < elements.length; i++) {
        if (ELEMENT_COMPARATOR.compare(elements[i], target) == 0) {
            return i;
        }
    }
    return -1;
}","int find(Element[] elements, Element target){
    for (int i = 0; i < elements.length; i++) {
        if (ELEMENT_COMPARATOR.compare(elements[i], target) == 0) {
            return i;
        }
    }
    return -1;
}","/**
     * @return an index of an element which is indicated as similar by rules
     * defined in the ELEMENT_COMPARATOR. The comparator indicates that
     * an element is found in the elements list with the same Id (for scenario)
     * as target element has or it's on the same line (for background).
     */","('find', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",56.0,  @return an index of an element which is indicated as similar by rules  defined in the ELEMENT_COMPARATOR.,19.0,"['An index of an element which is similar to rules in the ELEMENTCOMPARATOR is returned.', 'An index of an element which is similar to the rules in the ELEMENTCOMPARATOR is returned.', 'An index of an element which is similar to rules in the ELEMENTCOMPARATOR can be returned.']"
315,cdk,org/openscience/cdk/io/MDLRXNReader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLRXNReader.java,readChemModel,192-205,"/**
    * Read a IChemModel from a file in MDL RDF format.
    *
    * @param  chemModel The IChemModel
    * @return           The IChemModel that was read from the RDF file
    */
private IChemModel readChemModel(IChemModel chemModel) throws CDKException{
    IReactionSet setOfReactions = chemModel.getReactionSet();
    if (setOfReactions == null) {
        setOfReactions = chemModel.getBuilder().newInstance(IReactionSet.class);
    }
    chemModel.setReactionSet(readReactionSet(setOfReactions));
    return chemModel;
}","private IChemModel readChemModel(IChemModel chemModel) throws CDKException{
    IReactionSet setOfReactions = chemModel.getReactionSet();
    if (setOfReactions == null) {
        setOfReactions = chemModel.getBuilder().newInstance(IReactionSet.class);
    }
    chemModel.setReactionSet(readReactionSet(setOfReactions));
    return chemModel;
}","/**
    * Read a IChemModel from a file in MDL RDF format.
    *
    * @param  chemModel The IChemModel
    * @return           The IChemModel that was read from the RDF file
    */","('readChemModel', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",56.0,  Read a IChemModel from a file in MDL RDF format.,11.0,"['The IChemModel is in MDL RDF format.', 'You can read the IChemModel from a file.', 'You can read a IChemModel from a file.']"
316,dataverse,edu/harvard/iq/dataverse/authorization/groups/impl/maildomain/MailDomainGroupServiceBean.java,/src/main/java/edu/harvard/iq/dataverse/authorization/groups/impl/maildomain/MailDomainGroupServiceBean.java,findByAlias,114-129,"/**
     * Find a specific mail domain group by it's alias.
     * @param groupAlias
     * @return
     */
 Optional<MailDomainGroup> findByAlias(String groupAlias){
    try {
        return Optional.of(em.createNamedQuery(""MailDomainGroup.findByPersistedGroupAlias"", MailDomainGroup.class).setParameter(""persistedGroupAlias"", groupAlias).getSingleResult());
    } catch (NoResultException nre) {
        return Optional.empty();
    }
}"," Optional<MailDomainGroup> findByAlias(String groupAlias){
    try {
        return Optional.of(em.createNamedQuery(""MailDomainGroup.findByPersistedGroupAlias"", MailDomainGroup.class).setParameter(""persistedGroupAlias"", groupAlias).getSingleResult());
    } catch (NoResultException nre) {
        return Optional.empty();
    }
}","/**
     * Find a specific mail domain group by it's alias.
     * @param groupAlias
     * @return
     */","('findByAlias', {'INSTRUCTION': {'covered': 12, 'missed': 3}, 'LINE': {'covered': 4, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",56.0,  Find a specific mail domain group by it's alias.,11.0,"[""The mail domain group can be found by it's alias."", ""You can find a mail domain group by it's name."", ""You can find a specific mail domain group by using it's name.""]"
317,jackson-databind,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,classNameOf,703-716,"/**
     * Helper method used to construct appropriate description
     * when passed either type (Class) or an instance; in latter
     * case, class of instance is to be used.
     *
     * @since 2.9
     */
public static String classNameOf(Object inst){
    if (inst == null) {
        return ""[null]"";
    }
    Class<?> raw = (inst instanceof Class<?>) ? (Class<?>) inst : inst.getClass();
    return nameOf(raw);
}","public static String classNameOf(Object inst){
    if (inst == null) {
        return ""[null]"";
    }
    Class<?> raw = (inst instanceof Class<?>) ? (Class<?>) inst : inst.getClass();
    return nameOf(raw);
}","/**
     * Helper method used to construct appropriate description
     * when passed either type (Class) or an instance; in latter
     * case, class of instance is to be used.
     *
     * @since 2.9
     */","('classNameOf', {'INSTRUCTION': {'covered': 14, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",56.0,"  Helper method used to construct appropriate description  when passed either type (Class) or an instance; in latter  case, class of instance is to be used.",30.0,"['The class of instance is to be used when constructing the appropriate description.', 'The class of instance is to be used in the Helper method.', 'The class of instance is to be used when constructing the appropriate description using the helpers method.']"
318,dcache,org/dcache/services/billing/text/BillingParserBuilder.java,/modules/dcache/src/main/java/org/dcache/services/billing/text/BillingParserBuilder.java,toGroupName,252-261,"/**
     * Translates a attribute name into a name suitable for a named capturing group.
     */
private static String toGroupName(String attribute){
    int pos = attribute.indexOf(';');
    if (pos > -1) {
        attribute = attribute.substring(0, pos);
    }
    return attribute.replace(""X"", ""XX"").replace(""."", ""X"");
}","private static String toGroupName(String attribute){
    int pos = attribute.indexOf(';');
    if (pos > -1) {
        attribute = attribute.substring(0, pos);
    }
    return attribute.replace(""X"", ""XX"").replace(""."", ""X"");
}","/**
     * Translates a attribute name into a name suitable for a named capturing group.
     */","('toGroupName', {'INSTRUCTION': {'covered': 15, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,  Translates a attribute name into a name suitable for a named capturing group.,14.0,"['A named capturing group name is translated into a attribute name.', 'A name is translated into a group name.', 'A name is translated into a name suitable for a captured group.']"
319,openapi-generator,org/openapitools/codegen/DefaultCodegen.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java,toModelName,2380-2397,"/**
     * Converts the OpenAPI schema name to a model name suitable for the current code generator.
     * May be overridden for each programming language.
     * In case the name belongs to the TypeSystem it won't be renamed.
     *
     * @param name the name of the model
     * @return capitalized model name
     */
public String toModelName(final String name){
    if (schemaKeyToModelNameCache.containsKey(name)) {
        return schemaKeyToModelNameCache.get(name);
    }
    String camelizedName = camelize(modelNamePrefix + ""_"" + name + ""_"" + modelNameSuffix);
    schemaKeyToModelNameCache.put(name, camelizedName);
    return camelizedName;
}","public String toModelName(final String name){
    if (schemaKeyToModelNameCache.containsKey(name)) {
        return schemaKeyToModelNameCache.get(name);
    }
    String camelizedName = camelize(modelNamePrefix + ""_"" + name + ""_"" + modelNameSuffix);
    schemaKeyToModelNameCache.put(name, camelizedName);
    return camelizedName;
}","/**
     * Converts the OpenAPI schema name to a model name suitable for the current code generator.
     * May be overridden for each programming language.
     * In case the name belongs to the TypeSystem it won't be renamed.
     *
     * @param name the name of the model
     * @return capitalized model name
     */","('toModelName', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,  Converts the OpenAPI schema name to a model name suitable for the current code generator.,16.0,"['The model name is suitable for the current code generator.', 'The model name for the current code generator is converted from the OpenAPI schema name.', 'The model name for the current code generator can be converted to the OpenAPI schema name.']"
320,glowstone,net/glowstone/util/CompatibilityBundle.java,/src/main/java/net/glowstone/util/CompatibilityBundle.java,fromConfig,44-60,"/**
     * Converts the given config value into the appropriate bundle. If the given value is blank or
     * null, the default value is returned. If the given value does not match any preprogrammmed
     * bundles case insensitively, then null is returned.
     *
     * @param configValue The value from the config file.
     */
public static CompatibilityBundle fromConfig(String configValue){
    if (configValue == null || CharMatcher.whitespace().matchesAllOf(configValue)) {
        return CompatibilityBundle.CRAFTBUKKIT;
    }
    try {
        return valueOf(configValue.toUpperCase());
    } catch (IllegalArgumentException e) {
        return null;
    }
}","public static CompatibilityBundle fromConfig(String configValue){
    if (configValue == null || CharMatcher.whitespace().matchesAllOf(configValue)) {
        return CompatibilityBundle.CRAFTBUKKIT;
    }
    try {
        return valueOf(configValue.toUpperCase());
    } catch (IllegalArgumentException e) {
        return null;
    }
}","/**
     * Converts the given config value into the appropriate bundle. If the given value is blank or
     * null, the default value is returned. If the given value does not match any preprogrammmed
     * bundles case insensitively, then null is returned.
     *
     * @param configValue The value from the config file.
     */","('fromConfig', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,  Converts the given config value into the appropriate bundle.,10.0,"['The value is converted into a bundle.', 'The given value is converted into a bundle.', 'The given config value is converted into the appropriate bundle.']"
321,cdk,org/openscience/cdk/fingerprint/model/Bayesian.java,/tool/model/src/main/java/org/openscience/cdk/fingerprint/model/Bayesian.java,validateLeaveOneOut,315-327,"/**
     * Produces an ROC validation set, using the inputs provided prior to the model building, using leave-one-out. Note that
     * this should only be used for small datasets, since it is very thorough, and scales as O(N^2) relative to training set
     * size.
     */
public void validateLeaveOneOut(){
    final int sz = training.size();
    estimates = new double[sz];
    for (int n = 0; n < sz; n++) estimates[n] = singleLeaveOneOut(n);
    calculateROC();
    rocType = ""leave-one-out"";
}","public void validateLeaveOneOut(){
    final int sz = training.size();
    estimates = new double[sz];
    for (int n = 0; n < sz; n++) estimates[n] = singleLeaveOneOut(n);
    calculateROC();
    rocType = ""leave-one-out"";
}","/**
     * Produces an ROC validation set, using the inputs provided prior to the model building, using leave-one-out. Note that
     * this should only be used for small datasets, since it is very thorough, and scales as O(N^2) relative to training set
     * size.
     */","('validateLeaveOneOut', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,"  Produces an ROC validation set, using the inputs provided prior to the model building, using leave-one-out.",19.0,"['The ROC validation set was produced using the inputs provided prior to the model building.', 'The ROC validation set was produced using inputs provided prior to the model building.', 'The ROC validation set is produced using inputs provided prior to the model building.']"
322,jackson-databind,com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java,/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java,rewrapCtorProblem,590-611,"/**
     * Method that subclasses may call for standard handling of an exception thrown when
     * calling constructor or factory method. Will unwrap {@link ExceptionInInitializerError}
     * and {@link InvocationTargetException}s, then call {@link #wrapAsJsonMappingException}.
     *
     * @since 2.7
     */
protected JsonMappingException rewrapCtorProblem(DeserializationContext ctxt, Throwable t){
    if ((t instanceof ExceptionInInitializerError) || (t instanceof InvocationTargetException)) {
        Throwable cause = t.getCause();
        if (cause != null) {
            t = cause;
        }
    }
    return wrapAsJsonMappingException(ctxt, t);
}","protected JsonMappingException rewrapCtorProblem(DeserializationContext ctxt, Throwable t){
    if ((t instanceof ExceptionInInitializerError) || (t instanceof InvocationTargetException)) {
        Throwable cause = t.getCause();
        if (cause != null) {
            t = cause;
        }
    }
    return wrapAsJsonMappingException(ctxt, t);
}","/**
     * Method that subclasses may call for standard handling of an exception thrown when
     * calling constructor or factory method. Will unwrap {@link ExceptionInInitializerError}
     * and {@link InvocationTargetException}s, then call {@link #wrapAsJsonMappingException}.
     *
     * @since 2.7
     */","('rewrapCtorProblem', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,  Method that subclasses may call for standard handling of an exception thrown when  calling constructor or factory method.,19.0,"['subclasses may call for standard handling of an exception thrown when calling a factory method', 'subclasses may call for standard handling of an exception thrown when calling a method', 'Method that subclasses call for standard handling of an exception thrown when calling a factory method']"
323,cucumber-reporting,net/masterthought/cucumber/Trends.java,/src/main/java/net/masterthought/cucumber/Trends.java,fillMissingDurations,227-235,"/**
     * Since durations were added later there is need to fill missing data for those statuses.
     */
private void fillMissingDurations(){
    long[] extendedArray = new long[buildNumbers.length];
    Arrays.fill(extendedArray, -1);
    System.arraycopy(durations, 0, extendedArray, buildNumbers.length - durations.length, durations.length);
    durations = extendedArray;
}","private void fillMissingDurations(){
    long[] extendedArray = new long[buildNumbers.length];
    Arrays.fill(extendedArray, -1);
    System.arraycopy(durations, 0, extendedArray, buildNumbers.length - durations.length, durations.length);
    durations = extendedArray;
}","/**
     * Since durations were added later there is need to fill missing data for those statuses.
     */","('fillMissingDurations', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",57.0,  Since durations were added later there is need to fill missing data for those statuses.,16.0,"['There is a need to fill in missing data for those statuses since durations were added later.', 'There is a need to fill in missing data for those statuses.', 'Since durations were added later there is need to fill missing data.']"
324,mybatis-3,org/apache/ibatis/io/ResolverUtil.java,/src/main/java/org/apache/ibatis/io/ResolverUtil.java,findImplementations,185-208,"/**
   * Attempts to discover classes that are assignable to the type provided. In the case
   * that an interface is provided this method will collect implementations. In the case
   * of a non-interface class, subclasses will be collected.  Accumulated classes can be
   * accessed by calling {@link #getClasses()}.
   *
   * @param parent
   *          the class of interface to find subclasses or implementations of
   * @param packageNames
   *          one or more package names to scan (including subpackages) for classes
   * @return the resolver util
   */
public ResolverUtil<T> findImplementations(Class<?> parent, String... packageNames){
    if (packageNames == null) {
        return this;
    }
    Test test = new IsA(parent);
    for (String pkg : packageNames) {
        find(test, pkg);
    }
    return this;
}","public ResolverUtil<T> findImplementations(Class<?> parent, String... packageNames){
    if (packageNames == null) {
        return this;
    }
    Test test = new IsA(parent);
    for (String pkg : packageNames) {
        find(test, pkg);
    }
    return this;
}","/**
   * Attempts to discover classes that are assignable to the type provided. In the case
   * that an interface is provided this method will collect implementations. In the case
   * of a non-interface class, subclasses will be collected.  Accumulated classes can be
   * accessed by calling {@link #getClasses()}.
   *
   * @param parent
   *          the class of interface to find subclasses or implementations of
   * @param packageNames
   *          one or more package names to scan (including subpackages) for classes
   * @return the resolver util
   */","('findImplementations', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",58.0,  Attempts to discover classes that are assignable to the type provided.,12.0,"['Attempts to find classes that are assignable.', 'Attempts to discover classes that are assignable.', 'Attempts to find classes that can be assigned to a type.']"
325,matsim-libs,org/matsim/core/config/Config.java,/matsim/src/main/java/org/matsim/core/config/Config.java,createModule,226-243,"/**
	 * Creates a new module / config-group with the specified name.
	 *
	 * @param name
	 *            The name of the config-group to be created.
	 *
	 * @return the newly created config group
	 * @throws IllegalArgumentException
	 *             if a config-group with the specified name already exists.
	 */
public final ConfigGroup createModule(final String name){
    if (this.modules.containsKey(name)) {
        throw new IllegalArgumentException(""Module "" + name + "" exists already."");
    }
    ConfigGroup m = new ConfigGroup(name);
    this.modules.put(name, m);
    return m;
}","public final ConfigGroup createModule(final String name){
    if (this.modules.containsKey(name)) {
        throw new IllegalArgumentException(""Module "" + name + "" exists already."");
    }
    ConfigGroup m = new ConfigGroup(name);
    this.modules.put(name, m);
    return m;
}","/**
	 * Creates a new module / config-group with the specified name.
	 *
	 * @param name
	 *            The name of the config-group to be created.
	 *
	 * @return the newly created config group
	 * @throws IllegalArgumentException
	 *             if a config-group with the specified name already exists.
	 */","('createModule', {'INSTRUCTION': {'covered': 18, 'missed': 6}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",58.0,  Creates a new module / config-group with the specified name.,11.0,"['The specified name is used to create a new module.', 'A new module is created with the specified name.', 'A new module is created with the name specified.']"
326,weblogic-kubernetes-operator,oracle/kubernetes/json/SchemaGenerator.java,/json-schema-generator/src/main/java/oracle/kubernetes/json/SchemaGenerator.java,useKubernetesVersion,97-111,"/**
   * Specifies the version of the Kubernetes schema to use.
   *
   * @param version a Kubernetes version string, such as ""1.9.0""
   * @throws IOException if no schema for that version is cached.
   */
public void useKubernetesVersion(String version) throws IOException{
    KubernetesSchemaReference reference = KubernetesSchemaReference.create(version);
    URL cacheUrl = reference.getKubernetesSchemaCacheUrl();
    if (cacheUrl == null) {
        throw new IOException(""No schema cached for Kubernetes "" + version);
    }
    addExternalSchema(reference.getKubernetesSchemaUrl(), cacheUrl);
}","public void useKubernetesVersion(String version) throws IOException{
    KubernetesSchemaReference reference = KubernetesSchemaReference.create(version);
    URL cacheUrl = reference.getKubernetesSchemaCacheUrl();
    if (cacheUrl == null) {
        throw new IOException(""No schema cached for Kubernetes "" + version);
    }
    addExternalSchema(reference.getKubernetesSchemaUrl(), cacheUrl);
}","/**
   * Specifies the version of the Kubernetes schema to use.
   *
   * @param version a Kubernetes version string, such as ""1.9.0""
   * @throws IOException if no schema for that version is cached.
   */","('useKubernetesVersion', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",58.0,  Specifies the version of the Kubernetes schema to use.,10.0,"['The version of the database to use is specified.', 'The version of the database to use is given.', 'The version that is used is specified.']"
327,cdk,org/openscience/cdk/charges/InductivePartialCharges.java,/tool/charges/src/main/java/org/openscience/cdk/charges/InductivePartialCharges.java,calculateSquaredDistanceBetweenTwoAtoms,372-387,"/**
     *  Evaluate the square of the Euclidean distance between two atoms.
     *
     *@param  atom1  first atom
     *@param  atom2  second atom
     *@return        squared distance between the 2 atoms
     */
private double calculateSquaredDistanceBetweenTwoAtoms(IAtom atom1, IAtom atom2){
    double distance = 0;
    double tmp = 0;
    Point3d firstPoint = atom1.getPoint3d();
    Point3d secondPoint = atom2.getPoint3d();
    tmp = firstPoint.distance(secondPoint);
    distance = tmp * tmp;
    return distance;
}","private double calculateSquaredDistanceBetweenTwoAtoms(IAtom atom1, IAtom atom2){
    double distance = 0;
    double tmp = 0;
    Point3d firstPoint = atom1.getPoint3d();
    Point3d secondPoint = atom2.getPoint3d();
    tmp = firstPoint.distance(secondPoint);
    distance = tmp * tmp;
    return distance;
}","/**
     *  Evaluate the square of the Euclidean distance between two atoms.
     *
     *@param  atom1  first atom
     *@param  atom2  second atom
     *@return        squared distance between the 2 atoms
     */","('calculateSquaredDistanceBetweenTwoAtoms', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",58.0,  Evaluate the square of the Euclidean distance between two atoms.,11.0,"['Evaluate the distance between the two atoms.', 'Evaluate the distance between two atoms.', 'The distance between two atoms is evaluated.']"
328,jackson-databind,com/fasterxml/jackson/databind/module/SimpleModule.java,/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java,addValueInstantiator,470-486,"/**
     * Method for registering {@link ValueInstantiator} to use when deserializing
     * instances of type <code>beanType</code>.
     *<p>
     * Instantiator is
     * registered when module is registered for <code>ObjectMapper</code>.
     */
public SimpleModule addValueInstantiator(Class<?> beanType, ValueInstantiator inst){
    _checkNotNull(beanType, ""class to register value instantiator for"");
    _checkNotNull(inst, ""value instantiator"");
    if (_valueInstantiators == null) {
        _valueInstantiators = new SimpleValueInstantiators();
    }
    _valueInstantiators = _valueInstantiators.addValueInstantiator(beanType, inst);
    return this;
}","public SimpleModule addValueInstantiator(Class<?> beanType, ValueInstantiator inst){
    _checkNotNull(beanType, ""class to register value instantiator for"");
    _checkNotNull(inst, ""value instantiator"");
    if (_valueInstantiators == null) {
        _valueInstantiators = new SimpleValueInstantiators();
    }
    _valueInstantiators = _valueInstantiators.addValueInstantiator(beanType, inst);
    return this;
}","/**
     * Method for registering {@link ValueInstantiator} to use when deserializing
     * instances of type <code>beanType</code>.
     *<p>
     * Instantiator is
     * registered when module is registered for <code>ObjectMapper</code>.
     */","('addValueInstantiator', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",58.0,  Method for registering {@link ValueInstantiator} to use when deserializing  instances of type <code>beanType</code>.,23.0,"['When deserializing instances of type code>beanType/code>, the method for registration @link ValueInstantiator is needed.', 'When deserializing instances of type code>beanType/code>, the method for registering @link ValueInstantiator is needed.', 'When deserializing instances of type code>beanType/code>, the method for registering @link ValueInstantiator to use is needed.']"
329,logstash-logback-encoder,net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,/src/main/java/net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,appendPlaceHolder,460-471,"/**
     * Appends a placeholder indicating that some frames were not written.
     */
private void appendPlaceHolder(StringBuilder builder, int indent, int consecutiveExcluded, String message){
    indent(builder, indent);
    builder.append(ELLIPSIS).append("" "").append(consecutiveExcluded).append("" "").append(message).append(CoreConstants.LINE_SEPARATOR);
}","private void appendPlaceHolder(StringBuilder builder, int indent, int consecutiveExcluded, String message){
    indent(builder, indent);
    builder.append(ELLIPSIS).append("" "").append(consecutiveExcluded).append("" "").append(message).append(CoreConstants.LINE_SEPARATOR);
}","/**
     * Appends a placeholder indicating that some frames were not written.
     */","('appendPlaceHolder', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",59.0,  Appends a placeholder indicating that some frames were not written.,11.0,"['There is a placeholder indicating that some frames were not written.', 'There is a placeholder that indicates that some frames were not written.', 'There is a placeholder indicating that frames were not written.']"
330,cron-utils,com/cronutils/mapper/CronMapper.java,/src/main/java/com/cronutils/mapper/CronMapper.java,returnOnZeroExpression,238-250,"/**
     * Creates a Function that returns a On instance with zero value.
     *
     * @param name - Cron field name
     * @return new CronField -> CronField instance, never null
     */
 static Function<CronField, CronField> returnOnZeroExpression(final CronFieldName name){
    return field -> {
        final FieldConstraints constraints = FieldConstraintsBuilder.instance().forField(name).createConstraintsInstance();
        return new CronField(name, new On(new IntegerFieldValue(0)), constraints);
    };
}","static Function<CronField, CronField> returnOnZeroExpression(final CronFieldName name){
    return field -> {
        final FieldConstraints constraints = FieldConstraintsBuilder.instance().forField(name).createConstraintsInstance();
        return new CronField(name, new On(new IntegerFieldValue(0)), constraints);
    };
}","/**
     * Creates a Function that returns a On instance with zero value.
     *
     * @param name - Cron field name
     * @return new CronField -> CronField instance, never null
     */","('returnOnZeroExpression', {'INSTRUCTION': {'covered': 3, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",59.0,  Creates a Function that returns a On instance with zero value.,12.0,"['A function creates a On instance with zero value.', 'A function that returns a On instance with zero value was created.', 'A function that returns a On instance with zero value is created.']"
331,matsim-libs,org/matsim/contrib/analysis/spatial/SpatialInterpolation.java,/contribs/analysis/src/main/java/org/matsim/contrib/analysis/spatial/SpatialInterpolation.java,calculateWeightFromPoint,41-57,"/**
     * This uses an exponential distance weighting to calculate the impact of point based emissions onto the centroid of
     * a grid cell. The calculation is described in Kickhoefer's PhD thesis https://depositonce.tu-berlin.de/handle/11303/4386
     * in Appendix A.2
     *
     * @param emissionSource Centroid of the link
     * @param cellCentroid   Centroid of the impacted cell
     * @return weight factor by which the emission value should be multiplied to calculate the impact of the cell
     */
public static double calculateWeightFromPoint(final Coordinate emissionSource, final Coordinate cellCentroid, double smoothingRadius){
    if (smoothingRadius <= 0)
        throw new IllegalArgumentException(""smoothing radius must be greater 0"");
    double dist = emissionSource.distance(cellCentroid);
    return Math.exp((-dist * dist) / (smoothingRadius * smoothingRadius));
}","public static double calculateWeightFromPoint(final Coordinate emissionSource, final Coordinate cellCentroid, double smoothingRadius){
    if (smoothingRadius <= 0)
        throw new IllegalArgumentException(""smoothing radius must be greater 0"");
    double dist = emissionSource.distance(cellCentroid);
    return Math.exp((-dist * dist) / (smoothingRadius * smoothingRadius));
}","/**
     * This uses an exponential distance weighting to calculate the impact of point based emissions onto the centroid of
     * a grid cell. The calculation is described in Kickhoefer's PhD thesis https://depositonce.tu-berlin.de/handle/11303/4386
     * in Appendix A.2
     *
     * @param emissionSource Centroid of the link
     * @param cellCentroid   Centroid of the impacted cell
     * @return weight factor by which the emission value should be multiplied to calculate the impact of the cell
     */","('calculateWeightFromPoint', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,  This uses an exponential distance weighting to calculate the impact of point based emissions onto the centroid of  a grid cell.,22.0,"['The impact of point based emissions onto the centroid of a grid cell is calculated using an exponential distance weighting.', 'The impact of point based emissions onto the centroid of a grid cell is calculated using an exponential distance weight.', 'The impact of point based emissions onto the centroid of a grid cell is calculated using an exponential distance weightage.']"
332,weblogic-kubernetes-operator,oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,verifyMachinesConfigured,290-311,"/**
   * Verify whether the WebLogic domain already has all the machines configured for use by the
   * dynamic cluster. For example, if machineNamePrefix is ""domain1-cluster1-machine"" and
   * numMachinesNeeded is 2, this method return true if machines named ""domain1-cluster1-machine1""
   * and ""domain1-cluster1-machine2"" are configured in the WebLogic domain.
   *
   * @param machineNamePrefix Prefix of the names of the machines
   * @param numMachinesNeeded Number of machines needed for this dynamic cluster
   * @return True if the WebLogic domain already has all the machines configured, or if there is no
   *     WlsDomainConfig object associated with this cluster, in which case we cannot perform the
   *     verification, or if machineNamePrefix is null, false otherwise
   */
 boolean verifyMachinesConfigured(String machineNamePrefix, int numMachinesNeeded){
    if (wlsDomainConfig != null && machineNamePrefix != null) {
        for (int suffix = 1; suffix <= numMachinesNeeded; suffix++) {
            if (wlsDomainConfig.getMachineConfig(machineNamePrefix + suffix) == null) {
                return false;
            }
        }
    }
    return true;
}","boolean verifyMachinesConfigured(String machineNamePrefix, int numMachinesNeeded){
    if (wlsDomainConfig != null && machineNamePrefix != null) {
        for (int suffix = 1; suffix <= numMachinesNeeded; suffix++) {
            if (wlsDomainConfig.getMachineConfig(machineNamePrefix + suffix) == null) {
                return false;
            }
        }
    }
    return true;
}","/**
   * Verify whether the WebLogic domain already has all the machines configured for use by the
   * dynamic cluster. For example, if machineNamePrefix is ""domain1-cluster1-machine"" and
   * numMachinesNeeded is 2, this method return true if machines named ""domain1-cluster1-machine1""
   * and ""domain1-cluster1-machine2"" are configured in the WebLogic domain.
   *
   * @param machineNamePrefix Prefix of the names of the machines
   * @param numMachinesNeeded Number of machines needed for this dynamic cluster
   * @return True if the WebLogic domain already has all the machines configured, or if there is no
   *     WlsDomainConfig object associated with this cluster, in which case we cannot perform the
   *     verification, or if machineNamePrefix is null, false otherwise
   */","('verifyMachinesConfigured', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,  Verify whether the WebLogic domain already has all the machines configured for use by the  dynamic cluster.,18.0,"['Do you know if the WebLogic domain has all the machines configured for use in the dynamic cluster?', 'Do you know if the WebLogic domain has all the machines configured for use by the dynamic cluster?', 'Do you know if the WebLogic domain already has all the machines configured for use by the dynamic cluster?']"
333,cdk,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,cyclesOfSizeFiveOrSix,384-397,"/**
     * Locate all 5 and 6 member cycles (rings) in a structure representation.
     *
     * @param container structure representation
     * @param graph     adjacency list graph representation of structure
     * @return closed walks (first = last vertex) of the cycles
     */
 static int[][] cyclesOfSizeFiveOrSix(IAtomContainer container, int[][] graph){
    try {
        return Cycles.all(6).find(container, graph, 6).paths();
    } catch (Intractable intractable) {
        return new int[0][];
    }
}","static int[][] cyclesOfSizeFiveOrSix(IAtomContainer container, int[][] graph){
    try {
        return Cycles.all(6).find(container, graph, 6).paths();
    } catch (Intractable intractable) {
        return new int[0][];
    }
}","/**
     * Locate all 5 and 6 member cycles (rings) in a structure representation.
     *
     * @param container structure representation
     * @param graph     adjacency list graph representation of structure
     * @return closed walks (first = last vertex) of the cycles
     */","('cyclesOfSizeFiveOrSix', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,Locate all 5 and 6 member cycles (rings) in a structure representation.,15.0,"['There are 5 and 6 member cycles in a structure representation.', 'All 5 and 6 member cycles are in a structure representation.', 'There are 5 and 6 member cycles.']"
334,matsim-libs,org/matsim/contrib/osm/networkReader/SupersonicOsmNetworkReader.java,/contribs/osm/src/main/java/org/matsim/contrib/osm/networkReader/SupersonicOsmNetworkReader.java,adjustFreespeed,64-77,"/**
     * Creates a function to adjust the freespeed for urban links.
     * @see LinkProperties#DEFAULT_FREESPEED_FACTOR
     *
     * @apiNote Can be used as example, but no public access currently
     */
 static AfterLinkCreated adjustFreespeed(final double factor){
    return (link, osmTags, direction) -> {
        if (osmTags.containsKey(OsmTags.MAXSPEED)) {
            if (link.getFreespeed() < 51 / 3.6)
                link.setFreespeed(link.getFreespeed() * factor);
        }
    };
}","static AfterLinkCreated adjustFreespeed(final double factor){
    return (link, osmTags, direction) -> {
        if (osmTags.containsKey(OsmTags.MAXSPEED)) {
            if (link.getFreespeed() < 51 / 3.6)
                link.setFreespeed(link.getFreespeed() * factor);
        }
    };
}","/**
     * Creates a function to adjust the freespeed for urban links.
     * @see LinkProperties#DEFAULT_FREESPEED_FACTOR
     *
     * @apiNote Can be used as example, but no public access currently
     */","('adjustFreespeed', {'INSTRUCTION': {'covered': 3, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,  Creates a function to adjust the freespeed for urban links.,11.0,"['The function adjusts the freespeed for urban links.', 'The function was created to adjust the freespeed for urban links.', 'The function was created to adjust the freespeed.']"
335,cdk,org/openscience/cdk/formula/AdductFormula.java,/base/data/src/main/java/org/openscience/cdk/formula/AdductFormula.java,contains,111-128,"/**
     *  True, if the AdductFormula contains the given IIsotope object and not
     *  the instance. The method looks for other isotopes which has the same
     *  symbol, natural abundance and exact mass.
     *
     * @param  isotope  The IIsotope this AdductFormula is searched for
     * @return          True, if the AdductFormula contains the given isotope object
     */
public boolean contains(IIsotope isotope){
    for (Iterator<IIsotope> it = isotopes().iterator(); it.hasNext(); ) {
        IIsotope thisIsotope = it.next();
        if (isTheSame(thisIsotope, isotope)) {
            return true;
        }
    }
    return false;
}","public boolean contains(IIsotope isotope){
    for (Iterator<IIsotope> it = isotopes().iterator(); it.hasNext(); ) {
        IIsotope thisIsotope = it.next();
        if (isTheSame(thisIsotope, isotope)) {
            return true;
        }
    }
    return false;
}","/**
     *  True, if the AdductFormula contains the given IIsotope object and not
     *  the instance. The method looks for other isotopes which has the same
     *  symbol, natural abundance and exact mass.
     *
     * @param  isotope  The IIsotope this AdductFormula is searched for
     * @return          True, if the AdductFormula contains the given isotope object
     */","('contains', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,"  True, if the AdductFormula contains the given IIsotope object and not  the instance.",15.0,"[""If the AdductFormula contains the IIsotope object, it's true."", 'If the AdductFormula contains the IIsotope object, it is true.', ""If the AdductFormula contains the IIsotope object, then it's true.""]"
336,seata,io/seata/common/util/NetUtil.java,/common/src/main/java/io/seata/common/util/NetUtil.java,convertIpIfNecessary,233-249,"/**
     * convert ip if necessary
     *
     * @param ip
     * @return java.lang.String
     */
private static String convertIpIfNecessary(String ip){
    if (IP_PATTERN.matcher(ip).matches()) {
        return ip;
    } else {
        try {
            return InetAddress.getByName(ip).getHostAddress();
        } catch (UnknownHostException e) {
            throw new RuntimeException(e);
        }
    }
}","private static String convertIpIfNecessary(String ip){
    if (IP_PATTERN.matcher(ip).matches()) {
        return ip;
    } else {
        try {
            return InetAddress.getByName(ip).getHostAddress();
        } catch (UnknownHostException e) {
            throw new RuntimeException(e);
        }
    }
}","/**
     * convert ip if necessary
     *
     * @param ip
     * @return java.lang.String
     */","('convertIpIfNecessary', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,  convert ip if necessary   @param ip  @return java.,11.0,"[""If it's necessary, return java."", ""If it's necessary, convert the address if necessary."", ""If it's necessary, convert the address to java.""]"
337,liquibase,liquibase/change/ChangeFactory.java,/liquibase-core/src/main/java/liquibase/change/ChangeFactory.java,create,81-95,"/**
     * Create a new Change implementation for the given change name. The class of the constructed object will be the Change implementation with the highest priority.
     * Each call to create will return a new instance of the Change.
     */
public Change create(String name){
    Change plugin = getPlugin(name);
    if (plugin == null) {
        return null;
    }
    try {
        return plugin.getClass().getConstructor().newInstance();
    } catch (Exception e) {
        throw new UnexpectedLiquibaseException(e);
    }
}","public Change create(String name){
    Change plugin = getPlugin(name);
    if (plugin == null) {
        return null;
    }
    try {
        return plugin.getClass().getConstructor().newInstance();
    } catch (Exception e) {
        throw new UnexpectedLiquibaseException(e);
    }
}","/**
     * Create a new Change implementation for the given change name. The class of the constructed object will be the Change implementation with the highest priority.
     * Each call to create will return a new instance of the Change.
     */","('create', {'INSTRUCTION': {'covered': 24, 'missed': 6}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,  Create a new Change implementation for the given change name.,11.0,"['Change implementation created for given change name', 'Change implementation created for given change name.', 'Change implementation created for the given name.']"
339,mybatis-3,org/apache/ibatis/io/ResolverUtil.java,/src/main/java/org/apache/ibatis/io/ResolverUtil.java,findAnnotated,210-231,"/**
   * Attempts to discover classes that are annotated with the annotation. Accumulated
   * classes can be accessed by calling {@link #getClasses()}.
   *
   * @param annotation
   *          the annotation that should be present on matching classes
   * @param packageNames
   *          one or more package names to scan (including subpackages) for classes
   * @return the resolver util
   */
public ResolverUtil<T> findAnnotated(Class<? extends Annotation> annotation, String... packageNames){
    if (packageNames == null) {
        return this;
    }
    Test test = new AnnotatedWith(annotation);
    for (String pkg : packageNames) {
        find(test, pkg);
    }
    return this;
}","public ResolverUtil<T> findAnnotated(Class<? extends Annotation> annotation, String... packageNames){
    if (packageNames == null) {
        return this;
    }
    Test test = new AnnotatedWith(annotation);
    for (String pkg : packageNames) {
        find(test, pkg);
    }
    return this;
}","/**
   * Attempts to discover classes that are annotated with the annotation. Accumulated
   * classes can be accessed by calling {@link #getClasses()}.
   *
   * @param annotation
   *          the annotation that should be present on matching classes
   * @param packageNames
   *          one or more package names to scan (including subpackages) for classes
   * @return the resolver util
   */","('findAnnotated', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,  Attempts to discover classes that are annotated with the annotation.,11.0,"['Attempts to find classes that are annotated.', 'Attempts to find classes that have been annotated.', 'Attempts to discover classes that are annotated.']"
340,cdk,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,correctMass,838-854,"/**
     * Correct the mass according the charge of the IMmoleculeFormula.
     * Negative charge will add the mass of one electron to the mass.
     *
     * @param mass      The mass to correct
     * @param charge    The charge
     * @return          The mass with the correction
     */
private static double correctMass(double mass, Integer charge){
    if (charge == null)
        return mass;
    double massE = 0.00054857990927;
    if (charge > 0)
        mass -= massE * charge;
    else if (charge < 0)
        mass += massE * Math.abs(charge);
    return mass;
}","private static double correctMass(double mass, Integer charge){
    if (charge == null)
        return mass;
    double massE = 0.00054857990927;
    if (charge > 0)
        mass -= massE * charge;
    else if (charge < 0)
        mass += massE * Math.abs(charge);
    return mass;
}","/**
     * Correct the mass according the charge of the IMmoleculeFormula.
     * Negative charge will add the mass of one electron to the mass.
     *
     * @param mass      The mass to correct
     * @param charge    The charge
     * @return          The mass with the correction
     */","('correctMass', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,  Correct the mass according the charge of the IMmoleculeFormula.,10.0,"['Correct the mass according to the charge.', 'Correct the mass according to the charge of the formula.', 'Correct the mass according to the charge of the molecule.']"
341,cdk,org/openscience/cdk/renderer/RendererModel.java,/display/render/src/main/java/org/openscience/cdk/renderer/RendererModel.java,fireChange,404-415,"/**
     * Notifies registered listeners of certain changes that have occurred in
     * this model.
     */
public void fireChange(){
    if (getNotification() && listeners != null) {
        EventObject event = new EventObject(this);
        for (int i = 0; i < listeners.size(); i++) {
            listeners.get(i).stateChanged(event);
        }
    }
}","public void fireChange(){
    if (getNotification() && listeners != null) {
        EventObject event = new EventObject(this);
        for (int i = 0; i < listeners.size(); i++) {
            listeners.get(i).stateChanged(event);
        }
    }
}","/**
     * Notifies registered listeners of certain changes that have occurred in
     * this model.
     */","('fireChange', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,  Notifies registered listeners of certain changes that have occurred in  this model.,13.0,"['Changes have occurred in this model.', 'There have been changes in this model.', 'Changes that have occurred in this model have been notified.']"
342,tablesaw,tech/tablesaw/columns/numbers/NumberMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/numbers/NumberMapFunctions.java,neg,336-346,"/**
   * For each item in the column, returns the same number with the sign changed. For example: -1.3
   * returns 1.3, 2.135 returns -2.135 0 returns 0
   */
 DoubleColumn neg(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[neg]"", size());
    for (int i = 0; i < size(); i++) {
        newColumn.set(i, getDouble(i) * -1);
    }
    return newColumn;
}","DoubleColumn neg(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[neg]"", size());
    for (int i = 0; i < size(); i++) {
        newColumn.set(i, getDouble(i) * -1);
    }
    return newColumn;
}","/**
   * For each item in the column, returns the same number with the sign changed. For example: -1.3
   * returns 1.3, 2.135 returns -2.135 0 returns 0
   */","('neg', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,"  For each item in the column, returns the same number with the sign changed.",16.0,"['The same number is returned for each item in the column.', 'Each item in the column returns the same number.', 'The same number is returned for each item in the column']"
343,cdk,org/openscience/cdk/group/Permutation.java,/tool/group/src/main/java/org/openscience/cdk/group/Permutation.java,multiply,197-210,"/**
     * Multiply this permutation by another such that for all i,
     * this[i] = this[other[i]].
     *
     * @param other the other permutation to use
     * @return a new permutation with the result of multiplying the permutations
     */
public Permutation multiply(Permutation other){
    Permutation newPermutation = new Permutation(values.length);
    for (int i = 0; i < values.length; i++) {
        newPermutation.values[i] = this.values[other.values[i]];
    }
    return newPermutation;
}","public Permutation multiply(Permutation other){
    Permutation newPermutation = new Permutation(values.length);
    for (int i = 0; i < values.length; i++) {
        newPermutation.values[i] = this.values[other.values[i]];
    }
    return newPermutation;
}","/**
     * Multiply this permutation by another such that for all i,
     * this[i] = this[other[i]].
     *
     * @param other the other permutation to use
     * @return a new permutation with the result of multiplying the permutations
     */","('multiply', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",60.0,"  Multiply this permutation by another such that for all i,  this[i] = this[other[i]].",24.0,"['Multiply this permutation by another such that for all of us.', 'Multiply this permutation by another such that it is for all of us.', 'Multiply this permutation by another such that for all of me.']"
344,matsim-libs,org/matsim/contrib/osm/networkReader/LinkProperties.java,/contribs/osm/src/main/java/org/matsim/contrib/osm/networkReader/LinkProperties.java,calculateSpeedIfNoSpeedTag,174-188,"/**
	 * For links with unknown max speed we assume that links with a length of less than 300m are urban links. For urban
	 * links with a length of 0m the speed is 10km/h. For links with a length of 300m the speed is the default freespeed
	 * property for that highway type. For links with a length between 0 and 300m the speed is interpolated linearly.
	 * (2.778m/s ~ 10km/h)
	 *
	 * All links longer than 300m the default freesped property is assumed
	 */
public static double calculateSpeedIfNoSpeedTag(double linkLength, LinkProperties properties){
    if (properties.hierarchyLevel > LinkProperties.LEVEL_MOTORWAY && properties.hierarchyLevel <= LinkProperties.LEVEL_TERTIARY && linkLength <= 300) {
        return ((2.7778 + (properties.freespeed - 2.7778) / 300 * linkLength));
    }
    return properties.freespeed;
}","public static double calculateSpeedIfNoSpeedTag(double linkLength, LinkProperties properties){
    if (properties.hierarchyLevel > LinkProperties.LEVEL_MOTORWAY && properties.hierarchyLevel <= LinkProperties.LEVEL_TERTIARY && linkLength <= 300) {
        return ((2.7778 + (properties.freespeed - 2.7778) / 300 * linkLength));
    }
    return properties.freespeed;
}","/**
	 * For links with unknown max speed we assume that links with a length of less than 300m are urban links. For urban
	 * links with a length of 0m the speed is 10km/h. For links with a length of 300m the speed is the default freespeed
	 * property for that highway type. For links with a length between 0 and 300m the speed is interpolated linearly.
	 * (2.778m/s ~ 10km/h)
	 *
	 * All links longer than 300m the default freesped property is assumed
	 */","('calculateSpeedIfNoSpeedTag', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,For links with unknown max speed we assume that links with a length of less than 300m are urban links.,21.0,"['We assume links with a length of less than 300m are urban links for links with unknown max speed.', 'We assume links with a length of less than 300m are urban links.', 'We assume that links with a length of less than 300m are urban links.']"
345,cdk,org/openscience/cdk/geometry/cip/CIPTool.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/CIPTool.java,checkIfAllLigandsAreDifferent,220-233,"/**
     * Checks if each next {@link ILigand} is different from the previous
     * one according to the {@link CIPLigandRule}. It assumes that the input
     * is sorted based on that rule.
     *
     * @param ligands array of {@link ILigand} to check
     * @return true, if all ligands are different
     */
public static boolean checkIfAllLigandsAreDifferent(ILigand[] ligands){
    for (int i = 0; i < (ligands.length - 1); i++) {
        if (cipRule.compare(ligands[i], ligands[i + 1]) == 0)
            return false;
    }
    return true;
}","public static boolean checkIfAllLigandsAreDifferent(ILigand[] ligands){
    for (int i = 0; i < (ligands.length - 1); i++) {
        if (cipRule.compare(ligands[i], ligands[i + 1]) == 0)
            return false;
    }
    return true;
}","/**
     * Checks if each next {@link ILigand} is different from the previous
     * one according to the {@link CIPLigandRule}. It assumes that the input
     * is sorted based on that rule.
     *
     * @param ligands array of {@link ILigand} to check
     * @return true, if all ligands are different
     */","('checkIfAllLigandsAreDifferent', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,  Checks if each next {@link ILigand} is different from the previous  one according to the {@link CIPLigandRule}.,24.0,"['Checks if the next @link ILigand is the same as the previous one.', 'Checks if the previous one is different from the next one.', 'Checks if the next @link ILigand is different from the previous one.']"
346,metrics,io/dropwizard/metrics5/health/HealthCheckRegistry.java,/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/HealthCheckRegistry.java,unregister,112-128,"/**
     * Unregisters the application {@link HealthCheck} with the given name.
     *
     * @param name the name of the {@link HealthCheck} instance
     */
public void unregister(String name){
    HealthCheck healthCheck;
    synchronized (lock) {
        healthCheck = healthChecks.remove(name);
        if (healthCheck instanceof AsyncHealthCheckDecorator) {
            ((AsyncHealthCheckDecorator) healthCheck).tearDown();
        }
    }
    if (healthCheck != null) {
        onHealthCheckRemoved(name, healthCheck);
    }
}","public void unregister(String name){
    HealthCheck healthCheck;
    synchronized (lock) {
        healthCheck = healthChecks.remove(name);
        if (healthCheck instanceof AsyncHealthCheckDecorator) {
            ((AsyncHealthCheckDecorator) healthCheck).tearDown();
        }
    }
    if (healthCheck != null) {
        onHealthCheckRemoved(name, healthCheck);
    }
}","/**
     * Unregisters the application {@link HealthCheck} with the given name.
     *
     * @param name the name of the {@link HealthCheck} instance
     */","('unregister', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,  Unregisters the application {@link HealthCheck} with the given name.,13.0,"['The application is not registered with the given name.', 'Unregisters the application with the given name.', 'The application is unregistered with the given name.']"
347,matsim-libs,org/matsim/core/utils/geometry/CoordUtils.java,/matsim/src/main/java/org/matsim/core/utils/geometry/CoordUtils.java,calcProjectedEuclideanDistance,192-205,"/**
	 * Method to deal with distance calculation when only the x and y-components
	 * of the coordinates are used. The elevation (z component) is ignored,
	 * whether it is available or not. 
	 * (xy-plane)
	 * @param coord
	 * @param other
	 * @return
	 */
public static double calcProjectedEuclideanDistance(Coord coord, Coord other){
    double xDiff = other.getX() - coord.getX();
    double yDiff = other.getY() - coord.getY();
    return Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));
}","public static double calcProjectedEuclideanDistance(Coord coord, Coord other){
    double xDiff = other.getX() - coord.getX();
    double yDiff = other.getY() - coord.getY();
    return Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));
}","/**
	 * Method to deal with distance calculation when only the x and y-components
	 * of the coordinates are used. The elevation (z component) is ignored,
	 * whether it is available or not. 
	 * (xy-plane)
	 * @param coord
	 * @param other
	 * @return
	 */","('calcProjectedEuclideanDistance', {'INSTRUCTION': {'covered': 21, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,  Method to deal with distance calculation when only the x and y-components  of the coordinates are used.,18.0,"['When only the x and y-components of the coordinates are used, there is a method to deal with distance calculation.', 'When only the x and y-components of the coordinates are used, the method is used.', 'When only the x and y-components of the coordinates are used, there is a method for distance calculation.']"
348,cdk,org/openscience/cdk/pharmacophore/PharmacophoreQueryBond.java,/tool/pcore/src/main/java/org/openscience/cdk/pharmacophore/PharmacophoreQueryBond.java,matches,82-101,"/**
     * Checks whether the query distance constraint matches a target distance.
     * 
     * This method checks whether a query constraint is satisfied by an observed
     * distance (represented by a {@link PharmacophoreBond} in the target molecule.
     * Note that distance are compared upto 2 decimal places.
     *
     * @param bond The distance relationship in a target molecule
     * @return true if the target distance lies within the range of the query constraint
     */
public boolean matches(IBond bond){
    bond = BondRef.deref(bond);
    if (bond instanceof PharmacophoreBond) {
        PharmacophoreBond pbond = (PharmacophoreBond) bond;
        double bondLength = round(pbond.getBondLength(), 2);
        return bondLength >= lower && bondLength <= upper;
    } else
        return false;
}","public boolean matches(IBond bond){
    bond = BondRef.deref(bond);
    if (bond instanceof PharmacophoreBond) {
        PharmacophoreBond pbond = (PharmacophoreBond) bond;
        double bondLength = round(pbond.getBondLength(), 2);
        return bondLength >= lower && bondLength <= upper;
    } else
        return false;
}","/**
     * Checks whether the query distance constraint matches a target distance.
     * 
     * This method checks whether a query constraint is satisfied by an observed
     * distance (represented by a {@link PharmacophoreBond} in the target molecule.
     * Note that distance are compared upto 2 decimal places.
     *
     * @param bond The distance relationship in a target molecule
     * @return true if the target distance lies within the range of the query constraint
     */","('matches', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,  Checks whether the query distance constraint matches a target distance.,11.0,"['The query distance constraint is checked to see if it matches the target distance.', 'The query distance constraint is checked to see if it matches a target distance.', 'Checks if the query distance constraint matches the target distance.']"
349,matsim-libs,org/matsim/core/router/AStarEuclidean.java,/matsim/src/main/java/org/matsim/core/router/AStarEuclidean.java,visitNode,184-200,"/**
	 * Inserts the given Node n into the pendingNodes queue and updates its time and cost information.
	 * 
	 * @param n The Node that is revisited.
	 * @param data The data for node.
	 * @param pendingNodes The nodes visited and not processed yet.
	 * @param time The time of the visit of n.
	 * @param cost The accumulated cost at the time of the visit of n.
	 * @param expectedRemainingCost The expected remaining travel cost when
	 * traveling from n to the target node of the route.
	 * @param outLink The link from which we came visiting n.
	 */
private void visitNode(final Node n, final AStarNodeData data, final RouterPriorityQueue<Node> pendingNodes, final double time, final double cost, final double expectedRemainingCost, final Link outLink){
    data.setExpectedRemainingCost(expectedRemainingCost);
    super.visitNode(n, data, pendingNodes, time, cost, outLink);
}","private void visitNode(final Node n, final AStarNodeData data, final RouterPriorityQueue<Node> pendingNodes, final double time, final double cost, final double expectedRemainingCost, final Link outLink){
    data.setExpectedRemainingCost(expectedRemainingCost);
    super.visitNode(n, data, pendingNodes, time, cost, outLink);
}","/**
	 * Inserts the given Node n into the pendingNodes queue and updates its time and cost information.
	 * 
	 * @param n The Node that is revisited.
	 * @param data The data for node.
	 * @param pendingNodes The nodes visited and not processed yet.
	 * @param time The time of the visit of n.
	 * @param cost The accumulated cost at the time of the visit of n.
	 * @param expectedRemainingCost The expected remaining travel cost when
	 * traveling from n to the target node of the route.
	 * @param outLink The link from which we came visiting n.
	 */","('visitNode', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,  Inserts the given Node n into the pendingNodes queue and updates its time and cost information.,17.0,"['The given Node n is put into the pendingNodes queue and updated with time and cost information.', 'The given Node n is put into the pendingNodes queue and updated with its time and cost information.', 'The given Node n is put into the pendingNodes queue and updated.']"
350,tablesaw,tech/tablesaw/api/DoubleColumn.java,/core/src/main/java/tech/tablesaw/api/DoubleColumn.java,asIntColumn,566-594,"/**
   * Returns a new IntColumn containing a value for each value in this column, truncating if
   * necessary.
   *
   * <p>A narrowing primitive conversion such as this one may lose information about the overall
   * magnitude of a numeric value and may also lose precision and range. Specifically, if the value
   * is too small (a negative value of large magnitude or negative infinity), the result is the
   * smallest representable value of type int.
   *
   * <p>Similarly, if the value is too large (a positive value of large magnitude or positive
   * infinity), the result is the largest representable value of type int.
   *
   * <p>Despite the fact that overflow, underflow, or other loss of information may occur, a
   * narrowing primitive conversion never results in a run-time exception.
   *
   * <p>A missing value in the receiver is converted to a missing value in the result
   */
public IntColumn asIntColumn(){
    IntColumn result = IntColumn.create(name());
    for (double d : data) {
        if (DoubleColumnType.valueIsMissing(d)) {
            result.appendMissing();
        } else {
            result.append((int) d);
        }
    }
    return result;
}","public IntColumn asIntColumn(){
    IntColumn result = IntColumn.create(name());
    for (double d : data) {
        if (DoubleColumnType.valueIsMissing(d)) {
            result.appendMissing();
        } else {
            result.append((int) d);
        }
    }
    return result;
}","/**
   * Returns a new IntColumn containing a value for each value in this column, truncating if
   * necessary.
   *
   * <p>A narrowing primitive conversion such as this one may lose information about the overall
   * magnitude of a numeric value and may also lose precision and range. Specifically, if the value
   * is too small (a negative value of large magnitude or negative infinity), the result is the
   * smallest representable value of type int.
   *
   * <p>Similarly, if the value is too large (a positive value of large magnitude or positive
   * infinity), the result is the largest representable value of type int.
   *
   * <p>Despite the fact that overflow, underflow, or other loss of information may occur, a
   * narrowing primitive conversion never results in a run-time exception.
   *
   * <p>A missing value in the receiver is converted to a missing value in the result
   */","('asIntColumn', {'INSTRUCTION': {'covered': 27, 'missed': 4}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,"  Returns a new IntColumn containing a value for each value in this column, truncating if  necessary.",18.0,"['If necessary, returns a new IntColumn with a value for each value in it.', 'If necessary, returns a new IntColumn with a value for each value.', 'If necessary, returns a new IntColumn with a value for each value in the column.']"
351,cdk,org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,canDraw,279-306,"/**
     * Checks an atom to see if it should be drawn. There are three reasons
     * not to draw an atom - a) no coordinates, b) an invisible hydrogen or
     * c) an invisible carbon.
     *
     * @param atom the atom to check
     * @param container the atom container the atom is part of
     * @param model the renderer model
     * @return true if the atom should be drawn
     */
protected boolean canDraw(IAtom atom, IAtomContainer container, RendererModel model){
    if (!hasCoordinates(atom)) {
        return false;
    }
    if (invisibleHydrogen(atom, model)) {
        return false;
    }
    if (invisibleCarbon(atom, container, model)) {
        return false;
    }
    return true;
}","protected boolean canDraw(IAtom atom, IAtomContainer container, RendererModel model){
    if (!hasCoordinates(atom)) {
        return false;
    }
    if (invisibleHydrogen(atom, model)) {
        return false;
    }
    if (invisibleCarbon(atom, container, model)) {
        return false;
    }
    return true;
}","/**
     * Checks an atom to see if it should be drawn. There are three reasons
     * not to draw an atom - a) no coordinates, b) an invisible hydrogen or
     * c) an invisible carbon.
     *
     * @param atom the atom to check
     * @param container the atom container the atom is part of
     * @param model the renderer model
     * @return true if the atom should be drawn
     */","('canDraw', {'INSTRUCTION': {'covered': 21, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,  Checks an atom to see if it should be drawn.,11.0,"['The atom is checked to see if it should be drawn.', 'Checks the atom to see if it should be drawn.', 'If the atom should be drawn, the person checks it.']"
352,weblogic-kubernetes-operator,oracle/kubernetes/operator/helpers/ConfigMapSplitter.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/ConfigMapSplitter.java,split,45-62,"/**
   * Given a map, splits it so that no map has more total data than the specified limit, and returns a list of
   * target objects built from the resultant maps. This may result in some maps receiving partial value for the largest
   * items. If the target type implements CountRecorder, the 'recordCount' method of the first target will be invoked
   * with the number of targets created.
   *
   * @param data the map to split.
   */
public List<T> split(Map<String, String> data){
    startSplitResult();
    for (DataEntry dataEntry : getSortedEntrySizes(data)) {
        addToSplitResult(dataEntry);
    }
    recordSplitResult();
    recordTargetInfo(result.get(0), result.size());
    return result;
}","public List<T> split(Map<String, String> data){
    startSplitResult();
    for (DataEntry dataEntry : getSortedEntrySizes(data)) {
        addToSplitResult(dataEntry);
    }
    recordSplitResult();
    recordTargetInfo(result.get(0), result.size());
    return result;
}","/**
   * Given a map, splits it so that no map has more total data than the specified limit, and returns a list of
   * target objects built from the resultant maps. This may result in some maps receiving partial value for the largest
   * items. If the target type implements CountRecorder, the 'recordCount' method of the first target will be invoked
   * with the number of targets created.
   *
   * @param data the map to split.
   */","('split', {'INSTRUCTION': {'covered': 33, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,"  Given a map, splits it so that no map has more total data than the specified limit, and returns a list of  target objects built from the resultant maps.",32.0,"['If a map has more total data than the specified limit, it splits it so that no map has more target objects built from it.', 'If a map has more total data than the limit, it splits it so that no map has more target objects built from it.', 'If a map has more total data than the specified limit, it splits it so that no map has more target objects.']"
353,cdk,org/openscience/cdk/pharmacophore/PharmacophoreQueryAngleBond.java,/tool/pcore/src/main/java/org/openscience/cdk/pharmacophore/PharmacophoreQueryAngleBond.java,matches,85-104,"/**
     * Checks whether the query angle constraint matches a target distance.
     * 
     * This method checks whether a query constraint is satisfied by an observed
     * angle (represented by a {@link org.openscience.cdk.pharmacophore.PharmacophoreAngleBond} in the target molecule.
     * Note that angles are compared upto 2 decimal places.
     *
     * @param bond The angle relationship in a target molecule
     * @return true if the target angle lies within the range of the query constraint
     */
public boolean matches(IBond bond){
    bond = BondRef.deref(bond);
    if (bond instanceof PharmacophoreAngleBond) {
        PharmacophoreAngleBond pbond = (PharmacophoreAngleBond) bond;
        double bondLength = round(pbond.getBondLength(), 2);
        return bondLength >= lower && bondLength <= upper;
    } else
        return false;
}","public boolean matches(IBond bond){
    bond = BondRef.deref(bond);
    if (bond instanceof PharmacophoreAngleBond) {
        PharmacophoreAngleBond pbond = (PharmacophoreAngleBond) bond;
        double bondLength = round(pbond.getBondLength(), 2);
        return bondLength >= lower && bondLength <= upper;
    } else
        return false;
}","/**
     * Checks whether the query angle constraint matches a target distance.
     * 
     * This method checks whether a query constraint is satisfied by an observed
     * angle (represented by a {@link org.openscience.cdk.pharmacophore.PharmacophoreAngleBond} in the target molecule.
     * Note that angles are compared upto 2 decimal places.
     *
     * @param bond The angle relationship in a target molecule
     * @return true if the target angle lies within the range of the query constraint
     */","('matches', {'INSTRUCTION': {'covered': 29, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",61.0,  Checks whether the query angle constraint matches a target distance.,11.0,"['The query angle constraint is checked to see if it matches the target distance.', 'The query angle constraint is checked to see if it matches a target distance.', 'The query angle constraint is checked to see if it matches the distance.']"
354,matsim-libs,org/matsim/counts/Count.java,/matsim/src/main/java/org/matsim/counts/Count.java,createVolume,43-61,"/**
	 * Creates and adds a {@link Volume} to the {@link Count}ing station.
	 * @param h indicating the hour-of-day. <b><i>Note: the hours for a counting 
	 * 		station must be from 1-24, and <b><i>not</i></b> from 0-23, 
	 * 		otherwise the {@link MatsimCountsReader} will throw an error.
	 * 		</i></b>
	 * @param val the total number of vehicles counted during hour <code>h</code>.
	 * @return the {@link Count}ing station's {@link Volume}.
	 */
public final Volume createVolume(final int h, final double val){
    if (h < 1) {
        throw new RuntimeException(""counts start at 1, not at 0.  If you have a use case where you need to go below one, "" + ""let us know and we think about it, but so far we had numerous debugging sessions because someone inserted counts at 0."");
    }
    // overkill?
    Volume v = new Volume(h, val);
    this.volumes.put(Integer.valueOf(h), v);
    return v;
}","public final Volume createVolume(final int h, final double val){
    if (h < 1) {
        throw new RuntimeException(""counts start at 1, not at 0.  If you have a use case where you need to go below one, "" + ""let us know and we think about it, but so far we had numerous debugging sessions because someone inserted counts at 0."");
    }
    // overkill?
    Volume v = new Volume(h, val);
    this.volumes.put(Integer.valueOf(h), v);
    return v;
}","/**
	 * Creates and adds a {@link Volume} to the {@link Count}ing station.
	 * @param h indicating the hour-of-day. <b><i>Note: the hours for a counting 
	 * 		station must be from 1-24, and <b><i>not</i></b> from 0-23, 
	 * 		otherwise the {@link MatsimCountsReader} will throw an error.
	 * 		</i></b>
	 * @param val the total number of vehicles counted during hour <code>h</code>.
	 * @return the {@link Count}ing station's {@link Volume}.
	 */","('createVolume', {'INSTRUCTION': {'covered': 18, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",62.0,  Creates and adds a {@link Volume} to the {@link Count}ing station.,19.0,"['The @link Volume is added to the @link Counting station.', 'The @link Volume is added to the Counting station.', 'The @link Volume is added to the @link Counting station']"
355,tablesaw,tech/tablesaw/columns/numbers/NumberMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/numbers/NumberMapFunctions.java,logN,275-283,"/** Returns the natural log of the values in this column as a NumberColumn. */
 DoubleColumn logN(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[logN]"", size());
    for (int i = 0; i < size(); i++) {
        newColumn.set(i, Math.log(getDouble(i)));
    }
    return newColumn;
}","DoubleColumn logN(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[logN]"", size());
    for (int i = 0; i < size(); i++) {
        newColumn.set(i, Math.log(getDouble(i)));
    }
    return newColumn;
}",/** Returns the natural log of the values in this column as a NumberColumn. */,"('logN', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",62.0, Returns the natural log of the values in this column as a NumberColumn.,14.0,"['The natural log of the values in this column is returned.', 'The natural log of the values is returned as a NumberColumn.', 'The natural log of the values in this column is returned as a NumberColumn.']"
356,tablesaw,tech/tablesaw/columns/numbers/NumberMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/numbers/NumberMapFunctions.java,log10,285-292,"/** Returns the base 10 log of the values in this column as a NumberColumn. */
 DoubleColumn log10(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[log10]"", size());
    for (int i = 0; i < size(); i++) {
        newColumn.set(i, Math.log10(getDouble(i)));
    }
    return newColumn;
}","DoubleColumn log10(){
    DoubleColumn newColumn = DoubleColumn.create(name() + ""[log10]"", size());
    for (int i = 0; i < size(); i++) {
        newColumn.set(i, Math.log10(getDouble(i)));
    }
    return newColumn;
}",/** Returns the base 10 log of the values in this column as a NumberColumn. */,"('log10', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",62.0,Returns the base 10 log of the values in this column as a NumberColumn.,15.0,"['The base 10 log of the values is returned as a NumberColumn.', 'The base 10 log of the values is returned as a number column.', 'The base 10 log of the values in this column is returned.']"
357,cdk,org/openscience/cdk/AtomContainer.java,/base/data/src/main/java/org/openscience/cdk/AtomContainer.java,grow,1415-1432,"/**
     * Generic grow function, expand an array by a varried amount to have
     * enough (required) space.
     *
     * @param array    the array to expand
     * @param required the minimum required space
     * @param <T>      array type
     * @return the expanded array
     */
private static T[] grow(T[] array, int required){
    int oldCapacity = array.length;
    int newCapacity = oldCapacity == 0 ? DEFAULT_CAPACITY : oldCapacity + (oldCapacity >> 1);
    if (newCapacity < required)
        newCapacity = required;
    return Arrays.copyOf(array, newCapacity);
}","private static T[] grow(T[] array, int required){
    int oldCapacity = array.length;
    int newCapacity = oldCapacity == 0 ? DEFAULT_CAPACITY : oldCapacity + (oldCapacity >> 1);
    if (newCapacity < required)
        newCapacity = required;
    return Arrays.copyOf(array, newCapacity);
}","/**
     * Generic grow function, expand an array by a varried amount to have
     * enough (required) space.
     *
     * @param array    the array to expand
     * @param required the minimum required space
     * @param <T>      array type
     * @return the expanded array
     */","('grow', {'INSTRUCTION': {'covered': 20, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",62.0,"  Generic grow function, expand an array by a varried amount to have  enough (required) space.",19.0,"['The grow function expands an array by the varried amount.', 'A generic grow function expands an array by the varried amount.', 'A generic grow function expands an array by a certain amount.']"
358,tablesaw,tech/tablesaw/api/IntColumn.java,/core/src/main/java/tech/tablesaw/api/IntColumn.java,indexColumn,71-84,"/**
   * Returns a new numeric column initialized with the given name and size. The values in the column
   * are integers beginning at startsWith and continuing through size (exclusive), monotonically
   * increasing by 1 TODO consider a generic fill function including steps or random samples from
   * various distributions
   */
public static IntColumn indexColumn(final String columnName, final int size, final int startsWith){
    final IntColumn indexColumn = IntColumn.create(columnName, size);
    for (int i = 0; i < size; i++) {
        indexColumn.set(i, i + startsWith);
    }
    return indexColumn;
}","public static IntColumn indexColumn(final String columnName, final int size, final int startsWith){
    final IntColumn indexColumn = IntColumn.create(columnName, size);
    for (int i = 0; i < size; i++) {
        indexColumn.set(i, i + startsWith);
    }
    return indexColumn;
}","/**
   * Returns a new numeric column initialized with the given name and size. The values in the column
   * are integers beginning at startsWith and continuing through size (exclusive), monotonically
   * increasing by 1 TODO consider a generic fill function including steps or random samples from
   * various distributions
   */","('indexColumn', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",62.0,  Returns a new numeric column initialized with the given name and size.,13.0,"['A new column is returned with the given size and name.', 'A new column is returned with the name and size.', 'A new column is returned with the given name and size.']"
359,cdk,org/openscience/cdk/io/MDLRXNReader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLRXNReader.java,readChemFile,177-190,"/**
    * Read a ChemFile from a file in MDL RDF format.
    *
    * @param  chemFile The IChemFile
    * @return          The IChemFile that was read from the RDF file.
    */
private IChemFile readChemFile(IChemFile chemFile) throws CDKException{
    IChemSequence chemSequence = chemFile.getBuilder().newInstance(IChemSequence.class);
    IChemModel chemModel = chemFile.getBuilder().newInstance(IChemModel.class);
    chemSequence.addChemModel(readChemModel(chemModel));
    chemFile.addChemSequence(chemSequence);
    return chemFile;
}","private IChemFile readChemFile(IChemFile chemFile) throws CDKException{
    IChemSequence chemSequence = chemFile.getBuilder().newInstance(IChemSequence.class);
    IChemModel chemModel = chemFile.getBuilder().newInstance(IChemModel.class);
    chemSequence.addChemModel(readChemModel(chemModel));
    chemFile.addChemSequence(chemSequence);
    return chemFile;
}","/**
    * Read a ChemFile from a file in MDL RDF format.
    *
    * @param  chemFile The IChemFile
    * @return          The IChemFile that was read from the RDF file.
    */","('readChemFile', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",63.0,  Read a ChemFile from a file in MDL RDF format.,11.0,"['There is a file in the MDL RDF format.', 'There is a file in MDL RDF format.', 'There is a file in MDL RDF.']"
360,liquibase,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,checkForMissingCommandParameters,999-1010,"/**
     * Checks for missing command line parameters and, if any problems are found,
     * returns the list of issues in String form.
     *
     * @param messages an array of Strings to which messages for issues found will be added
     */
private void checkForMissingCommandParameters(final List<String> messages){
    if ((commandParams.isEmpty() || commandParams.iterator().next().startsWith(""-"")) && (COMMANDS.CALCULATE_CHECKSUM.equalsIgnoreCase(command))) {
        messages.add(coreBundle.getString(""changeset.identifier.missing""));
    }
}","private void checkForMissingCommandParameters(final List<String> messages){
    if ((commandParams.isEmpty() || commandParams.iterator().next().startsWith(""-"")) && (COMMANDS.CALCULATE_CHECKSUM.equalsIgnoreCase(command))) {
        messages.add(coreBundle.getString(""changeset.identifier.missing""));
    }
}","/**
     * Checks for missing command line parameters and, if any problems are found,
     * returns the list of issues in String form.
     *
     * @param messages an array of Strings to which messages for issues found will be added
     */","('checkForMissingCommandParameters', {'INSTRUCTION': {'covered': 18, 'missed': 6}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",63.0,"  Checks for missing command line parameters and, if any problems are found,  returns the list of issues in String form.",23.0,"['If any problems are found, the list of issues in String form is returned.', 'Checks for missing command line parameters and if any are found, returns a list of issues in String form.', 'Checks for missing command line parameters and if any are found, returns a list of issues.']"
361,anserini,io/anserini/search/SimpleSearcher.java,/src/main/java/io/anserini/search/SimpleSearcher.java,batchSearchFields,438-453,"/**
   * Searches the provided fields weighted by their boosts, using multiple threads.
   * Batch version of {@link #searchFields(String, Map, int)}.
   *
   * @param queries list of queries
   * @param qids list of unique query ids
   * @param k number of hits
   * @param threads number of threads
   * @param fields map of fields to search with weights
   * @return a map of query id to search results
   */
public Map<String, Result[]> batchSearchFields(List<String> queries, List<String> qids, int k, int threads, Map<String, Float> fields){
    QueryGenerator generator = new BagOfWordsQueryGenerator();
    return batchSearchFields(generator, queries, qids, k, threads, fields);
}","public Map<String, Result[]> batchSearchFields(List<String> queries, List<String> qids, int k, int threads, Map<String, Float> fields){
    QueryGenerator generator = new BagOfWordsQueryGenerator();
    return batchSearchFields(generator, queries, qids, k, threads, fields);
}","/**
   * Searches the provided fields weighted by their boosts, using multiple threads.
   * Batch version of {@link #searchFields(String, Map, int)}.
   *
   * @param queries list of queries
   * @param qids list of unique query ids
   * @param k number of hits
   * @param threads number of threads
   * @param fields map of fields to search with weights
   * @return a map of query id to search results
   */","('batchSearchFields', {'INSTRUCTION': {'covered': 13, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",63.0,"  Searches the provided fields weighted by their boosts, using multiple threads.",13.0,"['Multiple threads are used to search the fields weighted by their boost.', 'Multiple threads are used to search the fields weighted by their boosts.', 'Multiple threads are used to search the provided fields.']"
362,jackson-databind,com/fasterxml/jackson/databind/util/ISO8601Utils.java,/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java,indexOfNonDigit,311-320,"/**
     * Returns the index of the first character in the string that is not a digit, starting at offset.
     */
private static int indexOfNonDigit(String string, int offset){
    for (int i = offset; i < string.length(); i++) {
        char c = string.charAt(i);
        if (c < '0' || c > '9')
            return i;
    }
    return string.length();
}","private static int indexOfNonDigit(String string, int offset){
    for (int i = offset; i < string.length(); i++) {
        char c = string.charAt(i);
        if (c < '0' || c > '9')
            return i;
    }
    return string.length();
}","/**
     * Returns the index of the first character in the string that is not a digit, starting at offset.
     */","('indexOfNonDigit', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",63.0,"  Returns the index of the first character in the string that is not a digit, starting at offset.",20.0,"['The first character in the string is not a digit.', 'The first character in the string that is not a digit is returned.', 'The first character in the string that is not a digit is the index.']"
363,matsim-libs,org/matsim/contrib/freight/utils/FreightUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/utils/FreightUtils.java,convertSkillsAttributeToList,487-501,"/**
	 * Converts the 'skills' attribute to a list of strings.
	 *
	 * @param attributes the {@link Attributes} container that is checked for the
	 *                   skill(s) to be converted.
	 * @return the {@link List} of skills, possibly empty, as parsed from the
	 *         attribute.
	 */
private static List<String> convertSkillsAttributeToList(Attributes attributes){
    if (attributes.getAttribute(ATTR_SKILLS) == null) {
        return new ArrayList<>();
    } else {
        return Arrays.asList(Objects.requireNonNull(attributes.getAttribute(ATTR_SKILLS)).toString().split("",""));
    }
}","private static List<String> convertSkillsAttributeToList(Attributes attributes){
    if (attributes.getAttribute(ATTR_SKILLS) == null) {
        return new ArrayList<>();
    } else {
        return Arrays.asList(Objects.requireNonNull(attributes.getAttribute(ATTR_SKILLS)).toString().split("",""));
    }
}","/**
	 * Converts the 'skills' attribute to a list of strings.
	 *
	 * @param attributes the {@link Attributes} container that is checked for the
	 *                   skill(s) to be converted.
	 * @return the {@link List} of skills, possibly empty, as parsed from the
	 *         attribute.
	 */","('convertSkillsAttributeToList', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",64.0,  Converts the 'skills' attribute to a list of strings.,11.0,"['The skills attribute is converted to a list of strings.', ""The'skills' attribute is converted to a list of strings."", 'The skills attribute is converted to strings.']"
365,acs-aem-commons,com/adobe/acs/commons/wrap/impl/SessionLogoutGuardFactory.java,/bundle/src/main/java/com/adobe/acs/commons/wrap/impl/SessionLogoutGuardFactory.java,useBestWrapper,82-97,"/**
     * Return the best wrapped version of the provided session.
     *
     * @param session the session to wrap
     * @return a wrapped session
     */
public static Session useBestWrapper(final Session session){
    if (session instanceof JackrabbitWrapper || session instanceof JcrWrapper) {
        return session;
    } else if (session instanceof JackrabbitSession) {
        return new JackrabbitWrapper((JackrabbitSession) session);
    } else if (session != null) {
        return new JcrWrapper(session);
    }
    return null;
}","public static Session useBestWrapper(final Session session){
    if (session instanceof JackrabbitWrapper || session instanceof JcrWrapper) {
        return session;
    } else if (session instanceof JackrabbitSession) {
        return new JackrabbitWrapper((JackrabbitSession) session);
    } else if (session != null) {
        return new JcrWrapper(session);
    }
    return null;
}","/**
     * Return the best wrapped version of the provided session.
     *
     * @param session the session to wrap
     * @return a wrapped session
     */","('useBestWrapper', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",64.0,  Return the best wrapped version of the provided session.,10.0,"['The best wrapped version of the session should be returned.', 'The best version of the session should be returned.', 'Return the best version of the session.']"
366,liquibase,liquibase/precondition/PreconditionFactory.java,/liquibase-core/src/main/java/liquibase/precondition/PreconditionFactory.java,create,55-68,"/**
     * Create a new Precondition subclass based on the given tag name.
     */
public Precondition create(String tagName){
    Class<?> aClass = preconditions.get(tagName);
    if (aClass == null) {
        return null;
    }
    try {
        return (Precondition) aClass.getConstructor().newInstance();
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}","public Precondition create(String tagName){
    Class<?> aClass = preconditions.get(tagName);
    if (aClass == null) {
        return null;
    }
    try {
        return (Precondition) aClass.getConstructor().newInstance();
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}","/**
     * Create a new Precondition subclass based on the given tag name.
     */","('create', {'INSTRUCTION': {'covered': 19, 'missed': 6}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",64.0,  Create a new Precondition subclass based on the given tag name.,12.0,"['A new Precondition subclass can be created based on the given tag name.', 'A new Precondition subclass can be created based on the tag name.', 'A new subclass is created based on the given tag name.']"
367,metrics,io/dropwizard/metrics5/EWMA.java,/metrics-core/src/main/java/io/dropwizard/metrics5/EWMA.java,tick,84-97,"/**
     * Mark the passage of time and decay the current rate accordingly.
     */
public void tick(){
    final long count = uncounted.sumThenReset();
    final double instantRate = count / interval;
    if (initialized) {
        final double oldRate = this.rate;
        rate = oldRate + (alpha * (instantRate - oldRate));
    } else {
        rate = instantRate;
        initialized = true;
    }
}","public void tick(){
    final long count = uncounted.sumThenReset();
    final double instantRate = count / interval;
    if (initialized) {
        final double oldRate = this.rate;
        rate = oldRate + (alpha * (instantRate - oldRate));
    } else {
        rate = instantRate;
        initialized = true;
    }
}","/**
     * Mark the passage of time and decay the current rate accordingly.
     */","('tick', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",64.0,  Mark the passage of time and decay the current rate accordingly.,12.0,"['The current rate should be measured and decay according to the passage of time.', 'The current rate should be decayd according to the passage of time.', 'The current rate should be measured and decay as time passes.']"
368,weblogic-kubernetes-operator,oracle/kubernetes/operator/helpers/PodHelper.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/PodHelper.java,createCopy,263-280,"/**
   * Create a copy of the list of V1EnvVar environment variables.
   *
   * @param envVars list of environment variables to copy
   * @return List containing a copy of the original list.
   */
public static List<V1EnvVar> createCopy(List<V1EnvVar> envVars){
    ArrayList<V1EnvVar> copy = new ArrayList<>();
    if (envVars != null) {
        for (V1EnvVar envVar : envVars) {
            copy.add(new V1EnvVarBuilder(envVar).build());
        }
    }
    return copy;
}","public static List<V1EnvVar> createCopy(List<V1EnvVar> envVars){
    ArrayList<V1EnvVar> copy = new ArrayList<>();
    if (envVars != null) {
        for (V1EnvVar envVar : envVars) {
            copy.add(new V1EnvVarBuilder(envVar).build());
        }
    }
    return copy;
}","/**
   * Create a copy of the list of V1EnvVar environment variables.
   *
   * @param envVars list of environment variables to copy
   * @return List containing a copy of the original list.
   */","('createCopy', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",64.0,Create a copy of the list of V1EnvVar environment variables.,11.0,"['You can create a copy of the environment variables.', 'The list of V1EnvVar environment variables can be created.', 'A copy of the environment variables is needed.']"
369,dcache,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,recalcEarliestChildExpiry,398-419,"/**
     * Recalculate _earliestChildExpiryDate() by asking our children for their earliest expiring
     * child.
     * TODO: this isn't always necessary, but it's hard to know when.  Also, it isn't clear that the
     * cost of figuring out when it is necessary is less than the CPU time saved by always recalculating.
     */
private void recalcEarliestChildExpiry(){
    _earliestChildExpiry = null;
    for (StateComponent child : _children.values()) {
        Date earliestExpires = child.getEarliestChildExpiryDate();
        if (earliestExpires != null) {
            updateEarliestChildExpiryDate(earliestExpires);
        }
        if (child.isMortal()) {
            updateEarliestChildExpiryDate(child.getExpiryDate());
        }
    }
}","private void recalcEarliestChildExpiry(){
    _earliestChildExpiry = null;
    for (StateComponent child : _children.values()) {
        Date earliestExpires = child.getEarliestChildExpiryDate();
        if (earliestExpires != null) {
            updateEarliestChildExpiryDate(earliestExpires);
        }
        if (child.isMortal()) {
            updateEarliestChildExpiryDate(child.getExpiryDate());
        }
    }
}","/**
     * Recalculate _earliestChildExpiryDate() by asking our children for their earliest expiring
     * child.
     * TODO: this isn't always necessary, but it's hard to know when.  Also, it isn't clear that the
     * cost of figuring out when it is necessary is less than the CPU time saved by always recalculating.
     */","('recalcEarliestChildExpiry', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,  Recalculate _earliestChildExpiryDate() by asking our children for their earliest expiring  child.,14.0,"['Ask our children for their earliest expiring child.', 'Asking our children for their earliest expiring child is a way to calculateliest child expiry date.', 'Asking our children for their earliest expiring child will help calculateliest child expiry date.']"
370,dcache,org/dcache/auth/attributes/MultiTargetedRestriction.java,/modules/common/src/main/java/org/dcache/auth/attributes/MultiTargetedRestriction.java,hasAuthorisationSubsumedBy,176-185,"/**
     * Return true iff this restriction has an Authorisation that is subsumed by other.
     */
private boolean hasAuthorisationSubsumedBy(Authorisation other){
    EnumSet<Activity> disallowedOtherActivities = EnumSet.complementOf(other.activities);
    return authorisations.stream().anyMatch(ap -> disallowedOtherActivities.containsAll(EnumSet.complementOf(ap.activities)) && other.getPath().hasPrefix(ap.getPath()));
}","private boolean hasAuthorisationSubsumedBy(Authorisation other){
    EnumSet<Activity> disallowedOtherActivities = EnumSet.complementOf(other.activities);
    return authorisations.stream().anyMatch(ap -> disallowedOtherActivities.containsAll(EnumSet.complementOf(ap.activities)) && other.getPath().hasPrefix(ap.getPath()));
}","/**
     * Return true iff this restriction has an Authorisation that is subsumed by other.
     */","('hasAuthorisationSubsumedBy', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,  Return true iff this restriction has an Authorisation that is subsumed by other.,14.0,"['This restriction has an Authorisation that is subsumed by other.', 'If this restriction has an Authorisation subsumed by other, return true.', 'This restriction has an Authorisation that is subsumed by others.']"
371,cdk,org/openscience/cdk/isomorphism/CompatibilityMatrix.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/CompatibilityMatrix.java,fix,124-134,"/**
     * Create a fixed-size 2D array of the matrix (useful for debug).
     *
     * @return a fixed version of the matrix
     */
 int[][] fix(){
    int[][] m = new int[nRows][mCols];
    for (int i = 0; i < nRows; i++) System.arraycopy(data, (i * mCols), m[i], 0, mCols);
    return m;
}","int[][] fix(){
    int[][] m = new int[nRows][mCols];
    for (int i = 0; i < nRows; i++) System.arraycopy(data, (i * mCols), m[i], 0, mCols);
    return m;
}","/**
     * Create a fixed-size 2D array of the matrix (useful for debug).
     *
     * @return a fixed version of the matrix
     */","('fix', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,Create a fixed-size 2D array of the matrix (useful for debug).,14.0,"['The matrix can be created with a fixed-size 2D array.', 'A fixed-size 2D array of the matrix is useful.', 'A fixed-size 2D array of the matrix is useful for Debugging.']"
372,matsim-libs,org/matsim/core/utils/misc/OptionalTime.java,/matsim/src/main/java/org/matsim/core/utils/misc/OptionalTime.java,defined,41-55,"/**
	 * Creates OptionalTime that wraps only a defined time
	 *
	 * @throws IllegalArgumentException if seconds is Double.NaN or Time.getUndefined()
	 */
public static OptionalTime defined(double seconds){
    if (seconds == 0) {
        return TIME_0;
    } else if (seconds == Time.UNDEFINED_TIME) {
        throw new IllegalArgumentException(""Undefined time is not allowed"");
    } else if (Double.isNaN(seconds)) {
        throw new IllegalArgumentException(""NaN time is not allowed"");
    }
    return new OptionalTime(seconds);
}","public static OptionalTime defined(double seconds){
    if (seconds == 0) {
        return TIME_0;
    } else if (seconds == Time.UNDEFINED_TIME) {
        throw new IllegalArgumentException(""Undefined time is not allowed"");
    } else if (Double.isNaN(seconds)) {
        throw new IllegalArgumentException(""NaN time is not allowed"");
    }
    return new OptionalTime(seconds);
}","/**
	 * Creates OptionalTime that wraps only a defined time
	 *
	 * @throws IllegalArgumentException if seconds is Double.NaN or Time.getUndefined()
	 */","('defined', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,  Creates OptionalTime that wraps only a defined time   @throws IllegalArgumentException if seconds is Double.,16.0,"['If seconds is double, the OptionalTime that wraps only a defined time is created.', 'If seconds is double, the OptionalTime that wraps only a defined time will be created.', 'If seconds is double, then the OptionalTime that wraps only a defined time is created.']"
374,dcache,org/dcache/resilience/handlers/FileOperationHandler.java,/modules/dcache-resilience/src/main/java/org/dcache/resilience/handlers/FileOperationHandler.java,shouldTryToStage,1407-1427,"/**
     * <p>Called when there are no accessible replicas for the file.</p>
     *
     * <p>If the file's RetentionPolicy is CUSTODIAL, set the count to 1,
     * to make sure the task completes after this.  Staging is fire-and-forget, and depends on a new
     * add cache location message being processed after staging.</p>
     *
     * @return true if file is CUSTODIAL, false otherwise.
     */
private boolean shouldTryToStage(FileAttributes attributes, FileOperation operation){
    if (attributes.getRetentionPolicy() == RetentionPolicy.CUSTODIAL) {
        LOGGER.trace(""shouldTryToStage {}, retention policy is CUSTODIAL."", operation.getPnfsId());
        operation.setOpCount(1);
        return true;
    }
    LOGGER.trace(""shouldTryToStage {}, retention policy is not CUSTODIAL"", operation.getPnfsId());
    return false;
}","private boolean shouldTryToStage(FileAttributes attributes, FileOperation operation){
    if (attributes.getRetentionPolicy() == RetentionPolicy.CUSTODIAL) {
        LOGGER.trace(""shouldTryToStage {}, retention policy is CUSTODIAL."", operation.getPnfsId());
        operation.setOpCount(1);
        return true;
    }
    LOGGER.trace(""shouldTryToStage {}, retention policy is not CUSTODIAL"", operation.getPnfsId());
    return false;
}","/**
     * <p>Called when there are no accessible replicas for the file.</p>
     *
     * <p>If the file's RetentionPolicy is CUSTODIAL, set the count to 1,
     * to make sure the task completes after this.  Staging is fire-and-forget, and depends on a new
     * add cache location message being processed after staging.</p>
     *
     * @return true if file is CUSTODIAL, false otherwise.
     */","('shouldTryToStage', {'INSTRUCTION': {'covered': 21, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,  <p>Called when there are no accessible replicas for the file.,14.0,"['There are no replicas for the file.', 'When there are no replicas for the file.', ""It's called when there are no replicas for the file.""]"
375,tablesaw,tech/tablesaw/analytic/AnalyticQueryEngine.java,/core/src/main/java/tech/tablesaw/analytic/AnalyticQueryEngine.java,partition,140-148,"/**
   * Partition the source table into a series of table slices. Does not modify the underlying table.
   */
private Iterable<TableSlice> partition(){
    if (query.getPartitionColumns().isEmpty()) {
        return ImmutableList.of(new TableSlice(query.getTable()));
    }
    return query.getTable().splitOn(query.getPartitionColumns().toArray(new String[0]));
}","private Iterable<TableSlice> partition(){
    if (query.getPartitionColumns().isEmpty()) {
        return ImmutableList.of(new TableSlice(query.getTable()));
    }
    return query.getTable().splitOn(query.getPartitionColumns().toArray(new String[0]));
}","/**
   * Partition the source table into a series of table slices. Does not modify the underlying table.
   */","('partition', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,  Partition the source table into a series of table slices.,11.0,"['The source table should be partitioned into slices.', 'The source table should be partitioned into a series of slices.', 'The source table can be partitioned into slices.']"
376,cdk,org/openscience/cdk/ChemObject.java,/base/data/src/main/java/org/openscience/cdk/ChemObject.java,clone,301-323,"/**
     *  Clones this <code>IChemObject</code>. It clones the identifier, flags,
     *  properties and pointer vectors. The ChemObjectListeners are not cloned, and
     *  neither is the content of the pointer vectors.
     *
     *@return    The cloned object
     */
public Object clone() throws CloneNotSupportedException{
    ChemObject clone = (ChemObject) super.clone();
    clone.flags = getFlagValue().shortValue();
    if (properties != null)
        clone.properties = new HashMap<Object, Object>(getProperties());
    clone.chemObjectListeners = null;
    return clone;
}","public Object clone() throws CloneNotSupportedException{
    ChemObject clone = (ChemObject) super.clone();
    clone.flags = getFlagValue().shortValue();
    if (properties != null)
        clone.properties = new HashMap<Object, Object>(getProperties());
    clone.chemObjectListeners = null;
    return clone;
}","/**
     *  Clones this <code>IChemObject</code>. It clones the identifier, flags,
     *  properties and pointer vectors. The ChemObjectListeners are not cloned, and
     *  neither is the content of the pointer vectors.
     *
     *@return    The cloned object
     */","('clone', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,  Clones this <code>IChemObject</code>.,10.0,"['This is a clone of this code>IChemObject/code>.', 'This is a clone of the code>IChemObject/code>.', 'This is a clone of this code>IChemObject/code>']"
377,acs-aem-commons,com/adobe/acs/commons/util/BufferedServletOutput.java,/bundle/src/main/java/com/adobe/acs/commons/util/BufferedServletOutput.java,flushBuffer,204-220,"/**
     * Will not commit the response, but only make sure that the wrapped response's {@code flushBuffer()} is executed, once this {@link #close()} is called.
     * This only affects output which is buffered, i.e. for unbuffered output the flush is not deferred.
     * @throws IOException 
     */
public void flushBuffer() throws IOException{
    if (isBuffered()) {
        log.debug(""Prevent committing the response, it will be committed deferred, i.e. once this buffered response is closed"");
        if (log.isDebugEnabled()) {
            Throwable t = new Throwable("""");
            log.debug(""Stacktrace which triggered ServletResponse.flushBuffer()"", t);
        }
        flushWrappedBuffer = true;
    } else {
        wrappedResponse.flushBuffer();
    }
}","public void flushBuffer() throws IOException{
    if (isBuffered()) {
        log.debug(""Prevent committing the response, it will be committed deferred, i.e. once this buffered response is closed"");
        if (log.isDebugEnabled()) {
            Throwable t = new Throwable("""");
            log.debug(""Stacktrace which triggered ServletResponse.flushBuffer()"", t);
        }
        flushWrappedBuffer = true;
    } else {
        wrappedResponse.flushBuffer();
    }
}","/**
     * Will not commit the response, but only make sure that the wrapped response's {@code flushBuffer()} is executed, once this {@link #close()} is called.
     * This only affects output which is buffered, i.e. for unbuffered output the flush is not deferred.
     * @throws IOException 
     */","('flushBuffer', {'INSTRUCTION': {'covered': 23, 'missed': 3}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,"  Will not commit the response, but only make sure that the wrapped response's {@code flushBuffer()} is executed, once this {@link #close()} is called.",38.0,"[""Will not commit the response, but only make sure that the wrapped response's @code flushBuffer() is executed."", ""Will not commit the response, but only make sure that the wrapped response's @code flushBuffer"", ""Will not commit the response, but only make sure that the wrapped response's @code flushBuffer is executed.""]"
378,cdk,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,inSameCell,400-415,"/**
     * Check that two elements are in the same cell of the partition.
     *
     * @param elementI an element in the partition
     * @param elementJ an element in the partition
     * @return true if both elements are in the same cell
     */
public boolean inSameCell(int elementI, int elementJ){
    for (int cellIndex = 0; cellIndex < size(); cellIndex++) {
        SortedSet<Integer> cell = getCell(cellIndex);
        if (cell.contains(elementI) && cell.contains(elementJ)) {
            return true;
        }
    }
    return false;
}","public boolean inSameCell(int elementI, int elementJ){
    for (int cellIndex = 0; cellIndex < size(); cellIndex++) {
        SortedSet<Integer> cell = getCell(cellIndex);
        if (cell.contains(elementI) && cell.contains(elementJ)) {
            return true;
        }
    }
    return false;
}","/**
     * Check that two elements are in the same cell of the partition.
     *
     * @param elementI an element in the partition
     * @param elementJ an element in the partition
     * @return true if both elements are in the same cell
     */","('inSameCell', {'INSTRUCTION': {'covered': 24, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",65.0,  Check that two elements are in the same cell of the partition.,13.0,"['The partition has two elements in the same cell.', 'There are two elements in the partition.', 'There are two elements in the same cell.']"
379,matsim-libs,org/matsim/pt/router/TransitLeastCostPathTree.java,/matsim/src/main/java/org/matsim/pt/router/TransitLeastCostPathTree.java,revisitNode,482-506,"/**
	 * Changes the position of the given Node n in the pendingNodes queue and
	 * updates its time and cost information.
	 *
	 * @param n
	 *            The Node that is revisited.
	 * @param data
	 *            The data for n.
	 * @param pendingNodes
	 *            The nodes visited and not processed yet.
	 * @param time
	 *            The time of the visit of n.
	 * @param cost
	 *            The accumulated cost at the time of the visit of n.
	 * @param outLink
	 *            The link from which we came visiting n.
	 */
 void revisitNode(final Node n, final DijkstraNodeData data, final RouterPriorityQueue<Node> pendingNodes, final double time, final double cost, final Link outLink){
    pendingNodes.remove(n);
    data.visit(outLink, cost, time, getIterationId());
    pendingNodes.add(n, getPriority(data));
}"," void revisitNode(final Node n, final DijkstraNodeData data, final RouterPriorityQueue<Node> pendingNodes, final double time, final double cost, final Link outLink){
    pendingNodes.remove(n);
    data.visit(outLink, cost, time, getIterationId());
    pendingNodes.add(n, getPriority(data));
}","/**
	 * Changes the position of the given Node n in the pendingNodes queue and
	 * updates its time and cost information.
	 *
	 * @param n
	 *            The Node that is revisited.
	 * @param data
	 *            The data for n.
	 * @param pendingNodes
	 *            The nodes visited and not processed yet.
	 * @param time
	 *            The time of the visit of n.
	 * @param cost
	 *            The accumulated cost at the time of the visit of n.
	 * @param outLink
	 *            The link from which we came visiting n.
	 */","('revisitNode', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,  Changes the position of the given Node n in the pendingNodes queue and  updates its time and cost information.,20.0,"['Changes the position of the given Node n in the pendingNodes queue.', 'Changes the position of the given Node n in the pendingNodes queue and updates its time and cost information.', 'Changes the position of the given Node n in the queue.']"
380,matsim-libs,org/matsim/withinday/utils/EditRoutes.java,/matsim/src/main/java/org/matsim/withinday/utils/EditRoutes.java,replanCurrentLegRoute,352-376,"/**
	 * We create a new Plan which contains only the Leg that should be replanned and its previous and next
	 * Activities. By doing so the PlanAlgorithm will only change the Route of that Leg.
	 *
	 * Use currentNodeIndex from a DriverAgent if possible!
	 *
	 * Otherwise code it as following:
	 * startLink - Node1 - routeLink1 - Node2 - routeLink2 - Node3 - endLink
	 * The currentNodeIndex has to Point to the next Node
	 * (which is the endNode of the current Link)
	 */
public boolean replanCurrentLegRoute(Leg leg, Person person, int currentLinkIndex, double time){
    Route route = leg.getRoute();
    if (!(route instanceof NetworkRoute)) {
        log.warn(""route not instance of NetworkRoute"");
        return false;
    }
    return relocateCurrentLegRoute(leg, person, currentLinkIndex, route.getEndLinkId(), time);
}","public boolean replanCurrentLegRoute(Leg leg, Person person, int currentLinkIndex, double time){
    Route route = leg.getRoute();
    if (!(route instanceof NetworkRoute)) {
        log.warn(""route not instance of NetworkRoute"");
        return false;
    }
    return relocateCurrentLegRoute(leg, person, currentLinkIndex, route.getEndLinkId(), time);
}","/**
	 * We create a new Plan which contains only the Leg that should be replanned and its previous and next
	 * Activities. By doing so the PlanAlgorithm will only change the Route of that Leg.
	 *
	 * Use currentNodeIndex from a DriverAgent if possible!
	 *
	 * Otherwise code it as following:
	 * startLink - Node1 - routeLink1 - Node2 - routeLink2 - Node3 - endLink
	 * The currentNodeIndex has to Point to the next Node
	 * (which is the endNode of the current Link)
	 */","('replanCurrentLegRoute', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,  We create a new Plan which contains only the Leg that should be replanned and its previous and next  Activities.,21.0,"['A new plan is created that only has the Leg that should be replanned and its previous and next activities.', 'A new plan is created that only contains the Leg that should be re planned.', 'A new plan is created that only has the Leg that should be replanned and its previous and next Activities.']"
381,cdk,org/openscience/cdk/geometry/GeometryTools.java,/legacy/src/main/java/org/openscience/cdk/geometry/GeometryTools.java,has3DCoordinates,1080-1103,"/**
     * Determines if all this {@link IAtomContainer}'s atoms contain 3D coordinates. If any atom
     * is null or has unset 3D coordinates this method will return false. If the provided
     * container is null false is returned.
     *
     * @param container the atom container to examine
     *
     * @return indication that all 3D coordinates are available
     *
     * @see org.openscience.cdk.interfaces.IAtom#getPoint3d()
     */
public static boolean has3DCoordinates(IAtomContainer container){
    if (container == null || container.getAtomCount() == 0)
        return Boolean.FALSE;
    for (IAtom atom : container.atoms()) {
        if (atom == null || atom.getPoint3d() == null)
            return Boolean.FALSE;
    }
    return Boolean.TRUE;
}","public static boolean has3DCoordinates(IAtomContainer container){
    if (container == null || container.getAtomCount() == 0)
        return Boolean.FALSE;
    for (IAtom atom : container.atoms()) {
        if (atom == null || atom.getPoint3d() == null)
            return Boolean.FALSE;
    }
    return Boolean.TRUE;
}","/**
     * Determines if all this {@link IAtomContainer}'s atoms contain 3D coordinates. If any atom
     * is null or has unset 3D coordinates this method will return false. If the provided
     * container is null false is returned.
     *
     * @param container the atom container to examine
     *
     * @return indication that all 3D coordinates are available
     *
     * @see org.openscience.cdk.interfaces.IAtom#getPoint3d()
     */","('has3DCoordinates', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,Determines if all this {@link IAtomContainer}'s atoms contain 3D coordinates.,15.0,"['If the atoms of the IAtomContainer contain 3D coordinates.', 'If the atoms contain 3D coordinates.', ""If the atoms contain 3D coordinates, it's determined.""]"
382,tablesaw,tech/tablesaw/table/TableSlice.java,/core/src/main/java/tech/tablesaw/table/TableSlice.java,iterator,224-245,"/**
   * Iterate over the underlying rows in the source table. If you set one of the rows while
   * iterating it will change the row in the source table.
   */
public Iterator<Row> iterator(){
    return new Iterator<Row>() {

        private final Row row = new Row(TableSlice.this);

        @Override
        public Row next() {
            return row.next();
        }

        @Override
        public boolean hasNext() {
            return row.hasNext();
        }
    };
}","public Iterator<Row> iterator(){
    return new Iterator<Row>() {

        private final Row row = new Row(TableSlice.this);

        @Override
        public Row next() {
            return row.next();
        }

        @Override
        public boolean hasNext() {
            return row.hasNext();
        }
    };
}","/**
   * Iterate over the underlying rows in the source table. If you set one of the rows while
   * iterating it will change the row in the source table.
   */","('iterator', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,  Iterate over the underlying rows in the source table.,10.0,"['Over the underlying rows in the source table.', 'Iterate over the rows in the source table.', 'Iterate over the underlying rows.']"
383,weblogic-kubernetes-operator,oracle/kubernetes/operator/logging/LoggingFacade.java,/operator/src/main/java/oracle/kubernetes/operator/logging/LoggingFacade.java,formatMessage,608-622,"/**
   * Formats message based on string loaded from the resource bundle backing this logger.
   * @param msgId Message id
   * @param params Parameters to message formatting
   * @return Formatted message
   */
public String formatMessage(String msgId, Object... params){
    if (params == null || params.length == 0) {
        return getResourceBundle().getString(msgId);
    }
    String msg = getResourceBundle().getString(msgId);
    MessageFormat formatter = new MessageFormat(msg);
    return formatter.format(params);
}","public String formatMessage(String msgId, Object... params){
    if (params == null || params.length == 0) {
        return getResourceBundle().getString(msgId);
    }
    String msg = getResourceBundle().getString(msgId);
    MessageFormat formatter = new MessageFormat(msg);
    return formatter.format(params);
}","/**
   * Formats message based on string loaded from the resource bundle backing this logger.
   * @param msgId Message id
   * @param params Parameters to message formatting
   * @return Formatted message
   */","('formatMessage', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,  Formats message based on string loaded from the resource bundle backing this logger.,14.0,"['The message is formatted based on the string in the resource bundle.', 'The message is formatted based on the string loaded from the resource bundle.', 'The message is formatted based on string loaded from the resource bundle.']"
384,acs-aem-commons,com/adobe/acs/commons/httpcache/config/impl/HttpCacheConfigImpl.java,/bundle/src/main/java/com/adobe/acs/commons/httpcache/config/impl/HttpCacheConfigImpl.java,compileToPatterns,313-329,"/**
     * Converts an array of Regex strings into compiled Patterns.
     *
     * @param regexes the regex strings to compile into Patterns
     * @return the list of compiled Patterns
     */
private List<Pattern> compileToPatterns(final List<String> regexes){
    final List<Pattern> patterns = new ArrayList<Pattern>();
    for (String regex : regexes) {
        if (StringUtils.isNotBlank(regex)) {
            patterns.add(Pattern.compile(regex));
        }
    }
    return patterns;
}","private List<Pattern> compileToPatterns(final List<String> regexes){
    final List<Pattern> patterns = new ArrayList<Pattern>();
    for (String regex : regexes) {
        if (StringUtils.isNotBlank(regex)) {
            patterns.add(Pattern.compile(regex));
        }
    }
    return patterns;
}","/**
     * Converts an array of Regex strings into compiled Patterns.
     *
     * @param regexes the regex strings to compile into Patterns
     * @return the list of compiled Patterns
     */","('compileToPatterns', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,  Converts an array of Regex strings into compiled Patterns.,10.0,"['Patterns are compiled from an array of Regex strings.', 'A string is converted into a pattern.', 'The strings are converted into Patterns.']"
385,cdk,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,unit,80-94,"/**
     * Create a unit partition - in other words, the coarsest possible partition
     * where all the elements are in one cell.
     *
     * @param size the number of elements
     * @return a new Partition with one cell containing all the elements
     */
public static Partition unit(int size){
    Partition unit = new Partition();
    unit.cells.add(new TreeSet<Integer>());
    for (int i = 0; i < size; i++) {
        unit.cells.get(0).add(i);
    }
    return unit;
}","public static Partition unit(int size){
    Partition unit = new Partition();
    unit.cells.add(new TreeSet<Integer>());
    for (int i = 0; i < size; i++) {
        unit.cells.get(0).add(i);
    }
    return unit;
}","/**
     * Create a unit partition - in other words, the coarsest possible partition
     * where all the elements are in one cell.
     *
     * @param size the number of elements
     * @return a new Partition with one cell containing all the elements
     */","('unit', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,"  Create a unit partition - in other words, the coarsest possible partition  where all the elements are in one cell.",22.0,"['The coarsest partition where all the elements are in one cell is called a unit partition.', 'The coarsest partition where all the elements are in one cell is the unit partition.', 'A unit partition is a partition where all the elements are in one cell.']"
386,dcache,org/dcache/gplazma/scitoken/SciTokenPlugin.java,/modules/gplazma2-scitoken/src/main/java/org/dcache/gplazma/scitoken/SciTokenPlugin.java,parseScope,184-194,"/**
     * Parse the ""scope"" claim and extract all SciToken or WLCG Profile scopes.
     */
private static List<AuthorisationSupplier> parseScope(String claim) throws InvalidScopeException{
    return Splitter.on(' ').trimResults().splitToList(claim).stream().map(SciTokenPlugin::resolveScope).filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());
}","private static List<AuthorisationSupplier> parseScope(String claim) throws InvalidScopeException{
    return Splitter.on(' ').trimResults().splitToList(claim).stream().map(SciTokenPlugin::resolveScope).filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());
}","/**
     * Parse the ""scope"" claim and extract all SciToken or WLCG Profile scopes.
     */","('parseScope', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,"  Parse the ""scope"" claim and extract all SciToken or WLCG Profile scopes.",15.0,"['Parse the ""scope"" claim and extract all the scopes.', 'Parse the ""scope"" claim and then extract all the scopes.', 'Parse the ""scope"" claim and then extract the scope.']"
387,jackson-databind,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,closeOnFailAndThrowAsIOE,480-504,"/**
     * Helper method that encapsulate logic in trying to close output generator
     * in case of failure; useful mostly in forcing flush()ing as otherwise
     * error conditions tend to be hard to diagnose. However, it is often the
     * case that output state may be corrupt so we need to be prepared for
     * secondary exception without masking original one.
     *
     * @since 2.8
     */
public static void closeOnFailAndThrowAsIOE(JsonGenerator g, Exception fail) throws IOException{
    g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);
    try {
        g.close();
    } catch (Exception e) {
        fail.addSuppressed(e);
    }
    throwIfIOE(fail);
    throwIfRTE(fail);
    throw new RuntimeException(fail);
}","public static void closeOnFailAndThrowAsIOE(JsonGenerator g, Exception fail) throws IOException{
    g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);
    try {
        g.close();
    } catch (Exception e) {
        fail.addSuppressed(e);
    }
    throwIfIOE(fail);
    throwIfRTE(fail);
    throw new RuntimeException(fail);
}","/**
     * Helper method that encapsulate logic in trying to close output generator
     * in case of failure; useful mostly in forcing flush()ing as otherwise
     * error conditions tend to be hard to diagnose. However, it is often the
     * case that output state may be corrupt so we need to be prepared for
     * secondary exception without masking original one.
     *
     * @since 2.8
     */","('closeOnFailAndThrowAsIOE', {'INSTRUCTION': {'covered': 25, 'missed': 8}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 4}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,  Helper method that encapsulate logic in trying to close output generator  in case of failure; useful mostly in forcing flush()ing as otherwise  error conditions tend to be hard to diagnose.,35.0,"[""It's useful to have a method to close the output generator in case of failure, as otherwise error conditions tend to be hard to diagnose."", ""It's useful to have a method in place to close the output generator in case of failure, as otherwise error conditions tend to be hard to diagnose."", ""It's useful to have a method in place to close the output generator in case of failure, as otherwise error conditions tend to be difficult to diagnose.""]"
388,liquibase,liquibase/database/AbstractJdbcDatabase.java,/liquibase-core/src/main/java/liquibase/database/AbstractJdbcDatabase.java,isSafeToRunUpdate,1238-1255,"/**
     * Default implementation, just look for ""local"" IPs. If the database returns a null URL we return false since we don't know it's safe to run the update.
     *
     * @throws liquibase.exception.DatabaseException
     *
     */
public boolean isSafeToRunUpdate() throws DatabaseException{
    DatabaseConnection connection = getConnection();
    if (connection == null) {
        return true;
    }
    String url = connection.getURL();
    if (url == null) {
        return false;
    }
    return (url.contains(""localhost"")) || (url.contains(""127.0.0.1""));
}","public boolean isSafeToRunUpdate() throws DatabaseException{
    DatabaseConnection connection = getConnection();
    if (connection == null) {
        return true;
    }
    String url = connection.getURL();
    if (url == null) {
        return false;
    }
    return (url.contains(""localhost"")) || (url.contains(""127.0.0.1""));
}","/**
     * Default implementation, just look for ""local"" IPs. If the database returns a null URL we return false since we don't know it's safe to run the update.
     *
     * @throws liquibase.exception.DatabaseException
     *
     */","('isSafeToRunUpdate', {'INSTRUCTION': {'covered': 22, 'missed': 4}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,"  Default implementation, just look for ""local"" IPs.",11.0,"['Just look for ""local"" IPs.', 'Look for ""local"" IPs.', 'Look for ""local"" IPs in the default implementation.']"
389,cdk,org/openscience/cdk/signature/MoleculeSignature.java,/descriptor/signature/src/main/java/org/openscience/cdk/signature/MoleculeSignature.java,toCanonicalSignatureString,186-201,"/**
     * Make a canonical signature string of a given height.
     *
     * @param height the maximum height to make signatures
     * @return the canonical signature string
     */
public String toCanonicalSignatureString(int height){
    String canonicalSignature = null;
    for (int i = 0; i < getVertexCount(); i++) {
        String signatureForI = signatureStringForVertex(i, height);
        if (canonicalSignature == null || canonicalSignature.compareTo(signatureForI) < 0) {
            canonicalSignature = signatureForI;
        }
    }
    return canonicalSignature;
}","public String toCanonicalSignatureString(int height){
    String canonicalSignature = null;
    for (int i = 0; i < getVertexCount(); i++) {
        String signatureForI = signatureStringForVertex(i, height);
        if (canonicalSignature == null || canonicalSignature.compareTo(signatureForI) < 0) {
            canonicalSignature = signatureForI;
        }
    }
    return canonicalSignature;
}","/**
     * Make a canonical signature string of a given height.
     *
     * @param height the maximum height to make signatures
     * @return the canonical signature string
     */","('toCanonicalSignatureString', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,  Make a canonical signature string of a given height.,10.0,"['A signature string of a height.', 'A signature string of a given height.', 'A signature string of a given height is made.']"
390,tablesaw,tech/tablesaw/api/TimeColumn.java,/core/src/main/java/tech/tablesaw/api/TimeColumn.java,iterator,609-631,"/**
   * Returns an iterator over elements of type {@code T}.
   *
   * @return an Iterator.
   */
public Iterator<LocalTime> iterator(){
    return new Iterator<LocalTime>() {

        final IntIterator intIterator = intIterator();

        @Override
        public boolean hasNext() {
            return intIterator.hasNext();
        }

        @Override
        public LocalTime next() {
            return PackedLocalTime.asLocalTime(intIterator.nextInt());
        }
    };
}","public Iterator<LocalTime> iterator(){
    return new Iterator<LocalTime>() {

        final IntIterator intIterator = intIterator();

        @Override
        public boolean hasNext() {
            return intIterator.hasNext();
        }

        @Override
        public LocalTime next() {
            return PackedLocalTime.asLocalTime(intIterator.nextInt());
        }
    };
}","/**
   * Returns an iterator over elements of type {@code T}.
   *
   * @return an Iterator.
   */","('iterator', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,  Returns an iterator over elements of type {@code T}.,13.0,"['An iterator is returned over elements of type @code T.', 'A iterator is returned over elements of type @code T.', 'An iterator is used to return elements of type @code T.']"
391,acs-aem-commons,com/adobe/acs/commons/util/ThreadContextClassLoaderTaskExecutor.java,/bundle/src/main/java/com/adobe/acs/commons/util/ThreadContextClassLoaderTaskExecutor.java,doWithTccl,35-53,"/**
     * Execute the task while the Thread Context Class Loader is set to the provided
     * Class Loader.
     * 
     * @param classLoader the requested class loader
     * @param task the task
     * @param <V> the return type of the task
     * @return the return value
     * @throws Exception the exception throw, if any, by the task
     */
public static V doWithTccl(ClassLoader classLoader, Callable<V> task) throws Exception{
    ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(classLoader);
    try {
        return task.call();
    } finally {
        Thread.currentThread().setContextClassLoader(oldClassLoader);
    }
}","public static V doWithTccl(ClassLoader classLoader, Callable<V> task) throws Exception{
    ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(classLoader);
    try {
        return task.call();
    } finally {
        Thread.currentThread().setContextClassLoader(oldClassLoader);
    }
}","/**
     * Execute the task while the Thread Context Class Loader is set to the provided
     * Class Loader.
     * 
     * @param classLoader the requested class loader
     * @param task the task
     * @param <V> the return type of the task
     * @return the return value
     * @throws Exception the exception throw, if any, by the task
     */","('doWithTccl', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",66.0,  Execute the task while the Thread Context Class Loader is set to the provided  Class Loader.,17.0,"['While the Thread Context Class Loader is set, execute the task.', 'The Thread Context Class Loader is needed to execute the task.', 'The Thread Context Class Loader is set to execute the task.']"
392,cdk,org/openscience/cdk/qsar/descriptors/molecular/VABCDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/VABCDescriptor.java,calculate,78-96,"/**
     * Calculates the descriptor value using the {@link VABCVolume} class.
     *
     * @param atomContainer The {@link IAtomContainer} whose volume is to be calculated
     * @return A double containing the volume
     */
public DescriptorValue calculate(IAtomContainer atomContainer){
    double volume;
    try {
        volume = VABCVolume.calculate(clone(atomContainer));
    } catch (CDKException exception) {
        return getDummyDescriptorValue(exception);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(volume), getDescriptorNames());
}","public DescriptorValue calculate(IAtomContainer atomContainer){
    double volume;
    try {
        volume = VABCVolume.calculate(clone(atomContainer));
    } catch (CDKException exception) {
        return getDummyDescriptorValue(exception);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(volume), getDescriptorNames());
}","/**
     * Calculates the descriptor value using the {@link VABCVolume} class.
     *
     * @param atomContainer The {@link IAtomContainer} whose volume is to be calculated
     * @return A double containing the volume
     */","('calculate', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,  Calculates the descriptor value using the {@link VABCVolume} class.,13.0,"['The @link VABCVolume class is used to calculate the descriptor value.', 'The @link VABCVolume class is used to calculate the value.', 'The @link VABCVolume class is used to calculate the value of the descriptor.']"
393,cdk,org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,isContainedIn,562-583,"/**
     *  Test if set sourceBitSet is contained in  set targetBitSet.
     * @param  sourceBitSet  a bitSet
     * @param  targetBitSet  a bitSet
     * @return    true if  sourceBitSet is contained in  targetBitSet
     */
private boolean isContainedIn(BitSet sourceBitSet, BitSet targetBitSet){
    boolean result = false;
    if (sourceBitSet.isEmpty()) {
        return true;
    }
    BitSet setA = (BitSet) sourceBitSet.clone();
    setA.and(targetBitSet);
    if (setA.equals(sourceBitSet)) {
        result = true;
    }
    return result;
}","private boolean isContainedIn(BitSet sourceBitSet, BitSet targetBitSet){
    boolean result = false;
    if (sourceBitSet.isEmpty()) {
        return true;
    }
    BitSet setA = (BitSet) sourceBitSet.clone();
    setA.and(targetBitSet);
    if (setA.equals(sourceBitSet)) {
        result = true;
    }
    return result;
}","/**
     *  Test if set sourceBitSet is contained in  set targetBitSet.
     * @param  sourceBitSet  a bitSet
     * @param  targetBitSet  a bitSet
     * @return    true if  sourceBitSet is contained in  targetBitSet
     */","('isContainedIn', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,  Test if set sourceBitSet is contained in set targetBitSet.,10.0,"['If sourceBitSet is contained in set targetBitSet, test it.', 'Set sourceBitSet is contained in set targetBitSet.', 'If sourceBitSet is contained in set targetBitSet, you can test it.']"
394,tablesaw,tech/tablesaw/table/TableSlice.java,/core/src/main/java/tech/tablesaw/table/TableSlice.java,sourceRowNumberIterator,191-205,"/**
   * IntIterator of source table row numbers that are present in this view. This can be used to in
   * combination with the source table to iterate over the cells of a column in a sorted order
   * without copying the column.
   *
   * @return an int iterator of row numbers in the source table that are present in this view.
   */
protected PrimitiveIterator.OfInt sourceRowNumberIterator(){
    if (this.isSorted()) {
        return Arrays.stream(sortOrder).iterator();
    } else if (this.hasSelection()) {
        return selection.iterator();
    }
    return Selection.withRange(0, table.rowCount()).iterator();
}","protected PrimitiveIterator.OfInt sourceRowNumberIterator(){
    if (this.isSorted()) {
        return Arrays.stream(sortOrder).iterator();
    } else if (this.hasSelection()) {
        return selection.iterator();
    }
    return Selection.withRange(0, table.rowCount()).iterator();
}","/**
   * IntIterator of source table row numbers that are present in this view. This can be used to in
   * combination with the source table to iterate over the cells of a column in a sorted order
   * without copying the column.
   *
   * @return an int iterator of row numbers in the source table that are present in this view.
   */","('sourceRowNumberIterator', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,  IntIterator of source table row numbers that are present in this view.,13.0,"['There are source table row numbers in this view.', 'The source table row numbers are present in this view.', 'There are source table row numbers present in this view.']"
395,cdk,org/openscience/cdk/tools/LoggingTool.java,/misc/log4j/src/main/java/org/openscience/cdk/tools/LoggingTool.java,dumpSystemProperties,215-227,"/**
     * Outputs system properties for the operating system and the java
     * version. More specifically: os.name, os.version, os.arch, java.version
     * and java.vendor.
     */
public void dumpSystemProperties(){
    debug(""os.name        : "" + System.getProperty(""os.name""));
    debug(""os.version     : "" + System.getProperty(""os.version""));
    debug(""os.arch        : "" + System.getProperty(""os.arch""));
    debug(""java.version   : "" + System.getProperty(""java.version""));
    debug(""java.vendor    : "" + System.getProperty(""java.vendor""));
}","public void dumpSystemProperties(){
    debug(""os.name        : "" + System.getProperty(""os.name""));
    debug(""os.version     : "" + System.getProperty(""os.version""));
    debug(""os.arch        : "" + System.getProperty(""os.arch""));
    debug(""java.version   : "" + System.getProperty(""java.version""));
    debug(""java.vendor    : "" + System.getProperty(""java.vendor""));
}","/**
     * Outputs system properties for the operating system and the java
     * version. More specifically: os.name, os.version, os.arch, java.version
     * and java.vendor.
     */","('dumpSystemProperties', {'INSTRUCTION': {'covered': 56, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,  Outputs system properties for the operating system and the java  version.,12.0,"['The system properties are used for the operating system and the java version.', 'The system properties are used for the operating system and java version.', 'The system properties are used for the operating system.']"
396,weblogic-kubernetes-operator,oracle/kubernetes/operator/helpers/FileGroupReader.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/FileGroupReader.java,loadContents,45-57,"/**
   * Given a file path, loads the contents of the files into a map.
   *
   * @param rootDir the path to the top-level directory
   * @return a map of file names to string contents.
   * @throws IOException if an error occurs during the read
   */
 static Map<String, String> loadContents(Path rootDir) throws IOException{
    try (Stream<Path> walk = Files.walk(rootDir, 1)) {
        return walk.filter(path -> !Files.isDirectory(path)).collect(Collectors.toMap(FileGroupReader::asString, FileGroupReader::readContents));
    }
}","static Map<String, String> loadContents(Path rootDir) throws IOException{
    try (Stream<Path> walk = Files.walk(rootDir, 1)) {
        return walk.filter(path -> !Files.isDirectory(path)).collect(Collectors.toMap(FileGroupReader::asString, FileGroupReader::readContents));
    }
}","/**
   * Given a file path, loads the contents of the files into a map.
   *
   * @param rootDir the path to the top-level directory
   * @return a map of file names to string contents.
   * @throws IOException if an error occurs during the read
   */","('loadContents', {'INSTRUCTION': {'covered': 17, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,"  Given a file path, loads the contents of the files into a map.",15.0,"['Load the contents of the files into a map.', 'Load the contents of the files into a map with a file path.', 'Load the contents of the files into a map if you have a file path.']"
397,json-schema-validator,com/networknt/schema/TypeValidator.java,/src/main/java/com/networknt/schema/TypeValidator.java,isNumber,227-244,"/**
     * Check if the type of the JsonNode's value is number based on the
     * status of typeLoose flag.
     *
     * @param node        the JsonNode to check
     * @param config      the SchemaValidatorsConfig to depend on
     * @return boolean to indicate if it is a number
     */
public static boolean isNumber(JsonNode node, SchemaValidatorsConfig config){
    if (node.isNumber()) {
        return true;
    } else if (config.isTypeLoose()) {
        if (TypeFactory.getValueNodeType(node, config) == JsonType.STRING) {
            return isNumeric(node.textValue());
        }
    }
    return false;
}","public static boolean isNumber(JsonNode node, SchemaValidatorsConfig config){
    if (node.isNumber()) {
        return true;
    } else if (config.isTypeLoose()) {
        if (TypeFactory.getValueNodeType(node, config) == JsonType.STRING) {
            return isNumeric(node.textValue());
        }
    }
    return false;
}","/**
     * Check if the type of the JsonNode's value is number based on the
     * status of typeLoose flag.
     *
     * @param node        the JsonNode to check
     * @param config      the SchemaValidatorsConfig to depend on
     * @return boolean to indicate if it is a number
     */","('isNumber', {'INSTRUCTION': {'covered': 19, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,  Check if the type of the JsonNode's value is number based on the  status of typeLoose flag.,19.0,"[""The type of the JsonNode's value is based on the status of the typeLoose flag."", ""If the type of the JsonNode's number is based on the status of the typeLoose flag, check it."", ""If the type of the JsonNode's number is based on the typeLoose flag, check it.""]"
398,weblogic-kubernetes-operator,oracle/kubernetes/operator/calls/AsyncRequestStep.java,/operator/src/main/java/oracle/kubernetes/operator/calls/AsyncRequestStep.java,accessContinue,133-146,"/**
   * Access continue field, if any, from list metadata.
   * @param result Kubernetes list result
   * @return Continue value
   */
public static String accessContinue(Object result){
    return Optional.ofNullable(result).filter(KubernetesListObject.class::isInstance).map(KubernetesListObject.class::cast).map(KubernetesListObject::getMetadata).map(V1ListMeta::getContinue).filter(Predicate.not(String::isEmpty)).orElse(null);
}","public static String accessContinue(Object result){
    return Optional.ofNullable(result).filter(KubernetesListObject.class::isInstance).map(KubernetesListObject.class::cast).map(KubernetesListObject::getMetadata).map(V1ListMeta::getContinue).filter(Predicate.not(String::isEmpty)).orElse(null);
}","/**
   * Access continue field, if any, from list metadata.
   * @param result Kubernetes list result
   * @return Continue value
   */","('accessContinue', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,"  Access continue field, if any, from list metadata.",11.0,"['The access continue field is from the list.', 'The access continue field is from the list data.', 'The access continue field is from the list metadata.']"
399,dcache,org/dcache/util/cli/AnnotatedCommandScanner.java,/modules/common-cli/src/main/java/org/dcache/util/cli/AnnotatedCommandScanner.java,cast,24-38,"/**
     * Verifies that clazz implements Callable<? extends Serializable> and casts it to that type.
     *
     * @param clazz The clazz of the command object
     * @return clazz cast to Callable<? extends Serializable>
     */
private Class<? extends Callable<? extends Serializable>> cast(Class<?> clazz){
    if (EXPECTED_TYPE.isSupertypeOf(clazz)) {
        return (Class<? extends Callable<? extends Serializable>>) clazz.asSubclass(Callable.class);
    }
    throw new RuntimeException(""This is a bug. Please notify support@dcache.org ("" + clazz + "" does not implement Callable<? extends Serializable>)."");
}","private Class<? extends Callable<? extends Serializable>> cast(Class<?> clazz){
    if (EXPECTED_TYPE.isSupertypeOf(clazz)) {
        return (Class<? extends Callable<? extends Serializable>>) clazz.asSubclass(Callable.class);
    }
    throw new RuntimeException(""This is a bug. Please notify support@dcache.org ("" + clazz + "" does not implement Callable<? extends Serializable>)."");
}","/**
     * Verifies that clazz implements Callable<? extends Serializable> and casts it to that type.
     *
     * @param clazz The clazz of the command object
     * @return clazz cast to Callable<? extends Serializable>
     */","('cast', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,  Verifies that clazz implements Callable<? extends Serializable> and casts it to that type.,17.0,"['Verifies that it implements Callable and casts it to that type.', 'Verifies that it implements Callable and then casts it to that type.', 'Verifies that it implements Callable.']"
400,jeromq,org/zeromq/ZMsg.java,/src/main/java/org/zeromq/ZMsg.java,unwrap,129-148,"/**
     * Pop frame off front of message, caller now owns frame.
     * If next frame is empty, pops and destroys that empty frame
     * (e.g. useful when unwrapping ROUTER socket envelopes)
     * @return
     *          Unwrapped frame
     */
public ZFrame unwrap(){
    if (size() == 0) {
        return null;
    }
    ZFrame f = pop();
    ZFrame empty = getFirst();
    if (empty.hasData() && empty.size() == 0) {
        empty = pop();
        empty.destroy();
    }
    return f;
}","public ZFrame unwrap(){
    if (size() == 0) {
        return null;
    }
    ZFrame f = pop();
    ZFrame empty = getFirst();
    if (empty.hasData() && empty.size() == 0) {
        empty = pop();
        empty.destroy();
    }
    return f;
}","/**
     * Pop frame off front of message, caller now owns frame.
     * If next frame is empty, pops and destroys that empty frame
     * (e.g. useful when unwrapping ROUTER socket envelopes)
     * @return
     *          Unwrapped frame
     */","('unwrap', {'INSTRUCTION': {'covered': 22, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",67.0,"  Pop frame off front of message, caller now owns frame.",12.0,"['The caller now owns the frame.', 'The caller now owns the pop frame.', 'The caller now has the frame.']"
401,cdk,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,toCharge,1620-1645,"/**
     * Convert the a character (from an MDL V2000 input) to a charge value:
     * 1 = +1, 2 = +2, 3 = +3, 4 = doublet radical, 5 = -1, 6 = -2, 7 = -3.
     *
     * @param c a character
     * @return formal charge
     */
private static int toCharge(final char c){
    switch(c) {
        case '1':
            return +3;
        case '2':
            return +2;
        case '3':
            return +1;
        case '4':
            return 0;
        case '5':
            return -1;
        case '6':
            return -2;
        case '7':
            return -3;
    }
    return 0;
}","private static int toCharge(final char c){
    switch(c) {
        case '1':
            return +3;
        case '2':
            return +2;
        case '3':
            return +1;
        case '4':
            return 0;
        case '5':
            return -1;
        case '6':
            return -2;
        case '7':
            return -3;
    }
    return 0;
}","/**
     * Convert the a character (from an MDL V2000 input) to a charge value:
     * 1 = +1, 2 = +2, 3 = +3, 4 = doublet radical, 5 = -1, 6 = -2, 7 = -3.
     *
     * @param c a character
     * @return formal charge
     */","('toCharge', {'INSTRUCTION': {'covered': 18, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",68.0,"Convert the a character (from an MDL V2000 input) to a charge value:  1 = +1, 2 = +2, 3 = +3, 4 = doublet radical, 5 = -1, 6 = -2, 7 = -3.",45.0,"['A character from an MDL V2000 input can be converted to a charge value.', 'A character from an MDL V2000 input is converted to a charge value.', 'The a character from the MDL V2000 input can be converted to a charge value.']"
402,dataverse,edu/harvard/iq/dataverse/util/StringUtil.java,/src/main/java/edu/harvard/iq/dataverse/util/StringUtil.java,htmlArray2textArray,104-116,"/**
     * @return A list of clean strings or an empty list.
     */
public static List<String> htmlArray2textArray(List<String> htmlArray){
    List<String> cleanTextArray = new ArrayList<>();
    if (htmlArray == null) {
        return cleanTextArray;
    }
    for (String html : htmlArray) {
        cleanTextArray.add(Jsoup.parse(html).text());
    }
    return cleanTextArray;
}","public static List<String> htmlArray2textArray(List<String> htmlArray){
    List<String> cleanTextArray = new ArrayList<>();
    if (htmlArray == null) {
        return cleanTextArray;
    }
    for (String html : htmlArray) {
        cleanTextArray.add(Jsoup.parse(html).text());
    }
    return cleanTextArray;
}","/**
     * @return A list of clean strings or an empty list.
     */","('htmlArray2textArray', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",68.0,  @return A list of clean strings or an empty list.,12.0,"['There is a list of clean strings or an empty list.', 'A list of clean strings or empty strings.', 'A list of clean strings or an empty list is returned.']"
403,weblogic-kubernetes-operator,oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,containsServer,353-366,"/**
   * Whether the WebLogic domain contains a server with the given server name,
   * including standalone servers, and servers that belong to a configured or dynamic cluster.
   *
   * @param serverName server name to be checked
   * @return True if the WebLogic domain contains a server with the given server name
   */
public synchronized boolean containsServer(String serverName){
    if (!isNullOrEmpty(serverName)) {
        return getServers().stream().anyMatch(s -> serverName.equals(s.getName())) || getConfiguredClusters().stream().anyMatch(c -> c.containsServer(serverName));
    }
    return false;
}","public synchronized boolean containsServer(String serverName){
    if (!isNullOrEmpty(serverName)) {
        return getServers().stream().anyMatch(s -> serverName.equals(s.getName())) || getConfiguredClusters().stream().anyMatch(c -> c.containsServer(serverName));
    }
    return false;
}","/**
   * Whether the WebLogic domain contains a server with the given server name,
   * including standalone servers, and servers that belong to a configured or dynamic cluster.
   *
   * @param serverName server name to be checked
   * @return True if the WebLogic domain contains a server with the given server name
   */","('containsServer', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",68.0,"  Whether the WebLogic domain contains a server with the given server name,  including standalone servers, and servers that belong to a configured or dynamic cluster.",28.0,"['The server name, as well as the server name that is a part of a configured or dynamic cluster, can be found in the WebLogic domain.', 'The server name, as well as the server name that is a part of a configured or dynamic cluster, are included in the WebLogic domain.', 'The server name, as well as the server name that is a part of a configured or dynamic cluster, can be used for the WebLogic domain.']"
404,cdk,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,indexOfHetro,316-330,"/**
     * Find the index of a hetroatom in a cycle. A hetroatom in MMFF is the unique atom that
     * contributes a pi-lone-pair to the aromatic system.
     *
     * @param cycle        aromatic cycle, |C| = 5
     * @param contribution vector of p electron contributions from each vertex
     * @return index of hetroatom, if none found index is < 0.
     */
 static int indexOfHetro(int[] cycle, int[] contribution){
    int index = -1;
    for (int i = 0; i < cycle.length - 1; i++) {
        if (contribution[cycle[i]] == 2)
            index = index == -1 ? i : -2;
    }
    return index;
}","static int indexOfHetro(int[] cycle, int[] contribution){
    int index = -1;
    for (int i = 0; i < cycle.length - 1; i++) {
        if (contribution[cycle[i]] == 2)
            index = index == -1 ? i : -2;
    }
    return index;
}","/**
     * Find the index of a hetroatom in a cycle. A hetroatom in MMFF is the unique atom that
     * contributes a pi-lone-pair to the aromatic system.
     *
     * @param cycle        aromatic cycle, |C| = 5
     * @param contribution vector of p electron contributions from each vertex
     * @return index of hetroatom, if none found index is < 0.
     */","('indexOfHetro', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,  Find the index of a hetroatom in a cycle.,10.0,"[""The hetroatom's index is found in a cycle."", ""The hetroatom's index is in a cycle."", 'The hetroatom has an index.']"
405,egeria,org/odpi/openmetadata/repositoryservices/connectors/stores/metadatacollectionstore/properties/instances/InstanceAuditHeader.java,/open-metadata-implementation/repository-services/repository-services-apis/src/main/java/org/odpi/openmetadata/repositoryservices/connectors/stores/metadatacollectionstore/properties/instances/InstanceAuditHeader.java,hashCode,590-602,"/**
     * Return a hash code based on the values of this object.
     *
     * @return in hash code
     */
public int hashCode(){
    return Objects.hash(getType(), getInstanceProvenanceType(), getMetadataCollectionId(), getMetadataCollectionName(), getInstanceLicense(), getCreatedBy(), getUpdatedBy(), getCreateTime(), getMaintainedBy(), getUpdateTime(), getVersion(), getStatus(), getStatusOnDelete(), getMappingProperties());
}","public int hashCode(){
    return Objects.hash(getType(), getInstanceProvenanceType(), getMetadataCollectionId(), getMetadataCollectionName(), getInstanceLicense(), getCreatedBy(), getUpdatedBy(), getCreateTime(), getMaintainedBy(), getUpdateTime(), getVersion(), getStatus(), getStatusOnDelete(), getMappingProperties());
}","/**
     * Return a hash code based on the values of this object.
     *
     * @return in hash code
     */","('hashCode', {'INSTRUCTION': {'covered': 75, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,  Return a hash code based on the values of this object.,12.0,"['Return a code based on the values of the object.', 'Return a code based on the values.', 'Return a code based on the values of this object.']"
406,jackson-databind,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,_initForReading,4740-4770,"/**
     * Method called to ensure that given parser is ready for reading
     * content for data binding.
     *
     * @return First token to be used for data binding after this call:
     *  can never be null as exception will be thrown if parser cannot
     *  provide more tokens.
     *
     * @throws IOException if the underlying input source has problems during
     *   parsing
     */
protected JsonToken _initForReading(JsonParser p, JavaType targetType) throws IOException{
    _deserializationConfig.initialize(p);
    JsonToken t = p.currentToken();
    if (t == null) {
        t = p.nextToken();
        if (t == null) {
            throw MismatchedInputException.from(p, targetType, ""No content to map due to end-of-input"");
        }
    }
    return t;
}","protected JsonToken _initForReading(JsonParser p, JavaType targetType) throws IOException{
    _deserializationConfig.initialize(p);
    JsonToken t = p.currentToken();
    if (t == null) {
        t = p.nextToken();
        if (t == null) {
            throw MismatchedInputException.from(p, targetType, ""No content to map due to end-of-input"");
        }
    }
    return t;
}","/**
     * Method called to ensure that given parser is ready for reading
     * content for data binding.
     *
     * @return First token to be used for data binding after this call:
     *  can never be null as exception will be thrown if parser cannot
     *  provide more tokens.
     *
     * @throws IOException if the underlying input source has problems during
     *   parsing
     */","('_initForReading', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,  Method called to ensure that given parser is ready for reading  content for data binding.,16.0,"['The method was used to make sure that the given parser is ready for reading.', 'The method was used to make sure that the given parser was ready for reading.', 'The method was used to make sure that the given parser was ready to read the content.']"
407,jooby,io/jooby/Cookie.java,/jooby/src/main/java/io/jooby/Cookie.java,unsign,464-479,"/**
   * Un-sign a value, previously signed with {@link #sign(String, String)}.
   * Produces a nonnull value or <code>null</code> for invalid.
   *
   * @param value A signed value.
   * @param secret A secret key.
   * @return A new signed value or null.
   */
public static String unsign(@Nonnull final String value, @Nonnull final String secret){
    int sep = value.indexOf(""|"");
    if (sep <= 0) {
        return null;
    }
    String str = value.substring(sep + 1);
    return sign(str, secret).equals(value) ? str : null;
}","public static String unsign(@Nonnull final String value, @Nonnull final String secret){
    int sep = value.indexOf(""|"");
    if (sep <= 0) {
        return null;
    }
    String str = value.substring(sep + 1);
    return sign(str, secret).equals(value) ? str : null;
}","/**
   * Un-sign a value, previously signed with {@link #sign(String, String)}.
   * Produces a nonnull value or <code>null</code> for invalid.
   *
   * @param value A signed value.
   * @param secret A secret key.
   * @return A new signed value or null.
   */","('unsign', {'INSTRUCTION': {'covered': 21, 'missed': 3}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,"  Un-sign a value, previously signed with {@link #sign(String, String)}.",19.0,"['The value was previously signed with @link #sign(String, String).', 'Un-sign a value that was previously signed with @link #sign(String, String).', 'Un-sign a value that was previously signed with the @link #sign(String, String)']"
408,dataverse,edu/harvard/iq/dataverse/authorization/providers/oauth2/AbstractOAuth2AuthenticationProvider.java,/src/main/java/edu/harvard/iq/dataverse/authorization/providers/oauth2/AbstractOAuth2AuthenticationProvider.java,buildAuthzUrl,110-123,"/**
     * Build an Authorization URL for this identity provider
     * @param state A randomized state, necessary to secure the authorization flow. @see OAuth2LoginBackingBean.createState()
     * @param callbackUrl URL where the provider should send the browser after authn in code flow
     */
public String buildAuthzUrl(String state, String callbackUrl){
    OAuth20Service svc = this.getService(callbackUrl);
    AuthorizationUrlBuilder aub = svc.createAuthorizationUrlBuilder().state(state);
    // Do not include scope if empty string (necessary for GitHub)
    if (!this.getSpacedScope().isEmpty()) {
        aub.scope(this.getSpacedScope());
    }
    return aub.build();
}","public String buildAuthzUrl(String state, String callbackUrl){
    OAuth20Service svc = this.getService(callbackUrl);
    AuthorizationUrlBuilder aub = svc.createAuthorizationUrlBuilder().state(state);
    // Do not include scope if empty string (necessary for GitHub)
    if (!this.getSpacedScope().isEmpty()) {
        aub.scope(this.getSpacedScope());
    }
    return aub.build();
}","/**
     * Build an Authorization URL for this identity provider
     * @param state A randomized state, necessary to secure the authorization flow. @see OAuth2LoginBackingBean.createState()
     * @param callbackUrl URL where the provider should send the browser after authn in code flow
     */","('buildAuthzUrl', {'INSTRUCTION': {'covered': 16, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,"  Build an Authorization URL for this identity provider  @param state A randomized state, necessary to secure the authorization flow.",22.0,"['A randomized state is necessary to secure the authorization flow.', 'A randomized state is needed to secure the authorization flow.', 'A randomized state is necessary to secure authorization flow.']"
409,cron-utils,com/cronutils/model/definition/CronDefinitionBuilder.java,/src/main/java/com/cronutils/model/definition/CronDefinitionBuilder.java,instance,156-167,"/**
     * Creates a new CronDefinition instance with provided field definitions.
     *
     * @return returns CronDefinition instance, never null
     */
public CronDefinition instance(){
    final Set<CronConstraint> validations = new HashSet<>();
    validations.addAll(cronConstraints);
    final List<FieldDefinition> values = new ArrayList<>(fields.values());
    values.sort(FieldDefinition.createFieldDefinitionComparator());
    return new CronDefinition(values, validations, matchDayOfWeekAndDayOfMonth);
}","public CronDefinition instance(){
    final Set<CronConstraint> validations = new HashSet<>();
    validations.addAll(cronConstraints);
    final List<FieldDefinition> values = new ArrayList<>(fields.values());
    values.sort(FieldDefinition.createFieldDefinitionComparator());
    return new CronDefinition(values, validations, matchDayOfWeekAndDayOfMonth);
}","/**
     * Creates a new CronDefinition instance with provided field definitions.
     *
     * @return returns CronDefinition instance, never null
     */","('instance', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,  Creates a new CronDefinition instance with provided field definitions.,10.0,"['A new CronDefinition instance is created with field definitions.', 'A CronDefinition instance is created with field definitions.', 'A new CronDefinition instance is created.']"
410,cdk,org/openscience/cdk/inchi/InChIToStructure.java,/storage/inchi/src/main/java/org/openscience/cdk/inchi/InChIToStructure.java,findOtherSinglyBonded,400-415,"/**
     * Finds a neighbor attached to 'atom' that is singley bonded and isn't
     * 'exclude'. If no such atom exists, the 'atom' is returned.
     *
     * @param container a molecule container
     * @param atom      the atom to find the neighbor or
     * @param exclude   don't find this atom
     * @return the other atom (or 'atom')
     */
private static IAtom findOtherSinglyBonded(IAtomContainer container, IAtom atom, IAtom exclude){
    for (final IBond bond : container.getConnectedBondsList(atom)) {
        if (!IBond.Order.SINGLE.equals(bond.getOrder()) || bond.contains(exclude))
            continue;
        return bond.getOther(atom);
    }
    return atom;
}","private static IAtom findOtherSinglyBonded(IAtomContainer container, IAtom atom, IAtom exclude){
    for (final IBond bond : container.getConnectedBondsList(atom)) {
        if (!IBond.Order.SINGLE.equals(bond.getOrder()) || bond.contains(exclude))
            continue;
        return bond.getOther(atom);
    }
    return atom;
}","/**
     * Finds a neighbor attached to 'atom' that is singley bonded and isn't
     * 'exclude'. If no such atom exists, the 'atom' is returned.
     *
     * @param container a molecule container
     * @param atom      the atom to find the neighbor or
     * @param exclude   don't find this atom
     * @return the other atom (or 'atom')
     */","('findOtherSinglyBonded', {'INSTRUCTION': {'covered': 25, 'missed': 3}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 3, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,  Finds a neighbor attached to 'atom' that is singley bonded and isn't  'exclude'.,17.0,"[""A neighbor is attached to 'atom' that isn't excluded."", ""A neighbor is attached to 'atom' and not 'exclude'."", ""A neighbor is attached to 'atom' that isn't 'exclude'.""]"
411,jackson-databind,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,writeValueAsString,3807-3828,"/**
     * Method that can be used to serialize any Java value as
     * a String. Functionally equivalent to calling
     * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}
     * and constructing String, but more efficient.
     *<p>
     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
     */
public String writeValueAsString(Object value) throws JsonProcessingException{
    SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());
    try {
        _writeValueAndClose(createGenerator(sw), value);
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    return sw.getAndClear();
}","public String writeValueAsString(Object value) throws JsonProcessingException{
    SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());
    try {
        _writeValueAndClose(createGenerator(sw), value);
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
    return sw.getAndClear();
}","/**
     * Method that can be used to serialize any Java value as
     * a String. Functionally equivalent to calling
     * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}
     * and constructing String, but more efficient.
     *<p>
     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
     */","('writeValueAsString', {'INSTRUCTION': {'covered': 20, 'missed': 4}, 'LINE': {'covered': 6, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,  Method that can be used to serialize any Java value as  a String.,14.0,"['The method can be used toserialize any Java value.', 'A method that can be used to serialize a Java value.', 'A method that can be used to serialize any Java value.']"
412,cdk,org/openscience/cdk/geometry/cip/CIPTool.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/CIPTool.java,defineLigand,307-327,"/**
     * Creates a ligand attached to a single chiral atom, where the involved
     * atoms are identified by there index in the {@link IAtomContainer}. For ligand
     * atom, {@link #HYDROGEN} can be passed as index, which will indicate the presence of
     * an implicit hydrogen, not explicitly present in the chemical graph of the
     * given <code>container</code>.
     *
     * @param container  {@link IAtomContainer} for which the returned {@link ILigand}s are defined
     * @param visitedAtoms a list of atoms already visited in the analysis
     * @param chiralAtom an integer pointing to the {@link IAtom} index of the chiral atom
     * @param ligandAtom an integer pointing to the {@link IAtom} index of the {@link ILigand}
     * @return           the created {@link ILigand}
     */
public static ILigand defineLigand(IAtomContainer container, VisitedAtoms visitedAtoms, int chiralAtom, int ligandAtom){
    if (ligandAtom == HYDROGEN) {
        return new ImplicitHydrogenLigand(container, visitedAtoms, container.getAtom(chiralAtom));
    } else {
        return new Ligand(container, visitedAtoms, container.getAtom(chiralAtom), container.getAtom(ligandAtom));
    }
}","public static ILigand defineLigand(IAtomContainer container, VisitedAtoms visitedAtoms, int chiralAtom, int ligandAtom){
    if (ligandAtom == HYDROGEN) {
        return new ImplicitHydrogenLigand(container, visitedAtoms, container.getAtom(chiralAtom));
    } else {
        return new Ligand(container, visitedAtoms, container.getAtom(chiralAtom), container.getAtom(ligandAtom));
    }
}","/**
     * Creates a ligand attached to a single chiral atom, where the involved
     * atoms are identified by there index in the {@link IAtomContainer}. For ligand
     * atom, {@link #HYDROGEN} can be passed as index, which will indicate the presence of
     * an implicit hydrogen, not explicitly present in the chemical graph of the
     * given <code>container</code>.
     *
     * @param container  {@link IAtomContainer} for which the returned {@link ILigand}s are defined
     * @param visitedAtoms a list of atoms already visited in the analysis
     * @param chiralAtom an integer pointing to the {@link IAtom} index of the chiral atom
     * @param ligandAtom an integer pointing to the {@link IAtom} index of the {@link ILigand}
     * @return           the created {@link ILigand}
     */","('defineLigand', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",69.0,"  Creates a ligand attached to a single chiral atom, where the involved  atoms are identified by there index in the {@link IAtomContainer}.",27.0,"['The involved atoms are identified by the index in the @link IAtomContainer.', 'The involved atoms are identified by the index in the @link IAtomContainer when the ligand is attached to a single atom.', 'The involved atoms are identified by the index in the @link IAtomContainer, when the ligand is attached to a single atom.']"
414,cucumber-reporting,net/masterthought/cucumber/Trends.java,/src/main/java/net/masterthought/cucumber/Trends.java,applyPatchForFeatures,188-204,"/**
     * Due to the error with old implementation where total features
     * were passed instead of failures (and vice versa) following correction must be applied for trends generated
     * between release 3.0.0 and 3.1.0.
     */
private void applyPatchForFeatures(){
    for (int i = 0; i < totalFeatures.length; i++) {
        int total = totalFeatures[i];
        int failures = getFailedFeatures()[i];
        if (total < failures) {
            int tmp = total;
            totalFeatures[i] = failures;
            failedFeatures[i] = tmp;
        }
    }
}","private void applyPatchForFeatures(){
    for (int i = 0; i < totalFeatures.length; i++) {
        int total = totalFeatures[i];
        int failures = getFailedFeatures()[i];
        if (total < failures) {
            int tmp = total;
            totalFeatures[i] = failures;
            failedFeatures[i] = tmp;
        }
    }
}","/**
     * Due to the error with old implementation where total features
     * were passed instead of failures (and vice versa) following correction must be applied for trends generated
     * between release 3.0.0 and 3.1.0.
     */","('applyPatchForFeatures', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",70.0,Due to the error with old implementation where total features  were passed instead of failures (and vice versa) following correction must be applied for trends generated  between release 3.,32.0,"['The old implementation where total features were passed instead of failures must be corrected.', 'The error with old implementation where total features were passed instead of failures must be corrected.', 'The error with old implementation where total features were passed instead of failures has to be corrected.']"
415,cdk,org/openscience/cdk/smsd/filters/ChemicalFilters.java,/legacy/src/main/java/org/openscience/cdk/smsd/filters/ChemicalFilters.java,convertBondOrder,841-867,"/**
     * Get bond order value as {@code int} value.
     *
     * @param  bond The {@link IBond} for which the order is returned.
     * @return      1 for a single bond, 2 for a double bond, 3 for a triple bond, 4 for a quadruple bond,
     *              and 0 for any other bond type.
     */
public static int convertBondOrder(IBond bond){
    int value = 0;
    switch(bond.getOrder()) {
        case QUADRUPLE:
            value = 4;
            break;
        case TRIPLE:
            value = 3;
            break;
        case DOUBLE:
            value = 2;
            break;
        case SINGLE:
            value = 1;
            break;
        default:
            value = 0;
    }
    return value;
}","public static int convertBondOrder(IBond bond){
    int value = 0;
    switch(bond.getOrder()) {
        case QUADRUPLE:
            value = 4;
            break;
        case TRIPLE:
            value = 3;
            break;
        case DOUBLE:
            value = 2;
            break;
        case SINGLE:
            value = 1;
            break;
        default:
            value = 0;
    }
    return value;
}","/**
     * Get bond order value as {@code int} value.
     *
     * @param  bond The {@link IBond} for which the order is returned.
     * @return      1 for a single bond, 2 for a double bond, 3 for a triple bond, 4 for a quadruple bond,
     *              and 0 for any other bond type.
     */","('convertBondOrder', {'INSTRUCTION': {'covered': 18, 'missed': 6}, 'BRANCH': {'covered': 3, 'missed': 2}, 'LINE': {'covered': 8, 'missed': 4}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",70.0,  Get bond order value as {@code int} value.,12.0,"['The bond order value is @code int.', 'The bond order value is @code int value.', 'The bond order value is @code int']"
416,acs-aem-commons,com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,isChecksumable,142-157,"/**
     * Ensures the node's primary type is included in the Included Node Types and NOT in the Excluded Node Types and NOT in the Excluded Node Names.
     *
     * @param node    the candidate node
     * @param options the checksum options containing the included and excluded none types
     * @return true if the node represents a checksum-able node system
     * @throws RepositoryException
     */
private boolean isChecksumable(Node node, ChecksumGeneratorOptions options) throws RepositoryException{
    final Set<String> nodeTypeIncludes = options.getIncludedNodeTypes();
    final Set<String> nodeTypeExcludes = options.getExcludedNodeTypes();
    final String primaryNodeType = node.getPrimaryNodeType().getName();
    return nodeTypeIncludes.contains(primaryNodeType) && !nodeTypeExcludes.contains(primaryNodeType);
}","private boolean isChecksumable(Node node, ChecksumGeneratorOptions options) throws RepositoryException{
    final Set<String> nodeTypeIncludes = options.getIncludedNodeTypes();
    final Set<String> nodeTypeExcludes = options.getExcludedNodeTypes();
    final String primaryNodeType = node.getPrimaryNodeType().getName();
    return nodeTypeIncludes.contains(primaryNodeType) && !nodeTypeExcludes.contains(primaryNodeType);
}","/**
     * Ensures the node's primary type is included in the Included Node Types and NOT in the Excluded Node Types and NOT in the Excluded Node Names.
     *
     * @param node    the candidate node
     * @param options the checksum options containing the included and excluded none types
     * @return true if the node represents a checksum-able node system
     * @throws RepositoryException
     */","('isChecksumable', {'INSTRUCTION': {'covered': 22, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",70.0,  Ensures the node's primary type is included in the Included Node Types and NOT in the Excluded Node Types and NOT in the Excluded Node Names.,28.0,"['Ensures the primary type is included in the included type and not in the excluded type.', 'Ensures the primary type is included in the included types and not in the excluded types.', 'Ensures the primary type is included in the included type and not in the excluded type and not in the excluded name.']"
418,matsim-libs,org/matsim/core/network/algorithms/intersectionSimplifier/IntersectionSimplifier.java,/matsim/src/main/java/org/matsim/core/network/algorithms/intersectionSimplifier/IntersectionSimplifier.java,reportNetworkStatistics,221-231,"/**
	 * Provides basic statistics of a given {@link Network}.  
	 * @param network
	 */
public static void reportNetworkStatistics(Network network){
    LOG.info(""--- Network statistics: ------------------------------------------------------"");
    LOG.info(""   Network description: "" + network.getName());
    LOG.info(""       Number of nodes: "" + network.getNodes().size());
    LOG.info(""       Number of links: "" + network.getLinks().size());
    LOG.info(""------------------------------------------------------------------------------"");
}","public static void reportNetworkStatistics(Network network){
    LOG.info(""--- Network statistics: ------------------------------------------------------"");
    LOG.info(""   Network description: "" + network.getName());
    LOG.info(""       Number of nodes: "" + network.getNodes().size());
    LOG.info(""       Number of links: "" + network.getLinks().size());
    LOG.info(""------------------------------------------------------------------------------"");
}","/**
	 * Provides basic statistics of a given {@link Network}.  
	 * @param network
	 */","('reportNetworkStatistics', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",71.0,  Provides basic statistics of a given {@link Network}.,12.0,"['Basic statistics of a given network.', 'Provides basic statistics of a network.', 'Basic statistics of a given @link Network.']"
419,logstash-logback-encoder,net/logstash/logback/util/ThreadLocalHolder.java,/src/main/java/net/logstash/logback/util/ThreadLocalHolder.java,acquire,87-110,"/**
     * Get the value assigned to the current thread, creating a new one if none is assigned yet or the
     * previous has been disposed.
     * 
     * The value must be {@link #release()} to ensure proper life cycle before it can be {@link #acquire()}
     * again.
     * 
     * @return the value assigned to this thread
     * @throws IllegalStateException if the value is already in use and {@link #release()} was not yet invoked.
     */
public final T acquire(){
    Holder<T> holder = this.threadLocal.get();
    if (holder.leased) {
        throw new IllegalStateException(""ThreadLocal value is already in use and not yet released."");
    }
    if (holder.value == null) {
        holder.value = Objects.requireNonNull(createInstance());
    }
    holder.leased = true;
    return holder.value;
}","public final T acquire(){
    Holder<T> holder = this.threadLocal.get();
    if (holder.leased) {
        throw new IllegalStateException(""ThreadLocal value is already in use and not yet released."");
    }
    if (holder.value == null) {
        holder.value = Objects.requireNonNull(createInstance());
    }
    holder.leased = true;
    return holder.value;
}","/**
     * Get the value assigned to the current thread, creating a new one if none is assigned yet or the
     * previous has been disposed.
     * 
     * The value must be {@link #release()} to ensure proper life cycle before it can be {@link #acquire()}
     * again.
     * 
     * @return the value assigned to this thread
     * @throws IllegalStateException if the value is already in use and {@link #release()} was not yet invoked.
     */","('acquire', {'INSTRUCTION': {'covered': 24, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",71.0,"  Get the value assigned to the current thread, creating a new one if none is assigned yet or the  previous has been disposed.",25.0,"['Get the value assigned to the current thread and create a new one if none is assigned yet.', 'Get the value assigned to the current thread and create a new one if none is assigned yet or the previous has been removed.', 'Get the value assigned to the current thread and create a new one if no one assigns it yet.']"
420,jeromq,zmq/util/Timers.java,/src/main/java/zmq/util/Timers.java,add,113-130,"/**
     * Add timer to the set, timer repeats forever, or until cancel is called.
     * @param interval the interval of repetition in milliseconds.
     * @param handler the callback called at the expiration of the timer.
     * @param args the optional arguments for the handler.
     * @return an opaque handle for further cancel.
     */
public Timer add(long interval, Handler handler, Object... args){
    if (handler == null) {
        return null;
    }
    Utils.checkArgument(interval > 0, ""Delay of a timer has to be strictly greater than 0"");
    final Timer timer = new Timer(this, interval, handler, args);
    final boolean rc = insert(timer);
    assert (rc);
    return timer;
}","public Timer add(long interval, Handler handler, Object... args){
    if (handler == null) {
        return null;
    }
    Utils.checkArgument(interval > 0, ""Delay of a timer has to be strictly greater than 0"");
    final Timer timer = new Timer(this, interval, handler, args);
    final boolean rc = insert(timer);
    assert (rc);
    return timer;
}","/**
     * Add timer to the set, timer repeats forever, or until cancel is called.
     * @param interval the interval of repetition in milliseconds.
     * @param handler the callback called at the expiration of the timer.
     * @param args the optional arguments for the handler.
     * @return an opaque handle for further cancel.
     */","('add', {'INSTRUCTION': {'covered': 32, 'missed': 4}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",71.0,"  Add timer to the set, timer repeats forever, or until cancel is called.",16.0,"['Add a timer to the set and it will repeat forever.', 'Add a timer to the set and it will be repeated forever.', 'Add a timer to the set and it will be repeats forever.']"
421,cdk,org/openscience/cdk/silent/LonePair.java,/base/silent/src/main/java/org/openscience/cdk/silent/LonePair.java,toString,133-149,"/**
     * Returns a one line string representation of this LonePair.
     * This method is conform RFC #9.
     *
     * @return    The string representation of this LonePair
     */
public String toString(){
    StringBuffer resultString = new StringBuffer();
    resultString.append(""LonePair("");
    resultString.append(this.hashCode());
    if (atom != null) {
        resultString.append("", "").append(atom.toString());
    }
    resultString.append(')');
    return resultString.toString();
}","public String toString(){
    StringBuffer resultString = new StringBuffer();
    resultString.append(""LonePair("");
    resultString.append(this.hashCode());
    if (atom != null) {
        resultString.append("", "").append(atom.toString());
    }
    resultString.append(')');
    return resultString.toString();
}","/**
     * Returns a one line string representation of this LonePair.
     * This method is conform RFC #9.
     *
     * @return    The string representation of this LonePair
     */","('toString', {'INSTRUCTION': {'covered': 23, 'missed': 8}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",71.0,  Returns a one line string representation of this LonePair.,10.0,"['A one line string representation of this Lone Pair is returned.', 'A one line string representation of a Lone Pair.', 'A one line string representation of this Lone Pair.']"
422,cdk,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,indexAtoms,338-349,"/**
     * Create an index of atoms for the provided {@code container}.
     *
     * @param container the container to index the atoms of
     * @return the index/lookup of atoms to the index they appear
     */
private static Map<IAtom, Integer> indexAtoms(IAtomContainer container){
    Map<IAtom, Integer> map = new HashMap<>(2 * container.getAtomCount());
    for (int i = 0; i < container.getAtomCount(); i++) map.put(container.getAtom(i), i);
    return map;
}","private static Map<IAtom, Integer> indexAtoms(IAtomContainer container){
    Map<IAtom, Integer> map = new HashMap<>(2 * container.getAtomCount());
    for (int i = 0; i < container.getAtomCount(); i++) map.put(container.getAtom(i), i);
    return map;
}","/**
     * Create an index of atoms for the provided {@code container}.
     *
     * @param container the container to index the atoms of
     * @return the index/lookup of atoms to the index they appear
     */","('indexAtoms', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",72.0,  Create an index of atoms for the provided {@code container}.,14.0,"['The provided @code container has an index of atoms.', 'The provided code container has an index of atoms.', 'The provided @code container will give you an index of atoms.']"
424,matsim-libs,org/matsim/core/router/priorityqueue/BinaryMinHeap.java,/matsim/src/main/java/org/matsim/core/router/priorityqueue/BinaryMinHeap.java,decreaseKey,313-339,"/**
	 * Increases the priority (=decrease the given double value) of the element.
	 * If the element ins not part of the queue, it is added. If the new priority
	 * is lower than the existing one, the method returns <tt>false</tt>
	 *
	 * @return <tt>true</tt> if the elements priority was decreased.
	 */
public boolean decreaseKey(E value, double cost){
    int index = indices[this.getIndex(value)];
    if (index < 0) {
        return this.add(value, cost);
    }
    double oldCost = costs[index];
    if (oldCost < cost)
        return false;
    siftUp(index, value, cost);
    return true;
}","public boolean decreaseKey(E value, double cost){
    int index = indices[this.getIndex(value)];
    if (index < 0) {
        return this.add(value, cost);
    }
    double oldCost = costs[index];
    if (oldCost < cost)
        return false;
    siftUp(index, value, cost);
    return true;
}","/**
	 * Increases the priority (=decrease the given double value) of the element.
	 * If the element ins not part of the queue, it is added. If the new priority
	 * is lower than the existing one, the method returns <tt>false</tt>
	 *
	 * @return <tt>true</tt> if the elements priority was decreased.
	 */","('decreaseKey', {'INSTRUCTION': {'covered': 30, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",72.0,  Increases the priority (=decrease the given double value) of the element.,14.0,"['The priority of the element is increased.', ""The element's priority is increased if the double value is decreased."", ""The element's priority is increased by decreasing the double value.""]"
425,cdk,org/openscience/cdk/layout/IdentityTemplateLibrary.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/IdentityTemplateLibrary.java,decodeEntry,231-243,"/**
     * Create a library entry from a SMILES string with the coordinates suffixed in binary. The
     * entry should be created with {@link #encodeEntry(java.util.Map.Entry)} and not created
     * manually. Note, the entry is not added to the library.
     *
     * @param str input string
     * @return library entry
     */
 static Entry<String, Point2d[]> decodeEntry(String str){
    final int i = str.indexOf(' ');
    if (i < 0)
        throw new IllegalArgumentException();
    return new SimpleEntry<String, Point2d[]>(str.substring(0, i), decodeCoordinates(str.substring(i + 1)));
}","static Entry<String, Point2d[]> decodeEntry(String str){
    final int i = str.indexOf(' ');
    if (i < 0)
        throw new IllegalArgumentException();
    return new SimpleEntry<String, Point2d[]>(str.substring(0, i), decodeCoordinates(str.substring(i + 1)));
}","/**
     * Create a library entry from a SMILES string with the coordinates suffixed in binary. The
     * entry should be created with {@link #encodeEntry(java.util.Map.Entry)} and not created
     * manually. Note, the entry is not added to the library.
     *
     * @param str input string
     * @return library entry
     */","('decodeEntry', {'INSTRUCTION': {'covered': 20, 'missed': 4}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",72.0,  Create a library entry from a SMILES string with the coordinates suffixed in binary.,15.0,"['A library entry is created from a SMILES string.', 'A library entry is created from a SMILES string with coordinates.', 'A library entry is created from a SMILES string with the coordinates.']"
426,cdk,org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/VecmathUtil.java,newUnitVectors,97-110,"/**
     * Create unit vectors from one atom to all other provided atoms.
     *
     * @param fromAtom reference atom (will become 0,0)
     * @param toAtoms list of to atoms
     * @return unit vectors
     */
 static List<Vector2d> newUnitVectors(final IAtom fromAtom, final List<IAtom> toAtoms){
    final List<Vector2d> unitVectors = new ArrayList<Vector2d>(toAtoms.size());
    for (final IAtom toAtom : toAtoms) {
        unitVectors.add(newUnitVector(fromAtom.getPoint2d(), toAtom.getPoint2d()));
    }
    return unitVectors;
}","static List<Vector2d> newUnitVectors(final IAtom fromAtom, final List<IAtom> toAtoms){
    final List<Vector2d> unitVectors = new ArrayList<Vector2d>(toAtoms.size());
    for (final IAtom toAtom : toAtoms) {
        unitVectors.add(newUnitVector(fromAtom.getPoint2d(), toAtom.getPoint2d()));
    }
    return unitVectors;
}","/**
     * Create unit vectors from one atom to all other provided atoms.
     *
     * @param fromAtom reference atom (will become 0,0)
     * @param toAtoms list of to atoms
     * @return unit vectors
     */","('newUnitVectors', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",73.0,  Create unit vectors from one atom to all other provided atoms.,12.0,"['The unit is created from one atom to all the other atoms.', 'The unit is created from one atom to all other atoms.', 'The unit is created from one atom to all the others.']"
428,cron-utils,com/cronutils/utils/StringUtils.java,/src/main/java/com/cronutils/utils/StringUtils.java,join,208-245,"/**
     * <p>
     * Joins the elements of the provided array into a single String containing the
     * provided list of elements.
     * </p>
     *
     * <p>
     * No delimiter is added before or after the list. A {@code null} separator is
     * the same as an empty String (""""). Null objects or empty strings within the
     * array are represented by empty strings.
     * </p>
     *
     * <pre>
     * StringUtils.join(null, *)                = null
     * StringUtils.join([], *)                  = """"
     * StringUtils.join([null], *)              = ""null""
     * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
     * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
     * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
     * StringUtils.join([null, """", ""a""], ',')   = ""null,,a""
     * </pre>
     *
     * @param parts - the array of values to join together, may be null
     * @param separator - the separator character to use, null treated as """"
     * @return the joined String, {@code null} if null array input
     */
public static String join(final Object[] parts, final String separator){
    if (parts == null) {
        return null;
    }
    final StringJoiner joiner = new StringJoiner(separator == null ? EMPTY : separator);
    for (final Object part : parts) {
        joiner.add(String.valueOf(part));
    }
    return joiner.toString();
}","public static String join(final Object[] parts, final String separator){
    if (parts == null) {
        return null;
    }
    final StringJoiner joiner = new StringJoiner(separator == null ? EMPTY : separator);
    for (final Object part : parts) {
        joiner.add(String.valueOf(part));
    }
    return joiner.toString();
}","/**
     * <p>
     * Joins the elements of the provided array into a single String containing the
     * provided list of elements.
     * </p>
     *
     * <p>
     * No delimiter is added before or after the list. A {@code null} separator is
     * the same as an empty String (""""). Null objects or empty strings within the
     * array are represented by empty strings.
     * </p>
     *
     * <pre>
     * StringUtils.join(null, *)                = null
     * StringUtils.join([], *)                  = """"
     * StringUtils.join([null], *)              = ""null""
     * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
     * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
     * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
     * StringUtils.join([null, """", ""a""], ',')   = ""null,,a""
     * </pre>
     *
     * @param parts - the array of values to join together, may be null
     * @param separator - the separator character to use, null treated as """"
     * @return the joined String, {@code null} if null array input
     */","('join', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",73.0,  <p>  Joins the elements of the provided array into a single String containing the  provided list of elements.,21.0,"['The provided array contains a list of elements.', 'The provided array contains elements that are joined into a single string.', 'The provided array contains elements that are joined into a single String.']"
430,dcache,dmg/cells/nucleus/CellMessage.java,/modules/cells/src/main/java/dmg/cells/nucleus/CellMessage.java,clone,217-233,"/**
     * The method does not copy the message object - only the encoded message stream (if any).
     */
public CellMessage clone(){
    try {
        CellMessage copy = (CellMessage) super.clone();
        copy._destination = _destination.clone();
        if (_source != null) {
            copy._source = _source.clone();
        }
        copy._messageStream = _messageStream;
        return copy;
    } catch (CloneNotSupportedException e) {
        throw new RuntimeException(e);
    }
}","public CellMessage clone(){
    try {
        CellMessage copy = (CellMessage) super.clone();
        copy._destination = _destination.clone();
        if (_source != null) {
            copy._source = _source.clone();
        }
        copy._messageStream = _messageStream;
        return copy;
    } catch (CloneNotSupportedException e) {
        throw new RuntimeException(e);
    }
}","/**
     * The method does not copy the message object - only the encoded message stream (if any).
     */","('clone', {'INSTRUCTION': {'covered': 23, 'missed': 6}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",73.0,  The method does not copy the message object - only the encoded message stream (if any).,19.0,"[""The method doesn't copy the message object."", 'The method does not copy the message object.', ""The method doesn't copy the object, only the stream.""]"
431,openapi-generator,org/openapitools/codegen/DefaultCodegen.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java,toVarName,1451-1465,"/**
     * Return the variable name by removing invalid characters and proper escaping if
     * it's a reserved word.
     *
     * @param name the variable name
     * @return the sanitized variable name
     */
public String toVarName(final String name){
    if (reservedWords.contains(name)) {
        return escapeReservedWord(name);
    } else if (name.chars().anyMatch(character -> specialCharReplacements.containsKey(String.valueOf((char) character)))) {
        return escape(name, specialCharReplacements, null, null);
    }
    return name;
}","public String toVarName(final String name){
    if (reservedWords.contains(name)) {
        return escapeReservedWord(name);
    } else if (name.chars().anyMatch(character -> specialCharReplacements.containsKey(String.valueOf((char) character)))) {
        return escape(name, specialCharReplacements, null, null);
    }
    return name;
}","/**
     * Return the variable name by removing invalid characters and proper escaping if
     * it's a reserved word.
     *
     * @param name the variable name
     * @return the sanitized variable name
     */","('toVarName', {'INSTRUCTION': {'covered': 20, 'missed': 4}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",73.0,  Return the variable name by removing invalid characters and proper escaping if  it's a reserved word.,18.0,"[""Remove invalid characters and proper escaping if it's a reserved word to return the variable name."", 'Remove invalid characters and proper escaping if the variable name is a reserved word.', ""Remove invalid characters and proper escaping if it's a reserved word to return a variable name.""]"
433,metrics,io/dropwizard/metrics5/health/HealthCheck.java,/metrics-healthchecks/src/main/java/io/dropwizard/metrics5/health/HealthCheck.java,execute,363-379,"/**
     * Executes the health check, catching and handling any exceptions raised by {@link #check()}.
     *
     * @return if the component is healthy, a healthy {@link Result}; otherwise, an unhealthy {@link
     * Result} with a descriptive error message or exception
     */
 Result execute(){
    long start = clock().getTick();
    Result result;
    try {
        result = check();
    } catch (Exception e) {
        result = Result.unhealthy(e);
    }
    result.setDuration(TimeUnit.MILLISECONDS.convert(clock().getTick() - start, TimeUnit.NANOSECONDS));
    return result;
}"," Result execute(){
    long start = clock().getTick();
    Result result;
    try {
        result = check();
    } catch (Exception e) {
        result = Result.unhealthy(e);
    }
    result.setDuration(TimeUnit.MILLISECONDS.convert(clock().getTick() - start, TimeUnit.NANOSECONDS));
    return result;
}","/**
     * Executes the health check, catching and handling any exceptions raised by {@link #check()}.
     *
     * @return if the component is healthy, a healthy {@link Result}; otherwise, an unhealthy {@link
     * Result} with a descriptive error message or exception
     */","('execute', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,"  Executes the health check, catching and handling any exceptions raised by {@link #check()}.",21.0,"['Handling any exceptions raised by @link #check', 'Handling any exceptions raised by @link #check is done by the health check.', 'The health check is performed and handled by catching and handling exceptions.']"
434,egeria,org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,/open-metadata-implementation/access-services/asset-lineage/asset-lineage-server/src/main/java/org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,buildDataFileContext,305-325,"/**
     * Builds the data file context for a tabular column.
     *
     * @param userId       the unique identifier for the user
     * @param entityDetail the entity for which the context is build
     *
     * @return the data file context of the tabular column
     *
     * @throws OCFCheckedExceptionBase checked exception for reporting errors found when using OCF connectors
     */
private RelationshipsContext buildDataFileContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
    Set<GraphContext> context = new HashSet<>();
    addConnectionToAssetContext(userId, entityDetail, context);
    EntityDetail fileFolder = handlerHelper.addContextForRelationships(userId, entityDetail, NESTED_FILE, context);
    addContextForFileFolder(userId, fileFolder, context);
    return new RelationshipsContext(entityDetail.getGUID(), context);
}","private RelationshipsContext buildDataFileContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
    Set<GraphContext> context = new HashSet<>();
    addConnectionToAssetContext(userId, entityDetail, context);
    EntityDetail fileFolder = handlerHelper.addContextForRelationships(userId, entityDetail, NESTED_FILE, context);
    addContextForFileFolder(userId, fileFolder, context);
    return new RelationshipsContext(entityDetail.getGUID(), context);
}","/**
     * Builds the data file context for a tabular column.
     *
     * @param userId       the unique identifier for the user
     * @param entityDetail the entity for which the context is build
     *
     * @return the data file context of the tabular column
     *
     * @throws OCFCheckedExceptionBase checked exception for reporting errors found when using OCF connectors
     */","('buildDataFileContext', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,  Builds the data file context for a tabular column.,10.0,"['The data file context is built.', 'The data file context is built for a tabular column.', 'A tabular column has a data file context.']"
435,cdk,org/openscience/cdk/renderer/RendererModel.java,/display/render/src/main/java/org/openscience/cdk/renderer/RendererModel.java,registerParameters,266-281,"/**
     * Registers rendering parameters from {@link IGenerator}s
     * with this model.
     *
     * @param generator
     */
public void registerParameters(IGenerator<? extends IChemObject> generator){
    for (IGeneratorParameter<?> param : generator.getParameters()) {
        try {
            renderingParameters.put(param.getClass().getName(), param.getClass().newInstance());
        } catch (InstantiationException | IllegalAccessException e) {
            throw new IllegalStateException(""Could not create a copy of rendering parameter."");
        }
    }
}","public void registerParameters(IGenerator<? extends IChemObject> generator){
    for (IGeneratorParameter<?> param : generator.getParameters()) {
        try {
            renderingParameters.put(param.getClass().getName(), param.getClass().newInstance());
        } catch (InstantiationException | IllegalAccessException e) {
            throw new IllegalStateException(""Could not create a copy of rendering parameter."");
        }
    }
}","/**
     * Registers rendering parameters from {@link IGenerator}s
     * with this model.
     *
     * @param generator
     */","('registerParameters', {'INSTRUCTION': {'covered': 25, 'missed': 6}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,  Registers rendering parameters from {@link IGenerator}s  with this model.,14.0,"['This model is used to register rendering parameters from @link IGenerators.', 'This model is used to register rendering parameters from @link IGenerator.', 'Registers the parameters from @link IGenerators.']"
436,cdk,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,calculateMassT,521-536,"/**
     * Calculate the mass total given the elements and their respective occurrences.
     *
     * @param elemToCond_new  The IIsotope to calculate
     * @param value_In        Array matrix with occurrences
     * @return                The sum total
     */
private double calculateMassT(List<IIsotope> isoToCond_new, int[] value_In){
    double result = 0;
    for (int i = 0; i < isoToCond_new.size(); i++) {
        if (value_In[i] != 0) {
            result += isoToCond_new.get(i).getExactMass() * value_In[i];
        }
    }
    return result;
}","private double calculateMassT(List<IIsotope> isoToCond_new, int[] value_In){
    double result = 0;
    for (int i = 0; i < isoToCond_new.size(); i++) {
        if (value_In[i] != 0) {
            result += isoToCond_new.get(i).getExactMass() * value_In[i];
        }
    }
    return result;
}","/**
     * Calculate the mass total given the elements and their respective occurrences.
     *
     * @param elemToCond_new  The IIsotope to calculate
     * @param value_In        Array matrix with occurrences
     * @return                The sum total
     */","('calculateMassT', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,  Calculate the mass total given the elements and their respective occurrences.,12.0,"['Give the elements and their occurrences a mass total.', 'Give the elements and their occurrences the mass total.', 'The elements and their occurrences are given a mass total.']"
437,shardingsphere-elasticjob,org/apache/shardingsphere/elasticjob/lite/internal/config/ConfigurationService.java,/elasticjob-lite/elasticjob-lite-core/src/main/java/org/apache/shardingsphere/elasticjob/lite/internal/config/ConfigurationService.java,checkMaxTimeDiffSecondsTolerable,90-105,"/**
     * Check max time different seconds tolerable between job server and registry center.
     * 
     * @throws JobExecutionEnvironmentException throe JobExecutionEnvironmentException if exceed max time different seconds
     */
public void checkMaxTimeDiffSecondsTolerable() throws JobExecutionEnvironmentException{
    int maxTimeDiffSeconds = load(true).getMaxTimeDiffSeconds();
    if (0 > maxTimeDiffSeconds) {
        return;
    }
    long timeDiff = Math.abs(timeService.getCurrentMillis() - jobNodeStorage.getRegistryCenterTime());
    if (timeDiff > maxTimeDiffSeconds * 1000L) {
        throw new JobExecutionEnvironmentException(""Time different between job server and register center exceed '%s' seconds, max time different is '%s' seconds."", timeDiff / 1000, maxTimeDiffSeconds);
    }
}","public void checkMaxTimeDiffSecondsTolerable() throws JobExecutionEnvironmentException{
    int maxTimeDiffSeconds = load(true).getMaxTimeDiffSeconds();
    if (0 > maxTimeDiffSeconds) {
        return;
    }
    long timeDiff = Math.abs(timeService.getCurrentMillis() - jobNodeStorage.getRegistryCenterTime());
    if (timeDiff > maxTimeDiffSeconds * 1000L) {
        throw new JobExecutionEnvironmentException(""Time different between job server and register center exceed '%s' seconds, max time different is '%s' seconds."", timeDiff / 1000, maxTimeDiffSeconds);
    }
}","/**
     * Check max time different seconds tolerable between job server and registry center.
     * 
     * @throws JobExecutionEnvironmentException throe JobExecutionEnvironmentException if exceed max time different seconds
     */","('checkMaxTimeDiffSecondsTolerable', {'INSTRUCTION': {'covered': 45, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,  Check max time different seconds tolerable between job server and registry center.,13.0,"['Between job server and registry center, check max time.', 'Between the job server and registry center, check the max time.', 'Between the job server and the registry center, check the max time.']"
438,tablesaw,tech/tablesaw/util/StringUtils.java,/core/src/main/java/tech/tablesaw/util/StringUtils.java,isAlphanumeric,378-410,"/**
   * Checks if the CharSequence contains only Unicode letters or digits.
   *
   * <p>{@code null} will return {@code false}. An empty CharSequence (length()=0) will return
   * {@code false}.
   *
   * <pre>
   * StringUtils.isAlphanumeric(null)   = false
   * StringUtils.isAlphanumeric("""")     = false
   * StringUtils.isAlphanumeric(""  "")   = false
   * StringUtils.isAlphanumeric(""abc"")  = true
   * StringUtils.isAlphanumeric(""ab c"") = false
   * StringUtils.isAlphanumeric(""ab2c"") = true
   * StringUtils.isAlphanumeric(""ab-c"") = false
   * </pre>
   *
   * @param cs the CharSequence to check, may be null
   * @return {@code true} if only contains letters or digits, and is non-null
   * @since 3.0 Changed signature from isAlphanumeric(String) to isAlphanumeric(CharSequence)
   * @since 3.0 Changed """" to return false and not true
   */
public static boolean isAlphanumeric(final String cs){
    if (Strings.isNullOrEmpty(cs)) {
        return false;
    }
    final int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (!Character.isLetterOrDigit(cs.charAt(i))) {
            return false;
        }
    }
    return true;
}","public static boolean isAlphanumeric(final String cs){
    if (Strings.isNullOrEmpty(cs)) {
        return false;
    }
    final int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (!Character.isLetterOrDigit(cs.charAt(i))) {
            return false;
        }
    }
    return true;
}","/**
   * Checks if the CharSequence contains only Unicode letters or digits.
   *
   * <p>{@code null} will return {@code false}. An empty CharSequence (length()=0) will return
   * {@code false}.
   *
   * <pre>
   * StringUtils.isAlphanumeric(null)   = false
   * StringUtils.isAlphanumeric("""")     = false
   * StringUtils.isAlphanumeric(""  "")   = false
   * StringUtils.isAlphanumeric(""abc"")  = true
   * StringUtils.isAlphanumeric(""ab c"") = false
   * StringUtils.isAlphanumeric(""ab2c"") = true
   * StringUtils.isAlphanumeric(""ab-c"") = false
   * </pre>
   *
   * @param cs the CharSequence to check, may be null
   * @return {@code true} if only contains letters or digits, and is non-null
   * @since 3.0 Changed signature from isAlphanumeric(String) to isAlphanumeric(CharSequence)
   * @since 3.0 Changed """" to return false and not true
   */","('isAlphanumeric', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,  Checks if the CharSequence contains only Unicode letters or digits.,11.0,"[""If the CharSequence only contains letters or digits, it's checked."", ""If the CharSequence contains only letters or digits, it's checked."", 'If the CharSequence only contains letters or digits, it is checked.']"
440,openapi-generator,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,isMapSchema,477-528,"/**
     * Return true if the specified 'schema' is an object that can be extended with additional properties.
     * Additional properties means a Schema should support all explicitly defined properties plus any
     * undeclared properties.
     *
     * A MapSchema differs from an ObjectSchema in the following way:
     * - An ObjectSchema is not extensible, i.e. it has a fixed number of properties.
     * - A MapSchema is an object that can be extended with an arbitrary set of properties.
     *   The payload may include dynamic properties.
     *
     * Note that isMapSchema returns true for a composed schema (allOf, anyOf, oneOf) that also defines
     * additionalproperties.
     *
     * For example, an OpenAPI schema is considered a MapSchema in the following scenarios:
     *
     *   type: object
     *   additionalProperties: true
     *
     *   type: object
     *   additionalProperties:
     *     type: object
     *     properties:
     *       code:
     *         type: integer
     *
     *   allOf:
     *     - $ref: '#/components/schemas/Class1'
     *     - $ref: '#/components/schemas/Class2'
     *   additionalProperties: true
     *
     * @param schema the OAS schema
     * @return true if the specified schema is a Map schema.
     */
public static boolean isMapSchema(Schema schema){
    if (schema instanceof MapSchema) {
        return true;
    }
    if (schema == null) {
        return false;
    }
    if (schema.getAdditionalProperties() instanceof Schema) {
        return true;
    }
    if (schema.getAdditionalProperties() instanceof Boolean && (Boolean) schema.getAdditionalProperties()) {
        return true;
    }
    return false;
}","public static boolean isMapSchema(Schema schema){
    if (schema instanceof MapSchema) {
        return true;
    }
    if (schema == null) {
        return false;
    }
    if (schema.getAdditionalProperties() instanceof Schema) {
        return true;
    }
    if (schema.getAdditionalProperties() instanceof Boolean && (Boolean) schema.getAdditionalProperties()) {
        return true;
    }
    return false;
}","/**
     * Return true if the specified 'schema' is an object that can be extended with additional properties.
     * Additional properties means a Schema should support all explicitly defined properties plus any
     * undeclared properties.
     *
     * A MapSchema differs from an ObjectSchema in the following way:
     * - An ObjectSchema is not extensible, i.e. it has a fixed number of properties.
     * - A MapSchema is an object that can be extended with an arbitrary set of properties.
     *   The payload may include dynamic properties.
     *
     * Note that isMapSchema returns true for a composed schema (allOf, anyOf, oneOf) that also defines
     * additionalproperties.
     *
     * For example, an OpenAPI schema is considered a MapSchema in the following scenarios:
     *
     *   type: object
     *   additionalProperties: true
     *
     *   type: object
     *   additionalProperties:
     *     type: object
     *     properties:
     *       code:
     *         type: integer
     *
     *   allOf:
     *     - $ref: '#/components/schemas/Class1'
     *     - $ref: '#/components/schemas/Class2'
     *   additionalProperties: true
     *
     * @param schema the OAS schema
     * @return true if the specified schema is a Map schema.
     */","('isMapSchema', {'INSTRUCTION': {'covered': 24, 'missed': 4}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 2}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,  Return true if the specified 'schema' is an object that can be extended with additional properties.,18.0,"[""If the specified'schema' is an object that can be extended with additional properties, return true."", 'If the specifiedschema is an object that can be extended with additional properties, return true.', ""If the specified'schema' is an object that can be extended, return true.""]"
441,matsim-libs,org/matsim/core/replanning/selectors/RandomPlanSelector.java,/matsim/src/main/java/org/matsim/core/replanning/selectors/RandomPlanSelector.java,selectPlan,35-52,"/**
	 * Choose a random plan from the person and return it.
	 * @return The newly selected plan for this person; <code>null</code> if the person has no plans.
	 */
public T selectPlan(final HasPlansAndId<T, I> person){
    // this used to use person.getRandomPlan(), but I inlined the function here in order to get rid of the function of the data class.
    // kai, nov'13
    if (person.getPlans().size() == 0) {
        return null;
    }
    int index = (int) (MatsimRandom.getRandom().nextDouble() * person.getPlans().size());
    // yyyy As far as I can tell, this produces race conditions when running multi-threaded.  I.e. when running the same
    // setup twice, this function may return different results per thread or per person.  kai, jun'14
    return person.getPlans().get(index);
}","public T selectPlan(final HasPlansAndId<T, I> person){
    // this used to use person.getRandomPlan(), but I inlined the function here in order to get rid of the function of the data class.
    // kai, nov'13
    if (person.getPlans().size() == 0) {
        return null;
    }
    int index = (int) (MatsimRandom.getRandom().nextDouble() * person.getPlans().size());
    // yyyy As far as I can tell, this produces race conditions when running multi-threaded.  I.e. when running the same
    // setup twice, this function may return different results per thread or per person.  kai, jun'14
    return person.getPlans().get(index);
}","/**
	 * Choose a random plan from the person and return it.
	 * @return The newly selected plan for this person; <code>null</code> if the person has no plans.
	 */","('selectPlan', {'INSTRUCTION': {'covered': 21, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,  Choose a random plan from the person and return it.,11.0,"['Pick a random plan from the person and return it.', 'Pick a random plan from the person and send it back.', 'Pick a plan from the person and return it.']"
442,cron-utils,com/cronutils/model/field/expression/visitor/ValidationFieldExpressionVisitor.java,/src/main/java/com/cronutils/model/field/expression/visitor/ValidationFieldExpressionVisitor.java,isInRange,117-131,"/**
     * Check if given number is greater or equal to start range and minor or equal to end range.
     *
     * @param fieldValue - to be validated
     * @throws IllegalArgumentException - if not in range
     */
protected void isInRange(final FieldValue<?> fieldValue){
    if (fieldValue instanceof IntegerFieldValue) {
        final int value = ((IntegerFieldValue) fieldValue).getValue();
        if (!constraints.isInRange(value)) {
            throw new IllegalArgumentException(String.format(OORANGE, value, constraints.getStartRange(), constraints.getEndRange()));
        }
    }
}","protected void isInRange(final FieldValue<?> fieldValue){
    if (fieldValue instanceof IntegerFieldValue) {
        final int value = ((IntegerFieldValue) fieldValue).getValue();
        if (!constraints.isInRange(value)) {
            throw new IllegalArgumentException(String.format(OORANGE, value, constraints.getStartRange(), constraints.getEndRange()));
        }
    }
}","/**
     * Check if given number is greater or equal to start range and minor or equal to end range.
     *
     * @param fieldValue - to be validated
     * @throws IllegalArgumentException - if not in range
     */","('isInRange', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,  Check if given number is greater or equal to start range and minor or equal to end range.,19.0,"['If the number is greater or equal to the start range, you should check it.', 'If the number is greater or equal to start range or end range, you should check it.', 'If the number is greater or equal to the start range or end range, you should check it.']"
443,cdk,org/openscience/cdk/isomorphism/AbstractVFState.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/AbstractVFState.java,nextM,94-112,"/**
     * Given the current target candidate (m), find the next candidate. The next
     * candidate is the next vertex > m (in some ordering) that is unmapped and
     * is adjacent to a mapped vertex (terminal). If there is no such vertex
     * (disconnected) the next unmapped vertex is returned. If there are no more
     * candidates m == |V| of G2.
     *
     * @param m previous candidate m
     * @return the next value of m
     */
 final int nextM(int n, int m){
    if (size == 0)
        return m + 1;
    for (int i = m + 1; i < g2.length; i++) if (m2[i] == UNMAPPED && (t1[n] == 0 || t2[i] > 0))
        return i;
    return mMax();
}","final int nextM(int n, int m){
    if (size == 0)
        return m + 1;
    for (int i = m + 1; i < g2.length; i++) if (m2[i] == UNMAPPED && (t1[n] == 0 || t2[i] > 0))
        return i;
    return mMax();
}","/**
     * Given the current target candidate (m), find the next candidate. The next
     * candidate is the next vertex > m (in some ordering) that is unmapped and
     * is adjacent to a mapped vertex (terminal). If there is no such vertex
     * (disconnected) the next unmapped vertex is returned. If there are no more
     * candidates m == |V| of G2.
     *
     * @param m previous candidate m
     * @return the next value of m
     */","('nextM', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",74.0,"  Given the current target candidate (m), find the next candidate.",14.0,"['The next candidate should be found given the current target candidate.', 'Find the next candidate if you know the current target candidate.', 'Find the next candidate if you know the target candidate.']"
444,jackson-databind,com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java,/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java,_removeUnwantedAccessor,916-933,"/**
     * Method called to further get rid of unwanted individual accessors,
     * based on read/write settings and rules for ""pulling in"" accessors
     * (or not).
     */
protected void _removeUnwantedAccessor(Map<String, POJOPropertyBuilder> props){
    final boolean inferMutators = _config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS);
    Iterator<POJOPropertyBuilder> it = props.values().iterator();
    while (it.hasNext()) {
        POJOPropertyBuilder prop = it.next();
        prop.removeNonVisible(inferMutators, _forSerialization ? null : this);
    }
}","protected void _removeUnwantedAccessor(Map<String, POJOPropertyBuilder> props){
    final boolean inferMutators = _config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS);
    Iterator<POJOPropertyBuilder> it = props.values().iterator();
    while (it.hasNext()) {
        POJOPropertyBuilder prop = it.next();
        prop.removeNonVisible(inferMutators, _forSerialization ? null : this);
    }
}","/**
     * Method called to further get rid of unwanted individual accessors,
     * based on read/write settings and rules for ""pulling in"" accessors
     * (or not).
     */","('_removeUnwantedAccessor', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,"  Method called to further get rid of unwanted individual accessors,  based on read/write settings and rules for ""pulling in"" accessors  (or not).",28.0,"['Method called to get rid of unwanted individual accessors, based on read/write settings and rules for pulling in accessors.', 'Method called to get rid of unwanted individual accessors based on read/write settings and rules.', 'Method was called to get rid of unwanted individual accessors, based on read/write settings and rules for pulling in accessors.']"
446,acs-aem-commons,com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,isDispatcherHeaders,155-172,"/**
     * Checks if the agent has a valid dispatcher headers.
     *
     * @param agent Agent to check
     * @return true if the Agent's headers contain the proper values
     */
private boolean isDispatcherHeaders(final Agent agent){
    final ValueMap properties = agent.getConfiguration().getProperties();
    final String[] headers = properties.get(AgentConfig.PROTOCOL_HTTP_HEADERS, new String[] {});
    for (final String header : headers) {
        if (StringUtils.startsWith(header, CQ_ACTION_HEADER)) {
            return true;
        }
    }
    return false;
}","private boolean isDispatcherHeaders(final Agent agent){
    final ValueMap properties = agent.getConfiguration().getProperties();
    final String[] headers = properties.get(AgentConfig.PROTOCOL_HTTP_HEADERS, new String[] {});
    for (final String header : headers) {
        if (StringUtils.startsWith(header, CQ_ACTION_HEADER)) {
            return true;
        }
    }
    return false;
}","/**
     * Checks if the agent has a valid dispatcher headers.
     *
     * @param agent Agent to check
     * @return true if the Agent's headers contain the proper values
     */","('isDispatcherHeaders', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,  Checks if the agent has a valid dispatcher headers.,10.0,"['The agent is checked if he has a valid dispatch.', 'The agent is checked if he has a valid dispatchr.', ""The agent is checked if he has a valid dispatchr's headers.""]"
447,acs-aem-commons,com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,isResourceOnly,174-191,"/**
     * Checks if the agent has valid CQ-Action-Scope: ResourceOnly header.
     *
     * @param agent Agent to check
     * @return true if the Agent's headers contain the expected values
     */
private boolean isResourceOnly(final Agent agent){
    final ValueMap properties = agent.getConfiguration().getProperties();
    final String[] headers = properties.get(AgentConfig.PROTOCOL_HTTP_HEADERS, new String[] {});
    for (final String header : headers) {
        if (StringUtils.equals(header, CQ_SCOPE_ACTION_HEADER)) {
            return true;
        }
    }
    return false;
}","private boolean isResourceOnly(final Agent agent){
    final ValueMap properties = agent.getConfiguration().getProperties();
    final String[] headers = properties.get(AgentConfig.PROTOCOL_HTTP_HEADERS, new String[] {});
    for (final String header : headers) {
        if (StringUtils.equals(header, CQ_SCOPE_ACTION_HEADER)) {
            return true;
        }
    }
    return false;
}","/**
     * Checks if the agent has valid CQ-Action-Scope: ResourceOnly header.
     *
     * @param agent Agent to check
     * @return true if the Agent's headers contain the expected values
     */","('isResourceOnly', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,  Checks if the agent has valid CQ-Action-Scope: ResourceOnly header.,11.0,"['Checks if the agent has a valid ResourceOnly header.', 'Checks if the agent has a valid resource only header.', 'Checks if the agent has a valid resource only headers.']"
448,acs-aem-commons,com/adobe/acs/commons/util/ParameterUtil.java,/bundle/src/main/java/com/adobe/acs/commons/util/ParameterUtil.java,toPatterns,204-223,"/**
     * Util for converting a String[] into a List of compiled Patterns. Empty/blank strings will be skipped.
     * @param values the Strings to convert to patterns.
     * @return a List of Patterns
     */
public static List<Pattern> toPatterns(String[] values){
    List<Pattern> patterns = new ArrayList<Pattern>();
    if (values == null) {
        return patterns;
    }
    for (String value : values) {
        if (StringUtils.isNotBlank(value)) {
            patterns.add(Pattern.compile(value));
        }
    }
    return patterns;
}","public static List<Pattern> toPatterns(String[] values){
    List<Pattern> patterns = new ArrayList<Pattern>();
    if (values == null) {
        return patterns;
    }
    for (String value : values) {
        if (StringUtils.isNotBlank(value)) {
            patterns.add(Pattern.compile(value));
        }
    }
    return patterns;
}","/**
     * Util for converting a String[] into a List of compiled Patterns. Empty/blank strings will be skipped.
     * @param values the Strings to convert to patterns.
     * @return a List of Patterns
     */","('toPatterns', {'INSTRUCTION': {'covered': 32, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,  Util for converting a String[] into a List of compiled Patterns.,14.0,"['A List of compiled Patterns can be converted into a String.', 'Util for converting a string into a list of patterns.', 'A List of compiled Patterns can be converted into a string.']"
449,cdk,org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,moveToBack,216-233,"/**
     * Utility method for shifting a specified value in an index to the back
     * (see {@link #permutation(int[])}).
     *
     * @param neighbors list of neighbors
     * @param v         the value to shift to the back
     * @return <i>neighbors</i> array
     */
 static int[] moveToBack(int[] neighbors, int v){
    int j = 0;
    for (int i = 0; i < neighbors.length; i++) {
        if (neighbors[i] != v) {
            neighbors[j++] = neighbors[i];
        }
    }
    neighbors[neighbors.length - 1] = v;
    return neighbors;
}","static int[] moveToBack(int[] neighbors, int v){
    int j = 0;
    for (int i = 0; i < neighbors.length; i++) {
        if (neighbors[i] != v) {
            neighbors[j++] = neighbors[i];
        }
    }
    neighbors[neighbors.length - 1] = v;
    return neighbors;
}","/**
     * Utility method for shifting a specified value in an index to the back
     * (see {@link #permutation(int[])}).
     *
     * @param neighbors list of neighbors
     * @param v         the value to shift to the back
     * @return <i>neighbors</i> array
     */","('moveToBack', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,  Utility method for shifting a specified value in an index to the back  (see {@link #permutation(int[])}).,28.0,"['The method for shifting a specified value in an index to the back is a utility method.', 'The method for shifting a specified value to the back is a utility method.', 'The method for shifting a specified value in an index to the back is called a utility method.']"
450,dataverse,edu/harvard/iq/dataverse/authorization/groups/GroupServiceBean.java,/src/main/java/edu/harvard/iq/dataverse/authorization/groups/GroupServiceBean.java,flattenGroupsCollection,142-166,"/**
     * Collections of groups may include {@link ExplicitGroup}s, which have a 
     * recursive structure (more precisely, a Composite Pattern}. This has many 
     * advantages, but it makes answering the question ""which groups are 
     * contained in this group"" non-trivial. This method deals with this issue by
     * providing a ""flat list"" of the groups contained in the groups at the 
     * passed collection.
     * 
     * The resultant stream is distinct - groups appear in it only once, even if
     * some of them are members of multiple groups.
     * 
     * @param groups A collection of groups
     * @return A distinct stream of groups who are members of, or are 
     * descendants of members of the groups in {@code groups}.
     */
public Stream<Group> flattenGroupsCollection(Collection<Group> groups){
    Stream.Builder<Group> out = Stream.builder();
    groups.forEach(g -> {
        out.accept(g);
        if (g instanceof ExplicitGroup) {
            collectGroupContent((ExplicitGroup) g, out);
        }
    });
    return out.build().distinct();
}","public Stream<Group> flattenGroupsCollection(Collection<Group> groups){
    Stream.Builder<Group> out = Stream.builder();
    groups.forEach(g -> {
        out.accept(g);
        if (g instanceof ExplicitGroup) {
            collectGroupContent((ExplicitGroup) g, out);
        }
    });
    return out.build().distinct();
}","/**
     * Collections of groups may include {@link ExplicitGroup}s, which have a 
     * recursive structure (more precisely, a Composite Pattern}. This has many 
     * advantages, but it makes answering the question ""which groups are 
     * contained in this group"" non-trivial. This method deals with this issue by
     * providing a ""flat list"" of the groups contained in the groups at the 
     * passed collection.
     * 
     * The resultant stream is distinct - groups appear in it only once, even if
     * some of them are members of multiple groups.
     * 
     * @param groups A collection of groups
     * @return A distinct stream of groups who are members of, or are 
     * descendants of members of the groups in {@code groups}.
     */","('flattenGroupsCollection', {'INSTRUCTION': {'covered': 11, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,"  Collections of groups may include {@link ExplicitGroup}s, which have a   recursive structure (more precisely, a Composite Pattern}.",26.0,"['Collections of groups may include @link Explicit Groups, which have a recursive structure.', 'Collections of groups may include @link Explicit Groups, which have a structure similar to a pattern.', 'Collections of groups may include @link Explicit Groups, which have a structure that is more or less the same.']"
451,cdk,org/openscience/cdk/group/PermutationGroup.java,/tool/group/src/main/java/org/openscience/cdk/group/PermutationGroup.java,all,303-324,"/**
     * Generate the whole group from the compact list of permutations.
     *
     * @return a list of permutations
     */
public List<Permutation> all(){
    final List<Permutation> permutations = new ArrayList<Permutation>();
    Backtracker counter = new Backtracker() {

        @Override
        public void applyTo(Permutation p) {
            permutations.add(p);
        }

        @Override
        public boolean isFinished() {
            return false;
        }
    };
    this.apply(counter);
    return permutations;
}","public List<Permutation> all(){
    final List<Permutation> permutations = new ArrayList<Permutation>();
    Backtracker counter = new Backtracker() {

        @Override
        public void applyTo(Permutation p) {
            permutations.add(p);
        }

        @Override
        public boolean isFinished() {
            return false;
        }
    };
    this.apply(counter);
    return permutations;
}","/**
     * Generate the whole group from the compact list of permutations.
     *
     * @return a list of permutations
     */","('all', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,  Generate the whole group from the compact list of permutations.,11.0,"['The whole group can be generated from the compact list of permutations.', 'The whole group can be created from the compact list of permutations.', 'From the compact list of permutations, create the whole group.']"
452,acs-aem-commons,com/adobe/acs/commons/throttling/ThrottlingState.java,/bundle/src/main/java/com/adobe/acs/commons/throttling/ThrottlingState.java,purgeExpiredEntries,108-129,"/**
     * cleanup the timestamps array and replace all expired entries with
     * Instant.EPOCH;
     *
     * @return the number of emptied slots
     */
private int purgeExpiredEntries(){
    int result = 0;
    for (int i = 0; i < timestamps.length; i++) {
        long now = clock.instant().toEpochMilli();
        if (now - timestamps[i].toEpochMilli() > ONE_MINUTE) {
            timestamps[i] = Instant.EPOCH;
            result++;
        }
    }
    return result;
}","private int purgeExpiredEntries(){
    int result = 0;
    for (int i = 0; i < timestamps.length; i++) {
        long now = clock.instant().toEpochMilli();
        if (now - timestamps[i].toEpochMilli() > ONE_MINUTE) {
            timestamps[i] = Instant.EPOCH;
            result++;
        }
    }
    return result;
}","/**
     * cleanup the timestamps array and replace all expired entries with
     * Instant.EPOCH;
     *
     * @return the number of emptied slots
     */","('purgeExpiredEntries', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",75.0,  cleanup the timestamps array and replace all expired entries with  Instant.,12.0,"['All expired entries should be replaced with Instant.', 'All expired entries should be replaced with instant.', 'Remove the expired entries and use Instant.']"
454,shardingsphere-elasticjob,org/apache/shardingsphere/elasticjob/cloud/scheduler/context/JobContext.java,/elasticjob-cloud/elasticjob-cloud-scheduler/src/main/java/org/apache/shardingsphere/elasticjob/cloud/scheduler/context/JobContext.java,from,41-55,"/**
     * Create job running context from job configuration and execution type.
     *
     * @param cloudJobConfig cloud job configuration
     * @param type execution type
     * @return Job running context
     */
public static JobContext from(final CloudJobConfiguration cloudJobConfig, final ExecutionType type){
    int shardingTotalCount = cloudJobConfig.getJobConfig().getShardingTotalCount();
    List<Integer> shardingItems = new ArrayList<>(shardingTotalCount);
    for (int i = 0; i < shardingTotalCount; i++) {
        shardingItems.add(i);
    }
    return new JobContext(cloudJobConfig, shardingItems, type);
}","public static JobContext from(final CloudJobConfiguration cloudJobConfig, final ExecutionType type){
    int shardingTotalCount = cloudJobConfig.getJobConfig().getShardingTotalCount();
    List<Integer> shardingItems = new ArrayList<>(shardingTotalCount);
    for (int i = 0; i < shardingTotalCount; i++) {
        shardingItems.add(i);
    }
    return new JobContext(cloudJobConfig, shardingItems, type);
}","/**
     * Create job running context from job configuration and execution type.
     *
     * @param cloudJobConfig cloud job configuration
     * @param type execution type
     * @return Job running context
     */","('from', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",76.0,  Create job running context from job configuration and execution type.,11.0,"['From the job configuration and execution type, create a job.', 'From the job configuration and execution type you can create a job.', 'From the job configuration and execution type you can create a context job.']"
456,weblogic-kubernetes-operator,oracle/kubernetes/operator/helpers/NamespaceHelper.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/NamespaceHelper.java,parseNamespaceList,36-49,"/**
   * Parse a string of namespace names and return them as a collection.
   * @param namespaceString a comma-separated list of namespace names
   * @return Namespace list
   */
public static Collection<String> parseNamespaceList(String namespaceString){
    Collection<String> namespaces = Stream.of(namespaceString.split("","")).filter(s -> !isNullOrEmpty(s)).map(String::trim).collect(Collectors.toUnmodifiableList());
    return namespaces.isEmpty() ? Collections.singletonList(getOperatorNamespace()) : namespaces;
}","public static Collection<String> parseNamespaceList(String namespaceString){
    Collection<String> namespaces = Stream.of(namespaceString.split("","")).filter(s -> !isNullOrEmpty(s)).map(String::trim).collect(Collectors.toUnmodifiableList());
    return namespaces.isEmpty() ? Collections.singletonList(getOperatorNamespace()) : namespaces;
}","/**
   * Parse a string of namespace names and return them as a collection.
   * @param namespaceString a comma-separated list of namespace names
   * @return Namespace list
   */","('parseNamespaceList', {'INSTRUCTION': {'covered': 20, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",76.0,  Parse a string of namespace names and return them as a collection.,13.0,"['Return a string of names as a collection.', 'You can return a string of names as a collection.', 'Parse a string of names and return them as a collection.']"
458,cdk,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,neighbors,282-295,"/**
     * Access the neighbors of {@code element} as their indices.
     *
     * @param element tetrahedral element
     * @param map     atom index lookup
     * @return the neighbors
     */
private int[] neighbors(ITetrahedralChirality element, Map<IAtom, Integer> map){
    IAtom[] atoms = element.getLigands();
    int[] vs = new int[atoms.length];
    for (int i = 0; i < atoms.length; i++) vs[i] = map.get(atoms[i]);
    return vs;
}","private int[] neighbors(ITetrahedralChirality element, Map<IAtom, Integer> map){
    IAtom[] atoms = element.getLigands();
    int[] vs = new int[atoms.length];
    for (int i = 0; i < atoms.length; i++) vs[i] = map.get(atoms[i]);
    return vs;
}","/**
     * Access the neighbors of {@code element} as their indices.
     *
     * @param element tetrahedral element
     * @param map     atom index lookup
     * @return the neighbors
     */","('neighbors', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,  Access the neighbors of {@code element} as their indices.,13.0,"['The neighbors of @code element are their indices.', 'You can access the neighbors of @code element.', 'You can access the neighbors of @code element as their indices.']"
459,openapi-generator,org/openapitools/codegen/DefaultCodegen.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java,removeSelfReferenceImports,590-605,"/**
     * Removes imports from the model that points to itself
     * Marks a self referencing property, if detected
     *
     * @param model Self imports will be removed from this model.imports collection
     */
protected void removeSelfReferenceImports(CodegenModel model){
    for (CodegenProperty cp : model.allVars) {
        if (cp.dataType.equalsIgnoreCase(model.classname) || (cp.isContainer && cp.items != null && cp.items.dataType.equalsIgnoreCase(model.classname))) {
            model.imports.remove(model.classname);
            cp.isSelfReference = true;
        }
    }
}","protected void removeSelfReferenceImports(CodegenModel model){
    for (CodegenProperty cp : model.allVars) {
        if (cp.dataType.equalsIgnoreCase(model.classname) || (cp.isContainer && cp.items != null && cp.items.dataType.equalsIgnoreCase(model.classname))) {
            model.imports.remove(model.classname);
            cp.isSelfReference = true;
        }
    }
}","/**
     * Removes imports from the model that points to itself
     * Marks a self referencing property, if detected
     *
     * @param model Self imports will be removed from this model.imports collection
     */","('removeSelfReferenceImports', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,"  Removes imports from the model that points to itself  Marks a self referencing property, if detected   @param model Self imports will be removed from this model.",29.0,"['If detected, self imports will be removed from this model.', 'If a model is detected, self imports will be removed from it.', 'If detected, self imports will be removed from the model if it points to itself.']"
460,cdk,org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,nStereoBonds,222-248,"/**
     * access the number of stereo bonds in the provided bond list.
     *
     * @param bonds input list
     * @return number of UP/DOWN bonds in the list, -1 if a query bond was
     *         found
     */
private static int nStereoBonds(List<IBond> bonds){
    int count = 0;
    for (IBond bond : bonds) {
        IBond.Stereo stereo = bond.getStereo();
        switch(stereo) {
            case E_OR_Z:
            case UP_OR_DOWN:
            case UP_OR_DOWN_INVERTED:
                return -1;
            case UP:
            case DOWN:
            case UP_INVERTED:
            case DOWN_INVERTED:
                count++;
                break;
        }
    }
    return count;
}","private static int nStereoBonds(List<IBond> bonds){
    int count = 0;
    for (IBond bond : bonds) {
        IBond.Stereo stereo = bond.getStereo();
        switch(stereo) {
            case E_OR_Z:
            case UP_OR_DOWN:
            case UP_OR_DOWN_INVERTED:
                return -1;
            case UP:
            case DOWN:
            case UP_INVERTED:
            case DOWN_INVERTED:
                count++;
                break;
        }
    }
    return count;
}","/**
     * access the number of stereo bonds in the provided bond list.
     *
     * @param bonds input list
     * @return number of UP/DOWN bonds in the list, -1 if a query bond was
     *         found
     */","('nStereoBonds', {'INSTRUCTION': {'covered': 24, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,  access the number of stereo bonds in the provided bond list.,12.0,"['The provided bond list has the number of stereo bonds.', 'The number of stereo bonds is provided.', 'The provided bond list has the number of stereo bonds listed.']"
461,matsim-libs,org/matsim/core/utils/io/IOUtils.java,/matsim/src/main/java/org/matsim/core/utils/io/IOUtils.java,copyStream,378-398,"/**
	 * Copies the content from one stream to another stream.
	 *
	 * @param fromStream The stream containing the data to be copied
	 * @param toStream   The stream the data should be written to
	 * 
	 * @throws UncheckedIOException
	 */
public static void copyStream(final InputStream fromStream, final OutputStream toStream) throws UncheckedIOException{
    try {
        byte[] buffer = new byte[4096];
        int bytesRead;
        while ((bytesRead = fromStream.read(buffer)) != -1) {
            toStream.write(buffer, 0, bytesRead);
        }
    } catch (IOException e) {
        throw new UncheckedIOException(e);
    }
}","public static void copyStream(final InputStream fromStream, final OutputStream toStream) throws UncheckedIOException{
    try {
        byte[] buffer = new byte[4096];
        int bytesRead;
        while ((bytesRead = fromStream.read(buffer)) != -1) {
            toStream.write(buffer, 0, bytesRead);
        }
    } catch (IOException e) {
        throw new UncheckedIOException(e);
    }
}","/**
	 * Copies the content from one stream to another stream.
	 *
	 * @param fromStream The stream containing the data to be copied
	 * @param toStream   The stream the data should be written to
	 * 
	 * @throws UncheckedIOException
	 */","('copyStream', {'INSTRUCTION': {'covered': 18, 'missed': 6}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,  Copies the content from one stream to another stream.,10.0,"['The content is copied from one stream to another.', 'You can copy the content from one stream to another.', 'You can copy the content from one stream to another stream.']"
462,tablesaw,tech/tablesaw/columns/Column.java,/core/src/main/java/tech/tablesaw/columns/Column.java,mapInto,355-373,"/**
   * Maps the function across all rows, storing the results into the provided Column.
   *
   * <p>The target column must have at least the same number of rows.
   *
   * @param fun function to map
   * @param into Column into which results are set
   * @return the provided Column
   */
 C mapInto(Function<? super T, ? extends R> fun, C into){
    for (int i = 0; i < size(); i++) {
        if (isMissing(i)) {
            into.setMissing(i);
        } else {
            into.set(i, fun.apply(get(i)));
        }
    }
    return into;
}","C mapInto(Function<? super T, ? extends R> fun, C into){
    for (int i = 0; i < size(); i++) {
        if (isMissing(i)) {
            into.setMissing(i);
        } else {
            into.set(i, fun.apply(get(i)));
        }
    }
    return into;
}","/**
   * Maps the function across all rows, storing the results into the provided Column.
   *
   * <p>The target column must have at least the same number of rows.
   *
   * @param fun function to map
   * @param into Column into which results are set
   * @return the provided Column
   */","('mapInto', {'INSTRUCTION': {'covered': 23, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,"  Maps the function across all rows, storing the results into the provided Column.",15.0,"['The function is mapped across all the rows.', 'The function is mapped across all the rows and stored in the provided Column.', 'The function is mapped across all the rows and stored in the Column.']"
463,liquibase,liquibase/change/CheckSum.java,/liquibase-core/src/main/java/liquibase/change/CheckSum.java,parse,41-58,"/**
     * Parse the given storedCheckSum string value and return a new CheckSum object.
     */
public static CheckSum parse(String checksumValue){
    if (checksumValue == null) {
        return null;
    }
    // The general layout of a checksum is:
    // <1 digit: algorithm version number>:<1..n characters alphanumeric checksum>
    // Example: 7:2cdf9876e74347162401315d34b83746
    Matcher matcher = CHECKSUM_PATTERN.matcher(checksumValue);
    if (matcher.find()) {
        return new CheckSum(matcher.group(2), Integer.parseInt(matcher.group(1)));
    } else {
        // No version information found
        return new CheckSum(checksumValue, 1);
    }
}","public static CheckSum parse(String checksumValue){
    if (checksumValue == null) {
        return null;
    }
    // The general layout of a checksum is:
    // <1 digit: algorithm version number>:<1..n characters alphanumeric checksum>
    // Example: 7:2cdf9876e74347162401315d34b83746
    Matcher matcher = CHECKSUM_PATTERN.matcher(checksumValue);
    if (matcher.find()) {
        return new CheckSum(matcher.group(2), Integer.parseInt(matcher.group(1)));
    } else {
        // No version information found
        return new CheckSum(checksumValue, 1);
    }
}","/**
     * Parse the given storedCheckSum string value and return a new CheckSum object.
     */","('parse', {'INSTRUCTION': {'covered': 28, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,  Parse the given storedCheckSum string value and return a new CheckSum object.,13.0,"['Return a new CheckSum object when youParse the given storedCheckSum string value.', 'Parse the storedCheckSum string value and return a new object.', 'Parse the storedCheckSum string value and then return a new object.']"
464,cdk,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,positionMassLabel,528-541,"/**
     * Position the mass label relative to the element label. The mass adjunct is position to the
     * top left of the element label.
     *
     * @param massLabel    mass label outline
     * @param elementLabel element label outline
     * @return positioned mass label
     */
 TextOutline positionMassLabel(TextOutline massLabel, TextOutline elementLabel){
    final Rectangle2D elementBounds = elementLabel.getBounds();
    final Rectangle2D massBounds = massLabel.getBounds();
    return massLabel.translate((elementBounds.getMinX() - padding) - massBounds.getMaxX(), (elementBounds.getMinY() - (massBounds.getHeight() / 2)) - massBounds.getMinY());
}","TextOutline positionMassLabel(TextOutline massLabel, TextOutline elementLabel){
    final Rectangle2D elementBounds = elementLabel.getBounds();
    final Rectangle2D massBounds = massLabel.getBounds();
    return massLabel.translate((elementBounds.getMinX() - padding) - massBounds.getMaxX(), (elementBounds.getMinY() - (massBounds.getHeight() / 2)) - massBounds.getMinY());
}","/**
     * Position the mass label relative to the element label. The mass adjunct is position to the
     * top left of the element label.
     *
     * @param massLabel    mass label outline
     * @param elementLabel element label outline
     * @return positioned mass label
     */","('positionMassLabel', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,  Position the mass label relative to the element label.,10.0,"['The mass label should be placed relative to the element label.', 'The mass label should be positioned relative to the element label.', 'The mass label should be relative to the element label.']"
465,liquibase,liquibase/structure/core/PrimaryKey.java,/liquibase-core/src/main/java/liquibase/structure/core/PrimaryKey.java,addColumn,69-87,"/**
     * Adds a new column to the column list of this PrimaryKey. The first column has the position 0.
     * If you specify a position that is greater than the number of columns present, undefined
     * columns (NULL expressions) will be added as padding. If a position that is already
     * occupied by a column is specified, that column will be replaced.
     *
     * @param position the position where to insert or replace the column
     * @param column   the new column
     * @return a reference to the updated PrimaryKey object.
     */
public PrimaryKey addColumn(int position, Column column){
    if (position >= getColumns().size()) {
        for (int i = getColumns().size() - 1; i < position; i++) {
            this.getColumns().add(null);
        }
    }
    this.getColumns().set(position, column);
    return this;
}","public PrimaryKey addColumn(int position, Column column){
    if (position >= getColumns().size()) {
        for (int i = getColumns().size() - 1; i < position; i++) {
            this.getColumns().add(null);
        }
    }
    this.getColumns().set(position, column);
    return this;
}","/**
     * Adds a new column to the column list of this PrimaryKey. The first column has the position 0.
     * If you specify a position that is greater than the number of columns present, undefined
     * columns (NULL expressions) will be added as padding. If a position that is already
     * occupied by a column is specified, that column will be replaced.
     *
     * @param position the position where to insert or replace the column
     * @param column   the new column
     * @return a reference to the updated PrimaryKey object.
     */","('addColumn', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,  Adds a new column to the column list of this PrimaryKey.,12.0,"['A new column is added to the PrimaryKey.', 'A new column has been added to the PrimaryKey.', 'There is a new column added to the PrimaryKey.']"
466,cdk,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,newModel,283-301,"/**
     * Create a new chem model for a single {@link IAtomContainer}.
     *
     * @param container the container to create the model for
     * @return a new {@link IChemModel}
     */
private static IChemModel newModel(final IAtomContainer container){
    if (container == null)
        throw new NullPointerException(""cannot create chem model for a null container"");
    final IChemObjectBuilder builder = container.getBuilder();
    final IChemModel model = builder.newInstance(IChemModel.class);
    final IAtomContainerSet containers = builder.newInstance(IAtomContainerSet.class);
    containers.addAtomContainer(container);
    model.setMoleculeSet(containers);
    return model;
}","private static IChemModel newModel(final IAtomContainer container){
    if (container == null)
        throw new NullPointerException(""cannot create chem model for a null container"");
    final IChemObjectBuilder builder = container.getBuilder();
    final IChemModel model = builder.newInstance(IChemModel.class);
    final IAtomContainerSet containers = builder.newInstance(IAtomContainerSet.class);
    containers.addAtomContainer(container);
    model.setMoleculeSet(containers);
    return model;
}","/**
     * Create a new chem model for a single {@link IAtomContainer}.
     *
     * @param container the container to create the model for
     * @return a new {@link IChemModel}
     */","('newModel', {'INSTRUCTION': {'covered': 27, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",77.0,  Create a new chem model for a single {@link IAtomContainer}.,14.0,"['There is a single CHEM model for IAtomContainer.', 'A single CHEM model for a single IAtomContainer is needed.', 'There is a single CHEM model for the IAtomContainer.']"
467,dcache,org/dcache/util/histograms/TimeseriesHistogram.java,/modules/common/src/main/java/org/dcache/util/histograms/TimeseriesHistogram.java,withTimeFrame,153-177,"/**
     * <p>Initialize bin metrics using the {@link TimeFrame} construct. </p>
     */
public void withTimeFrame(TimeFrame timeFrame){
    timeFrame.configure();
    binCount = timeFrame.getBinCount();
    /**
     * TimeFrame width is computed in seconds.
     * This is the histogram ""unit"".
     * Width is 1000 for histogram in this case.
     */
    binUnit = timeFrame.getBinWidth();
    binWidth = 1000;
    binUnitLabel = timeFrame.getTimebin().name();
    /**
     * TimeFrame 'high time' is the upper bound defining
     * the highest edge of the last bin.  So the highest bin
     * is one bin size less.
     */
    double binSize = binUnit * binWidth;
    highestBin = (double) timeFrame.getHighTime() - binSize;
    lowestBin = (double) timeFrame.getLowTime();
}","public void withTimeFrame(TimeFrame timeFrame){
    timeFrame.configure();
    binCount = timeFrame.getBinCount();
    /**
     * TimeFrame width is computed in seconds.
     * This is the histogram ""unit"".
     * Width is 1000 for histogram in this case.
     */
    binUnit = timeFrame.getBinWidth();
    binWidth = 1000;
    binUnitLabel = timeFrame.getTimebin().name();
    /**
     * TimeFrame 'high time' is the upper bound defining
     * the highest edge of the last bin.  So the highest bin
     * is one bin size less.
     */
    double binSize = binUnit * binWidth;
    highestBin = (double) timeFrame.getHighTime() - binSize;
    lowestBin = (double) timeFrame.getLowTime();
}","/**
     * <p>Initialize bin metrics using the {@link TimeFrame} construct. </p>
     */","('withTimeFrame', {'INSTRUCTION': {'covered': 47, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",78.0,  <p>Initialize bin metrics using the {@link TimeFrame} construct.,15.0,"['The @link TimeFrame construct is used toInitialize bin metrics.', 'Bin metrics can be created using the@link TimeFrame construct.', 'The @link TimeFrame construct is used to create bin metrics.']"
470,acs-aem-commons,com/adobe/acs/commons/mcp/impl/processes/TagCreator.java,/bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/TagCreator.java,importTags,187-205,"/**
     * Perform the tag creation based on the successfully parsed values in parseTags(..).
     *
     * @param manager the action manager
     */
public void importTags(ActionManager manager){
    tagDefinitions.values().stream().forEach(tagDefinition -> {
        try {
            manager.withResolver(rr -> {
                final TagManager tagManager = rr.adaptTo(TagManager.class);
                ReportRowSatus status;
                createTag(tagDefinition, tagManager);
            });
        } catch (Exception e) {
            log.error(""Unable to import tags via ACS Commons MCP - Tag Creator"", e);
        }
    });
}","public void importTags(ActionManager manager){
    tagDefinitions.values().stream().forEach(tagDefinition -> {
        try {
            manager.withResolver(rr -> {
                final TagManager tagManager = rr.adaptTo(TagManager.class);
                ReportRowSatus status;
                createTag(tagDefinition, tagManager);
            });
        } catch (Exception e) {
            log.error(""Unable to import tags via ACS Commons MCP - Tag Creator"", e);
        }
    });
}","/**
     * Perform the tag creation based on the successfully parsed values in parseTags(..).
     *
     * @param manager the action manager
     */","('importTags', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",79.0,  Perform the tag creation based on the successfully parsed values in parseTags(.,14.0,"['The tag creation should be based on the successfully parsed values.', 'The tag creation can be done based on the successfully parsed values.', 'The tag creation can be done based on successfully parsed values.']"
471,cdk,org/openscience/cdk/normalize/SMSDNormalizer.java,/legacy/src/main/java/org/openscience/cdk/normalize/SMSDNormalizer.java,percieveAtomTypesAndConfigureAtoms,302-323,"/**
     * Convenience method to perceive atom types for all <code>IAtom</code>s in the
     * <code>IAtomContainer</code>, using the <code>CDKAtomTypeMatcher</code>. If the
     * matcher finds atom matching atom type, the <code>IAtom</code> will be configured
     * to have the same properties as the <code>IAtomType</code>. If no matching atom
     * type is found, no configuration is performed.
     * @param container
     * @throws CDKException
     */
public static void percieveAtomTypesAndConfigureAtoms(IAtomContainer container) throws CDKException{
    CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.getInstance(container.getBuilder());
    for (IAtom atom : container.atoms()) {
        if (!(atom instanceof IPseudoAtom)) {
            IAtomType matched = matcher.findMatchingAtomType(container, atom);
            if (matched != null) {
                AtomTypeManipulator.configure(atom, matched);
            }
        }
    }
}","public static void percieveAtomTypesAndConfigureAtoms(IAtomContainer container) throws CDKException{
    CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.getInstance(container.getBuilder());
    for (IAtom atom : container.atoms()) {
        if (!(atom instanceof IPseudoAtom)) {
            IAtomType matched = matcher.findMatchingAtomType(container, atom);
            if (matched != null) {
                AtomTypeManipulator.configure(atom, matched);
            }
        }
    }
}","/**
     * Convenience method to perceive atom types for all <code>IAtom</code>s in the
     * <code>IAtomContainer</code>, using the <code>CDKAtomTypeMatcher</code>. If the
     * matcher finds atom matching atom type, the <code>IAtom</code> will be configured
     * to have the same properties as the <code>IAtomType</code>. If no matching atom
     * type is found, no configuration is performed.
     * @param container
     * @throws CDKException
     */","('percieveAtomTypesAndConfigureAtoms', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",79.0,"  Convenience method to perceive atom types for all <code>IAtom</code>s in the  <code>IAtomContainer</code>, using the <code>CDKAtomTypeMatcher</code>.",36.0,"['A convenience method to see atom types for all code>IAtom/code>s in the code>IAtomContainer/code>.', 'A convenience method to perceive atom types for all code>IAtom/code>s in the code>IAtomContainer/code>.', 'A convenience method to perceive atom types for all code>IAtom/code>s in the code>IAtomContainer/code>, using the code>CDKAtomTypeMatcher/code>.']"
472,cdk,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,permutationParity,310-324,"/**
     * Compute the permutation parity of the values {@code vs}. The parity is
     * whether we need to do an odd or even number of swaps to put the values in
     * sorted order.
     *
     * @param vs values
     * @return parity of the permutation (odd = -1, even = +1)
     */
private int permutationParity(int[] vs){
    int n = 0;
    for (int i = 0; i < vs.length; i++) for (int j = i + 1; j < vs.length; j++) if (vs[i] > vs[j])
        n++;
    return (n & 0x1) == 1 ? -1 : 1;
}","private int permutationParity(int[] vs){
    int n = 0;
    for (int i = 0; i < vs.length; i++) for (int j = i + 1; j < vs.length; j++) if (vs[i] > vs[j])
        n++;
    return (n & 0x1) == 1 ? -1 : 1;
}","/**
     * Compute the permutation parity of the values {@code vs}. The parity is
     * whether we need to do an odd or even number of swaps to put the values in
     * sorted order.
     *
     * @param vs values
     * @return parity of the permutation (odd = -1, even = +1)
     */","('permutationParity', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",79.0,  Compute the permutation parity of the values {@code vs}.,13.0,"['The permutation parity of the values is computed.', 'The values @code vs have permutation parity.', 'The permutation parity of the values is calculated.']"
473,matsim-libs,org/matsim/core/config/CommandLine.java,/matsim/src/main/java/org/matsim/core/config/CommandLine.java,applyConfiguration,485-498,"/**
	 * Applies the command line configuration to a MATSim {@link Config} instance.
	 * See {@link CommandLine} for more information on the syntax.
	 * 
	 * @throws ConfigurationException
	 */
public void applyConfiguration(Config config) throws ConfigurationException{
    List<String> configOptions = options.keySet().stream().filter(o -> o.startsWith(CONFIG_PREFIX + "":"")).collect(Collectors.toList());
    for (String option : configOptions) {
        processConfigOption(config, option, option.substring(CONFIG_PREFIX.length() + 1));
    }
}","public void applyConfiguration(Config config) throws ConfigurationException{
    List<String> configOptions = options.keySet().stream().filter(o -> o.startsWith(CONFIG_PREFIX + "":"")).collect(Collectors.toList());
    for (String option : configOptions) {
        processConfigOption(config, option, option.substring(CONFIG_PREFIX.length() + 1));
    }
}","/**
	 * Applies the command line configuration to a MATSim {@link Config} instance.
	 * See {@link CommandLine} for more information on the syntax.
	 * 
	 * @throws ConfigurationException
	 */","('applyConfiguration', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",79.0,  Applies the command line configuration to a MATSim {@link Config} instance.,15.0,"['The command line configuration should be applied to the instance.', 'The command line configuration can be applied to the instance.', 'The command line configuration can be applied to a MATSim.']"
475,jooby,io/jooby/Usage.java,/jooby/src/main/java/io/jooby/Usage.java,parameterNameNotPresent,45-59,"/**
   * Thrown when the reflective bean converter has no access to a parameter name. Compilation
   * must be done using <code>parameters</code> compiler option.
   *
   * @param parameter Parameter.
   * @return Usage exception.
   */
public static Usage parameterNameNotPresent(@Nonnull Parameter parameter){
    Executable executable = parameter.getDeclaringExecutable();
    int p = Stream.of(executable.getParameters()).collect(Collectors.toList()).indexOf(parameter);
    String message = ""Unable to provision parameter at position: '"" + p + ""', require by: "" + ProvisioningException.toString(parameter.getDeclaringExecutable()) + "". Parameter's name is missing"";
    return new Usage(message, ""bean-converter-parameter-name-missing"");
}","public static Usage parameterNameNotPresent(@Nonnull Parameter parameter){
    Executable executable = parameter.getDeclaringExecutable();
    int p = Stream.of(executable.getParameters()).collect(Collectors.toList()).indexOf(parameter);
    String message = ""Unable to provision parameter at position: '"" + p + ""', require by: "" + ProvisioningException.toString(parameter.getDeclaringExecutable()) + "". Parameter's name is missing"";
    return new Usage(message, ""bean-converter-parameter-name-missing"");
}","/**
   * Thrown when the reflective bean converter has no access to a parameter name. Compilation
   * must be done using <code>parameters</code> compiler option.
   *
   * @param parameter Parameter.
   * @return Usage exception.
   */","('parameterNameNotPresent', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",80.0,  Thrown when the reflective bean converter has no access to a parameter name.,14.0,"[""Thrown when the reflective bean converter doesn't have access to a name."", 'Thrown when the bean is not able to access a name.', 'Thrown when the reflective bean is not able to access a name.']"
476,cdk,org/openscience/cdk/renderer/visitor/AbstractAWTDrawVisitor.java,/display/renderawt/src/main/java/org/openscience/cdk/renderer/visitor/AbstractAWTDrawVisitor.java,transformPoint,45-58,"/**
     * Transforms a point according to the current affine transformation,
     * converting a world coordinate into a screen coordinate.
     *
     * @param xCoord x-coordinate of the world point to transform
     * @param yCoord y-coordinate of the world point to transform
     * @return       the transformed screen coordinate
     */
public int[] transformPoint(double xCoord, double yCoord){
    double[] src = new double[] { xCoord, yCoord };
    double[] dest = new double[2];
    this.transform.transform(src, 0, dest, 0, 1);
    return new int[] { (int) dest[0], (int) dest[1] };
}","public int[] transformPoint(double xCoord, double yCoord){
    double[] src = new double[] { xCoord, yCoord };
    double[] dest = new double[2];
    this.transform.transform(src, 0, dest, 0, 1);
    return new int[] { (int) dest[0], (int) dest[1] };
}","/**
     * Transforms a point according to the current affine transformation,
     * converting a world coordinate into a screen coordinate.
     *
     * @param xCoord x-coordinate of the world point to transform
     * @param yCoord y-coordinate of the world point to transform
     * @return       the transformed screen coordinate
     */","('transformPoint', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",80.0,"  Transforms a point according to the current affine transformation,  converting a world coordinate into a screen coordinate.",19.0,"['A world coordinate is converted into a screen coordinate by the current affine transformation.', 'A world coordinate is transformed into a screen coordinate by the current affine transformation.', 'A world coordinate is converted into a screen coordinate by transforming a point.']"
477,shardingsphere-elasticjob,org/apache/shardingsphere/elasticjob/lite/internal/sharding/ShardingService.java,/elasticjob-lite/elasticjob-lite-core/src/main/java/org/apache/shardingsphere/elasticjob/lite/internal/sharding/ShardingService.java,hasShardingInfoInOfflineServers,211-225,"/**
     * Query has sharding info in offline servers or not.
     * 
     * @return has sharding info in offline servers or not
     */
public boolean hasShardingInfoInOfflineServers(){
    List<String> onlineInstances = jobNodeStorage.getJobNodeChildrenKeys(InstanceNode.ROOT);
    int shardingTotalCount = configService.load(true).getShardingTotalCount();
    for (int i = 0; i < shardingTotalCount; i++) {
        if (!onlineInstances.contains(jobNodeStorage.getJobNodeData(ShardingNode.getInstanceNode(i)))) {
            return true;
        }
    }
    return false;
}","public boolean hasShardingInfoInOfflineServers(){
    List<String> onlineInstances = jobNodeStorage.getJobNodeChildrenKeys(InstanceNode.ROOT);
    int shardingTotalCount = configService.load(true).getShardingTotalCount();
    for (int i = 0; i < shardingTotalCount; i++) {
        if (!onlineInstances.contains(jobNodeStorage.getJobNodeData(ShardingNode.getInstanceNode(i)))) {
            return true;
        }
    }
    return false;
}","/**
     * Query has sharding info in offline servers or not.
     * 
     * @return has sharding info in offline servers or not
     */","('hasShardingInfoInOfflineServers', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",80.0,  Query has sharding info in offline servers or not.,10.0,"['There is a query that has sharding info in offline server.', 'There is a query that has sharding info in the offline server.', 'There is a query with sharding info in offline server.']"
479,weblogic-kubernetes-operator,oracle/kubernetes/operator/helpers/KubernetesUtils.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/KubernetesUtils.java,isMissingValues,39-59,"/**
   * Returns true if the current map is missing values from the required map. This method is
   * typically used to compare labels and annotations against specifications derived from the
   * domain.
   *
   * @param current  a map of the values found in a Kubernetes resource
   * @param required a map of the values specified for the resource by the domain
   * @return true if there is a problem that must be fixed by patching
   */
 static boolean isMissingValues(Map<String, String> current, Map<String, String> required){
    if (!hasAllRequiredNames(current, required)) {
        return true;
    }
    for (String name : required.keySet()) {
        if (!Objects.equals(current.get(name), required.get(name))) {
            return true;
        }
    }
    return false;
}"," static boolean isMissingValues(Map<String, String> current, Map<String, String> required){
    if (!hasAllRequiredNames(current, required)) {
        return true;
    }
    for (String name : required.keySet()) {
        if (!Objects.equals(current.get(name), required.get(name))) {
            return true;
        }
    }
    return false;
}","/**
   * Returns true if the current map is missing values from the required map. This method is
   * typically used to compare labels and annotations against specifications derived from the
   * domain.
   *
   * @param current  a map of the values found in a Kubernetes resource
   * @param required a map of the values specified for the resource by the domain
   * @return true if there is a problem that must be fixed by patching
   */","('isMissingValues', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",80.0,  Returns true if the current map is missing values from the required map.,14.0,"['If the current map is missing values, this is true.', ""If the current map is missing values, it's true."", 'If the current map is missing values, this will be true.']"
482,acs-aem-commons,com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,pathMatchesFilter,347-369,"/**
     * See if any of the provided filter patterns match the current path.  TRUE, if no filters are received.
     *
     * @param filters An array of string making up the regex to match with the path.  They should never
     *                be empty since there is a DEFAULT value.
     * @param path The path to interrogate.
     * @return true (match found) or false (no match)
     */
private boolean pathMatchesFilter(final String[] filters, String path){
    boolean matches = false;
    for (String filter : filters) {
        try {
            if (filter.equals(""*"") || path.matches(filter)) {
                matches = true;
                break;
            }
        } catch (PatternSyntaxException ex) {
            logErrorMessage(""Ignoring invalid regex filter: ["" + filter + ""].  Reason: "" + ex.getMessage());
        }
    }
    return matches;
}","private boolean pathMatchesFilter(final String[] filters, String path){
    boolean matches = false;
    for (String filter : filters) {
        try {
            if (filter.equals(""*"") || path.matches(filter)) {
                matches = true;
                break;
            }
        } catch (PatternSyntaxException ex) {
            logErrorMessage(""Ignoring invalid regex filter: ["" + filter + ""].  Reason: "" + ex.getMessage());
        }
    }
    return matches;
}","/**
     * See if any of the provided filter patterns match the current path.  TRUE, if no filters are received.
     *
     * @param filters An array of string making up the regex to match with the path.  They should never
     *                be empty since there is a DEFAULT value.
     * @param path The path to interrogate.
     * @return true (match found) or false (no match)
     */","('pathMatchesFilter', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",81.0,  See if any of the provided filter patterns match the current path.,13.0,"[""If any of the filters match the current path, then that's good."", ""If any of the filters match the current path, then that's a good sign."", 'If any of the filters match the current path, you should.']"
483,cdk,org/openscience/cdk/renderer/generators/standard/TextOutline.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/TextOutline.java,resize,215-230,"/**
     * Convenience function to resize the outline and maintain the existing
     * center point.
     *
     * @param scaleX scale x-axis
     * @param scaleY scale y-axis
     * @return resized outline
     */
 TextOutline resize(final double scaleX, final double scaleY){
    final Point2D center = getCenter();
    final AffineTransform transform = new AffineTransform();
    transform.translate(center.getX(), center.getY());
    transform.scale(scaleX, scaleY);
    transform.translate(-center.getX(), -center.getY());
    return transform(transform);
}","TextOutline resize(final double scaleX, final double scaleY){
    final Point2D center = getCenter();
    final AffineTransform transform = new AffineTransform();
    transform.translate(center.getX(), center.getY());
    transform.scale(scaleX, scaleY);
    transform.translate(-center.getX(), -center.getY());
    return transform(transform);
}","/**
     * Convenience function to resize the outline and maintain the existing
     * center point.
     *
     * @param scaleX scale x-axis
     * @param scaleY scale y-axis
     * @return resized outline
     */","('resize', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",81.0,  Convenience function to resize the outline and maintain the existing  center point.,13.0,"['To maintain the existing center point, the convenience function is needed.', 'To maintain the center point, the convenience function is needed.', 'To maintain the existing center point, the convenience function is necessary.']"
484,cdk,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,positionSubscript,462-475,"/**
     * Positions an outline in the subscript position relative to another 'primary' label.
     *
     * @param label     a label outline
     * @param subscript the label outline to position as subscript
     * @return positioned subscript outline
     */
 TextOutline positionSubscript(TextOutline label, TextOutline subscript){
    final Rectangle2D hydrogenBounds = label.getBounds();
    final Rectangle2D hydrogenCountBounds = subscript.getBounds();
    subscript = subscript.translate((hydrogenBounds.getMaxX() + padding) - hydrogenCountBounds.getMinX(), (hydrogenBounds.getMaxY() + (hydrogenCountBounds.getHeight() / 2)) - hydrogenCountBounds.getMaxY());
    return subscript;
}","TextOutline positionSubscript(TextOutline label, TextOutline subscript){
    final Rectangle2D hydrogenBounds = label.getBounds();
    final Rectangle2D hydrogenCountBounds = subscript.getBounds();
    subscript = subscript.translate((hydrogenBounds.getMaxX() + padding) - hydrogenCountBounds.getMinX(), (hydrogenBounds.getMaxY() + (hydrogenCountBounds.getHeight() / 2)) - hydrogenCountBounds.getMaxY());
    return subscript;
}","/**
     * Positions an outline in the subscript position relative to another 'primary' label.
     *
     * @param label     a label outline
     * @param subscript the label outline to position as subscript
     * @return positioned subscript outline
     */","('positionSubscript', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",81.0,  Positions an outline in the subscript position relative to another 'primary' label.,14.0,"['An outline is placed in the subscript position.', 'The subscript position has an outline in it.', 'An outline in the subscript position is relative to another label.']"
485,dcache,dmg/util/logback/FilterThresholdSet.java,/modules/cells/src/main/java/dmg/util/logback/FilterThresholdSet.java,computeEffectiveMap,193-210,"/**
     * Returns a map from appenders to levels for a logger.
     * <p>
     * The map contains the effective log levels, that is, the levels used for filtering log
     * events.
     */
private synchronized Map<String, Level> computeEffectiveMap(LoggerName logger){
    Map<String, Level> inheritedMap = getInheritedMap(logger);
    if (!isRoot(logger)) {
        LoggerName parent = logger.getParent();
        if (parent != null) {
            Map<String, Level> mergedMap = computeEffectiveMap(parent);
            mergedMap.putAll(inheritedMap);
            return mergedMap;
        }
    }
    return inheritedMap;
}","private synchronized Map<String, Level> computeEffectiveMap(LoggerName logger){
    Map<String, Level> inheritedMap = getInheritedMap(logger);
    if (!isRoot(logger)) {
        LoggerName parent = logger.getParent();
        if (parent != null) {
            Map<String, Level> mergedMap = computeEffectiveMap(parent);
            mergedMap.putAll(inheritedMap);
            return mergedMap;
        }
    }
    return inheritedMap;
}","/**
     * Returns a map from appenders to levels for a logger.
     * <p>
     * The map contains the effective log levels, that is, the levels used for filtering log
     * events.
     */","('computeEffectiveMap', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",81.0,  Returns a map from appenders to levels for a logger.,11.0,"['A map is returned from the appenders to the levels.', 'A map is returned to levels for a logger.', 'A map is returned from the appenders to the logger.']"
486,cdk,org/openscience/cdk/qsar/descriptors/atomic/AtomDegreeDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/AtomDegreeDescriptor.java,calculate,92-108,"/**
     * This method calculates the number of not-H substituents of an atom.
     *
     * @param  atom              The IAtom for which the DescriptorValue is requested
     * @param  container         The {@link IAtomContainer} for which this descriptor is to be calculated for
     * @return   The number of bonds on the shortest path between two atoms
     */
public DescriptorValue calculate(IAtom atom, IAtomContainer container){
    int atomDegree = 0;
    List<IAtom> neighboors = container.getConnectedAtomsList(atom);
    for (IAtom neighboor : neighboors) {
        if (neighboor.getAtomicNumber() != IElement.H)
            atomDegree += 1;
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(atomDegree), getDescriptorNames());
}","public DescriptorValue calculate(IAtom atom, IAtomContainer container){
    int atomDegree = 0;
    List<IAtom> neighboors = container.getConnectedAtomsList(atom);
    for (IAtom neighboor : neighboors) {
        if (neighboor.getAtomicNumber() != IElement.H)
            atomDegree += 1;
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(atomDegree), getDescriptorNames());
}","/**
     * This method calculates the number of not-H substituents of an atom.
     *
     * @param  atom              The IAtom for which the DescriptorValue is requested
     * @param  container         The {@link IAtomContainer} for which this descriptor is to be calculated for
     * @return   The number of bonds on the shortest path between two atoms
     */","('calculate', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",82.0,  This method calculates the number of not-H substituents of an atom.,12.0,"['The number of not-H substituents of an atom is calculated using this method.', 'The number of not-H substituents is calculated using this method.', 'The number of not-H substituents of an atom is calculated.']"
487,dcache,org/dcache/util/Checksum.java,/modules/common/src/main/java/org/dcache/util/Checksum.java,parseChecksum,130-150,"/**
     * Create a new checksum instance for an already computed digest of a particular type.
     *
     * @param digest the input must have the following format:
     *               <type>:<hexadecimal digest>
     * @throws IllegalArgumentException if argument has wrong form
     * @throws NullPointerException     if argument is null
     */
public static Checksum parseChecksum(String digest){
    requireNonNull(digest, ""value may not be null"");
    int del = digest.indexOf(DELIMITER);
    if (del < 1) {
        throw new IllegalArgumentException(""Not a dCache checksum: "" + digest);
    }
    String type = digest.substring(0, del);
    String checksum = digest.substring(del + 1);
    return new Checksum(ChecksumType.getChecksumType(type), checksum);
}","public static Checksum parseChecksum(String digest){
    requireNonNull(digest, ""value may not be null"");
    int del = digest.indexOf(DELIMITER);
    if (del < 1) {
        throw new IllegalArgumentException(""Not a dCache checksum: "" + digest);
    }
    String type = digest.substring(0, del);
    String checksum = digest.substring(del + 1);
    return new Checksum(ChecksumType.getChecksumType(type), checksum);
}","/**
     * Create a new checksum instance for an already computed digest of a particular type.
     *
     * @param digest the input must have the following format:
     *               <type>:<hexadecimal digest>
     * @throws IllegalArgumentException if argument has wrong form
     * @throws NullPointerException     if argument is null
     */","('parseChecksum', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",82.0,  Create a new checksum instance for an already computed digest of a particular type.,15.0,"['You can create a new instance for an already computed digest.', 'You can create a new instance for an already computed digest of a particular type.', 'If you want to create a new instance for an already computed digest of a particular type, you have to create a new instance.']"
488,cdk,org/openscience/cdk/smiles/DeduceBondSystemTool.java,/legacy/src/main/java/org/openscience/cdk/smiles/DeduceBondSystemTool.java,isOK,95-116,"/**
     * Determines if, according to the algorithms implemented in this class, the given
     * AtomContainer has properly distributed double bonds.
     *
     * @param  m {@link IAtomContainer} to check the bond orders for.
     * @return true, if bond orders are properly distributed
     * @throws CDKException thrown when something went wrong
     */
public boolean isOK(IAtomContainer m) throws CDKException{
    // OK, we take advantage here from the fact that this class does not take
    // into account rings larger than 7 atoms. See fixAromaticBondOrders().
    IRingSet rs = allRingsFinder.findAllRings(m, 7);
    storeRingSystem(m, rs);
    boolean StructureOK = this.isStructureOK(m);
    IRingSet irs = this.removeExtraRings(m);
    if (irs == null)
        throw new CDKException(""error in AllRingsFinder.findAllRings"");
    int count = this.getBadCount(m, irs);
    return StructureOK && count == 0;
}","public boolean isOK(IAtomContainer m) throws CDKException{
    // OK, we take advantage here from the fact that this class does not take
    // into account rings larger than 7 atoms. See fixAromaticBondOrders().
    IRingSet rs = allRingsFinder.findAllRings(m, 7);
    storeRingSystem(m, rs);
    boolean StructureOK = this.isStructureOK(m);
    IRingSet irs = this.removeExtraRings(m);
    if (irs == null)
        throw new CDKException(""error in AllRingsFinder.findAllRings"");
    int count = this.getBadCount(m, irs);
    return StructureOK && count == 0;
}","/**
     * Determines if, according to the algorithms implemented in this class, the given
     * AtomContainer has properly distributed double bonds.
     *
     * @param  m {@link IAtomContainer} to check the bond orders for.
     * @return true, if bond orders are properly distributed
     * @throws CDKException thrown when something went wrong
     */","('isOK', {'INSTRUCTION': {'covered': 32, 'missed': 6}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",82.0,"  Determines if, according to the algorithms implemented in this class, the given  AtomContainer has properly distributed double bonds.",21.0,"['Determines if the given AtomContainer has properly distributed double bonds.', 'If the given AtomContainer has properly distributed double bonds, it is determined.', 'If the given AtomContainer has properly distributed double bonds, it is determined by this class.']"
489,weblogic-kubernetes-operator,oracle/kubernetes/weblogic/domain/model/DomainStatus.java,/operator/src/main/java/oracle/kubernetes/weblogic/domain/model/DomainStatus.java,addCondition,116-134,"/**
   * Adds a condition to the status, replacing any existing conditions with the same type, and removing other
   * conditions according to the domain rules.
   *
   * @param newCondition the condition to add.
   * @return this object.
   */
public DomainStatus addCondition(DomainCondition newCondition){
    if (conditions.contains(newCondition)) {
        return this;
    }
    conditions = conditions.stream().filter(c -> preserve(c, newCondition.getType())).collect(Collectors.toList());
    conditions.add(newCondition);
    reason = newCondition.getStatusReason();
    message = newCondition.getStatusMessage();
    return this;
}","public DomainStatus addCondition(DomainCondition newCondition){
    if (conditions.contains(newCondition)) {
        return this;
    }
    conditions = conditions.stream().filter(c -> preserve(c, newCondition.getType())).collect(Collectors.toList());
    conditions.add(newCondition);
    reason = newCondition.getStatusReason();
    message = newCondition.getStatusMessage();
    return this;
}","/**
   * Adds a condition to the status, replacing any existing conditions with the same type, and removing other
   * conditions according to the domain rules.
   *
   * @param newCondition the condition to add.
   * @return this object.
   */","('addCondition', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",82.0,"  Adds a condition to the status, replacing any existing conditions with the same type, and removing other  conditions according to the domain rules.",26.0,"['Adds a condition to the status, replacing any existing conditions with the same type, and removing other conditions according to the domain rules.', 'Adding a condition to the status, replacing any existing conditions with the same type, and removing other conditions according to the domain rules.', 'Adding a condition to the status, replacing any existing conditions with the same type, and removing other conditions according to the domain rules are all done this way.']"
490,cdk,org/openscience/cdk/layout/TemplateHandler.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/TemplateHandler.java,addMolecule,151-171,"/**
     * Adds a Molecule to the list of templates use by this TemplateHandler.
     *
     * @param molecule The molecule to be added to the TemplateHandler
     */
public void addMolecule(IAtomContainer molecule){
    if (!GeometryUtil.has2DCoordinates(molecule))
        throw new IllegalArgumentException(""Template did not have 2D coordinates"");
    GeometryUtil.scaleMolecule(molecule, GeometryUtil.getScaleFactor(molecule, StructureDiagramGenerator.DEFAULT_BOND_LENGTH));
    templates.add(molecule);
    anonPatterns.add(VentoFoggia.findSubstructure(molecule, anonAtomMatcher, anonBondMatcher));
    elemPatterns.add(VentoFoggia.findSubstructure(molecule, elemAtomMatcher, anonBondMatcher));
}","public void addMolecule(IAtomContainer molecule){
    if (!GeometryUtil.has2DCoordinates(molecule))
        throw new IllegalArgumentException(""Template did not have 2D coordinates"");
    GeometryUtil.scaleMolecule(molecule, GeometryUtil.getScaleFactor(molecule, StructureDiagramGenerator.DEFAULT_BOND_LENGTH));
    templates.add(molecule);
    anonPatterns.add(VentoFoggia.findSubstructure(molecule, anonAtomMatcher, anonBondMatcher));
    elemPatterns.add(VentoFoggia.findSubstructure(molecule, elemAtomMatcher, anonBondMatcher));
}","/**
     * Adds a Molecule to the list of templates use by this TemplateHandler.
     *
     * @param molecule The molecule to be added to the TemplateHandler
     */","('addMolecule', {'INSTRUCTION': {'covered': 34, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",83.0,  Adds a Molecule to the list of templates use by this TemplateHandler.,13.0,"['A Molecule is added to the list of templates.', 'The Molecule is added to the list of templates.', 'A Molecule is added to the list of templates used by this template handler.']"
491,cdk,org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,projectG1,530-544,"/**
     *  Projects a CDKRGraph bitset on the source graph G1.
     * @param  set  CDKRGraph BitSet to project
     * @return      The associate BitSet in G1
     */
public BitSet projectG1(BitSet set){
    BitSet projection = new BitSet(getFirstGraphSize());
    CDKRNode xNode = null;
    for (int x = set.nextSetBit(0); x >= 0; x = set.nextSetBit(x + 1)) {
        xNode = getGraph().get(x);
        projection.set(xNode.getRMap().getId1());
    }
    return projection;
}","public BitSet projectG1(BitSet set){
    BitSet projection = new BitSet(getFirstGraphSize());
    CDKRNode xNode = null;
    for (int x = set.nextSetBit(0); x >= 0; x = set.nextSetBit(x + 1)) {
        xNode = getGraph().get(x);
        projection.set(xNode.getRMap().getId1());
    }
    return projection;
}","/**
     *  Projects a CDKRGraph bitset on the source graph G1.
     * @param  set  CDKRGraph BitSet to project
     * @return      The associate BitSet in G1
     */","('projectG1', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",83.0,Projects a CDKRGraph bitset on the source graph G1.,10.0,"['The bitset is on the source graph G1.', 'The source graph G1 has a CDKRGraph bitset on it.', 'The source graph G1 has a CDKRGraph bitset.']"
492,cdk,org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,projectG2,546-560,"/**
     *  Projects a CDKRGraph bitset on the source graph G2.
     * @param  set  CDKRGraph BitSet to project
     * @return      The associate BitSet in G2
     */
public BitSet projectG2(BitSet set){
    BitSet projection = new BitSet(getSecondGraphSize());
    CDKRNode xNode = null;
    for (int x = set.nextSetBit(0); x >= 0; x = set.nextSetBit(x + 1)) {
        xNode = getGraph().get(x);
        projection.set(xNode.getRMap().getId2());
    }
    return projection;
}","public BitSet projectG2(BitSet set){
    BitSet projection = new BitSet(getSecondGraphSize());
    CDKRNode xNode = null;
    for (int x = set.nextSetBit(0); x >= 0; x = set.nextSetBit(x + 1)) {
        xNode = getGraph().get(x);
        projection.set(xNode.getRMap().getId2());
    }
    return projection;
}","/**
     *  Projects a CDKRGraph bitset on the source graph G2.
     * @param  set  CDKRGraph BitSet to project
     * @return      The associate BitSet in G2
     */","('projectG2', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",83.0,Projects a CDKRGraph bitset on the source graph G2.,10.0,"['The bitset is on the source graph G2.', 'The source graph G2 has a CDKRGraph bitset on it.', 'The source graph G2 has a CDKRGraph bitset.']"
493,dcache,org/dcache/resilience/handlers/FileOperationHandler.java,/modules/dcache-resilience/src/main/java/org/dcache/resilience/handlers/FileOperationHandler.java,handleScannedLocation,375-416,"/**
     * <p>The entry method for a PnfsId operation from a pool scan task.</p>
     *
     * <p>If the entry is already in the current map, its count is incremented.</p>
     *
     * <p>All attributes of the file that are necessary for resilience
     * processing are then fetched.  Preliminary checks run for disqualifying conditions here
     * include whether this is a storage unit modification, in which case the task is registered if
     * the file has the storage unit in question. Otherwise, verification proceeds as in the {@link
     * #handleLocationUpdate(FileUpdate)} method.</p>
     *
     * @return true if a new operation is added to the map.
     */
public boolean handleScannedLocation(FileUpdate data, Integer storageUnit) throws CacheException{
    LOGGER.debug(""handleScannedLocation {}"", data);
    if (!data.validateAttributes(namespace)) {
        return false;
    }
    data.verifyPoolGroup(poolInfoMap);
    if (!data.validateForAction(storageUnit, poolInfoMap, verifier, pools)) {
        return false;
    }
    LOGGER.debug(""handleScannedLocation, update to be registered: {}"", data);
    return fileOpMap.register(data);
}","public boolean handleScannedLocation(FileUpdate data, Integer storageUnit) throws CacheException{
    LOGGER.debug(""handleScannedLocation {}"", data);
    if (!data.validateAttributes(namespace)) {
        return false;
    }
    data.verifyPoolGroup(poolInfoMap);
    if (!data.validateForAction(storageUnit, poolInfoMap, verifier, pools)) {
        return false;
    }
    LOGGER.debug(""handleScannedLocation, update to be registered: {}"", data);
    return fileOpMap.register(data);
}","/**
     * <p>The entry method for a PnfsId operation from a pool scan task.</p>
     *
     * <p>If the entry is already in the current map, its count is incremented.</p>
     *
     * <p>All attributes of the file that are necessary for resilience
     * processing are then fetched.  Preliminary checks run for disqualifying conditions here
     * include whether this is a storage unit modification, in which case the task is registered if
     * the file has the storage unit in question. Otherwise, verification proceeds as in the {@link
     * #handleLocationUpdate(FileUpdate)} method.</p>
     *
     * @return true if a new operation is added to the map.
     */","('handleScannedLocation', {'INSTRUCTION': {'covered': 35, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",83.0,  <p>The entry method for a PnfsId operation from a pool scan task.,16.0,"['The entry method is used for a PnfsId operation.', 'The entry method for a PnfsId operation is used.', 'The entry method for a PnfsId operation is from a pool task.']"
494,matsim-libs,org/matsim/core/controler/OutputDirectoryHierarchy.java,/matsim/src/main/java/org/matsim/core/controler/OutputDirectoryHierarchy.java,createIterationDirectory,187-202,"/**
	 * Creates the path where all iteration-related data should be stored.
	 */
public final void createIterationDirectory(final int iteration){
    File dir = new File(getIterationPath(iteration));
    if (!dir.mkdir()) {
        if (this.overwriteFiles == OverwriteFileSetting.overwriteExistingFiles && dir.exists()) {
            log.info(""Iteration directory "" + getIterationPath(iteration) + "" exists already."");
        } else {
            log.warn(""Could not create iteration directory "" + getIterationPath(iteration) + ""."");
        }
    }
}","public final void createIterationDirectory(final int iteration){
    File dir = new File(getIterationPath(iteration));
    if (!dir.mkdir()) {
        if (this.overwriteFiles == OverwriteFileSetting.overwriteExistingFiles && dir.exists()) {
            log.info(""Iteration directory "" + getIterationPath(iteration) + "" exists already."");
        } else {
            log.warn(""Could not create iteration directory "" + getIterationPath(iteration) + ""."");
        }
    }
}","/**
	 * Creates the path where all iteration-related data should be stored.
	 */","('createIterationDirectory', {'INSTRUCTION': {'covered': 25, 'missed': 6}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 6, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",83.0,  Creates the path where all iteration-related data should be stored.,11.0,"['The path where data should be stored is created.', 'The path where all iteration-related data should be stored is created.', 'All iteration-related data should be stored in this path.']"
495,activiti,org/activiti/engine/impl/bpmn/deployer/BpmnDeployer.java,/activiti-core/activiti-engine/src/main/java/org/activiti/engine/impl/bpmn/deployer/BpmnDeployer.java,makeProcessDefinitionsConsistentWithPersistedVersions,268-284,"/**
     * Loads the persisted version of each process definition and set values on the in-memory
     * version to be consistent.
     */
protected void makeProcessDefinitionsConsistentWithPersistedVersions(ParsedDeployment parsedDeployment){
    for (ProcessDefinitionEntity processDefinition : parsedDeployment.getAllProcessDefinitions()) {
        ProcessDefinitionEntity persistedProcessDefinition = bpmnDeploymentHelper.getPersistedInstanceOfProcessDefinition(processDefinition);
        if (persistedProcessDefinition != null) {
            processDefinition.setId(persistedProcessDefinition.getId());
            processDefinition.setVersion(persistedProcessDefinition.getVersion());
            processDefinition.setAppVersion(persistedProcessDefinition.getAppVersion());
            processDefinition.setSuspensionState(persistedProcessDefinition.getSuspensionState());
        }
    }
}","protected void makeProcessDefinitionsConsistentWithPersistedVersions(ParsedDeployment parsedDeployment){
    for (ProcessDefinitionEntity processDefinition : parsedDeployment.getAllProcessDefinitions()) {
        ProcessDefinitionEntity persistedProcessDefinition = bpmnDeploymentHelper.getPersistedInstanceOfProcessDefinition(processDefinition);
        if (persistedProcessDefinition != null) {
            processDefinition.setId(persistedProcessDefinition.getId());
            processDefinition.setVersion(persistedProcessDefinition.getVersion());
            processDefinition.setAppVersion(persistedProcessDefinition.getAppVersion());
            processDefinition.setSuspensionState(persistedProcessDefinition.getSuspensionState());
        }
    }
}","/**
     * Loads the persisted version of each process definition and set values on the in-memory
     * version to be consistent.
     */","('makeProcessDefinitionsConsistentWithPersistedVersions', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,  Loads the persisted version of each process definition and set values on the in-memory  version to be consistent.,19.0,"['Set values on the in-memory version of the persisted version of the process definition.', 'Set values on the in-memory version of the persisted version of the process definition to be consistent.', 'Set the values on the in-memory version of the persisted version of the process definition to be consistent.']"
496,dataverse,edu/harvard/iq/dataverse/util/FileUtil.java,/src/main/java/edu/harvard/iq/dataverse/util/FileUtil.java,isPubliclyDownloadable,1542-1585,"/**
     * Provide download URL if no Terms of Use, no guestbook, and not
     * restricted.
     */
public static boolean isPubliclyDownloadable(FileMetadata fileMetadata){
    if (fileMetadata == null) {
        return false;
    }
    if (fileMetadata.isRestricted()) {
        String msg = ""Not publicly downloadable because the file is restricted."";
        logger.fine(msg);
        return false;
    }
    if (isActivelyEmbargoed(fileMetadata)) {
        return false;
    }
    boolean popupReasons = isDownloadPopupRequired(fileMetadata.getDatasetVersion());
    if (popupReasons == true) {
        return false;
    }
    return true;
}","public static boolean isPubliclyDownloadable(FileMetadata fileMetadata){
    if (fileMetadata == null) {
        return false;
    }
    if (fileMetadata.isRestricted()) {
        String msg = ""Not publicly downloadable because the file is restricted."";
        logger.fine(msg);
        return false;
    }
    if (isActivelyEmbargoed(fileMetadata)) {
        return false;
    }
    boolean popupReasons = isDownloadPopupRequired(fileMetadata.getDatasetVersion());
    if (popupReasons == true) {
        return false;
    }
    return true;
}","/**
     * Provide download URL if no Terms of Use, no guestbook, and not
     * restricted.
     */","('isPubliclyDownloadable', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,"  Provide download URL if no Terms of Use, no guestbook, and not  restricted.",16.0,"['If there are no Terms of Use, no guestbook, and no download URL, give it to you.', 'If there are no Terms of Use, no guestbook, and no download URL, give it.', 'If there are no Terms of Use, no guestbook, and no download URL, you should provide one.']"
497,cdk,org/openscience/cdk/io/iterator/IteratingSMILESReader.java,/storage/smiles/src/main/java/org/openscience/cdk/io/iterator/IteratingSMILESReader.java,readSmiles,162-178,"/**
     * Read the SMILES given in the input line - or return an empty container.
     *
     * @param line input line
     * @return the read container (or an empty one)
     */
private IAtomContainer readSmiles(final String line){
    try {
        return sp.parseSmiles(line);
    } catch (CDKException e) {
        logger.error(""Error while reading the SMILES from: "" + line + "", "", e);
        final IAtomContainer empty = builder.newInstance(IAtomContainer.class, 0, 0, 0, 0);
        empty.setProperty(BAD_SMILES_INPUT, line);
        empty.setTitle(suffix(line));
        return empty;
    }
}","private IAtomContainer readSmiles(final String line){
    try {
        return sp.parseSmiles(line);
    } catch (CDKException e) {
        logger.error(""Error while reading the SMILES from: "" + line + "", "", e);
        final IAtomContainer empty = builder.newInstance(IAtomContainer.class, 0, 0, 0, 0);
        empty.setProperty(BAD_SMILES_INPUT, line);
        empty.setTitle(suffix(line));
        return empty;
    }
}","/**
     * Read the SMILES given in the input line - or return an empty container.
     *
     * @param line input line
     * @return the read container (or an empty one)
     */","('readSmiles', {'INSTRUCTION': {'covered': 63, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,  Read the SMILES given in the input line - or return an empty container.,15.0,"['Return an empty container if you read the SMILES given in the input line.', 'Return an empty container if you read the SMILES in the input line.', 'Return an empty container if you want to read the SMILES given in the input line.']"
499,acs-aem-commons,com/adobe/acs/commons/ondeploy/impl/OnDeployExecutorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/ondeploy/impl/OnDeployExecutorImpl.java,bindScriptProvider,138-154,"/**
     * Executes all on-deploy scripts on bind of a script provider.
     */
protected void bindScriptProvider(OnDeployScriptProvider scriptProvider){
    logger.info(""Executing on-deploy scripts from scriptProvider: {}"", scriptProvider.getClass().getName());
    scriptProviders.add(scriptProvider);
    List<OnDeployScript> scripts = scriptProvider.getScripts();
    if (scripts.size() == 0) {
        logger.debug(""No on-deploy scripts found."");
        return;
    }
    try (ResourceResolver resourceResolver = logIn()) {
        runScripts(resourceResolver, scripts);
    }
}","protected void bindScriptProvider(OnDeployScriptProvider scriptProvider){
    logger.info(""Executing on-deploy scripts from scriptProvider: {}"", scriptProvider.getClass().getName());
    scriptProviders.add(scriptProvider);
    List<OnDeployScript> scripts = scriptProvider.getScripts();
    if (scripts.size() == 0) {
        logger.debug(""No on-deploy scripts found."");
        return;
    }
    try (ResourceResolver resourceResolver = logIn()) {
        runScripts(resourceResolver, scripts);
    }
}","/**
     * Executes all on-deploy scripts on bind of a script provider.
     */","('bindScriptProvider', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,  Executes all on-deploy scripts on bind of a script provider.,11.0,"['The script is executed on the bind of the script provider.', 'All on-deploy scripts are executed on the bind of the script provider.', 'All on-deploy scripts are executed on the bind of a script provider.']"
500,matsim-libs,org/matsim/core/utils/collections/QuadTree.java,/matsim/src/main/java/org/matsim/core/utils/collections/QuadTree.java,put,75-95,"/**
	 * Associates the specified value with the specified coordinates in this
	 * QuadTree.
	 *
	 * @param x x-coordinate where the specified value is to be associated.
	 * @param y y-coordinate where the specified value is to be associated.
	 * @param value value to be associated with the specified coordinates.
	 *
	 * @return true if insertion was successful and the data structure changed,
	 *         false otherwise.
	 */
public boolean put(final double x, final double y, final T value){
    if (!this.top.bounds.containsOrEquals(x, y)) {
        throw new IllegalArgumentException(""cannot add a point at x="" + x + "", y="" + y + "" with bounds "" + this.top.bounds);
    }
    if (this.top.put(x, y, value)) {
        incrementSize();
        return true;
    }
    return false;
}","public boolean put(final double x, final double y, final T value){
    if (!this.top.bounds.containsOrEquals(x, y)) {
        throw new IllegalArgumentException(""cannot add a point at x="" + x + "", y="" + y + "" with bounds "" + this.top.bounds);
    }
    if (this.top.put(x, y, value)) {
        incrementSize();
        return true;
    }
    return false;
}","/**
	 * Associates the specified value with the specified coordinates in this
	 * QuadTree.
	 *
	 * @param x x-coordinate where the specified value is to be associated.
	 * @param y y-coordinate where the specified value is to be associated.
	 * @param value value to be associated with the specified coordinates.
	 *
	 * @return true if insertion was successful and the data structure changed,
	 *         false otherwise.
	 */","('put', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,  Associates the specified value with the specified coordinates in this  QuadTree.,12.0,"['The specified value should be associated with the specified coordinates.', 'The specified value should be associated with the coordinates in this QuadTree.', 'The specified value should be associated with the specified coordinates in this QuadTree.']"
501,weblogic-kubernetes-operator,oracle/kubernetes/operator/helpers/DomainPresenceInfo.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/DomainPresenceInfo.java,updateLastKnownServerStatus,346-366,"/**
   * Updates the last status reported for the specified server.
   *
   * @param serverName the name of the server
   * @param status the new status
   */
public void updateLastKnownServerStatus(String serverName, String status){
    getSko(serverName).getLastKnownStatus().getAndUpdate(lastKnownStatus -> {
        LastKnownStatus updatedStatus = null;
        if (status != null) {
            updatedStatus = (lastKnownStatus != null && status.equals(lastKnownStatus.getStatus())) ? new LastKnownStatus(status, lastKnownStatus.getUnchangedCount() + 1) : new LastKnownStatus(status);
        }
        return updatedStatus;
    });
}","public void updateLastKnownServerStatus(String serverName, String status){
    getSko(serverName).getLastKnownStatus().getAndUpdate(lastKnownStatus -> {
        LastKnownStatus updatedStatus = null;
        if (status != null) {
            updatedStatus = (lastKnownStatus != null && status.equals(lastKnownStatus.getStatus())) ? new LastKnownStatus(status, lastKnownStatus.getUnchangedCount() + 1) : new LastKnownStatus(status);
        }
        return updatedStatus;
    });
}","/**
   * Updates the last status reported for the specified server.
   *
   * @param serverName the name of the server
   * @param status the new status
   */","('updateLastKnownServerStatus', {'INSTRUCTION': {'covered': 9, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,  Updates the last status reported for the specified server.,10.0,"[""The server's last status was updated."", ""The server's last status is updated."", ""The specified server's last status was updated.""]"
502,cdk,org/openscience/cdk/group/PermutationGroup.java,/tool/group/src/main/java/org/openscience/cdk/group/PermutationGroup.java,test,384-402,"/**
     * Test a permutation to see if it is in the group. Note that this also
     * alters the permutation passed in.
     *
     * @param permutation the one to test
     * @return the position it should be in the group, if any
     */
public int test(Permutation permutation){
    for (int i = 0; i < size; i++) {
        int x = permutation.get(base.get(i));
        Permutation h = permutations[i][x];
        if (h == null) {
            return i;
        } else {
            permutation.setTo(h.invert().multiply(permutation));
        }
    }
    return size;
}","public int test(Permutation permutation){
    for (int i = 0; i < size; i++) {
        int x = permutation.get(base.get(i));
        Permutation h = permutations[i][x];
        if (h == null) {
            return i;
        } else {
            permutation.setTo(h.invert().multiply(permutation));
        }
    }
    return size;
}","/**
     * Test a permutation to see if it is in the group. Note that this also
     * alters the permutation passed in.
     *
     * @param permutation the one to test
     * @return the position it should be in the group, if any
     */","('test', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",84.0,  Test a permutation to see if it is in the group.,12.0,"['To find out if it is in the group, test a permutation.', 'If it is in the group, try a permutation.', 'To find out if it is in the group, you have to test a permutation.']"
503,acs-aem-commons,com/adobe/acs/commons/util/TypeUtil.java,/bundle/src/main/java/com/adobe/acs/commons/util/TypeUtil.java,toValueMap,243-257,"/**
     * Transforms a Map of &lgt;String, ?&gt; into a ValueMap.
     *
     * @param map
     * @return a ValueMap of the parameter map
     */
public static ValueMap toValueMap(final Map<String, ?> map){
    final Map<String, Object> objectMap = new LinkedHashMap<String, Object>(map.size());
    for (final Map.Entry<String, ?> entry : map.entrySet()) {
        objectMap.put(entry.getKey(), entry.getValue());
    }
    return new ValueMapDecorator(objectMap);
}","public static ValueMap toValueMap(final Map<String, ?> map){
    final Map<String, Object> objectMap = new LinkedHashMap<String, Object>(map.size());
    for (final Map.Entry<String, ?> entry : map.entrySet()) {
        objectMap.put(entry.getKey(), entry.getValue());
    }
    return new ValueMapDecorator(objectMap);
}","/**
     * Transforms a Map of &lgt;String, ?&gt; into a ValueMap.
     *
     * @param map
     * @return a ValueMap of the parameter map
     */","('toValueMap', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",85.0,"  Transforms a Map of &lgt;String, ?&gt; into a ValueMap.",17.0,"['A Map is transformed into a ValueMap.', 'The Map is transformed into a ValueMap.', 'A Map is transformed into a value map.']"
504,cdk,org/openscience/cdk/layout/OverlapResolver.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/OverlapResolver.java,resolveOverlap,63-81,"/**
     * Main method to be called to resolve overlap situations.
     *
     * @param  ac    The atomcontainer in which the atom or bond overlap exists
     * @param  sssr  A ring set for this atom container if one exists, otherwhise null
     */
public double resolveOverlap(IAtomContainer ac, IRingSet sssr){
    Vector overlappingAtoms = new Vector();
    Vector overlappingBonds = new Vector();
    logger.debug(""Start of resolveOverlap"");
    double overlapScore = getOverlapScore(ac, overlappingAtoms, overlappingBonds);
    if (overlapScore > 0) {
        overlapScore = displace(ac, overlappingAtoms, overlappingBonds);
    }
    logger.debug(""overlapScore = "" + overlapScore);
    logger.debug(""End of resolveOverlap"");
    return overlapScore;
}","public double resolveOverlap(IAtomContainer ac, IRingSet sssr){
    Vector overlappingAtoms = new Vector();
    Vector overlappingBonds = new Vector();
    logger.debug(""Start of resolveOverlap"");
    double overlapScore = getOverlapScore(ac, overlappingAtoms, overlappingBonds);
    if (overlapScore > 0) {
        overlapScore = displace(ac, overlappingAtoms, overlappingBonds);
    }
    logger.debug(""overlapScore = "" + overlapScore);
    logger.debug(""End of resolveOverlap"");
    return overlapScore;
}","/**
     * Main method to be called to resolve overlap situations.
     *
     * @param  ac    The atomcontainer in which the atom or bond overlap exists
     * @param  sssr  A ring set for this atom container if one exists, otherwhise null
     */","('resolveOverlap', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",85.0,  Main method to be called to resolve overlap situations.,10.0,"['There is a main method to resolve overlap situations.', 'The main method to resolve overlap situations.', 'The main method to resolve overlap situations is called.']"
505,acs-aem-commons,com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/DispatcherFlushFilter.java,isIncluded,78-95,"/**
     * Checks if the @agent is considered an active Flush agent (Serialization Type ~&gt; Flush and is enabled).
     *
     * @param agent the agent to test test
     * @return true is is considered an enabled Flush agent
     */
public final boolean isIncluded(final Agent agent){
    if (FlushType.All.equals(this.flushType)) {
        return this.isIncludedCommon(agent);
    } else if (FlushType.Hierarchical.equals(this.flushType)) {
        return this.isIncludedHierarchical(agent);
    } else if (FlushType.ResourceOnly.equals(this.flushType)) {
        return this.isIncludedResourceOnly(agent);
    }
    return false;
}","public final boolean isIncluded(final Agent agent){
    if (FlushType.All.equals(this.flushType)) {
        return this.isIncludedCommon(agent);
    } else if (FlushType.Hierarchical.equals(this.flushType)) {
        return this.isIncludedHierarchical(agent);
    } else if (FlushType.ResourceOnly.equals(this.flushType)) {
        return this.isIncludedResourceOnly(agent);
    }
    return false;
}","/**
     * Checks if the @agent is considered an active Flush agent (Serialization Type ~&gt; Flush and is enabled).
     *
     * @param agent the agent to test test
     * @return true is is considered an enabled Flush agent
     */","('isIncluded', {'INSTRUCTION': {'covered': 27, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",85.0,  Checks if the @agent is considered an active Flush agent (Serialization Type ~&gt; Flush and is enabled).,24.0,"['If the agent is considered an active Flush agent, it is checked.', ""If the agent is considered an active Flush agent, it's checked."", 'If the agent is considered an active Flush agent, the check is done.']"
506,glowstone,net/glowstone/entity/AttributeManager.java,/src/main/java/net/glowstone/entity/AttributeManager.java,sendMessages,56-74,"/**
     * Sends the managed entity's properties to the client, if the client's snapshot is stale.
     *
     * @param session the client's session
     */
public void sendMessages(GlowSession session){
    if (!needsUpdate) {
        return;
    }
    int id = entity.entityId;
    if (entity instanceof GlowPlayer) {
        GlowPlayer player = (GlowPlayer) entity;
        if (player.getUniqueId().equals(session.getPlayer().getUniqueId())) {
            id = 0;
        }
    }
    session.send(new EntityPropertyMessage(id, properties));
    needsUpdate = false;
}","public void sendMessages(GlowSession session){
    if (!needsUpdate) {
        return;
    }
    int id = entity.entityId;
    if (entity instanceof GlowPlayer) {
        GlowPlayer player = (GlowPlayer) entity;
        if (player.getUniqueId().equals(session.getPlayer().getUniqueId())) {
            id = 0;
        }
    }
    session.send(new EntityPropertyMessage(id, properties));
    needsUpdate = false;
}","/**
     * Sends the managed entity's properties to the client, if the client's snapshot is stale.
     *
     * @param session the client's session
     */","('sendMessages', {'INSTRUCTION': {'covered': 36, 'missed': 1}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 9, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",85.0,"  Sends the managed entity's properties to the client, if the client's snapshot is stale.",18.0,"[""If the client's snapshot is not fresh, the managed entity's properties are sent to them."", ""If the client's snapshot is not fresh, the managed entity's properties are sent to the client."", ""If the client's snapshot is old, the managed entity's properties are sent to them.""]"
507,openapi-generator,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,isObjectSchema,425-461,"/**
     * Return true if the specified schema is an object with a fixed number of properties.
     *
     * A ObjectSchema differs from an MapSchema in the following way:
     * - An ObjectSchema is not extensible, i.e. it has a fixed number of properties.
     * - A MapSchema is an object that can be extended with an arbitrary set of properties.
     *   The payload may include dynamic properties.
     *
     * For example, an OpenAPI schema is considered an ObjectSchema in the following scenarios:
     *
     *   type: object
     *   additionalProperties: false
     *   properties:
     *     name:
     *       type: string
     *     address:
     *       type: string
     *
     * @param schema the OAS schema
     * @return true if the specified schema is an Object schema.
     */
public static boolean isObjectSchema(Schema schema){
    if (schema instanceof ObjectSchema) {
        return true;
    }
    if (SchemaTypeUtil.OBJECT_TYPE.equals(schema.getType()) && !(schema instanceof MapSchema)) {
        return true;
    }
    if (schema.getType() == null && schema.getProperties() != null && !schema.getProperties().isEmpty()) {
        return true;
    }
    return false;
}","public static boolean isObjectSchema(Schema schema){
    if (schema instanceof ObjectSchema) {
        return true;
    }
    if (SchemaTypeUtil.OBJECT_TYPE.equals(schema.getType()) && !(schema instanceof MapSchema)) {
        return true;
    }
    if (schema.getType() == null && schema.getProperties() != null && !schema.getProperties().isEmpty()) {
        return true;
    }
    return false;
}","/**
     * Return true if the specified schema is an object with a fixed number of properties.
     *
     * A ObjectSchema differs from an MapSchema in the following way:
     * - An ObjectSchema is not extensible, i.e. it has a fixed number of properties.
     * - A MapSchema is an object that can be extended with an arbitrary set of properties.
     *   The payload may include dynamic properties.
     *
     * For example, an OpenAPI schema is considered an ObjectSchema in the following scenarios:
     *
     *   type: object
     *   additionalProperties: false
     *   properties:
     *     name:
     *       type: string
     *     address:
     *       type: string
     *
     * @param schema the OAS schema
     * @return true if the specified schema is an Object schema.
     */","('isObjectSchema', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",85.0,  Return true if the specified schema is an object with a fixed number of properties.,16.0,"['If the specified object is an object with a fixed number of properties, return true.', 'Return true if the specified object has a fixed number of properties.', 'If the specified object is an object with a fixed number of properties, then return true.']"
508,sonar-cxx,org/sonar/cxx/sensors/compiler/CxxCompilerSensor.java,/cxx-sensors/src/main/java/org/sonar/cxx/sensors/compiler/CxxCompilerSensor.java,isInputValid,107-129,"/**
   * Derived classes can overload this method
   *
   * A valid issue must have an id and, if it has a line number, a filename.
   *
   * @param filename
   * @param line
   * @param column is optional
   * @param id
   * @param msg
   * @return true, if valid
   */
protected boolean isInputValid(@Nullable String filename, @Nullable String line, @Nullable String column, @Nullable String id, String msg){
    if ((id == null) || id.isEmpty()) {
        return false;
    }
    if ((line != null) && !line.isEmpty() && ((filename == null) || filename.isEmpty())) {
        return false;
    }
    return true;
}","protected boolean isInputValid(@Nullable String filename, @Nullable String line, @Nullable String column, @Nullable String id, String msg){
    if ((id == null) || id.isEmpty()) {
        return false;
    }
    if ((line != null) && !line.isEmpty() && ((filename == null) || filename.isEmpty())) {
        return false;
    }
    return true;
}","/**
   * Derived classes can overload this method
   *
   * A valid issue must have an id and, if it has a line number, a filename.
   *
   * @param filename
   * @param line
   * @param column is optional
   * @param id
   * @param msg
   * @return true, if valid
   */","('isInputValid', {'INSTRUCTION': {'covered': 17, 'missed': 4}, 'BRANCH': {'covered': 6, 'missed': 6}, 'LINE': {'covered': 3, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",85.0,"  Derived classes can overload this method   A valid issue must have an id and, if it has a line number, a filename.",25.0,"['Derived classes can overload this method if the issue has an id and a line number.', 'Derived classes can overload this method if the valid issue has an id and a line number.', 'Derived classes can overload this method if there is an id and a line number.']"
509,matsim-libs,org/matsim/core/network/NetworkImpl.java,/matsim/src/main/java/org/matsim/core/network/NetworkImpl.java,addNetworkChangeEvent,299-322,"/**
	 * Adds a single network change event and applies it to the corresponding
	 * links.
	 *
	 * @param event
	 *            a network change event.
	 */
public void addNetworkChangeEvent(final NetworkChangeEvent event){
    this.networkChangeEvents.add(event);
    for (Link link : event.getLinks()) {
        if (link instanceof TimeVariantLinkImpl) {
            ((TimeVariantLinkImpl) link).applyEvent(event);
        } else {
            throw new IllegalArgumentException(""Link "" + link.getId().toString() + "" is not timeVariant. "" + ""Did you make the network factory time variant?  The easiest way to achieve this is "" + ""either in the config file, or syntax of the type\n"" + ""config.network().setTimeVariantNetwork(true);\n"" + ""Scenario scenario = ScenarioUtils.load/createScenario(config);\n"" + ""Note that the scenario needs to be created _after_ the config option is set, otherwise"" + ""the factory will already be there."");
        }
    }
}","public void addNetworkChangeEvent(final NetworkChangeEvent event){
    this.networkChangeEvents.add(event);
    for (Link link : event.getLinks()) {
        if (link instanceof TimeVariantLinkImpl) {
            ((TimeVariantLinkImpl) link).applyEvent(event);
        } else {
            throw new IllegalArgumentException(""Link "" + link.getId().toString() + "" is not timeVariant. "" + ""Did you make the network factory time variant?  The easiest way to achieve this is "" + ""either in the config file, or syntax of the type\n"" + ""config.network().setTimeVariantNetwork(true);\n"" + ""Scenario scenario = ScenarioUtils.load/createScenario(config);\n"" + ""Note that the scenario needs to be created _after_ the config option is set, otherwise"" + ""the factory will already be there."");
        }
    }
}","/**
	 * Adds a single network change event and applies it to the corresponding
	 * links.
	 *
	 * @param event
	 *            a network change event.
	 */","('addNetworkChangeEvent', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",86.0,  Adds a single network change event and applies it to the corresponding  links.,14.0,"['A single network change event is added and applied to the links.', 'A network change event is added and applied to the links.', 'Adds a single network change event and applies it to the links.']"
510,logstash-logback-encoder,net/logstash/logback/composite/GlobalCustomFieldsJsonProvider.java,/src/main/java/net/logstash/logback/composite/GlobalCustomFieldsJsonProvider.java,writeFieldsOfNode,53-64,"/**
     * Writes the fields of the given node into the generator.
     */
private void writeFieldsOfNode(JsonGenerator generator, JsonNode node) throws IOException{
    if (node != null) {
        for (Iterator<Entry<String, JsonNode>> fields = node.fields(); fields.hasNext(); ) {
            Entry<String, JsonNode> field = fields.next();
            generator.writeFieldName(field.getKey());
            generator.writeTree(field.getValue());
        }
    }
}","private void writeFieldsOfNode(JsonGenerator generator, JsonNode node) throws IOException{
    if (node != null) {
        for (Iterator<Entry<String, JsonNode>> fields = node.fields(); fields.hasNext(); ) {
            Entry<String, JsonNode> field = fields.next();
            generator.writeFieldName(field.getKey());
            generator.writeTree(field.getValue());
        }
    }
}","/**
     * Writes the fields of the given node into the generator.
     */","('writeFieldsOfNode', {'INSTRUCTION': {'covered': 24, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",86.0,  Writes the fields of the given node into the generator.,11.0,"['The fields are written into the generator.', 'The fields are written into the generator', 'The fields are written into the generator by the writer.']"
511,dcache,org/dcache/resilience/handlers/FileOperationHandler.java,/modules/dcache-resilience/src/main/java/org/dcache/resilience/handlers/FileOperationHandler.java,handleRemoveOneCopy,507-525,"/**
     * <p>Calls {@link #removeTarget(PnfsId, String)} and then reports
     * success or failure to the completion handler.</p>
     */
public void handleRemoveOneCopy(FileAttributes attributes){
    PnfsId pnfsId = attributes.getPnfsId();
    FileOperation operation = fileOpMap.getOperation(pnfsId);
    try {
        String target = poolInfoMap.getPool(operation.getTarget());
        LOGGER.trace(""handleRemoveOneCopy {}, removing {}."", pnfsId, target);
        removeTarget(pnfsId, target);
    } catch (CacheException e) {
        completionHandler.taskFailed(pnfsId, e);
    }
    completionHandler.taskCompleted(pnfsId);
}","public void handleRemoveOneCopy(FileAttributes attributes){
    PnfsId pnfsId = attributes.getPnfsId();
    FileOperation operation = fileOpMap.getOperation(pnfsId);
    try {
        String target = poolInfoMap.getPool(operation.getTarget());
        LOGGER.trace(""handleRemoveOneCopy {}, removing {}."", pnfsId, target);
        removeTarget(pnfsId, target);
    } catch (CacheException e) {
        completionHandler.taskFailed(pnfsId, e);
    }
    completionHandler.taskCompleted(pnfsId);
}","/**
     * <p>Calls {@link #removeTarget(PnfsId, String)} and then reports
     * success or failure to the completion handler.</p>
     */","('handleRemoveOneCopy', {'INSTRUCTION': {'covered': 29, 'missed': 6}, 'LINE': {'covered': 8, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",86.0,"  <p>Calls {@link #removeTarget(PnfsId, String)} and then reports  success or failure to the completion handler.",26.0,"['Call @link #removeTarget(Pnfs id, String) and report success or failure to the completion handler.', 'Call @link #removeTarget(PnfsId, String) and report success or failure to the completion handler.', 'Call @link #removeTarget(Pnfs id, String) and report failure or success to the completion handler.']"
512,nfe,com/fincatto/documentofiscal/DFUnidadeFederativa.java,/src/main/java/com/fincatto/documentofiscal/DFUnidadeFederativa.java,valueOfCodigo,96-111,"/**
     * Identifica a UF pela sigla ou pelo codigo IBGE.
     *
     * @param codigo Sigla ou codigo IBGE da UF.
     * @return Objeto da UF.
     */
public static DFUnidadeFederativa valueOfCodigo(final String codigo){
    for (final DFUnidadeFederativa uf : DFUnidadeFederativa.values()) {
        if (uf.getCodigo().equalsIgnoreCase(StringUtils.trim(codigo))) {
            return uf;
        } else if (uf.getCodigoIbge().equalsIgnoreCase(StringUtils.trim(codigo))) {
            return uf;
        }
    }
    throw new IllegalArgumentException(String.format(""N\u00e3o existe o c\u00f3digo %s no mapeamento."", codigo));
}","public static DFUnidadeFederativa valueOfCodigo(final String codigo){
    for (final DFUnidadeFederativa uf : DFUnidadeFederativa.values()) {
        if (uf.getCodigo().equalsIgnoreCase(StringUtils.trim(codigo))) {
            return uf;
        } else if (uf.getCodigoIbge().equalsIgnoreCase(StringUtils.trim(codigo))) {
            return uf;
        }
    }
    throw new IllegalArgumentException(String.format(""N\u00e3o existe o c\u00f3digo %s no mapeamento."", codigo));
}","/**
     * Identifica a UF pela sigla ou pelo codigo IBGE.
     *
     * @param codigo Sigla ou codigo IBGE da UF.
     * @return Objeto da UF.
     */","('valueOfCodigo', {'INSTRUCTION': {'covered': 44, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",86.0,  Identifica a UF pela sigla ou pelo codigo IBGE.,10.0,"['A sigla ou pelo codigo IBGE is identical.', 'A sigla ou pelo codigo IBGE is related.', 'A sigla ou pelo codigo IBGE is similar.']"
513,glowstone,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,putList,925-941,"/**
     * Adds or replaces a list subtag, converting the list entries to tags.
     *
     * @param <V> the list elements' Java type
     * @param key the key to write to
     * @param type the list elements' tag type
     * @param value the list contents, as objects to convert to tags
     * @param tagCreator a function that will convert each V to an element tag
     */
public void putList(@NonNls String key, TagType type, List<V> value, Function<? super V, ? extends Tag> tagCreator){
    List<Tag> result = new ArrayList<>(value.size());
    for (V item : value) {
        result.add(tagCreator.apply(item));
    }
    put(key, new ListTag<>(type, result));
}","public void putList(@NonNls String key, TagType type, List<V> value, Function<? super V, ? extends Tag> tagCreator){
    List<Tag> result = new ArrayList<>(value.size());
    for (V item : value) {
        result.add(tagCreator.apply(item));
    }
    put(key, new ListTag<>(type, result));
}","/**
     * Adds or replaces a list subtag, converting the list entries to tags.
     *
     * @param <V> the list elements' Java type
     * @param key the key to write to
     * @param type the list elements' tag type
     * @param value the list contents, as objects to convert to tags
     * @param tagCreator a function that will convert each V to an element tag
     */","('putList', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",86.0,"  Adds or replaces a list subtag, converting the list entries to tags.",14.0,"['The list entries are converted to tags.', 'Adding or replacing a list subtag converts the list entries to tags.', 'Adding or replacing a list subtag converts the entries to tags.']"
515,glowstone,net/glowstone/entity/GlowAnimal.java,/src/main/java/net/glowstone/entity/GlowAnimal.java,tryFeed,53-76,"/**
     * Determines whether this entity can eat an item while healthy, and if so, applies the effects
     * of eating it.
     *
     * @param player the player feeding the entity, for statistical purposes
     * @param type an item that may be food
     * @return true if the item should be consumed; false otherwise
     */
protected boolean tryFeed(Material type, GlowPlayer player){
    if (!getBreedingFoods().contains(type)) {
        return false;
    }
    if (canBreed() && getInLove() <= 0) {
        // TODO get the correct duration
        setInLove(1000);
        player.incrementStatistic(Statistic.ANIMALS_BRED);
        return true;
    }
    int growth = computeGrowthAmount(type);
    if (growth > 0) {
        grow(growth);
        return true;
    }
    return false;
}","protected boolean tryFeed(Material type, GlowPlayer player){
    if (!getBreedingFoods().contains(type)) {
        return false;
    }
    if (canBreed() && getInLove() <= 0) {
        // TODO get the correct duration
        setInLove(1000);
        player.incrementStatistic(Statistic.ANIMALS_BRED);
        return true;
    }
    int growth = computeGrowthAmount(type);
    if (growth > 0) {
        grow(growth);
        return true;
    }
    return false;
}","/**
     * Determines whether this entity can eat an item while healthy, and if so, applies the effects
     * of eating it.
     *
     * @param player the player feeding the entity, for statistical purposes
     * @param type an item that may be food
     * @return true if the item should be consumed; false otherwise
     */","('tryFeed', {'INSTRUCTION': {'covered': 29, 'missed': 5}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 2}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,"  Determines whether this entity can eat an item while healthy, and if so, applies the effects  of eating it.",22.0,"['Determines if this entity can eat a healthy item and apply the effects to it.', ""If this entity can eat an item while healthy and apply the effects of eating it, then it's a good thing."", 'Determines if this entity can eat a healthy item and apply the effects of eating it.']"
516,cdk,org/openscience/cdk/signature/MoleculeSignature.java,/descriptor/signature/src/main/java/org/openscience/cdk/signature/MoleculeSignature.java,calculateOrbits,153-169,"/**
     * Calculates the orbits of the atoms of the molecule.
     *
     * @return a list of orbits
     */
public List<Orbit> calculateOrbits(){
    List<Orbit> orbits = new ArrayList<Orbit>();
    List<SymmetryClass> symmetryClasses = super.getSymmetryClasses();
    for (SymmetryClass symmetryClass : symmetryClasses) {
        Orbit orbit = new Orbit(symmetryClass.getSignatureString(), -1);
        for (int atomIndex : symmetryClass) {
            orbit.addAtom(atomIndex);
        }
        orbits.add(orbit);
    }
    return orbits;
}","public List<Orbit> calculateOrbits(){
    List<Orbit> orbits = new ArrayList<Orbit>();
    List<SymmetryClass> symmetryClasses = super.getSymmetryClasses();
    for (SymmetryClass symmetryClass : symmetryClasses) {
        Orbit orbit = new Orbit(symmetryClass.getSignatureString(), -1);
        for (int atomIndex : symmetryClass) {
            orbit.addAtom(atomIndex);
        }
        orbits.add(orbit);
    }
    return orbits;
}","/**
     * Calculates the orbits of the atoms of the molecule.
     *
     * @return a list of orbits
     */","('calculateOrbits', {'INSTRUCTION': {'covered': 46, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,  Calculates the orbits of the atoms of the molecule.,10.0,"['The atoms of the molecule are calculated.', ""The molecule's atoms are calculated."", 'The atoms of the molecule have their orbits calculated.']"
517,cucumber-reporting,net/masterthought/cucumber/reducers/ElementComparator.java,/src/main/java/net/masterthought/cucumber/reducers/ElementComparator.java,compare,14-32,"/**
     * @return comparison result of Ids or line numbers if elements have the same type
     * or -1 if type of elements is different.
     */
public int compare(Element element1, Element element2){
    if (hasSameType(element1, element2)) {
        if (element1.isScenario()) {
            return Comparator.nullsFirst(String::compareToIgnoreCase).compare(element1.getId(), element2.getId());
        }
        /*
             * Compares non-scenario elements, like Background.
             */
        return Comparator.nullsFirst(Integer::compare).compare(element1.getLine(), element2.getLine());
    }
    return -1;
}","public int compare(Element element1, Element element2){
    if (hasSameType(element1, element2)) {
        if (element1.isScenario()) {
            return Comparator.nullsFirst(String::compareToIgnoreCase).compare(element1.getId(), element2.getId());
        }
        /*
             * Compares non-scenario elements, like Background.
             */
        return Comparator.nullsFirst(Integer::compare).compare(element1.getLine(), element2.getLine());
    }
    return -1;
}","/**
     * @return comparison result of Ids or line numbers if elements have the same type
     * or -1 if type of elements is different.
     */","('compare', {'INSTRUCTION': {'covered': 26, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,@return comparison result of Ids or line numbers if elements have the same type  or -1 if type of elements is different.,24.0,"['If elements have the same type or different types, return a comparison result of Ids or line numbers.', 'If the elements have the same type or different type, return a comparison result of Ids or line numbers.', 'If elements have the same type or different types, return a comparison result.']"
518,dcache,org/dcache/services/info/base/StatePath.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StatePath.java,equalsOrHasChild,181-227,"/**
     * Check whether otherPath points to the same location, or is a child of this path.  This is
     * true iff each element of this path is identical to the corresponding element in otherPath.
     * <pre>
     *  StatePath p1 = new StatePath(""foo.bar"");
     *  StatePath p2 = new StatePath(""foo.bar.baz"");
     *
     *  p1.equalsOrHasChild(p1) // true
     *  p2.equalsOrHasChild(p2) // true
     *  p1.equalsOrHasChild(p2) // true
     *  p2.equalsOrHasChild(p1) // false
     * </pre>
     *
     * @param otherPath the potential child path
     * @return true if otherPath is a child of this path.
     */
public boolean equalsOrHasChild(StatePath otherPath){
    if (otherPath == null) {
        return false;
    }
    if (_elements.size() > otherPath._elements.size()) {
        return false;
    }
    for (int i = 0; i < _elements.size(); i++) {
        if (_elements.get(i) != otherPath._elements.get(i)) {
            return false;
        }
    }
    return true;
}","public boolean equalsOrHasChild(StatePath otherPath){
    if (otherPath == null) {
        return false;
    }
    if (_elements.size() > otherPath._elements.size()) {
        return false;
    }
    for (int i = 0; i < _elements.size(); i++) {
        if (_elements.get(i) != otherPath._elements.get(i)) {
            return false;
        }
    }
    return true;
}","/**
     * Check whether otherPath points to the same location, or is a child of this path.  This is
     * true iff each element of this path is identical to the corresponding element in otherPath.
     * <pre>
     *  StatePath p1 = new StatePath(""foo.bar"");
     *  StatePath p2 = new StatePath(""foo.bar.baz"");
     *
     *  p1.equalsOrHasChild(p1) // true
     *  p2.equalsOrHasChild(p2) // true
     *  p1.equalsOrHasChild(p2) // true
     *  p2.equalsOrHasChild(p1) // false
     * </pre>
     *
     * @param otherPath the potential child path
     * @return true if otherPath is a child of this path.
     */","('equalsOrHasChild', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,"  Check whether otherPath points to the same location, or is a child of this path.",17.0,"[""If otherpath points to the same location, it's a child of this path."", 'Check to see if otherpath points to the same location or if it is a child of this path.', 'Check if otherpath points to the same location or if it is a child of this path.']"
519,dataverse,edu/harvard/iq/dataverse/FileMetadata.java,/src/main/java/edu/harvard/iq/dataverse/FileMetadata.java,createCopy,115-132,"/**
     * Creates a copy of {@code this}, with identical business logic fields.
     * E.g., {@link #label} would be duplicated; {@link #version} will not.
     * 
     * @return A copy of {@code this}, except for the DB-related data.
     */
public FileMetadata createCopy(){
    FileMetadata fmd = new FileMetadata();
    fmd.setCategories(new LinkedList<>(getCategories()));
    fmd.setDataFile(getDataFile());
    fmd.setDatasetVersion(getDatasetVersion());
    fmd.setDescription(getDescription());
    fmd.setLabel(getLabel());
    fmd.setRestricted(isRestricted());
    fmd.setDirectoryLabel(getDirectoryLabel());
    return fmd;
}","public FileMetadata createCopy(){
    FileMetadata fmd = new FileMetadata();
    fmd.setCategories(new LinkedList<>(getCategories()));
    fmd.setDataFile(getDataFile());
    fmd.setDatasetVersion(getDatasetVersion());
    fmd.setDescription(getDescription());
    fmd.setLabel(getLabel());
    fmd.setRestricted(isRestricted());
    fmd.setDirectoryLabel(getDirectoryLabel());
    return fmd;
}","/**
     * Creates a copy of {@code this}, with identical business logic fields.
     * E.g., {@link #label} would be duplicated; {@link #version} will not.
     * 
     * @return A copy of {@code this}, except for the DB-related data.
     */","('createCopy', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,"  Creates a copy of {@code this}, with identical business logic fields.",16.0,"['A copy of @code this is created.', 'A copy of @code this is created with the same business logic fields.', 'A copy of @code this is created with identical business logic fields.']"
520,tablesaw,tech/tablesaw/api/TimeColumn.java,/core/src/main/java/tech/tablesaw/api/TimeColumn.java,top,495-510,"/**
   * Returns the largest (""top"") n values in the column. Does not change the order in this column
   *
   * @param n The maximum number of records to return. The actual number will be smaller if n is
   *     greater than the number of observations in the column
   * @return A list, possibly empty, of the largest observations
   */
public List<LocalTime> top(int n){
    List<LocalTime> top = new ArrayList<>();
    int[] values = data.toIntArray();
    IntArrays.parallelQuickSort(values, IntComparators.OPPOSITE_COMPARATOR);
    for (int i = 0; i < n && i < values.length; i++) {
        top.add(PackedLocalTime.asLocalTime(values[i]));
    }
    return top;
}","public List<LocalTime> top(int n){
    List<LocalTime> top = new ArrayList<>();
    int[] values = data.toIntArray();
    IntArrays.parallelQuickSort(values, IntComparators.OPPOSITE_COMPARATOR);
    for (int i = 0; i < n && i < values.length; i++) {
        top.add(PackedLocalTime.asLocalTime(values[i]));
    }
    return top;
}","/**
   * Returns the largest (""top"") n values in the column. Does not change the order in this column
   *
   * @param n The maximum number of records to return. The actual number will be smaller if n is
   *     greater than the number of observations in the column
   * @return A list, possibly empty, of the largest observations
   */","('top', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,"  Returns the largest (""top"") n values in the column.",14.0,"['The largest values are in the column.', 'The largest value is returned in the column.', 'The largest n values are returned.']"
521,cdk,org/openscience/cdk/tools/ProteinBuilderTool.java,/storage/pdb/src/main/java/org/openscience/cdk/tools/ProteinBuilderTool.java,addAminoAcidAtCTerminus,74-96,"/**
     * Builds a protein by connecting a new amino acid at the C-terminus of the
     * given strand. The acidic oxygen of the added amino acid is removed so that
     * additional amino acids can be added savely. But this also means that you
     * might want to add an oxygen at the end of the protein building!
     *
     * @param protein protein to which the strand belongs
     * @param aaToAdd amino acid to add to the strand of the protein
     * @param strand  strand to which the protein is added
     */
public static IBioPolymer addAminoAcidAtCTerminus(IBioPolymer protein, IAminoAcid aaToAdd, IStrand strand, IAminoAcid aaToAddTo){
    addAminoAcid(protein, aaToAdd, strand);
    if ((protein.getMonomerCount() != 0) && (aaToAddTo != null)) {
        protein.addBond(aaToAdd.getBuilder().newInstance(IBond.class, aaToAddTo.getCTerminus(), aaToAdd.getNTerminus(), IBond.Order.SINGLE));
    }
    return protein;
}","public static IBioPolymer addAminoAcidAtCTerminus(IBioPolymer protein, IAminoAcid aaToAdd, IStrand strand, IAminoAcid aaToAddTo){
    addAminoAcid(protein, aaToAdd, strand);
    if ((protein.getMonomerCount() != 0) && (aaToAddTo != null)) {
        protein.addBond(aaToAdd.getBuilder().newInstance(IBond.class, aaToAddTo.getCTerminus(), aaToAdd.getNTerminus(), IBond.Order.SINGLE));
    }
    return protein;
}","/**
     * Builds a protein by connecting a new amino acid at the C-terminus of the
     * given strand. The acidic oxygen of the added amino acid is removed so that
     * additional amino acids can be added savely. But this also means that you
     * might want to add an oxygen at the end of the protein building!
     *
     * @param protein protein to which the strand belongs
     * @param aaToAdd amino acid to add to the strand of the protein
     * @param strand  strand to which the protein is added
     */","('addAminoAcidAtCTerminus', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,  Builds a protein by connecting a new amino acid at the C-terminus of the  given strand.,17.0,"['The C-terminus of the given strand is connected by a new amino acid.', 'The C-terminus of the given strand is connected with a new amino acid.', 'The C-terminus of a strand is connected with a new amino acid.']"
522,cdk,org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,insert,427-445,"/**
     * Insert a string (str) into the trie.
     *
     * @param trie trie node
     * @param str  the string to insert
     * @param i    index in the string
     * @return a created child node or null
     */
private static Trie insert(Trie trie, String str, int i){
    if (trie == null)
        trie = new Trie();
    if (i == str.length()) {
        trie.token = str;
    } else {
        final char c = str.charAt(i);
        trie.children[c] = insert(trie.children[c], str, i + 1);
    }
    return trie;
}","private static Trie insert(Trie trie, String str, int i){
    if (trie == null)
        trie = new Trie();
    if (i == str.length()) {
        trie.token = str;
    } else {
        final char c = str.charAt(i);
        trie.children[c] = insert(trie.children[c], str, i + 1);
    }
    return trie;
}","/**
     * Insert a string (str) into the trie.
     *
     * @param trie trie node
     * @param str  the string to insert
     * @param i    index in the string
     * @return a created child node or null
     */","('insert', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,  Insert a string (str) into the trie.,10.0,"['There is a string in the trie.', 'The trie has a string in it.', 'The trie has a string.']"
523,acs-aem-commons,com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,aggregateChecksums,376-391,"/**
     * Aggregates a set of checksum entries into a single checksum value.
     * @param checksums the checksums
     * @return the checksum value
     */
protected String aggregateChecksums(final Map<String, String> checksums){
    if (checksums.isEmpty()) {
        return null;
    }
    StringBuilder data = new StringBuilder();
    for (Map.Entry<String, String> entry : checksums.entrySet()) {
        data.append(entry.getKey() + ""="" + entry.getValue());
    }
    return DigestUtils.sha1Hex(data.toString());
}","protected String aggregateChecksums(final Map<String, String> checksums){
    if (checksums.isEmpty()) {
        return null;
    }
    StringBuilder data = new StringBuilder();
    for (Map.Entry<String, String> entry : checksums.entrySet()) {
        data.append(entry.getKey() + ""="" + entry.getValue());
    }
    return DigestUtils.sha1Hex(data.toString());
}","/**
     * Aggregates a set of checksum entries into a single checksum value.
     * @param checksums the checksums
     * @return the checksum value
     */","('aggregateChecksums', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",87.0,  Aggregates a set of checksum entries into a single checksum value.,12.0,"['A set of entries are aggregated into a single value.', 'A set of entries are Aggregated into a single value.', 'A set of entries are Aggregated.']"
524,matsim-libs,org/matsim/contrib/drt/optimizer/insertion/InsertionCostCalculator.java,/contribs/drt/src/main/java/org/matsim/contrib/drt/optimizer/insertion/InsertionCostCalculator.java,calculate,87-111,"/**
	 * As the main goal is to minimise bus operation time, this method calculates how much longer the bus will operate
	 * after insertion. By returning INFEASIBLE_SOLUTION_COST, the insertion is considered infeasible
	 * <p>
	 * The insertion is invalid if some maxTravel/Wait constraints for the already scheduled requests are not fulfilled.
	 * This is denoted by returning INFEASIBLE_SOLUTION_COST.
	 * <p>
	 *
	 * @param drtRequest the request
	 * @param insertion  the insertion to be considered here
	 * @return cost of insertion (INFEASIBLE_SOLUTION_COST represents an infeasible insertion)
	 */
public double calculate(DrtRequest drtRequest, InsertionWithDetourData<D> insertion){
    // TODO precompute time slacks for each stop to filter out even more infeasible insertions ???????????
    var detourTimeInfo = detourTimeCalculator.calculateDetourTimeInfo(insertion);
    if (!checkTimeConstraintsForScheduledRequests(insertion.getInsertion(), detourTimeInfo.pickupTimeLoss, detourTimeInfo.getTotalTimeLoss())) {
        return INFEASIBLE_SOLUTION_COST;
    }
    double vehicleSlackTime = calcVehicleSlackTime(insertion.getVehicleEntry(), timeOfDay.getAsDouble());
    return costCalculationStrategy.calcCost(drtRequest, insertion.getInsertion(), vehicleSlackTime, detourTimeInfo);
}","public double calculate(DrtRequest drtRequest, InsertionWithDetourData<D> insertion){
    // TODO precompute time slacks for each stop to filter out even more infeasible insertions ???????????
    var detourTimeInfo = detourTimeCalculator.calculateDetourTimeInfo(insertion);
    if (!checkTimeConstraintsForScheduledRequests(insertion.getInsertion(), detourTimeInfo.pickupTimeLoss, detourTimeInfo.getTotalTimeLoss())) {
        return INFEASIBLE_SOLUTION_COST;
    }
    double vehicleSlackTime = calcVehicleSlackTime(insertion.getVehicleEntry(), timeOfDay.getAsDouble());
    return costCalculationStrategy.calcCost(drtRequest, insertion.getInsertion(), vehicleSlackTime, detourTimeInfo);
}","/**
	 * As the main goal is to minimise bus operation time, this method calculates how much longer the bus will operate
	 * after insertion. By returning INFEASIBLE_SOLUTION_COST, the insertion is considered infeasible
	 * <p>
	 * The insertion is invalid if some maxTravel/Wait constraints for the already scheduled requests are not fulfilled.
	 * This is denoted by returning INFEASIBLE_SOLUTION_COST.
	 * <p>
	 *
	 * @param drtRequest the request
	 * @param insertion  the insertion to be considered here
	 * @return cost of insertion (INFEASIBLE_SOLUTION_COST represents an infeasible insertion)
	 */","('calculate', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,"  As the main goal is to minimise bus operation time, this method calculates how much longer the bus will operate  after insertion.",24.0,"['The main goal is to reduce bus operation time.', 'This method calculates how long the bus will operate after it is inserted.', 'The main goal is to reduce bus operation time, so this method calculates how much longer the bus will operate.']"
525,dcache,org/dcache/resilience/handlers/ResilienceMessageHandler.java,/modules/dcache-resilience/src/main/java/org/dcache/resilience/handlers/ResilienceMessageHandler.java,handleInternalMessage,103-124,"/**
     * <p>Pool status changes are detected internally during the
     * comparison of pool monitor states.  The change is rerouted here as a loopback to conform with
     * the way external file updates are handled.</p>
     *
     * <p>Pools that have not yet been fully initialized are skipped.</p>
     */
public void handleInternalMessage(PoolStateUpdate update){
    if (!messageGuard.isEnabled()) {
        LOGGER.trace(""Ignoring pool state update "" + ""because message guard is disabled."");
        return;
    }
    updateService.submit(() -> {
        poolInfoMap.updatePoolStatus(update);
        if (poolInfoMap.isInitialized(update.pool)) {
            counters.incrementMessage(update.getStatus().getMessageType().name());
            poolOperationHandler.handlePoolStatusChange(update);
        }
    });
}","public void handleInternalMessage(PoolStateUpdate update){
    if (!messageGuard.isEnabled()) {
        LOGGER.trace(""Ignoring pool state update "" + ""because message guard is disabled."");
        return;
    }
    updateService.submit(() -> {
        poolInfoMap.updatePoolStatus(update);
        if (poolInfoMap.isInitialized(update.pool)) {
            counters.incrementMessage(update.getStatus().getMessageType().name());
            poolOperationHandler.handlePoolStatusChange(update);
        }
    });
}","/**
     * <p>Pool status changes are detected internally during the
     * comparison of pool monitor states.  The change is rerouted here as a loopback to conform with
     * the way external file updates are handled.</p>
     *
     * <p>Pools that have not yet been fully initialized are skipped.</p>
     */","('handleInternalMessage', {'INSTRUCTION': {'covered': 12, 'missed': 4}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,  <p>Pool status changes are detected internally during the  comparison of pool monitor states.,17.0,"['During the comparison of pool monitor states, pool status changes are detected.', 'During the comparison of pool monitor states, pool status changes can be detected.', 'During the comparison of pool monitor states, pool status changes are detected internally.']"
526,matsim-libs,org/matsim/core/router/TripRouter.java,/matsim/src/main/java/org/matsim/core/router/TripRouter.java,calcEndOfPlanElement,202-224,"/**
	 * Helper method, that can be used to compute start time of legs.
	 * (it is also used internally).
	 * It is provided here, because such an operation is mainly useful for routing,
	 * but it may be externalized in a ""util"" class...
	 * @param config TODO
	 */
public static double calcEndOfPlanElement(final double now, final PlanElement pe, Config config){
    Preconditions.checkArgument(Double.isFinite(now));
    if (pe instanceof Activity) {
        Activity act = (Activity) pe;
        return PopulationUtils.decideOnActivityEndTime(act, now, config).seconds();
    } else {
        double ttime = PopulationUtils.decideOnTravelTimeForLeg((Leg) pe).orElse(0);
        return now + ttime;
    }
}","public static double calcEndOfPlanElement(final double now, final PlanElement pe, Config config){
    Preconditions.checkArgument(Double.isFinite(now));
    if (pe instanceof Activity) {
        Activity act = (Activity) pe;
        return PopulationUtils.decideOnActivityEndTime(act, now, config).seconds();
    } else {
        double ttime = PopulationUtils.decideOnTravelTimeForLeg((Leg) pe).orElse(0);
        return now + ttime;
    }
}","/**
	 * Helper method, that can be used to compute start time of legs.
	 * (it is also used internally).
	 * It is provided here, because such an operation is mainly useful for routing,
	 * but it may be externalized in a ""util"" class...
	 * @param config TODO
	 */","('calcEndOfPlanElement', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,"  Helper method, that can be used to compute start time of legs.",14.0,"['The method can be used to calculate the start time of legs.', 'The method can be used to calculate start time of legs.', 'The method can be used to calculate start time.']"
527,cdk,org/openscience/cdk/libio/jena/Convertor.java,/storage/iordf/src/main/java/org/openscience/cdk/libio/jena/Convertor.java,resource2Order,253-270,"/**
     * Converts a {@link Resource} object into the matching {@link Order}.
     *
     * @param rdfOrder Resource for which the matching {@link Order} should be given.
     * @return the matching {@link Order}.
     */
public static Order resource2Order(Resource rdfOrder){
    if (rdfOrder.equals(CDK.SINGLEBOND)) {
        return Order.SINGLE;
    } else if (rdfOrder.equals(CDK.DOUBLEBOND)) {
        return Order.DOUBLE;
    } else if (rdfOrder.equals(CDK.TRIPLEBOND)) {
        return Order.TRIPLE;
    } else if (rdfOrder.equals(CDK.QUADRUPLEBOND)) {
        return Order.QUADRUPLE;
    }
    return null;
}","public static Order resource2Order(Resource rdfOrder){
    if (rdfOrder.equals(CDK.SINGLEBOND)) {
        return Order.SINGLE;
    } else if (rdfOrder.equals(CDK.DOUBLEBOND)) {
        return Order.DOUBLE;
    } else if (rdfOrder.equals(CDK.TRIPLEBOND)) {
        return Order.TRIPLE;
    } else if (rdfOrder.equals(CDK.QUADRUPLEBOND)) {
        return Order.QUADRUPLE;
    }
    return null;
}","/**
     * Converts a {@link Resource} object into the matching {@link Order}.
     *
     * @param rdfOrder Resource for which the matching {@link Order} should be given.
     * @return the matching {@link Order}.
     */","('resource2Order', {'INSTRUCTION': {'covered': 24, 'missed': 2}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,  Converts a {@link Resource} object into the matching {@link Order}.,17.0,"['The @link Resource object is converted into the matching @link Order.', 'A @link Resource object is converted into a @link Order.', 'A @link Resource object is converted into a matching @link Order.']"
528,cdk,org/openscience/cdk/layout/AtomPlacer.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/AtomPlacer.java,partitionPartners,542-561,"/**
     *  Partition the bonding partners of a given atom into placed (coordinates
     *  assinged) and not placed.
     *
     *@param  atom              The atom whose bonding partners are to be
     *      partitioned
     *@param  unplacedPartners  A vector for the unplaced bonding partners to go in
     *@param  placedPartners    A vector for the placed bonding partners to go in
     */
public void partitionPartners(IAtom atom, IAtomContainer unplacedPartners, IAtomContainer placedPartners){
    List atoms = molecule.getConnectedAtomsList(atom);
    for (int i = 0; i < atoms.size(); i++) {
        IAtom curatom = (IAtom) atoms.get(i);
        if (curatom.getFlag(CDKConstants.ISPLACED)) {
            placedPartners.addAtom(curatom);
        } else {
            unplacedPartners.addAtom(curatom);
        }
    }
}","public void partitionPartners(IAtom atom, IAtomContainer unplacedPartners, IAtomContainer placedPartners){
    List atoms = molecule.getConnectedAtomsList(atom);
    for (int i = 0; i < atoms.size(); i++) {
        IAtom curatom = (IAtom) atoms.get(i);
        if (curatom.getFlag(CDKConstants.ISPLACED)) {
            placedPartners.addAtom(curatom);
        } else {
            unplacedPartners.addAtom(curatom);
        }
    }
}","/**
     *  Partition the bonding partners of a given atom into placed (coordinates
     *  assinged) and not placed.
     *
     *@param  atom              The atom whose bonding partners are to be
     *      partitioned
     *@param  unplacedPartners  A vector for the unplaced bonding partners to go in
     *@param  placedPartners    A vector for the placed bonding partners to go in
     */","('partitionPartners', {'INSTRUCTION': {'covered': 30, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,  Partition the bonding partners of a given atom into placed (coordinates  assinged) and not placed.,18.0,"['The bonding partners of a given atom can be placed or not placed.', 'The bonding partners of a given atom should be placed and not placed.', 'The bonding partners of a given atom should be separated.']"
529,egeria,org/odpi/openmetadata/accessservices/digitalservice/properties/DigitalService.java,/open-metadata-implementation/access-services/digital-service/digital-service-api/src/main/java/org/odpi/openmetadata/accessservices/digitalservice/properties/DigitalService.java,equals,141-161,"/**
     * {@inheritDoc}
     *
     * Return comparison result based on the content of the properties.
     */
public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (!(objectToCompare instanceof DigitalService)) {
        return false;
    }
    DigitalService asset = (DigitalService) objectToCompare;
    return Objects.equals(getVersion(), asset.getVersion()) && Objects.equals(getDisplayName(), asset.getDisplayName()) && Objects.equals(getDescription(), asset.getDescription());
}","public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (!(objectToCompare instanceof DigitalService)) {
        return false;
    }
    DigitalService asset = (DigitalService) objectToCompare;
    return Objects.equals(getVersion(), asset.getVersion()) && Objects.equals(getDisplayName(), asset.getDisplayName()) && Objects.equals(getDescription(), asset.getDescription());
}","/**
     * {@inheritDoc}
     *
     * Return comparison result based on the content of the properties.
     */","('equals', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,  {@inheritDoc}   Return comparison result based on the content of the properties.,15.0,"['The return result is based on the content of the properties.', 'The result is based on the content of the properties.', 'Return comparison result is based on the content of the properties.']"
530,soul,org/apache/shenyu/admin/listener/AbstractDataChangedListener.java,/shenyu-admin/src/main/java/org/apache/shenyu/admin/listener/AbstractDataChangedListener.java,updateCache,225-236,"/**
     * if md5 is not the same as the original, then update lcoal cache.
     * @param group ConfigGroupEnum
     * @param <T> the type of class
     * @param data the new config data
     */
protected void updateCache(final ConfigGroupEnum group, final List<T> data){
    String json = GsonUtils.getInstance().toJson(data);
    ConfigDataCache newVal = new ConfigDataCache(group.name(), json, Md5Utils.md5(json), System.currentTimeMillis());
    ConfigDataCache oldVal = CACHE.put(newVal.getGroup(), newVal);
    LOG.info(""update config cache[{}], old: {}, updated: {}"", group, oldVal, newVal);
}","protected void updateCache(final ConfigGroupEnum group, final List<T> data){
    String json = GsonUtils.getInstance().toJson(data);
    ConfigDataCache newVal = new ConfigDataCache(group.name(), json, Md5Utils.md5(json), System.currentTimeMillis());
    ConfigDataCache oldVal = CACHE.put(newVal.getGroup(), newVal);
    LOG.info(""update config cache[{}], old: {}, updated: {}"", group, oldVal, newVal);
}","/**
     * if md5 is not the same as the original, then update lcoal cache.
     * @param group ConfigGroupEnum
     * @param <T> the type of class
     * @param data the new config data
     */","('updateCache', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",88.0,"if md5 is not the same as the original, then update lcoal cache.",15.0,"['Update lcoal cache if md5 is not the same as the original.', 'If md5 is not the same as the original, then update lcoal cache.', 'If md5 is not the same as the original, then you should update lcoal cache.']"
532,tablesaw,tech/tablesaw/io/Source.java,/core/src/main/java/tech/tablesaw/io/Source.java,createReader,86-103,"/**
   * If cachedBytes are not null, returns a Reader created from the cachedBytes. Otherwise, returns
   * a Reader from the underlying source.
   */
public Reader createReader(byte[] cachedBytes) throws IOException{
    if (cachedBytes != null) {
        return charset != null ? new InputStreamReader(new ByteArrayInputStream(cachedBytes), charset) : new InputStreamReader(new ByteArrayInputStream(cachedBytes));
    }
    if (inputStream != null) {
        return new InputStreamReader(inputStream, charset);
    }
    if (reader != null) {
        return reader;
    }
    return new InputStreamReader(new FileInputStream(file), charset);
}","public Reader createReader(byte[] cachedBytes) throws IOException{
    if (cachedBytes != null) {
        return charset != null ? new InputStreamReader(new ByteArrayInputStream(cachedBytes), charset) : new InputStreamReader(new ByteArrayInputStream(cachedBytes));
    }
    if (inputStream != null) {
        return new InputStreamReader(inputStream, charset);
    }
    if (reader != null) {
        return reader;
    }
    return new InputStreamReader(new FileInputStream(file), charset);
}","/**
   * If cachedBytes are not null, returns a Reader created from the cachedBytes. Otherwise, returns
   * a Reader from the underlying source.
   */","('createReader', {'INSTRUCTION': {'covered': 51, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",89.0,"  If cachedBytes are not null, returns a Reader created from the cachedBytes.",14.0,"['A Reader is created from the cachedBytes if they are not null.', 'The Reader is created from the cachedBytes if they are not null.', 'If theBytes are not null, a Reader is created from them.']"
533,cdk,org/openscience/cdk/formula/MolecularFormulaGenerator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/MolecularFormulaGenerator.java,isIllPosed,79-114,"/**
     * Decides wheter to use the round robin algorithm or full enumeration algorithm.
     * The round robin implementation here is optimized for chemical elements in organic compounds. It gets slow
     * if
     * - the mass of the smallest element is very large (i.e. hydrogen is not allowed)
     * - the maximal mass to decompose is too large (round robin always decomposes integers. Therefore, the mass have
     *   to be small enough to be represented as 32 bit integer)
     * - the number of elements in the set is extremely small (in this case, however, the problem becomes trivial anyways)
     *
     * In theory we could handle these problems by optimizing the way DECOMP discretizes the masses. However, it's easier
     * to just fall back to the full enumeration method if a problem occurs (especially, because most of the problems
     * lead to trivial cases that are fast to compute).
     *
     * @return true if the problem is ill-posed (i.e. should be calculated by full enumeration method)
     */
private static boolean isIllPosed(double minMass, double maxMass, MolecularFormulaRange mfRange){
    // when the number of integers to decompose is incredible large
    // we have to adjust the internal settings (e.g. precision!)
    // instead we simply fallback to the full enumeration method
    if (maxMass - minMass >= 1)
        return true;
    if (maxMass > 400000)
        return true;
    // if the number of elements to decompose is very small
    // we fall back to the full enumeration methods as the
    // minimal decomposable mass of a certain residue class might
    // exceed the 32 bit integer space
    if (mfRange.getIsotopeCount() <= 2)
        return true;
    // if the mass of the smallest element in alphabet is large
    // it is more efficient to use the full enumeration method
    double smallestMass = Double.POSITIVE_INFINITY;
    for (IIsotope i : mfRange.isotopes()) {
        smallestMass = Math.min(smallestMass, i.getExactMass());
    }
    return smallestMass > 5;
}","private static boolean isIllPosed(double minMass, double maxMass, MolecularFormulaRange mfRange){
    // when the number of integers to decompose is incredible large
    // we have to adjust the internal settings (e.g. precision!)
    // instead we simply fallback to the full enumeration method
    if (maxMass - minMass >= 1)
        return true;
    if (maxMass > 400000)
        return true;
    // if the number of elements to decompose is very small
    // we fall back to the full enumeration methods as the
    // minimal decomposable mass of a certain residue class might
    // exceed the 32 bit integer space
    if (mfRange.getIsotopeCount() <= 2)
        return true;
    // if the mass of the smallest element in alphabet is large
    // it is more efficient to use the full enumeration method
    double smallestMass = Double.POSITIVE_INFINITY;
    for (IIsotope i : mfRange.isotopes()) {
        smallestMass = Math.min(smallestMass, i.getExactMass());
    }
    return smallestMass > 5;
}","/**
     * Decides wheter to use the round robin algorithm or full enumeration algorithm.
     * The round robin implementation here is optimized for chemical elements in organic compounds. It gets slow
     * if
     * - the mass of the smallest element is very large (i.e. hydrogen is not allowed)
     * - the maximal mass to decompose is too large (round robin always decomposes integers. Therefore, the mass have
     *   to be small enough to be represented as 32 bit integer)
     * - the number of elements in the set is extremely small (in this case, however, the problem becomes trivial anyways)
     *
     * In theory we could handle these problems by optimizing the way DECOMP discretizes the masses. However, it's easier
     * to just fall back to the full enumeration method if a problem occurs (especially, because most of the problems
     * lead to trivial cases that are fast to compute).
     *
     * @return true if the problem is ill-posed (i.e. should be calculated by full enumeration method)
     */","('isIllPosed', {'INSTRUCTION': {'covered': 46, 'missed': 2}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",89.0,  Decides wheter to use the round robin algorithm or full enumeration algorithm.,13.0,"['The wheter decided to use either the round robin or full enumeration algorithm.', 'The wheter decided to use either the full enumeration or the round robin algorithm.', 'The wheter decided to use either the full enumeration or the round Robin algorithm.']"
535,matsim-libs,org/matsim/core/utils/charts/XYScatterChart.java,/matsim/src/main/java/org/matsim/core/utils/charts/XYScatterChart.java,addSeries,80-98,"/**
	 * Adds a new data series to the chart with the specified title.
	 * <code>xs<code> and <code>ys</code> should have the same length. If not,
	 * only as many items are shown as the shorter array contains.
	 * 
	 * @param title
	 * @param xs
	 *            The x values.
	 * @param ys
	 *            The y values.
	 */
public void addSeries(final String title, final double[] xs, final double[] ys){
    XYSeries series = new XYSeries(title, false, true);
    for (int i = 0, n = Math.min(xs.length, ys.length); i < n; i++) {
        series.add(xs[i], ys[i]);
    }
    this.dataset.addSeries(series);
}","public void addSeries(final String title, final double[] xs, final double[] ys){
    XYSeries series = new XYSeries(title, false, true);
    for (int i = 0, n = Math.min(xs.length, ys.length); i < n; i++) {
        series.add(xs[i], ys[i]);
    }
    this.dataset.addSeries(series);
}","/**
	 * Adds a new data series to the chart with the specified title.
	 * <code>xs<code> and <code>ys</code> should have the same length. If not,
	 * only as many items are shown as the shorter array contains.
	 * 
	 * @param title
	 * @param xs
	 *            The x values.
	 * @param ys
	 *            The y values.
	 */","('addSeries', {'INSTRUCTION': {'covered': 33, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",90.0,  Adds a new data series to the chart with the specified title.,13.0,"['A new data series is added to the chart.', 'There is a new data series added to the chart.', 'A new data series is added to the chart with the title.']"
536,cdk,org/openscience/cdk/qsar/descriptors/molecular/RotatableBondsCountDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/RotatableBondsCountDescriptor.java,isAmide,192-215,"/**
     * Checks whether both atoms are involved in an amide C-N bond: *N(*)C(*)=O.
     *
     * Only the most common constitution is considered. Tautomeric, O\C(*)=N\*,
     * and charged forms, [O-]\C(*)=N\*, are ignored.
     *
     * @param atom0 the first bonding partner
     * @param atom1 the second bonding partner
     * @param ac the parent container
     *
     * @return if both partners are involved in an amide C-N bond
     */
private boolean isAmide(IAtom atom0, IAtom atom1, IAtomContainer ac){
    if (atom0.getAtomicNumber() == IElement.C && atom1.getAtomicNumber() == IElement.N) {
        for (IAtom neighbor : ac.getConnectedAtomsList(atom0)) {
            if (neighbor.getAtomicNumber() == IElement.O && ac.getBond(atom0, neighbor).getOrder() == Order.DOUBLE) {
                return true;
            }
        }
    }
    return false;
}","private boolean isAmide(IAtom atom0, IAtom atom1, IAtomContainer ac){
    if (atom0.getAtomicNumber() == IElement.C && atom1.getAtomicNumber() == IElement.N) {
        for (IAtom neighbor : ac.getConnectedAtomsList(atom0)) {
            if (neighbor.getAtomicNumber() == IElement.O && ac.getBond(atom0, neighbor).getOrder() == Order.DOUBLE) {
                return true;
            }
        }
    }
    return false;
}","/**
     * Checks whether both atoms are involved in an amide C-N bond: *N(*)C(*)=O.
     *
     * Only the most common constitution is considered. Tautomeric, O\C(*)=N\*,
     * and charged forms, [O-]\C(*)=N\*, are ignored.
     *
     * @param atom0 the first bonding partner
     * @param atom1 the second bonding partner
     * @param ac the parent container
     *
     * @return if both partners are involved in an amide C-N bond
     */","('isAmide', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",90.0,  Checks whether both atoms are involved in an amide C-N bond: N()C()=O.,20.0,"['Checks if both atoms are involved in the amide C-N bond.', 'Checks if the two atoms are involved in the amide C-N bond.', 'Checks to see if the two atoms are involved in the amide C-N bond.']"
537,jackson-databind,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,writeValueAsBytes,3830-3853,"/**
     * Method that can be used to serialize any Java value as
     * a byte array. Functionally equivalent to calling
     * {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}
     * and getting bytes, but more efficient.
     * Encoding used will be UTF-8.
     *<p>
     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
     */
public byte[] writeValueAsBytes(Object value) throws JsonProcessingException{
    try (ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler())) {
        _writeValueAndClose(createGenerator(bb, JsonEncoding.UTF8), value);
        final byte[] result = bb.toByteArray();
        bb.release();
        return result;
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
}","public byte[] writeValueAsBytes(Object value) throws JsonProcessingException{
    try (ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler())) {
        _writeValueAndClose(createGenerator(bb, JsonEncoding.UTF8), value);
        final byte[] result = bb.toByteArray();
        bb.release();
        return result;
    } catch (JsonProcessingException e) {
        throw e;
    } catch (IOException e) {
        throw JsonMappingException.fromUnexpectedIOE(e);
    }
}","/**
     * Method that can be used to serialize any Java value as
     * a byte array. Functionally equivalent to calling
     * {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}
     * and getting bytes, but more efficient.
     * Encoding used will be UTF-8.
     *<p>
     * Note: prior to version 2.1, throws clause included {@link IOException}; 2.1 removed it.
     */","('writeValueAsBytes', {'INSTRUCTION': {'covered': 23, 'missed': 7}, 'LINE': {'covered': 5, 'missed': 4}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",90.0,  Method that can be used to serialize any Java value as  a byte array.,15.0,"['The method can be used toserialize any Java value.', 'Any Java value can be serialized using this method.', 'A method that can be used toserialize any Java value.']"
538,openapi-generator,org/openapitools/codegen/DefaultCodegen.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java,generateNextName,5112-5132,"/**
     * Generate the next name for the given name, i.e. append ""2"" to the base name if not ending with a number,
     * otherwise increase the number by 1. For example:
     * status    => status2
     * status2   => status3
     * myName100 => myName101
     *
     * @param name The base name
     * @return The next name for the base name
     */
private static String generateNextName(String name){
    Pattern pattern = Pattern.compile(""\\d+\\z"");
    Matcher matcher = pattern.matcher(name);
    if (matcher.find()) {
        String numStr = matcher.group();
        int num = Integer.parseInt(numStr) + 1;
        return name.substring(0, name.length() - numStr.length()) + num;
    } else {
        return name + ""2"";
    }
}","private static String generateNextName(String name){
    Pattern pattern = Pattern.compile(""\\d+\\z"");
    Matcher matcher = pattern.matcher(name);
    if (matcher.find()) {
        String numStr = matcher.group();
        int num = Integer.parseInt(numStr) + 1;
        return name.substring(0, name.length() - numStr.length()) + num;
    } else {
        return name + ""2"";
    }
}","/**
     * Generate the next name for the given name, i.e. append ""2"" to the base name if not ending with a number,
     * otherwise increase the number by 1. For example:
     * status    => status2
     * status2   => status3
     * myName100 => myName101
     *
     * @param name The base name
     * @return The next name for the base name
     */","('generateNextName', {'INSTRUCTION': {'covered': 43, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,"  Generate the next name for the given name, i.",11.0,"['The next name should be generated.', 'The next name should be Generate.', 'The next name should be Generated.']"
539,twilio-java,com/twilio/Twilio.java,/src/main/java/com/twilio/Twilio.java,validateSslCertificate,229-249,"/**
     * Validate that we can connect to the new SSL certificate posted on api.twilio.com.
     *
     * @throws CertificateValidationException if the connection fails
     */
public static void validateSslCertificate(){
    final NetworkHttpClient client = new NetworkHttpClient();
    final Request request = new Request(HttpMethod.GET, ""https://api.twilio.com:8443"");
    try {
        final Response response = client.makeRequest(request);
        if (!TwilioRestClient.SUCCESS.test(response.getStatusCode())) {
            throw new CertificateValidationException(""Unexpected response from certificate endpoint"", request, response);
        }
    } catch (final ApiException e) {
        throw new CertificateValidationException(""Could not get response from certificate endpoint"", request);
    }
}","public static void validateSslCertificate(){
    final NetworkHttpClient client = new NetworkHttpClient();
    final Request request = new Request(HttpMethod.GET, ""https://api.twilio.com:8443"");
    try {
        final Response response = client.makeRequest(request);
        if (!TwilioRestClient.SUCCESS.test(response.getStatusCode())) {
            throw new CertificateValidationException(""Unexpected response from certificate endpoint"", request, response);
        }
    } catch (final ApiException e) {
        throw new CertificateValidationException(""Could not get response from certificate endpoint"", request);
    }
}","/**
     * Validate that we can connect to the new SSL certificate posted on api.twilio.com.
     *
     * @throws CertificateValidationException if the connection fails
     */","('validateSslCertificate', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,  Validate that we can connect to the new SSL certificate posted on api.,14.0,"['We can connect to the new certificate if we confirm that.', 'We can connect to the new certificate if we verify that we can.', 'We can connect to the new certificate if we verify.']"
540,matsim-libs,org/matsim/contrib/sumo/SumoNetworkConverter.java,/contribs/sumo/src/main/java/org/matsim/contrib/sumo/SumoNetworkConverter.java,calculateLaneCapacities,144-155,"/**
     * Calculates lane capacities, according to {@link LanesUtils}.
     */
public void calculateLaneCapacities(Network network, Lanes lanes){
    for (LanesToLinkAssignment l2l : lanes.getLanesToLinkAssignments().values()) {
        Link link = network.getLinks().get(l2l.getLinkId());
        for (Lane lane : l2l.getLanes().values()) {
            calculateAndSetCapacity(lane, lane.getToLaneIds() == null || lane.getToLaneIds().isEmpty(), link, network);
        }
    }
}","public void calculateLaneCapacities(Network network, Lanes lanes){
    for (LanesToLinkAssignment l2l : lanes.getLanesToLinkAssignments().values()) {
        Link link = network.getLinks().get(l2l.getLinkId());
        for (Lane lane : l2l.getLanes().values()) {
            calculateAndSetCapacity(lane, lane.getToLaneIds() == null || lane.getToLaneIds().isEmpty(), link, network);
        }
    }
}","/**
     * Calculates lane capacities, according to {@link LanesUtils}.
     */","('calculateLaneCapacities', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,"  Calculates lane capacities, according to {@link LanesUtils}.",12.0,"['According to @link LanesUtils, it calculates lane capacities.', 'According to @link LanesUtils, calculates lane capacities.', 'According to @link LanesUtils, the lane capacities are calculated.']"
541,matsim-libs,org/matsim/core/utils/collections/PseudoRemovePriorityQueue.java,/matsim/src/main/java/org/matsim/core/utils/collections/PseudoRemovePriorityQueue.java,add,59-79,"/**
	 * Adds the specified element to this priority queue, with the given priority.
	 * @param o
	 * @param priority
	 * @return <tt>true</tt> if the element was added to the collection.
	 */
public boolean add(final E o, final double priority){
    if (o == null) {
        throw new NullPointerException();
    }
    PseudoEntry<E> entry = new PseudoEntry<E>(o, priority);
    if (this.lastEntry.containsKey(o)) {
        return false;
    }
    if (this.delegate.add(entry)) {
        this.lastEntry.put(o, entry);
        return true;
    }
    // this should never happen
    return false;
}","public boolean add(final E o, final double priority){
    if (o == null) {
        throw new NullPointerException();
    }
    PseudoEntry<E> entry = new PseudoEntry<E>(o, priority);
    if (this.lastEntry.containsKey(o)) {
        return false;
    }
    if (this.delegate.add(entry)) {
        this.lastEntry.put(o, entry);
        return true;
    }
    // this should never happen
    return false;
}","/**
	 * Adds the specified element to this priority queue, with the given priority.
	 * @param o
	 * @param priority
	 * @return <tt>true</tt> if the element was added to the collection.
	 */","('add', {'INSTRUCTION': {'covered': 32, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,"  Adds the specified element to this priority queue, with the given priority.",14.0,"['The specified element is added to the priority queue.', 'This priority queue has a specified element added to it.', 'The specified element is added to this priority queue.']"
543,dcache,org/dcache/services/info/base/StatePath.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StatePath.java,isParentOf,229-266,"/**
     * Check whether otherPath points to a location that is a child of this location.  This is true
     * iff each element of this path is identical to the corresponding element in otherPath and
     * otherPath has length precisely greater by one.
     * <pre>
     *  StatePath p1 = new StatePath(""foo.bar"");
     *  StatePath p2 = new StatePath(""foo.bar.baz"");
     *  StatePath p3 = new StatePath(""foo.bar.baz.other"");
     *
     *  p1.isParentOf(p1) // false
     *  p1.isParentOf(p2) // true
     *  p1.isParentOf(p3) // false
     *  p2.isParentOf(p1) // false
     *  p2.isParentOf(p2) // false
     *  p2.isParentOf(p3) // true
     * </pre>
     *
     * @param otherPath
     * @return
     */
public boolean isParentOf(StatePath otherPath){
    if (otherPath == null) {
        return false;
    }
    if ((_elements.size() + 1) != otherPath._elements.size()) {
        return false;
    }
    for (int i = 0; i < _elements.size(); i++) {
        if (_elements.get(i) != otherPath._elements.get(i)) {
            return false;
        }
    }
    return true;
}","public boolean isParentOf(StatePath otherPath){
    if (otherPath == null) {
        return false;
    }
    if ((_elements.size() + 1) != otherPath._elements.size()) {
        return false;
    }
    for (int i = 0; i < _elements.size(); i++) {
        if (_elements.get(i) != otherPath._elements.get(i)) {
            return false;
        }
    }
    return true;
}","/**
     * Check whether otherPath points to a location that is a child of this location.  This is true
     * iff each element of this path is identical to the corresponding element in otherPath and
     * otherPath has length precisely greater by one.
     * <pre>
     *  StatePath p1 = new StatePath(""foo.bar"");
     *  StatePath p2 = new StatePath(""foo.bar.baz"");
     *  StatePath p3 = new StatePath(""foo.bar.baz.other"");
     *
     *  p1.isParentOf(p1) // false
     *  p1.isParentOf(p2) // true
     *  p1.isParentOf(p3) // false
     *  p2.isParentOf(p1) // false
     *  p2.isParentOf(p2) // false
     *  p2.isParentOf(p3) // true
     * </pre>
     *
     * @param otherPath
     * @return
     */","('isParentOf', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,  Check whether otherPath points to a location that is a child of this location.,15.0,"['Check if otherpath points to a location that is a child of this location.', 'If otherpath points to a location that is a child of this location, you should check it.', 'If otherpath points to a location that is a child of this location, you should check that.']"
544,cdk,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,elements,169-188,"/**
     *  Get a list of all Elements which are contained
     *  molecular.
     *
     *@param   formula The MolecularFormula to check
     *@return          The list with the IElements in this molecular formula
     */
public static List<IElement> elements(IMolecularFormula formula){
    List<IElement> elementList = new ArrayList<IElement>();
    List<String> stringList = new ArrayList<String>();
    for (IIsotope isotope : formula.isotopes()) {
        if (!stringList.contains(isotope.getSymbol())) {
            elementList.add(isotope);
            stringList.add(isotope.getSymbol());
        }
    }
    return elementList;
}","public static List<IElement> elements(IMolecularFormula formula){
    List<IElement> elementList = new ArrayList<IElement>();
    List<String> stringList = new ArrayList<String>();
    for (IIsotope isotope : formula.isotopes()) {
        if (!stringList.contains(isotope.getSymbol())) {
            elementList.add(isotope);
            stringList.add(isotope.getSymbol());
        }
    }
    return elementList;
}","/**
     *  Get a list of all Elements which are contained
     *  molecular.
     *
     *@param   formula The MolecularFormula to check
     *@return          The list with the IElements in this molecular formula
     */","('elements', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,  Get a list of all Elements which are contained  molecular.,11.0,"['Get a list of all elements.', 'Get a list of elements that are related.', 'Get a list of elements that are in the same family.']"
545,weblogic-kubernetes-operator,oracle/kubernetes/operator/helpers/KubernetesUtils.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/KubernetesUtils.java,isFirstNewer,122-147,"/**
   * Returns true if the first metadata indicates a newer resource than does the second. 'Newer'
   * indicates that the creation time is later. If two items have the same creation time, a higher
   * resource version indicates the newer resource.
   *
   * @param first  the first item to compare
   * @param second the second item to compare
   * @return true if the first object is newer than the second object
   */
public static boolean isFirstNewer(V1ObjectMeta first, V1ObjectMeta second){
    if (second == null) {
        return true;
    }
    if (first == null) {
        return false;
    }
    OffsetDateTime time1 = first.getCreationTimestamp();
    OffsetDateTime time2 = second.getCreationTimestamp();
    if (time1.equals(time2)) {
        return getResourceVersion(first).compareTo(getResourceVersion(second)) > 0;
    } else {
        return time1.isAfter(time2);
    }
}","public static boolean isFirstNewer(V1ObjectMeta first, V1ObjectMeta second){
    if (second == null) {
        return true;
    }
    if (first == null) {
        return false;
    }
    OffsetDateTime time1 = first.getCreationTimestamp();
    OffsetDateTime time2 = second.getCreationTimestamp();
    if (time1.equals(time2)) {
        return getResourceVersion(first).compareTo(getResourceVersion(second)) > 0;
    } else {
        return time1.isAfter(time2);
    }
}","/**
   * Returns true if the first metadata indicates a newer resource than does the second. 'Newer'
   * indicates that the creation time is later. If two items have the same creation time, a higher
   * resource version indicates the newer resource.
   *
   * @param first  the first item to compare
   * @param second the second item to compare
   * @return true if the first object is newer than the second object
   */","('isFirstNewer', {'INSTRUCTION': {'covered': 30, 'missed': 2}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,  Returns true if the first metadata indicates a newer resource than does the second.,15.0,"[""If the first metadata indicates a newer resource than the second, it's true."", ""If the first metadata shows a newer resource than the second, it's true."", ""If the first metadata indicates a newer resource than the second, then it's true.""]"
546,acs-aem-commons,com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,/bundle/src/main/java/com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,replaceInString,219-236,"/**
     * Reusable method to replace placeholders in the input string./
     *
     * @param input String input
     * @param contentVariableReplacements current map of content variables
     * @return The replaced or original String
     */
private String replaceInString(String input, Map<String, Object> contentVariableReplacements){
    final List<String> keys = ContentVariableReplacementUtil.getKeys(input);
    for (String key : keys) {
        if (ContentVariableReplacementUtil.hasKey(contentVariableReplacements, key)) {
            String replaceValue = (String) ContentVariableReplacementUtil.getValue(contentVariableReplacements, key);
            input = ContentVariableReplacementUtil.doReplacement(input, key, replaceValue, propertyConfigService.getAction(key));
        }
    }
    return input;
}","private String replaceInString(String input, Map<String, Object> contentVariableReplacements){
    final List<String> keys = ContentVariableReplacementUtil.getKeys(input);
    for (String key : keys) {
        if (ContentVariableReplacementUtil.hasKey(contentVariableReplacements, key)) {
            String replaceValue = (String) ContentVariableReplacementUtil.getValue(contentVariableReplacements, key);
            input = ContentVariableReplacementUtil.doReplacement(input, key, replaceValue, propertyConfigService.getAction(key));
        }
    }
    return input;
}","/**
     * Reusable method to replace placeholders in the input string./
     *
     * @param input String input
     * @param contentVariableReplacements current map of content variables
     * @return The replaced or original String
     */","('replaceInString', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,  Reusable method to replace placeholders in the input string.,10.0,"['There is a method to replace the input string with something else.', 'There is a method to replace the input string.', 'There is a method to replace the input string with a different one.']"
548,liquibase,liquibase/database/core/PostgresDatabase.java,/liquibase-core/src/main/java/liquibase/database/core/PostgresDatabase.java,escapeObjectName,276-290,"/**
     * This has special case logic to handle NOT quoting column names if they are
     * of type 'LiquibaseColumn' - columns in the DATABASECHANGELOG or DATABASECHANGELOGLOCK
     * tables.
     */
public String escapeObjectName(String objectName, Class<? extends DatabaseObject> objectType){
    if ((quotingStrategy == ObjectQuotingStrategy.LEGACY) && hasMixedCase(objectName)) {
        return ""\"""" + objectName + ""\"""";
    } else if (objectType != null && LiquibaseColumn.class.isAssignableFrom(objectType)) {
        return (objectName != null && !objectName.isEmpty()) ? objectName.trim() : objectName;
    }
    return super.escapeObjectName(objectName, objectType);
}","public String escapeObjectName(String objectName, Class<? extends DatabaseObject> objectType){
    if ((quotingStrategy == ObjectQuotingStrategy.LEGACY) && hasMixedCase(objectName)) {
        return ""\"""" + objectName + ""\"""";
    } else if (objectType != null && LiquibaseColumn.class.isAssignableFrom(objectType)) {
        return (objectName != null && !objectName.isEmpty()) ? objectName.trim() : objectName;
    }
    return super.escapeObjectName(objectName, objectType);
}","/**
     * This has special case logic to handle NOT quoting column names if they are
     * of type 'LiquibaseColumn' - columns in the DATABASECHANGELOG or DATABASECHANGELOGLOCK
     * tables.
     */","('escapeObjectName', {'INSTRUCTION': {'covered': 39, 'missed': 1}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,  This has special case logic to handle NOT quoting column names if they are  of type 'LiquibaseColumn' - columns in the DATABASECHANGELOG or DATABASECHANGELOGLOCK  tables.,27.0,"['This has special case logic to not quote column names if they are in the DATABASECHANGELOG or DATABASECHANGELOGLOCK tables.', 'This has special case logic to not quote column names if they are in the DATABASECHANGELOG or DATABASECHANGELOCK tables.', 'This has special case logic to not quote column names if they are in a DATABASECHANGELOG or DATABASECHANGELOGLOCK tables.']"
549,dataverse,edu/harvard/iq/dataverse/authorization/providers/shib/ShibUtil.java,/src/main/java/edu/harvard/iq/dataverse/authorization/providers/shib/ShibUtil.java,printAttributes,297-367,"/**
     * These are the attributes we are getting from the IdP at testshib.org, a
     * dump from https://pdurbin.pagekite.me/Shibboleth.sso/Session
     *
     * Miscellaneous
     *
     * Session Expiration (barring inactivity): 479 minute(s)
     *
     * Client Address: 10.0.2.2
     *
     * SSO Protocol: urn:oasis:names:tc:SAML:2.0:protocol
     *
     * Identity Provider: https://idp.testshib.org/idp/shibboleth
     *
     * Authentication Time: 2014-09-12T17:07:36.137Z
     *
     * Authentication Context Class:
     * urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport
     *
     * Authentication Context Decl: (none)
     *
     *
     *
     * Attributes
     *
     * affiliation: Member@testshib.org;Staff@testshib.org
     *
     * cn: Me Myself And I
     *
     * entitlement: urn:mace:dir:entitlement:common-lib-terms
     *
     * eppn: myself@testshib.org
     *
     * givenName: Me Myself
     *
     * persistent-id:
     * https://idp.testshib.org/idp/shibboleth!https://pdurbin.pagekite.me/shibboleth!zylzL+NruovU5OOGXDOL576jxfo=
     *
     * sn: And I
     *
     * telephoneNumber: 555-5555
     *
     * uid: myself
     *
     * unscoped-affiliation: Member;Staff
     *
     */
public static void printAttributes(HttpServletRequest request){
    List<String> shibValues = new ArrayList<>();
    if (request == null) {
        logger.fine(""HttpServletRequest was null. No shib values to print."");
        return;
    }
    for (String attr : shibAttrs) {
        Object attrObject = request.getAttribute(attr);
        if (attrObject != null) {
            shibValues.add(attr + "": "" + attrObject.toString());
        }
    }
    logger.fine(""shib values: "" + shibValues);
}","public static void printAttributes(HttpServletRequest request){
    List<String> shibValues = new ArrayList<>();
    if (request == null) {
        logger.fine(""HttpServletRequest was null. No shib values to print."");
        return;
    }
    for (String attr : shibAttrs) {
        Object attrObject = request.getAttribute(attr);
        if (attrObject != null) {
            shibValues.add(attr + "": "" + attrObject.toString());
        }
    }
    logger.fine(""shib values: "" + shibValues);
}","/**
     * These are the attributes we are getting from the IdP at testshib.org, a
     * dump from https://pdurbin.pagekite.me/Shibboleth.sso/Session
     *
     * Miscellaneous
     *
     * Session Expiration (barring inactivity): 479 minute(s)
     *
     * Client Address: 10.0.2.2
     *
     * SSO Protocol: urn:oasis:names:tc:SAML:2.0:protocol
     *
     * Identity Provider: https://idp.testshib.org/idp/shibboleth
     *
     * Authentication Time: 2014-09-12T17:07:36.137Z
     *
     * Authentication Context Class:
     * urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport
     *
     * Authentication Context Decl: (none)
     *
     *
     *
     * Attributes
     *
     * affiliation: Member@testshib.org;Staff@testshib.org
     *
     * cn: Me Myself And I
     *
     * entitlement: urn:mace:dir:entitlement:common-lib-terms
     *
     * eppn: myself@testshib.org
     *
     * givenName: Me Myself
     *
     * persistent-id:
     * https://idp.testshib.org/idp/shibboleth!https://pdurbin.pagekite.me/shibboleth!zylzL+NruovU5OOGXDOL576jxfo=
     *
     * sn: And I
     *
     * telephoneNumber: 555-5555
     *
     * uid: myself
     *
     * unscoped-affiliation: Member;Staff
     *
     */","('printAttributes', {'INSTRUCTION': {'covered': 32, 'missed': 7}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",91.0,  These are the attributes we are getting from the IdP at testshib.,13.0,"['The IdP at testshib gives us these attributes.', 'The IdP is giving us these attributes.', 'The IdP has some attributes we are getting.']"
550,dcache,org/dcache/services/billing/text/BillingParserBuilder.java,/modules/dcache/src/main/java/org/dcache/services/billing/text/BillingParserBuilder.java,toPatterns,140-151,"/**
     * Returns Patterns for the provided billing formats, as a Multimap mapping the Pattern to the
     * attributes contained in the pattern.
     */
private static ImmutableSetMultimap<Pattern, String> toPatterns(Map<String, String> formats){
    ImmutableSetMultimap.Builder<Pattern, String> builder = ImmutableSetMultimap.builder();
    for (Map.Entry<String, String> format : formats.entrySet()) {
        builder.putAll(toPattern(format.getKey(), format.getValue()), toAttributes(format.getValue()));
    }
    return builder.build();
}","private static ImmutableSetMultimap<Pattern, String> toPatterns(Map<String, String> formats){
    ImmutableSetMultimap.Builder<Pattern, String> builder = ImmutableSetMultimap.builder();
    for (Map.Entry<String, String> format : formats.entrySet()) {
        builder.putAll(toPattern(format.getKey(), format.getValue()), toAttributes(format.getValue()));
    }
    return builder.build();
}","/**
     * Returns Patterns for the provided billing formats, as a Multimap mapping the Pattern to the
     * attributes contained in the pattern.
     */","('toPatterns', {'INSTRUCTION': {'covered': 31, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,"  Returns Patterns for the provided billing formats, as a Multimap mapping the Pattern to the  attributes contained in the pattern.",22.0,"['As a Multimap mapping the pattern to the attributes contained in the pattern, returns Patterns for the provided billing formats.', 'As a Multimap mapping the pattern to the attributes contained in it, returns Patterns for the provided billing formats.', 'As a Multimap mapping the pattern to the attributes contained in the pattern, returns patterns for the provided billing formats.']"
551,mybatis-3,org/apache/ibatis/io/VFS.java,/src/main/java/org/apache/ibatis/io/VFS.java,invoke,148-179,"/**
   * Invoke a method on an object and return whatever it returns.
   *
   * @param <T>
   *          the generic type
   * @param method
   *          The method to invoke.
   * @param object
   *          The instance or class (for static methods) on which to invoke the method.
   * @param parameters
   *          The parameters to pass to the method.
   * @return Whatever the method returns.
   * @throws IOException
   *           If I/O errors occur
   * @throws RuntimeException
   *           If anything else goes wrong
   */
protected static T invoke(Method method, Object object, Object... parameters) throws IOException, RuntimeException{
    try {
        return (T) method.invoke(object, parameters);
    } catch (IllegalArgumentException | IllegalAccessException e) {
        throw new RuntimeException(e);
    } catch (InvocationTargetException e) {
        if (e.getTargetException() instanceof IOException) {
            throw (IOException) e.getTargetException();
        } else {
            throw new RuntimeException(e);
        }
    }
}","protected static T invoke(Method method, Object object, Object... parameters) throws IOException, RuntimeException{
    try {
        return (T) method.invoke(object, parameters);
    } catch (IllegalArgumentException | IllegalAccessException e) {
        throw new RuntimeException(e);
    } catch (InvocationTargetException e) {
        if (e.getTargetException() instanceof IOException) {
            throw (IOException) e.getTargetException();
        } else {
            throw new RuntimeException(e);
        }
    }
}","/**
   * Invoke a method on an object and return whatever it returns.
   *
   * @param <T>
   *          the generic type
   * @param method
   *          The method to invoke.
   * @param object
   *          The instance or class (for static methods) on which to invoke the method.
   * @param parameters
   *          The parameters to pass to the method.
   * @return Whatever the method returns.
   * @throws IOException
   *           If I/O errors occur
   * @throws RuntimeException
   *           If anything else goes wrong
   */","('invoke', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,  Invoke a method on an object and return whatever it returns.,12.0,"['If you invoke a method on an object, you can return whatever it returns.', 'If you invoke a method on an object, you can return it.', 'If you invoke a method on an object, you will get what you get.']"
552,cdk,org/openscience/cdk/graph/invariant/InChINumbersTools.java,/storage/inchi/src/main/java/org/openscience/cdk/graph/invariant/InChINumbersTools.java,findPiBondedOxygen,206-222,"/**
     * Find a neutral oxygen bonded to the {@code atom} with a pi bond.
     *
     * @param container the container
     * @param atom      an atom from the container
     * @return a pi bonded oxygen (or null if not found)
     */
private static IAtom findPiBondedOxygen(IAtomContainer container, IAtom atom){
    for (IBond bond : container.getConnectedBondsList(atom)) {
        if (bond.getOrder() == IBond.Order.DOUBLE) {
            IAtom neighbor = bond.getOther(atom);
            int charge = neighbor.getFormalCharge() == null ? 0 : neighbor.getFormalCharge();
            if (neighbor.getAtomicNumber() == 8 && charge == 0)
                return neighbor;
        }
    }
    return null;
}","private static IAtom findPiBondedOxygen(IAtomContainer container, IAtom atom){
    for (IBond bond : container.getConnectedBondsList(atom)) {
        if (bond.getOrder() == IBond.Order.DOUBLE) {
            IAtom neighbor = bond.getOther(atom);
            int charge = neighbor.getFormalCharge() == null ? 0 : neighbor.getFormalCharge();
            if (neighbor.getAtomicNumber() == 8 && charge == 0)
                return neighbor;
        }
    }
    return null;
}","/**
     * Find a neutral oxygen bonded to the {@code atom} with a pi bond.
     *
     * @param container the container
     * @param atom      an atom from the container
     * @return a pi bonded oxygen (or null if not found)
     */","('findPiBondedOxygen', {'INSTRUCTION': {'covered': 37, 'missed': 4}, 'BRANCH': {'covered': 6, 'missed': 4}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,  Find a neutral oxygen bonded to the {@code atom} with a pi bond.,17.0,"['There is a neutral oxygen and a pi bond.', 'There is a neutral oxygen bond to the atom.', 'There is a neutral oxygen and a pi bond to the atom.']"
553,glowstone,net/glowstone/entity/GlowEntity.java,/src/main/java/net/glowstone/entity/GlowEntity.java,remove,1126-1144,"/**
     * Destroys this entity by removing it from the world and marking it as not being active.
     */
public void remove(){
    removed = true;
    active = false;
    boundingBox = null;
    world.getEntityManager().unregister(this);
    server.getEntityIdManager().deallocate(this);
    this.setPassenger(null);
    leaveVehicle();
    ImmutableList.copyOf(this.leashedEntities).forEach(e -> unleash(e, UnleashReason.HOLDER_GONE));
    if (isLeashed()) {
        unleash(this, UnleashReason.HOLDER_GONE);
    }
}","public void remove(){
    removed = true;
    active = false;
    boundingBox = null;
    world.getEntityManager().unregister(this);
    server.getEntityIdManager().deallocate(this);
    this.setPassenger(null);
    leaveVehicle();
    ImmutableList.copyOf(this.leashedEntities).forEach(e -> unleash(e, UnleashReason.HOLDER_GONE));
    if (isLeashed()) {
        unleash(this, UnleashReason.HOLDER_GONE);
    }
}","/**
     * Destroys this entity by removing it from the world and marking it as not being active.
     */","('remove', {'INSTRUCTION': {'covered': 36, 'missed': 4}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 11, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,  Destroys this entity by removing it from the world and marking it as not being active.,17.0,"['Removes this entity from the world and marks it as inactive.', 'Removes this entity from the world and marks it as not being active.', 'This entity is destroyed by removing it from the world and marking it as inactive.']"
554,cdk,org/openscience/cdk/smsd/filters/PostFilter.java,/legacy/src/main/java/org/openscience/cdk/smsd/filters/PostFilter.java,filter,51-68,"/**
     *
     * Creates a new instance of Post Filter and removes
     * redundant mapping(s).
     *
     * @param mappings
     * @return Filtered non-redundant mappings
     */
public static List<Map<Integer, Integer>> filter(List<List<Integer>> mappings){
    FinalMappings finalMappings = FinalMappings.getInstance();
    if (mappings != null && !mappings.isEmpty()) {
        finalMappings.set(removeRedundantMapping(mappings));
        mappings.clear();
    } else {
        finalMappings.set(new ArrayList<Map<Integer, Integer>>());
    }
    return finalMappings.getFinalMapping();
}","public static List<Map<Integer, Integer>> filter(List<List<Integer>> mappings){
    FinalMappings finalMappings = FinalMappings.getInstance();
    if (mappings != null && !mappings.isEmpty()) {
        finalMappings.set(removeRedundantMapping(mappings));
        mappings.clear();
    } else {
        finalMappings.set(new ArrayList<Map<Integer, Integer>>());
    }
    return finalMappings.getFinalMapping();
}","/**
     *
     * Creates a new instance of Post Filter and removes
     * redundant mapping(s).
     *
     * @param mappings
     * @return Filtered non-redundant mappings
     */","('filter', {'INSTRUCTION': {'covered': 17, 'missed': 5}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,   Creates a new instance of Post Filter and removes  redundant mapping(s).,15.0,"['A new instance of Post Filter is created.', 'There is a new instance of Post Filter created.', 'A new instance of Post Filter is created and removed.']"
555,weblogic-kubernetes-operator,oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsClusterConfig.java,create,53-83,"/**
   * Creates a WlsClusterConfig object using an ""clusters"" item parsed from JSON result from WLS
   * REST call.
   *
   * @param clusterConfigMap Map containing ""cluster"" item parsed from JSON result from WLS REST
   *     call
   * @param serverTemplates Map containing all server templates configuration read from the WLS
   *     domain
   * @param domainName Name of the WLS domain that this WLS cluster belongs to
   * @return A new WlsClusterConfig object created based on the JSON result
   */
 static WlsClusterConfig create(Map<String, Object> clusterConfigMap, Map<String, WlsServerConfig> serverTemplates, String domainName){
    String clusterName = (String) clusterConfigMap.get(""name"");
    WlsDynamicServersConfig dynamicServersConfig = WlsDynamicServersConfig.create((Map<String, Object>) clusterConfigMap.get(""dynamicServers""), serverTemplates, clusterName, domainName);
    // set dynamicServersConfig only if the cluster contains dynamic servers, i.e., its dynamic
    // servers configuration
    // contains non-null server template name
    if (dynamicServersConfig.getServerTemplate() == null) {
        dynamicServersConfig = null;
    }
    return new WlsClusterConfig(clusterName, dynamicServersConfig);
}"," static WlsClusterConfig create(Map<String, Object> clusterConfigMap, Map<String, WlsServerConfig> serverTemplates, String domainName){
    String clusterName = (String) clusterConfigMap.get(""name"");
    WlsDynamicServersConfig dynamicServersConfig = WlsDynamicServersConfig.create((Map<String, Object>) clusterConfigMap.get(""dynamicServers""), serverTemplates, clusterName, domainName);
    // set dynamicServersConfig only if the cluster contains dynamic servers, i.e., its dynamic
    // servers configuration
    // contains non-null server template name
    if (dynamicServersConfig.getServerTemplate() == null) {
        dynamicServersConfig = null;
    }
    return new WlsClusterConfig(clusterName, dynamicServersConfig);
}","/**
   * Creates a WlsClusterConfig object using an ""clusters"" item parsed from JSON result from WLS
   * REST call.
   *
   * @param clusterConfigMap Map containing ""cluster"" item parsed from JSON result from WLS REST
   *     call
   * @param serverTemplates Map containing all server templates configuration read from the WLS
   *     domain
   * @param domainName Name of the WLS domain that this WLS cluster belongs to
   * @return A new WlsClusterConfig object created based on the JSON result
   */","('create', {'INSTRUCTION': {'covered': 23, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,"  Creates a WlsClusterConfig object using an ""clusters"" item parsed from JSON result from WLS  REST call.",19.0,"['A WlsClusterConfig object is created using a ""clusters"" item from aWLS call.', 'A WlsClusterConfig object is created using the ""clusters"" item from the WLS call.', 'A WlsClusterConfig object is created using a ""clusters"" item from the WLS call.']"
556,cdk,org/openscience/cdk/silent/Mapping.java,/base/silent/src/main/java/org/openscience/cdk/silent/Mapping.java,clone,118-136,"/**
     * Clones this <code>Mapping</code> and the mapped <code>IChemObject</code>s.
     *
     * @return  The cloned object
     */
public Object clone() throws CloneNotSupportedException{
    Mapping clone = (Mapping) super.clone();
    if (relation != null) {
        clone.relation = new IChemObject[relation.length];
        for (int f = 0; f < relation.length; f++) {
            if (relation[f] != null) {
                clone.relation[f] = (IChemObject) relation[f].clone();
            }
        }
    }
    return clone;
}","public Object clone() throws CloneNotSupportedException{
    Mapping clone = (Mapping) super.clone();
    if (relation != null) {
        clone.relation = new IChemObject[relation.length];
        for (int f = 0; f < relation.length; f++) {
            if (relation[f] != null) {
                clone.relation[f] = (IChemObject) relation[f].clone();
            }
        }
    }
    return clone;
}","/**
     * Clones this <code>Mapping</code> and the mapped <code>IChemObject</code>s.
     *
     * @return  The cloned object
     */","('clone', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,  Clones this <code>Mapping</code> and the mapped <code>IChemObject</code>s.,21.0,"['This code>Mapping/code> and the mapped code>IChemObject/code>s were cloned.', 'Clones the code>Mapping/code> and the code>IChemObject/code>s.', 'This code>Mapping/code> and the mapped code>IChemObject/code>s are cloned.']"
557,cdk,org/openscience/cdk/layout/StructureDiagramGenerator.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/StructureDiagramGenerator.java,isMacroCycle,1801-1827,"/**
     * Check if a ring in a ring set is a macro cycle. We define this as a
     * ring with >= 10 atom and has at least one bond that isn't contained
     * in any other rings.
     *
     * @param ring ring to check
     * @param rs   rest of ring system
     * @return ring is a macro cycle
     */
private boolean isMacroCycle(IRing ring, IRingSet rs){
    if (ring.getAtomCount() < 8)
        return false;
    for (IBond bond : ring.bonds()) {
        boolean found = false;
        for (IAtomContainer other : rs.atomContainers()) {
            if (ring == other)
                continue;
            if (other.contains(bond)) {
                found = true;
                break;
            }
        }
        if (!found)
            return true;
    }
    return false;
}","private boolean isMacroCycle(IRing ring, IRingSet rs){
    if (ring.getAtomCount() < 8)
        return false;
    for (IBond bond : ring.bonds()) {
        boolean found = false;
        for (IAtomContainer other : rs.atomContainers()) {
            if (ring == other)
                continue;
            if (other.contains(bond)) {
                found = true;
                break;
            }
        }
        if (!found)
            return true;
    }
    return false;
}","/**
     * Check if a ring in a ring set is a macro cycle. We define this as a
     * ring with >= 10 atom and has at least one bond that isn't contained
     * in any other rings.
     *
     * @param ring ring to check
     * @param rs   rest of ring system
     * @return ring is a macro cycle
     */","('isMacroCycle', {'INSTRUCTION': {'covered': 43, 'missed': 6}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 11, 'missed': 4}, 'COMPLEXITY': {'covered': 4, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",92.0,  Check if a ring in a ring set is a macro cycle.,13.0,"['If a ring is a macro cycle, you should check it.', 'If a ring in a set is a macro cycle, you should check it.', 'If a ring is a macro cycle, you need to check it.']"
558,dataverse,edu/harvard/iq/dataverse/authorization/users/AuthenticatedUser.java,/src/main/java/edu/harvard/iq/dataverse/authorization/users/AuthenticatedUser.java,applyDisplayInfo,178-194,"/**
     * Takes the passed info object and updated the internal fields according to it.
     * @param inf the info from which we update the fields.
    */
public void applyDisplayInfo(AuthenticatedUserDisplayInfo inf){
    setFirstName(inf.getFirstName());
    setLastName(inf.getLastName());
    if (nonEmpty(inf.getEmailAddress())) {
        setEmail(inf.getEmailAddress());
    }
    if (nonEmpty(inf.getAffiliation())) {
        setAffiliation(inf.getAffiliation());
    }
    if (nonEmpty(inf.getPosition())) {
        setPosition(inf.getPosition());
    }
}","public void applyDisplayInfo(AuthenticatedUserDisplayInfo inf){
    setFirstName(inf.getFirstName());
    setLastName(inf.getLastName());
    if (nonEmpty(inf.getEmailAddress())) {
        setEmail(inf.getEmailAddress());
    }
    if (nonEmpty(inf.getAffiliation())) {
        setAffiliation(inf.getAffiliation());
    }
    if (nonEmpty(inf.getPosition())) {
        setPosition(inf.getPosition());
    }
}","/**
     * Takes the passed info object and updated the internal fields according to it.
     * @param inf the info from which we update the fields.
    */","('applyDisplayInfo', {'INSTRUCTION': {'covered': 33, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",93.0,  Takes the passed info object and updated the internal fields according to it.,14.0,"['The internal fields were updated according to the passed info object.', 'The internal fields are updated according to the passed info object.', 'The internal fields were updated according to the passed info object']"
559,cdk,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,inOrder,169-191,"/**
     * Check whether the cells are ordered such that for cells i and j,
     * first(j) &gt; first(i) and last(j) &gt; last(i).
     *
     * @return true if all cells in the partition are ordered
     */
public boolean inOrder(){
    SortedSet<Integer> prev = null;
    for (SortedSet<Integer> cell : cells) {
        if (prev == null) {
            prev = cell;
        } else {
            int first = cell.first();
            int last = cell.last();
            if (first > prev.first() && last > prev.last()) {
                prev = cell;
            } else {
                return false;
            }
        }
    }
    return true;
}","public boolean inOrder(){
    SortedSet<Integer> prev = null;
    for (SortedSet<Integer> cell : cells) {
        if (prev == null) {
            prev = cell;
        } else {
            int first = cell.first();
            int last = cell.last();
            if (first > prev.first() && last > prev.last()) {
                prev = cell;
            } else {
                return false;
            }
        }
    }
    return true;
}","/**
     * Check whether the cells are ordered such that for cells i and j,
     * first(j) &gt; first(i) and last(j) &gt; last(i).
     *
     * @return true if all cells in the partition are ordered
     */","('inOrder', {'INSTRUCTION': {'covered': 46, 'missed': 2}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 10, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",93.0,"  Check whether the cells are ordered such that for cells i and j,  first(j) &gt; first(i) and last(j) &gt; last(i).",38.0,"['Check to see if the cells are ordered such that for cells i and j.', 'Check to see if the cells are ordered such that for cells i and j, first(j) and first(i) and last(j) and last(i)', 'Check to see if the cells are ordered such that for cells i and j, first(j) and first(i) and last(j) and last(i).']"
560,acs-aem-commons,com/adobe/acs/commons/data/Spreadsheet.java,/bundle/src/main/java/com/adobe/acs/commons/data/Spreadsheet.java,upgradeToArray,374-396,"/**
     * Consider if a column is seen twice then that column type should be
     * considered an array. Because String is a default assumption when no type
     * is specified, any redefinition of a column to a more specific type will
     * be then assumed for that property altogether.
     *
     * @param a
     * @param b
     * @return
     */
private Optional<Class> upgradeToArray(Optional<Class> a, Optional<Class> b){
    if (!a.isPresent()) {
        return b;
    }
    if (!b.isPresent()) {
        return a;
    }
    if (a.get().equals(b.get()) || b.get() == Object.class) {
        return getArrayType(a);
    } else {
        return getArrayType(b);
    }
}","private Optional<Class> upgradeToArray(Optional<Class> a, Optional<Class> b){
    if (!a.isPresent()) {
        return b;
    }
    if (!b.isPresent()) {
        return a;
    }
    if (a.get().equals(b.get()) || b.get() == Object.class) {
        return getArrayType(a);
    } else {
        return getArrayType(b);
    }
}","/**
     * Consider if a column is seen twice then that column type should be
     * considered an array. Because String is a default assumption when no type
     * is specified, any redefinition of a column to a more specific type will
     * be then assumed for that property altogether.
     *
     * @param a
     * @param b
     * @return
     */","('upgradeToArray', {'INSTRUCTION': {'covered': 20, 'missed': 7}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 4, 'missed': 3}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",93.0,  Consider if a column is seen twice then that column type should be  considered an array.,17.0,"['If a column is seen more than once, it should be considered an array.', 'If a column is seen more than once then it should be considered an array.', 'If a column is seen more than once, then it should be considered an array.']"
561,matsim-libs,org/matsim/core/utils/collections/PseudoRemovePriorityQueue.java,/matsim/src/main/java/org/matsim/core/utils/collections/PseudoRemovePriorityQueue.java,iterator,164-192,"/**
	 * Returns an iterator over the elements in this queue. The iterator
	 * does not return the elements in any particular order. Removing
	 * elements is not supported via the iterator.
	 *
	 * @return an iterator over the elements in this queue.
	 */
public Iterator<E> iterator(){
    return new Iterator<E>() {

        final Iterator<E> iterDelegate = PseudoRemovePriorityQueue.this.lastEntry.keySet().iterator();

        @Override
        public boolean hasNext() {
            return this.iterDelegate.hasNext();
        }

        @Override
        public E next() {
            return this.iterDelegate.next();
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    };
}","public Iterator<E> iterator(){
    return new Iterator<E>() {

        final Iterator<E> iterDelegate = PseudoRemovePriorityQueue.this.lastEntry.keySet().iterator();

        @Override
        public boolean hasNext() {
            return this.iterDelegate.hasNext();
        }

        @Override
        public E next() {
            return this.iterDelegate.next();
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    };
}","/**
	 * Returns an iterator over the elements in this queue. The iterator
	 * does not return the elements in any particular order. Removing
	 * elements is not supported via the iterator.
	 *
	 * @return an iterator over the elements in this queue.
	 */","('iterator', {'INSTRUCTION': {'covered': 5, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",93.0,  Returns an iterator over the elements in this queue.,10.0,"['The elements are in this queue.', 'A iterator is returned over the elements.', 'A iterator is returned in this queue.']"
562,jackson-databind,com/fasterxml/jackson/databind/util/EnumValues.java,/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java,internalMap,116-131,"/**
     * Method used for serialization and introspection by core Jackson code.
     */
public EnumMap<?, SerializableString> internalMap(){
    EnumMap<?, SerializableString> result = _asMap;
    if (result == null) {
        Map<Enum<?>, SerializableString> map = new LinkedHashMap<Enum<?>, SerializableString>();
        for (Enum<?> en : _values) {
            map.put(en, _textual[en.ordinal()]);
        }
        result = new EnumMap(map);
    }
    return result;
}","public EnumMap<?, SerializableString> internalMap(){
    EnumMap<?, SerializableString> result = _asMap;
    if (result == null) {
        Map<Enum<?>, SerializableString> map = new LinkedHashMap<Enum<?>, SerializableString>();
        for (Enum<?> en : _values) {
            map.put(en, _textual[en.ordinal()]);
        }
        result = new EnumMap(map);
    }
    return result;
}","/**
     * Method used for serialization and introspection by core Jackson code.
     */","('internalMap', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",93.0,  Method used for serialization and introspection by core Jackson code.,11.0,"['Core Jackson code is used for the method.', 'The method is used for Jackson code.', 'Core Jackson code is used for this method.']"
563,jeromq,zmq/util/Timers.java,/src/main/java/zmq/util/Timers.java,timeout,173-199,"/**
     * Returns the time in millisecond until the next timer.
     * @return the time in millisecond until the next timer.
     */
public long timeout(){
    final long now = now();
    for (Entry<Timer, Long> entry : entries()) {
        final Timer timer = entry.getKey();
        final Long expiration = entry.getValue();
        if (timer.alive) {
            if (expiration - now > 0) {
                return expiration - now;
            } else {
                return 0;
            }
        }
        timers.remove(expiration, timer);
    }
    return -1;
}","public long timeout(){
    final long now = now();
    for (Entry<Timer, Long> entry : entries()) {
        final Timer timer = entry.getKey();
        final Long expiration = entry.getValue();
        if (timer.alive) {
            if (expiration - now > 0) {
                return expiration - now;
            } else {
                return 0;
            }
        }
        timers.remove(expiration, timer);
    }
    return -1;
}","/**
     * Returns the time in millisecond until the next timer.
     * @return the time in millisecond until the next timer.
     */","('timeout', {'INSTRUCTION': {'covered': 41, 'missed': 7}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 2}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",93.0,  Returns the time in millisecond until the next timer.,10.0,"['The time is returned until the next timer.', 'The time is returned until the next time.', 'The time is returned in a second.']"
564,cdk,org/openscience/cdk/isomorphism/UllmannState.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/UllmannState.java,verify,196-217,"/**
     * Verify that for every vertex adjacent to n, there should be at least one
     * feasible candidate adjacent which can be mapped. If no such candidate
     * exists the mapping of n -> m is not longer valid.
     *
     * @param n query vertex
     * @param m target vertex
     * @return mapping is still valid
     */
private boolean verify(int n, int m){
    for (int n_prime : g1[n]) {
        boolean found = false;
        for (int m_prime : g2[m]) {
            if (matrix.get(n_prime, m_prime) && bondMatcher.matches(bond1.get(n, n_prime), bonds2.get(m, m_prime))) {
                found = true;
                break;
            }
        }
        if (!found)
            return false;
    }
    return true;
}","private boolean verify(int n, int m){
    for (int n_prime : g1[n]) {
        boolean found = false;
        for (int m_prime : g2[m]) {
            if (matrix.get(n_prime, m_prime) && bondMatcher.matches(bond1.get(n, n_prime), bonds2.get(m, m_prime))) {
                found = true;
                break;
            }
        }
        if (!found)
            return false;
    }
    return true;
}","/**
     * Verify that for every vertex adjacent to n, there should be at least one
     * feasible candidate adjacent which can be mapped. If no such candidate
     * exists the mapping of n -> m is not longer valid.
     *
     * @param n query vertex
     * @param m target vertex
     * @return mapping is still valid
     */","('verify', {'INSTRUCTION': {'covered': 69, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",94.0,"  Verify that for every vertex adjacent to n, there should be at least one  feasible candidate adjacent which can be mapped.",23.0,"['There should be at least one feasible candidate adjacent which can be mapped.', 'There should be at least one feasible candidate adjacent which can be mapped if you verify.', 'There should be at least one feasible candidate adjacent which can be mapped for every vertex.']"
565,dataverse,edu/harvard/iq/dataverse/ingest/IngestUtil.java,/src/main/java/edu/harvard/iq/dataverse/ingest/IngestUtil.java,checkForDuplicateFileNamesFinal,54-74,"/**
     * Checks a list of new data files for duplicate names, renaming any
     * duplicates to ensure that they are unique.
     *
     * @param version the dataset version
     * @param newFiles the list of new data files to add to it
     * @param fileToReplace
     */
public static void checkForDuplicateFileNamesFinal(DatasetVersion version, List<DataFile> newFiles, DataFile fileToReplace){
    // Step 1: create list of existing path names from all FileMetadata in the DatasetVersion
    // unique path name: directoryLabel + file separator + fileLabel
    Set<String> pathNamesExisting = existingPathNamesAsSet(version, ((fileToReplace == null) ? null : fileToReplace.getFileMetadata()));
    // Step 2: check each new DataFile against the list of path names, if a duplicate create a new unique file name
    for (Iterator<DataFile> dfIt = newFiles.iterator(); dfIt.hasNext(); ) {
        FileMetadata fm = dfIt.next().getFileMetadata();
        fm.setLabel(duplicateFilenameCheck(fm, pathNamesExisting));
    }
}","public static void checkForDuplicateFileNamesFinal(DatasetVersion version, List<DataFile> newFiles, DataFile fileToReplace){
    // Step 1: create list of existing path names from all FileMetadata in the DatasetVersion
    // unique path name: directoryLabel + file separator + fileLabel
    Set<String> pathNamesExisting = existingPathNamesAsSet(version, ((fileToReplace == null) ? null : fileToReplace.getFileMetadata()));
    // Step 2: check each new DataFile against the list of path names, if a duplicate create a new unique file name
    for (Iterator<DataFile> dfIt = newFiles.iterator(); dfIt.hasNext(); ) {
        FileMetadata fm = dfIt.next().getFileMetadata();
        fm.setLabel(duplicateFilenameCheck(fm, pathNamesExisting));
    }
}","/**
     * Checks a list of new data files for duplicate names, renaming any
     * duplicates to ensure that they are unique.
     *
     * @param version the dataset version
     * @param newFiles the list of new data files to add to it
     * @param fileToReplace
     */","('checkForDuplicateFileNamesFinal', {'INSTRUCTION': {'covered': 27, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",94.0,"  Checks a list of new data files for duplicate names, renaming any  duplicates to ensure that they are unique.",21.0,"['Checks a list of new data files to make sure they are unique.', 'A list of new data files is checked to make sure they are unique.', ""Checks a list of new data files to make sure they're unique.""]"
566,cdk,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,dataHeader,2292-2307,"/**
     * Obtain the field name from a potential SD data header. If the header
     * does not contain a field name, then null is returned. The method does
     * not currently return field numbers (e.g. DT&lt;n&gt;).
     *
     * @param line an input line
     * @return the field name
     */
 static String dataHeader(final String line){
    if (line.length() > 2 && line.charAt(0) != '>' && line.charAt(1) != ' ')
        return null;
    int i = line.indexOf('<', 2);
    if (i < 0)
        return null;
    int j = line.indexOf('>', i);
    if (j < 0)
        return null;
    return line.substring(i + 1, j);
}","static String dataHeader(final String line){
    if (line.length() > 2 && line.charAt(0) != '>' && line.charAt(1) != ' ')
        return null;
    int i = line.indexOf('<', 2);
    if (i < 0)
        return null;
    int j = line.indexOf('>', i);
    if (j < 0)
        return null;
    return line.substring(i + 1, j);
}","/**
     * Obtain the field name from a potential SD data header. If the header
     * does not contain a field name, then null is returned. The method does
     * not currently return field numbers (e.g. DT&lt;n&gt;).
     *
     * @param line an input line
     * @return the field name
     */","('dataHeader', {'INSTRUCTION': {'covered': 39, 'missed': 2}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",95.0,  Obtain the field name from a potential SD data header.,11.0,"['Obtain the field name from the data.', 'The field name should be obtained from the data.', 'The field name should be obtained from a potential data file.']"
567,matsim-libs,org/matsim/core/scenario/ScenarioLoaderImpl.java,/matsim/src/main/java/org/matsim/core/scenario/ScenarioLoaderImpl.java,loadScenario,101-126,"/**
	 * Loads all mandatory Scenario elements and
	 * if activated in config's scenario module/group
	 * optional elements.
	 * @return the Scenario
	 */
 Scenario loadScenario(){
    // String currentDir = new File(""tmp"").getAbsolutePath();
    // currentDir = currentDir.substring(0, currentDir.length() - 3);
    // log.info(""loading scenario from base directory: "" + currentDir);
    // the above is not used and thus only causing confusion in the log output.  kai, sep'18
    this.loadNetwork();
    this.loadActivityFacilities();
    this.loadPopulation();
    // tests internally if the file is there
    this.loadHouseholds();
    // tests internally if the file is there
    this.loadTransit();
    // tests internally if the file is there
    this.loadTransitVehicles();
    if (this.config.vehicles().getVehiclesFile() != null) {
        this.loadVehicles();
    }
    if (this.config.network().getLaneDefinitionsFile() != null) {
        this.loadLanes();
    }
    return this.scenario;
}","Scenario loadScenario(){
    // String currentDir = new File(""tmp"").getAbsolutePath();
    // currentDir = currentDir.substring(0, currentDir.length() - 3);
    // log.info(""loading scenario from base directory: "" + currentDir);
    // the above is not used and thus only causing confusion in the log output.  kai, sep'18
    this.loadNetwork();
    this.loadActivityFacilities();
    this.loadPopulation();
    // tests internally if the file is there
    this.loadHouseholds();
    // tests internally if the file is there
    this.loadTransit();
    // tests internally if the file is there
    this.loadTransitVehicles();
    if (this.config.vehicles().getVehiclesFile() != null) {
        this.loadVehicles();
    }
    if (this.config.network().getLaneDefinitionsFile() != null) {
        this.loadLanes();
    }
    return this.scenario;
}","/**
	 * Loads all mandatory Scenario elements and
	 * if activated in config's scenario module/group
	 * optional elements.
	 * @return the Scenario
	 */","('loadScenario', {'INSTRUCTION': {'covered': 27, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",95.0,  Loads all mandatory Scenario elements and  if activated in config's scenario module/group  optional elements.,16.0,"[""If activated in config's scenario module/group optional elements, loads all mandatory Scenario elements."", 'If activated in the scenario module, loads all mandatory Scenario elements.', ""If activated in config's scenario module/group optional elements, load all mandatory Scenario elements.""]"
568,cdk,org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,findPrefix,404-425,"/**
     * Find the longest prefix from position (i) in this string that
     * is present in the trie symbol table.
     *
     * @param trie   trie node (start with root)
     * @param string string to find a prefix of
     * @param i      the position in the string
     * @param best   best score so far (-1 to start)
     * @return the length of the prefix
     */
private static int findPrefix(Trie trie, String string, int i, int best){
    if (trie == null)
        return best;
    if (trie.token != null)
        best = i;
    if (i == string.length())
        return best;
    final char c = norm(string.charAt(i));
    if (c > 128)
        return best;
    return findPrefix(trie.children[c], string, i + 1, best);
}","private static int findPrefix(Trie trie, String string, int i, int best){
    if (trie == null)
        return best;
    if (trie.token != null)
        best = i;
    if (i == string.length())
        return best;
    final char c = norm(string.charAt(i));
    if (c > 128)
        return best;
    return findPrefix(trie.children[c], string, i + 1, best);
}","/**
     * Find the longest prefix from position (i) in this string that
     * is present in the trie symbol table.
     *
     * @param trie   trie node (start with root)
     * @param string string to find a prefix of
     * @param i      the position in the string
     * @param best   best score so far (-1 to start)
     * @return the length of the prefix
     */","('findPrefix', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",95.0,  Find the longest prefix from position (i) in this string that  is present in the trie symbol table.,21.0,"['There is a string in the trie symbol table that has the longest prefix from position.', 'There is a string in the trie symbol table that has the longest prefix.', 'There is a string in the trie symbol table that has the longest prefix from position i.']"
569,cdk,org/openscience/cdk/geometry/GeometryTools.java,/legacy/src/main/java/org/openscience/cdk/geometry/GeometryTools.java,has2DCoordinatesNew,1020-1051,"/**
     *  Determines if this AtomContainer contains 2D coordinates for some or all molecules.
     *  See comment for center(IAtomContainer atomCon, Dimension areaDim, HashMap renderingCoordinates) for details on coordinate sets
     *
     *
     * @param container the molecule to be considered
     * @return    0 no 2d, 1=some, 2= for each atom
     * @deprecated use {@link #get2DCoordinateCoverage(org.openscience.cdk.interfaces.IAtomContainer)} for determining
     *             partial coordinates
     * @see #get2DCoordinateCoverage(org.openscience.cdk.interfaces.IAtomContainer)
     */
public static int has2DCoordinatesNew(IAtomContainer container){
    if (container == null)
        return 0;
    boolean no2d = false;
    boolean with2d = false;
    for (IAtom atom : container.atoms()) {
        if (atom.getPoint2d() == null) {
            no2d = true;
        } else {
            with2d = true;
        }
    }
    if (!no2d && with2d) {
        return 2;
    } else if (no2d && with2d) {
        return 1;
    } else {
        return 0;
    }
}","public static int has2DCoordinatesNew(IAtomContainer container){
    if (container == null)
        return 0;
    boolean no2d = false;
    boolean with2d = false;
    for (IAtom atom : container.atoms()) {
        if (atom.getPoint2d() == null) {
            no2d = true;
        } else {
            with2d = true;
        }
    }
    if (!no2d && with2d) {
        return 2;
    } else if (no2d && with2d) {
        return 1;
    } else {
        return 0;
    }
}","/**
     *  Determines if this AtomContainer contains 2D coordinates for some or all molecules.
     *  See comment for center(IAtomContainer atomCon, Dimension areaDim, HashMap renderingCoordinates) for details on coordinate sets
     *
     *
     * @param container the molecule to be considered
     * @return    0 no 2d, 1=some, 2= for each atom
     * @deprecated use {@link #get2DCoordinateCoverage(org.openscience.cdk.interfaces.IAtomContainer)} for determining
     *             partial coordinates
     * @see #get2DCoordinateCoverage(org.openscience.cdk.interfaces.IAtomContainer)
     */","('has2DCoordinatesNew', {'INSTRUCTION': {'covered': 40, 'missed': 2}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",95.0,Determines if this AtomContainer contains 2D coordinates for some or all molecules.,13.0,"['Determines if this container has 2D coordinates.', ""If the AtomContainer contains 2D coordinates for some or all molecules, it's determined."", 'If the AtomContainer contains 2D coordinates for some or all molecules, it is determined.']"
570,cdk,org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,evalSimpleIndex,101-120,"/**
     * Evaluates the simple chi index for a set of fragments.
     *
     * @param atomContainer The target <code>AtomContainer</code>
     * @param fragLists      A list of fragments
     * @return The simple chi index
     */
public static double evalSimpleIndex(IAtomContainer atomContainer, List<List<Integer>> fragLists){
    double sum = 0;
    for (List<Integer> fragList : fragLists) {
        double prod = 1.0;
        for (Integer atomSerial : fragList) {
            IAtom atom = atomContainer.getAtom(atomSerial);
            int nconnected = atomContainer.getConnectedBondsCount(atom);
            prod = prod * nconnected;
        }
        if (prod != 0)
            sum += 1.0 / Math.sqrt(prod);
    }
    return sum;
}","public static double evalSimpleIndex(IAtomContainer atomContainer, List<List<Integer>> fragLists){
    double sum = 0;
    for (List<Integer> fragList : fragLists) {
        double prod = 1.0;
        for (Integer atomSerial : fragList) {
            IAtom atom = atomContainer.getAtom(atomSerial);
            int nconnected = atomContainer.getConnectedBondsCount(atom);
            prod = prod * nconnected;
        }
        if (prod != 0)
            sum += 1.0 / Math.sqrt(prod);
    }
    return sum;
}","/**
     * Evaluates the simple chi index for a set of fragments.
     *
     * @param atomContainer The target <code>AtomContainer</code>
     * @param fragLists      A list of fragments
     * @return The simple chi index
     */","('evalSimpleIndex', {'INSTRUCTION': {'covered': 53, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",96.0,  Evaluates the simple chi index for a set of fragments.,11.0,"['Evaluates the chi index for fragments.', 'The simple chi index is evaluated.', 'Evaluates the chi index for a set of fragments.']"
571,dataverse,edu/harvard/iq/dataverse/util/xml/XmlValidator.java,/src/main/java/edu/harvard/iq/dataverse/util/xml/XmlValidator.java,validateXmlWellFormed,43-62,"/**
     * @param filename XML file on disk to check for well-formedness.
     * @return true if well-formed or an exception with a message about why if
     * not.
     * @throws Exception if the XML is not well-formed with a message about why.
     */
public static boolean validateXmlWellFormed(String filename) throws Exception{
    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    factory.setValidating(false);
    factory.setNamespaceAware(true);
    DocumentBuilder builder = factory.newDocumentBuilder();
    builder.setErrorHandler(new SimpleErrorHandler());
    try {
        Document document = builder.parse(new InputSource(filename));
        return true;
    } catch (SAXException ex) {
        throw new Exception(""XML is not well formed: "" + ex.getMessage(), ex);
    }
}","public static boolean validateXmlWellFormed(String filename) throws Exception{
    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    factory.setValidating(false);
    factory.setNamespaceAware(true);
    DocumentBuilder builder = factory.newDocumentBuilder();
    builder.setErrorHandler(new SimpleErrorHandler());
    try {
        Document document = builder.parse(new InputSource(filename));
        return true;
    } catch (SAXException ex) {
        throw new Exception(""XML is not well formed: "" + ex.getMessage(), ex);
    }
}","/**
     * @param filename XML file on disk to check for well-formedness.
     * @return true if well-formed or an exception with a message about why if
     * not.
     * @throws Exception if the XML is not well-formed with a message about why.
     */","('validateXmlWellFormed', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",96.0,  @param filename XML file on disk to check for well-formedness.,12.0,"['To check for well-formedness, use the filename as a reference.', 'To check for well-formedness, you need to use the name of the file.', 'To check for well-formedness, you need to use the filename as a reference.']"
572,acs-aem-commons,com/adobe/acs/commons/httpcache/store/jcr/impl/writer/EntryNodeWriter.java,/bundle/src/main/java/com/adobe/acs/commons/httpcache/store/jcr/impl/writer/EntryNodeWriter.java,populateBinaryContent,99-112,"/**
     * Save the inputstream to a binary property under the cache entry node.
     * @throws RepositoryException
     */
private void populateBinaryContent() throws RepositoryException{
    final Node contents = getOrCreateByPath(entryNode, JCRHttpCacheStoreConstants.PATH_CONTENTS, JcrConstants.NT_FILE, JcrConstants.NT_FILE);
    final Node jcrContent = getOrCreateByPath(contents, JcrConstants.JCR_CONTENT, JcrConstants.NT_RESOURCE, JcrConstants.NT_RESOURCE);
    final Binary binary = session.getValueFactory().createBinary(cacheContent.getInputDataStream());
    jcrContent.setProperty(JcrConstants.JCR_DATA, binary);
    jcrContent.setProperty(JcrConstants.JCR_MIMETYPE, cacheContent.getContentType());
}","private void populateBinaryContent() throws RepositoryException{
    final Node contents = getOrCreateByPath(entryNode, JCRHttpCacheStoreConstants.PATH_CONTENTS, JcrConstants.NT_FILE, JcrConstants.NT_FILE);
    final Node jcrContent = getOrCreateByPath(contents, JcrConstants.JCR_CONTENT, JcrConstants.NT_RESOURCE, JcrConstants.NT_RESOURCE);
    final Binary binary = session.getValueFactory().createBinary(cacheContent.getInputDataStream());
    jcrContent.setProperty(JcrConstants.JCR_DATA, binary);
    jcrContent.setProperty(JcrConstants.JCR_MIMETYPE, cacheContent.getContentType());
}","/**
     * Save the inputstream to a binary property under the cache entry node.
     * @throws RepositoryException
     */","('populateBinaryContent', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",96.0,  Save the inputstream to a binary property under the cache entry node.,13.0,"['The inputstream should be saved to a property.', 'The inputstream should be saved to a property under the cache entry.', 'The inputstream should be saved to a property under the cache entry nodes.']"
573,egeria,org/odpi/openmetadata/accessservices/assetlineage/listeners/AssetLineageOMRSTopicListener.java,/open-metadata-implementation/access-services/asset-lineage/asset-lineage-server/src/main/java/org/odpi/openmetadata/accessservices/assetlineage/listeners/AssetLineageOMRSTopicListener.java,processDeclassifiedEntityEvent,269-293,"/**
     * Process De-Classified Entity event for lineage entity
     * The entity context is published if there is no lineage classification left.
     * The Classification Context event is sent if there are lineage classifications available on lineage entity.
     *
     * @param entityDetail the entity object that contains a classification that has been deleted
     *
     * @throws OCFCheckedExceptionBase unable to send the event due to connectivity issue
     * @throws JsonProcessingException exception parsing the event json
     */
private void processDeclassifiedEntityEvent(EntityDetail entityDetail) throws OCFCheckedExceptionBase, JsonProcessingException{
    if (!immutableValidLineageEntityEvents.contains(entityDetail.getType().getTypeDefName())) {
        return;
    }
    log.debug(PROCESSING_ENTITY_DETAIL_DEBUG_MESSAGE, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT.getEventTypeName(), entityDetail.getGUID(), entityDetail.getType().getTypeDefName());
    if (anyLineageClassificationsLeft(entityDetail)) {
        publisher.publishClassificationContext(entityDetail, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT);
        return;
    }
    publishEntityEvent(entityDetail, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT);
}","private void processDeclassifiedEntityEvent(EntityDetail entityDetail) throws OCFCheckedExceptionBase, JsonProcessingException{
    if (!immutableValidLineageEntityEvents.contains(entityDetail.getType().getTypeDefName())) {
        return;
    }
    log.debug(PROCESSING_ENTITY_DETAIL_DEBUG_MESSAGE, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT.getEventTypeName(), entityDetail.getGUID(), entityDetail.getType().getTypeDefName());
    if (anyLineageClassificationsLeft(entityDetail)) {
        publisher.publishClassificationContext(entityDetail, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT);
        return;
    }
    publishEntityEvent(entityDetail, AssetLineageEventType.DECLASSIFIED_ENTITY_EVENT);
}","/**
     * Process De-Classified Entity event for lineage entity
     * The entity context is published if there is no lineage classification left.
     * The Classification Context event is sent if there are lineage classifications available on lineage entity.
     *
     * @param entityDetail the entity object that contains a classification that has been deleted
     *
     * @throws OCFCheckedExceptionBase unable to send the event due to connectivity issue
     * @throws JsonProcessingException exception parsing the event json
     */","('processDeclassifiedEntityEvent', {'INSTRUCTION': {'covered': 43, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",97.0,  Process De-Classified Entity event for lineage entity  The entity context is published if there is no lineage classification left.,20.0,"['If there is no classification left, the entity context is published.', 'If there is no lineage classification left, the entity context is published.', 'The entity context is published if there is no classification left.']"
574,jackson-databind,com/fasterxml/jackson/databind/ObjectReader.java,/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java,withValueToUpdate,792-822,"/**
     * Method for constructing a new instance with configuration that
     * updates passed Object (as root value), instead of constructing 
     * a new value.
     *<p>
     * Note that the method does NOT change state of this reader, but
     * rather construct and returns a newly configured instance.
     */
public ObjectReader withValueToUpdate(Object value){
    if (value == _valueToUpdate)
        return this;
    if (value == null) {
        return _new(this, _config, _valueType, _rootDeserializer, null, _schema, _injectableValues, _dataFormatReaders);
    }
    JavaType t;
    if (_valueType == null) {
        t = _config.constructType(value.getClass());
    } else {
        t = _valueType;
    }
    return _new(this, _config, t, _rootDeserializer, value, _schema, _injectableValues, _dataFormatReaders);
}","public ObjectReader withValueToUpdate(Object value){
    if (value == _valueToUpdate)
        return this;
    if (value == null) {
        return _new(this, _config, _valueType, _rootDeserializer, null, _schema, _injectableValues, _dataFormatReaders);
    }
    JavaType t;
    if (_valueType == null) {
        t = _config.constructType(value.getClass());
    } else {
        t = _valueType;
    }
    return _new(this, _config, t, _rootDeserializer, value, _schema, _injectableValues, _dataFormatReaders);
}","/**
     * Method for constructing a new instance with configuration that
     * updates passed Object (as root value), instead of constructing 
     * a new value.
     *<p>
     * Note that the method does NOT change state of this reader, but
     * rather construct and returns a newly configured instance.
     */","('withValueToUpdate', {'INSTRUCTION': {'covered': 54, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",97.0,"  Method for constructing a new instance with configuration that  updates passed Object (as root value), instead of constructing   a new value.",25.0,"['The method for constructing a new instance with configuration that updates passed object is different from constructing a new value.', 'The method for constructing a new instance with configuration that updates passed Object is different from constructing a new value.', 'A method for constructing a new instance with configuration that updates passed object, instead of constructing a new value.']"
575,cdk,org/openscience/cdk/Bond.java,/base/data/src/main/java/org/openscience/cdk/Bond.java,clone,553-572,"/**
     * Clones this bond object, including clones of the atoms between which the
     * bond is defined.
     *
     * @return The cloned object
     */
public IBond clone() throws CloneNotSupportedException{
    Bond clone = (Bond) super.clone();
    if (atoms != null) {
        clone.atoms = new IAtom[atoms.length];
        for (int f = 0; f < atoms.length; f++) {
            if (atoms[f] != null) {
                clone.atoms[f] = (IAtom) ((IAtom) atoms[f]).clone();
            }
        }
    }
    return clone;
}","public IBond clone() throws CloneNotSupportedException{
    Bond clone = (Bond) super.clone();
    if (atoms != null) {
        clone.atoms = new IAtom[atoms.length];
        for (int f = 0; f < atoms.length; f++) {
            if (atoms[f] != null) {
                clone.atoms[f] = (IAtom) ((IAtom) atoms[f]).clone();
            }
        }
    }
    return clone;
}","/**
     * Clones this bond object, including clones of the atoms between which the
     * bond is defined.
     *
     * @return The cloned object
     */","('clone', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",97.0,"  Clones this bond object, including clones of the atoms between which the  bond is defined.",17.0,"['Clones the bond object, including the atoms between which it is defined.', 'Clones the bond object with the atoms between which it is defined.', 'Clones the bond object, including the atoms between it.']"
576,dataverse,edu/harvard/iq/dataverse/settings/source/DbSettingConfigSource.java,/src/main/java/edu/harvard/iq/dataverse/settings/source/DbSettingConfigSource.java,updateProperties,37-49,"/**
     * Retrieve settings from the database via service and update cache.
     */
public static void updateProperties(){
    if (settingsSvc == null) {
        return;
    }
    properties.clear();
    Set<Setting> dbSettings = settingsSvc.listAll();
    dbSettings.forEach(s -> properties.put(PREFIX + ""."" + s.getName().substring(1) + (s.getLang() == null ? """" : ""."" + s.getLang()), s.getContent()));
    lastUpdate = Instant.now();
}","public static void updateProperties(){
    if (settingsSvc == null) {
        return;
    }
    properties.clear();
    Set<Setting> dbSettings = settingsSvc.listAll();
    dbSettings.forEach(s -> properties.put(PREFIX + ""."" + s.getName().substring(1) + (s.getLang() == null ? """" : ""."" + s.getLang()), s.getContent()));
    lastUpdate = Instant.now();
}","/**
     * Retrieve settings from the database via service and update cache.
     */","('updateProperties', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",97.0,  Retrieve settings from the database via service and update cache.,11.0,"['Update cache and retrieve settings from the database.', 'Updating cache and retrieving settings from the database are ways to do this.', 'Updating cache and retrieving settings from the database are ways to do that.']"
577,jeromq,org/zeromq/ZCertStore.java,/src/main/java/org/zeromq/ZCertStore.java,checkForChanges,270-293,"/**
     * Check if files in the certificate folders have been added or removed.
     */
 boolean checkForChanges(){
    final Map<File, byte[]> presents = new HashMap<>(fingerprints);
    boolean modified = traverseDirectory(location, new IFileVisitor() {

        @Override
        public boolean visitFile(File file) {
            return modified(presents.remove(file), file);
        }

        @Override
        public boolean visitDir(File dir) {
            return modified(presents.remove(dir), dir);
        }
    });
    return modified || !presents.isEmpty();
}"," boolean checkForChanges(){
    final Map<File, byte[]> presents = new HashMap<>(fingerprints);
    boolean modified = traverseDirectory(location, new IFileVisitor() {

        @Override
        public boolean visitFile(File file) {
            return modified(presents.remove(file), file);
        }

        @Override
        public boolean visitDir(File dir) {
            return modified(presents.remove(dir), dir);
        }
    });
    return modified || !presents.isEmpty();
}","/**
     * Check if files in the certificate folders have been added or removed.
     */","('checkForChanges', {'INSTRUCTION': {'covered': 25, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",98.0,  Check if files in the certificate folders have been added or removed.,13.0,"['If files have been added or removed, you should check them.', 'If files have been added or removed, check them out.', 'If the files have been added or removed, you should check them.']"
578,tablesaw,tech/tablesaw/joining/DataFrameJoiner.java,/core/src/main/java/tech/tablesaw/joining/DataFrameJoiner.java,createMultiColSelection,435-461,"/**
   * Create a big multicolumn selection for all join columns in the given table. Joins two tables.
   *
   * @param table the table that used to generate Selection.
   * @param ri row number of row in table.
   * @param indexes a reverse index for every join column in the table.
   * @param selectionSize max size in table .
   * @param joinColumnIndexes the column index of join key in tables
   * @return selection created
   */
private Selection createMultiColSelection(Table table, int ri, List<Index> indexes, int selectionSize, List<Integer> joinColumnIndexes){
    Selection multiColSelection = Selection.withRange(0, selectionSize);
    int i = 0;
    for (Integer joinColumnIndex : joinColumnIndexes) {
        Column<?> col = table.column(joinColumnIndex);
        Selection oneColSelection = selectionForColumn(col, ri, indexes.get(i));
        multiColSelection = multiColSelection.and(oneColSelection);
        i++;
    }
    return multiColSelection;
}","private Selection createMultiColSelection(Table table, int ri, List<Index> indexes, int selectionSize, List<Integer> joinColumnIndexes){
    Selection multiColSelection = Selection.withRange(0, selectionSize);
    int i = 0;
    for (Integer joinColumnIndex : joinColumnIndexes) {
        Column<?> col = table.column(joinColumnIndex);
        Selection oneColSelection = selectionForColumn(col, ri, indexes.get(i));
        multiColSelection = multiColSelection.and(oneColSelection);
        i++;
    }
    return multiColSelection;
}","/**
   * Create a big multicolumn selection for all join columns in the given table. Joins two tables.
   *
   * @param table the table that used to generate Selection.
   * @param ri row number of row in table.
   * @param indexes a reverse index for every join column in the table.
   * @param selectionSize max size in table .
   * @param joinColumnIndexes the column index of join key in tables
   * @return selection created
   */","('createMultiColSelection', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",98.0,  Create a big multicolumn selection for all join columns in the given table.,14.0,"['A big multicolumn selection is needed for all the columns in the table.', 'A big multicolumn selection is needed for all columns in the table.', 'A big multicolumn selection is needed for all the columns.']"
579,cdk,org/openscience/cdk/layout/IdentityTemplateLibrary.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/IdentityTemplateLibrary.java,store,484-502,"/**
     * Store a template library to the provided output stream.
     *
     * @param out output stream
     * @throws IOException low level IO error
     */
 void store(OutputStream out) throws IOException{
    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(out));
    for (Entry<String, List<Point2d[]>> e : templateMap.entrySet()) {
        for (Point2d[] val : e.getValue()) {
            bw.write(encodeEntry(new AbstractMap.SimpleImmutableEntry<>(e.getKey(), val)));
            bw.write('\n');
        }
    }
    bw.close();
}","void store(OutputStream out) throws IOException{
    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(out));
    for (Entry<String, List<Point2d[]>> e : templateMap.entrySet()) {
        for (Point2d[] val : e.getValue()) {
            bw.write(encodeEntry(new AbstractMap.SimpleImmutableEntry<>(e.getKey(), val)));
            bw.write('\n');
        }
    }
    bw.close();
}","/**
     * Store a template library to the provided output stream.
     *
     * @param out output stream
     * @throws IOException low level IO error
     */","('store', {'INSTRUCTION': {'covered': 50, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",98.0,  Store a template library to the provided output stream.,10.0,"['Store the template library in the output stream.', 'Store a template library.', 'Store the template library in the provided stream.']"
581,cdk,org/openscience/cdk/hash/stereo/DoubleBond3DParity.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/DoubleBond3DParity.java,parity,63-91,"/**
     * Calculate the configuration of the double bond as a parity.
     *
     * @return opposite (+1), together (-1)
     */
public int parity(){
    // create three vectors, v->u, v->w and u->x
    double[] vu = toVector(v, u);
    double[] vw = toVector(v, w);
    double[] ux = toVector(u, x);
    // normal vector (to compare against), the normal vector (n) looks like:
    // x     n w
    // \    |/
    // u = v
    double[] normal = crossProduct(vu, crossProduct(vu, vw));
    // compare the dot products of v->w and u->x, if the signs are the same
    // they are both pointing the same direction. if a value is close to 0
    // then it is at pi/2 radians (i.e. unspecified) however 3D coordinates
    // are generally discrete and do not normally represent on unspecified
    // stereo configurations so we don't check this
    int parity = (int) Math.signum(dot(normal, vw)) * (int) Math.signum(dot(normal, ux));
    // invert sign, this then matches with Sp2 double bond parity
    return parity * -1;
}","public int parity(){
    // create three vectors, v->u, v->w and u->x
    double[] vu = toVector(v, u);
    double[] vw = toVector(v, w);
    double[] ux = toVector(u, x);
    // normal vector (to compare against), the normal vector (n) looks like:
    // x     n w
    // \    |/
    // u = v
    double[] normal = crossProduct(vu, crossProduct(vu, vw));
    // compare the dot products of v->w and u->x, if the signs are the same
    // they are both pointing the same direction. if a value is close to 0
    // then it is at pi/2 radians (i.e. unspecified) however 3D coordinates
    // are generally discrete and do not normally represent on unspecified
    // stereo configurations so we don't check this
    int parity = (int) Math.signum(dot(normal, vw)) * (int) Math.signum(dot(normal, ux));
    // invert sign, this then matches with Sp2 double bond parity
    return parity * -1;
}","/**
     * Calculate the configuration of the double bond as a parity.
     *
     * @return opposite (+1), together (-1)
     */","('parity', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",99.0,  Calculate the configuration of the double bond as a parity.,11.0,"[""The double bond's configuration should be calculated as a parity."", ""The double bond's configuration can be calculated."", 'The double bond has a configuration.']"
582,cdk,org/openscience/cdk/smiles/BeamToCDK.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/BeamToCDK.java,toCDKAtom,604-625,"/**
     * Create a new CDK {@link IAtom} from the Beam Atom.
     *
     * @param beamAtom an Atom from the Beam ChemicalGraph
     * @param hCount   hydrogen count for the atom
     * @return the CDK atom to have it's properties set
     */
 IAtom toCDKAtom(Atom beamAtom, int hCount){
    IAtom cdkAtom = newCDKAtom(beamAtom);
    cdkAtom.setImplicitHydrogenCount(hCount);
    cdkAtom.setFormalCharge(beamAtom.charge());
    if (beamAtom.isotope() >= 0)
        cdkAtom.setMassNumber(beamAtom.isotope());
    if (beamAtom.aromatic())
        cdkAtom.setIsAromatic(true);
    if (beamAtom.atomClass() > 0)
        cdkAtom.setProperty(ATOM_ATOM_MAPPING, beamAtom.atomClass());
    return cdkAtom;
}","IAtom toCDKAtom(Atom beamAtom, int hCount){
    IAtom cdkAtom = newCDKAtom(beamAtom);
    cdkAtom.setImplicitHydrogenCount(hCount);
    cdkAtom.setFormalCharge(beamAtom.charge());
    if (beamAtom.isotope() >= 0)
        cdkAtom.setMassNumber(beamAtom.isotope());
    if (beamAtom.aromatic())
        cdkAtom.setIsAromatic(true);
    if (beamAtom.atomClass() > 0)
        cdkAtom.setProperty(ATOM_ATOM_MAPPING, beamAtom.atomClass());
    return cdkAtom;
}","/**
     * Create a new CDK {@link IAtom} from the Beam Atom.
     *
     * @param beamAtom an Atom from the Beam ChemicalGraph
     * @param hCount   hydrogen count for the atom
     * @return the CDK atom to have it's properties set
     */","('toCDKAtom', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",99.0,  Create a new CDK {@link IAtom} from the Beam Atom.,14.0,"['You can create a new CDK from the beam atom.', 'A new CDK is created from the beam atom.', 'A new CDK @link IAtom can be created.']"
584,openapi-generator,org/openapitools/codegen/validation/GenericValidator.java,/modules/openapi-generator-core/src/main/java/org/openapitools/codegen/validation/GenericValidator.java,validate,38-59,"/**
     * Validates input, resulting in a instance of {@link ValidationResult} which provides details on all validations performed (success, error, warning).
     *
     * @param input The object instance to be validated.
     *
     * @return A {@link ValidationResult} which details the success, error, and warning validation results.
     */
public ValidationResult validate(TInput input){
    ValidationResult result = new ValidationResult();
    if (rules != null) {
        rules.forEach(it -> {
            ValidationRule.Result attempt = it.evaluate(input);
            if (attempt.passed()) {
                result.addResult(Validated.valid(it));
            } else {
                result.addResult(Validated.invalid(it, it.getFailureMessage(), attempt.getDetails()));
            }
        });
    }
    return result;
}","public ValidationResult validate(TInput input){
    ValidationResult result = new ValidationResult();
    if (rules != null) {
        rules.forEach(it -> {
            ValidationRule.Result attempt = it.evaluate(input);
            if (attempt.passed()) {
                result.addResult(Validated.valid(it));
            } else {
                result.addResult(Validated.invalid(it, it.getFailureMessage(), attempt.getDetails()));
            }
        });
    }
    return result;
}","/**
     * Validates input, resulting in a instance of {@link ValidationResult} which provides details on all validations performed (success, error, warning).
     *
     * @param input The object instance to be validated.
     *
     * @return A {@link ValidationResult} which details the success, error, and warning validation results.
     */","('validate', {'INSTRUCTION': {'covered': 15, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",99.0,"  Validates input, resulting in a instance of {@link ValidationResult} which provides details on all validations performed (success, error, warning).",28.0,"['The instance of @link ValidationResult provides details on all validations performed.', 'Validates input, resulting in a instance of @link ValidationResult which provides details on all validations.', 'Validates input, resulting in a instance of @link ValidationResult which provides details on all validations performed.']"
585,weblogic-kubernetes-operator,oracle/kubernetes/weblogic/domain/model/CrdSchemaGenerator.java,/operator/src/main/java/oracle/kubernetes/weblogic/domain/model/CrdSchemaGenerator.java,createCrdSchemaGenerator,15-31,"/**
   * Creates a schema generator, suitably customized for generating Kubernetes CRD schemas.
   */
public static SchemaGenerator createCrdSchemaGenerator(){
    SchemaGenerator generator = new SchemaGenerator();
    generator.defineAdditionalProperties(Quantity.class, ""string"");
    generator.setForbidAdditionalProperties(false);
    generator.setSupportObjectReferences(false);
    generator.setIncludeSchemaReference(false);
    generator.addPackageToSuppressDescriptions(""io.kubernetes.client.openapi.models"");
    generator.defineEnabledFeatures(Optional.ofNullable(TuningParameters.getInstance()).map(TuningParameters::getFeatureGates).map(TuningParameters.FeatureGates::getEnabledFeatures).orElse(Collections.emptyList()));
    return generator;
}","public static SchemaGenerator createCrdSchemaGenerator(){
    SchemaGenerator generator = new SchemaGenerator();
    generator.defineAdditionalProperties(Quantity.class, ""string"");
    generator.setForbidAdditionalProperties(false);
    generator.setSupportObjectReferences(false);
    generator.setIncludeSchemaReference(false);
    generator.addPackageToSuppressDescriptions(""io.kubernetes.client.openapi.models"");
    generator.defineEnabledFeatures(Optional.ofNullable(TuningParameters.getInstance()).map(TuningParameters::getFeatureGates).map(TuningParameters.FeatureGates::getEnabledFeatures).orElse(Collections.emptyList()));
    return generator;
}","/**
   * Creates a schema generator, suitably customized for generating Kubernetes CRD schemas.
   */","('createCrdSchemaGenerator', {'INSTRUCTION': {'covered': 33, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",99.0,"  Creates a schema generator, suitably customized for generating Kubernetes CRD schemas.",13.0,"['The generator is specially designed for generating Kubernetes CRD schemas.', 'The generator is specially designed to generate Kubernetes CRD schemas.', 'The generator is specially designed for generating the Kubernetes CRD schemas.']"
587,matsim-libs,org/matsim/core/network/algorithms/MultimodalNetworkCleaner.java,/matsim/src/main/java/org/matsim/core/network/algorithms/MultimodalNetworkCleaner.java,removeNodesWithoutLinks,61-74,"/**
	 * Removes nodes from the network that have no incoming or outgoing links attached to them.
	 */
public void removeNodesWithoutLinks(){
    List<Node> toBeRemoved = new ArrayList<>();
    for (Node node : this.network.getNodes().values()) {
        if ((node.getInLinks().size() == 0) && (node.getOutLinks().size() == 0)) {
            toBeRemoved.add(node);
        }
    }
    for (Node node : toBeRemoved) {
        this.network.removeNode(node.getId());
    }
}","public void removeNodesWithoutLinks(){
    List<Node> toBeRemoved = new ArrayList<>();
    for (Node node : this.network.getNodes().values()) {
        if ((node.getInLinks().size() == 0) && (node.getOutLinks().size() == 0)) {
            toBeRemoved.add(node);
        }
    }
    for (Node node : toBeRemoved) {
        this.network.removeNode(node.getId());
    }
}","/**
	 * Removes nodes from the network that have no incoming or outgoing links attached to them.
	 */","('removeNodesWithoutLinks', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",100.0,  Removes nodes from the network that have no incoming or outgoing links attached to them.,16.0,"['The network has no incoming or outgoing links for the nodes that have been removed.', 'The network has no incoming or outgoing links for the nodes that are removed.', 'The network has no incoming or outgoing links for the nodes removed.']"
588,anserini,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,convertDocidToLuceneDocid,731-755,"/**
   * Converts a collection docid to a Lucene internal docid.
   *
   * @param reader index reader
   * @param docid collection docid
   * @return corresponding Lucene internal docid, or -1 if docid not found
   */
public static int convertDocidToLuceneDocid(IndexReader reader, String docid){
    try {
        IndexSearcher searcher = new IndexSearcher(reader);
        Query q = new TermQuery(new Term(IndexArgs.ID, docid));
        TopDocs rs = searcher.search(q, 1);
        ScoreDoc[] hits = rs.scoreDocs;
        if (hits == null || hits.length == 0) {
            return -1;
        }
        return hits[0].doc;
    } catch (IOException e) {
        return -1;
    }
}","public static int convertDocidToLuceneDocid(IndexReader reader, String docid){
    try {
        IndexSearcher searcher = new IndexSearcher(reader);
        Query q = new TermQuery(new Term(IndexArgs.ID, docid));
        TopDocs rs = searcher.search(q, 1);
        ScoreDoc[] hits = rs.scoreDocs;
        if (hits == null || hits.length == 0) {
            return -1;
        }
        return hits[0].doc;
    } catch (IOException e) {
        return -1;
    }
}","/**
   * Converts a collection docid to a Lucene internal docid.
   *
   * @param reader index reader
   * @param docid collection docid
   * @return corresponding Lucene internal docid, or -1 if docid not found
   */","('convertDocidToLuceneDocid', {'INSTRUCTION': {'covered': 34, 'missed': 3}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",100.0,  Converts a collection docid to a Lucene internal docid.,10.0,"['A collection docid is converted to a Lucene internal docid.', 'A collection docid can be converted to a Lucene internal docid.', 'A collection docid is converted to a internal docid.']"
589,acs-aem-commons,com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,formatExtensions,126-140,"/**
     * Take the mapped extensions and organize them by individual extension.
     * @param configuredExtensions Map of extension mappings
     * @return Map with extension as keys
     */
private Map<String, String[]> formatExtensions(final Map<String, String> configuredExtensions){
    final Map<String, String[]> extensions = new LinkedHashMap<>();
    for (final Map.Entry<String, String> entry : configuredExtensions.entrySet()) {
        final String ext = entry.getKey().trim();
        extensions.put(ext, entry.getValue().trim().split(""&""));
    }
    return extensions;
}","private Map<String, String[]> formatExtensions(final Map<String, String> configuredExtensions){
    final Map<String, String[]> extensions = new LinkedHashMap<>();
    for (final Map.Entry<String, String> entry : configuredExtensions.entrySet()) {
        final String ext = entry.getKey().trim();
        extensions.put(ext, entry.getValue().trim().split(""&""));
    }
    return extensions;
}","/**
     * Take the mapped extensions and organize them by individual extension.
     * @param configuredExtensions Map of extension mappings
     * @return Map with extension as keys
     */","('formatExtensions', {'INSTRUCTION': {'covered': 33, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",100.0,  Take the mapped extensions and organize them by individual extension.,11.0,"['Take the mapped extensions and organize them by extension.', 'Take the mapped extensions and organize them by their individual extensions.', 'Take the mapped extensions and organize them by individual extension.']"
591,dcache,org/dcache/resilience/data/PoolInfoMap.java,/modules/dcache-resilience/src/main/java/org/dcache/resilience/data/PoolInfoMap.java,verifyConstraints,734-761,"/**
     * <p>A coarse-grained verification that the required and tag constraints
     * of the pool group and its associated storage groups can be met. For the default and each
     * storage unit, it attempts to fulfill the max independent location requirement via the {@link
     * CopyLocationExtractor}.</p>
     *
     * @throws IllegalStateException upon encountering the first set of constraints which cannot be
     *                               met.
     */
public void verifyConstraints(Integer pgindex) throws IllegalStateException{
    Collection<Integer> storageGroups;
    CopyLocationExtractor extractor;
    read.lock();
    try {
        storageGroups = poolGroupToStorage.get(pgindex);
        for (Integer index : storageGroups) {
            StorageUnitConstraints unitConstraints = (StorageUnitConstraints) constraints.get(index);
            int required = unitConstraints.getRequired();
            extractor = new CopyLocationExtractor(unitConstraints.getOneCopyPer(), this);
            verify(pgindex, extractor, required);
        }
    } finally {
        read.unlock();
    }
}","public void verifyConstraints(Integer pgindex) throws IllegalStateException{
    Collection<Integer> storageGroups;
    CopyLocationExtractor extractor;
    read.lock();
    try {
        storageGroups = poolGroupToStorage.get(pgindex);
        for (Integer index : storageGroups) {
            StorageUnitConstraints unitConstraints = (StorageUnitConstraints) constraints.get(index);
            int required = unitConstraints.getRequired();
            extractor = new CopyLocationExtractor(unitConstraints.getOneCopyPer(), this);
            verify(pgindex, extractor, required);
        }
    } finally {
        read.unlock();
    }
}","/**
     * <p>A coarse-grained verification that the required and tag constraints
     * of the pool group and its associated storage groups can be met. For the default and each
     * storage unit, it attempts to fulfill the max independent location requirement via the {@link
     * CopyLocationExtractor}.</p>
     *
     * @throws IllegalStateException upon encountering the first set of constraints which cannot be
     *                               met.
     */","('verifyConstraints', {'INSTRUCTION': {'covered': 44, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",101.0,  <p>A coarse-grained verification that the required and tag constraints  of the pool group and its associated storage groups can be met.,25.0,"['The required and tag constraints of the pool group and its associated storage groups can be verified.', 'The required and tag constraints of the pool group and its associated storage groups can be met.', 'The required and tag constraints of the pool group can be verified.']"
593,weblogic-kubernetes-operator,oracle/kubernetes/operator/logging/LoggingFacade.java,/operator/src/main/java/oracle/kubernetes/operator/logging/LoggingFacade.java,inferCaller,624-649,"/**
   * Obtains caller details, class name and method, to be provided to the actual Logger. This code
   * is adapted from ODLLogRecord, which should yield consistency in reporting using PlatformLogger
   * versus a raw (ODL) Logger. JDK Logger does something similar but utilizes native methods
   * directly.
   */
 CallerDetails inferCaller(){
    CallerDetails details = new CallerDetails();
    Throwable t = new Throwable();
    StackTraceElement[] stack = t.getStackTrace();
    int i = 0;
    while (i < stack.length) {
        StackTraceElement frame = stack[i];
        String cname = frame.getClassName();
        if (!cname.equals(CLASS)) {
            details.clazz = cname;
            details.method = frame.getMethodName();
            break;
        }
        i++;
    }
    return details;
}","CallerDetails inferCaller(){
    CallerDetails details = new CallerDetails();
    Throwable t = new Throwable();
    StackTraceElement[] stack = t.getStackTrace();
    int i = 0;
    while (i < stack.length) {
        StackTraceElement frame = stack[i];
        String cname = frame.getClassName();
        if (!cname.equals(CLASS)) {
            details.clazz = cname;
            details.method = frame.getMethodName();
            break;
        }
        i++;
    }
    return details;
}","/**
   * Obtains caller details, class name and method, to be provided to the actual Logger. This code
   * is adapted from ODLLogRecord, which should yield consistency in reporting using PlatformLogger
   * versus a raw (ODL) Logger. JDK Logger does something similar but utilizes native methods
   * directly.
   */","('inferCaller', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",101.0,"  Obtains caller details, class name and method, to be provided to the actual Logger.",17.0,"['To be provided to the actual Logger, caller details, class name and method are obtained.', 'To be provided to the actual Logger, the caller details, class name and method are obtained.', 'To be provided to the actual Logger, caller details, class name, and method are obtained.']"
594,weblogic-kubernetes-operator,oracle/kubernetes/operator/wlsconfig/WlsServerConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsServerConfig.java,isLocalAdminProtocolChannelSecure,383-409,"/**
   * Check if the admin protocol channel is using a secure protocol like T3S or HTTPS.
   * @return true is a secure protocol is being used
   */
public boolean isLocalAdminProtocolChannelSecure(){
    boolean adminProtocolPortSecure = false;
    boolean adminProtocolPortFound = false;
    if (networkAccessPoints != null) {
        for (NetworkAccessPoint nap : networkAccessPoints) {
            if (nap.isAdminProtocol()) {
                adminProtocolPortFound = true;
                adminProtocolPortSecure = true;
                break;
            }
        }
    }
    if (!adminProtocolPortFound) {
        if (adminPort != null) {
            adminProtocolPortSecure = true;
        } else if (sslListenPort != null) {
            adminProtocolPortSecure = true;
        } else if (listenPort != null) {
            adminProtocolPortSecure = false;
        }
    }
    return adminProtocolPortSecure;
}","public boolean isLocalAdminProtocolChannelSecure(){
    boolean adminProtocolPortSecure = false;
    boolean adminProtocolPortFound = false;
    if (networkAccessPoints != null) {
        for (NetworkAccessPoint nap : networkAccessPoints) {
            if (nap.isAdminProtocol()) {
                adminProtocolPortFound = true;
                adminProtocolPortSecure = true;
                break;
            }
        }
    }
    if (!adminProtocolPortFound) {
        if (adminPort != null) {
            adminProtocolPortSecure = true;
        } else if (sslListenPort != null) {
            adminProtocolPortSecure = true;
        } else if (listenPort != null) {
            adminProtocolPortSecure = false;
        }
    }
    return adminProtocolPortSecure;
}","/**
   * Check if the admin protocol channel is using a secure protocol like T3S or HTTPS.
   * @return true is a secure protocol is being used
   */","('isLocalAdminProtocolChannelSecure', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 13, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",102.0,Check if the admin protocol channel is using a secure protocol like T3S or HTTPS.,16.0,"['Check if the admin protocol channel uses a secure protocol.', 'If the admin protocol channel uses a secure protocol, you should check it.', 'If the admin protocol channel is using a secure protocol, you should check it.']"
595,dcache,org/dcache/services/bulk/handlers/BulkJobCompletionHandler.java,/modules/dcache-bulk/src/main/java/org/dcache/services/bulk/handlers/BulkJobCompletionHandler.java,addChild,107-134,"/**
     * When a job is submitted, it adds itself as the child of a parent job.  When it terminates, it
     * removes itself from the parent list.  The multimap implementation automatically removes the
     * parent key from the table when its child collection is empty.
     * <p>
     * Breadth-first directories do not remove themselves from the map until all their children are
     * registered.
     * <p>
     * Depth-first directories wait for their immediate children to terminate.  Subdirectories of
     * the root expansion node do not add themselves as children, since the expansion is done by
     * recursion rather than exec'ing a new job (as in breadth-first).
     */
public void addChild(BulkJob job){
    Preconditions.checkArgument(job.getParentKey().getRequestId().equals(job.getKey().getRequestId()), ""Job completion listener is "" + ""being shared between two "" + ""different requests! "" + ""This is a bug."");
    synchronized (descendants) {
        Long parentId = job.getParentKey().getJobId();
        Long childId = job.getKey().getJobId();
        descendants.put(parentId, childId);
        LOGGER.trace(""addChild: parent {}, child {}; descendants {}."", parentId, childId, descendants.size());
    }
}","public void addChild(BulkJob job){
    Preconditions.checkArgument(job.getParentKey().getRequestId().equals(job.getKey().getRequestId()), ""Job completion listener is "" + ""being shared between two "" + ""different requests! "" + ""This is a bug."");
    synchronized (descendants) {
        Long parentId = job.getParentKey().getJobId();
        Long childId = job.getKey().getJobId();
        descendants.put(parentId, childId);
        LOGGER.trace(""addChild: parent {}, child {}; descendants {}."", parentId, childId, descendants.size());
    }
}","/**
     * When a job is submitted, it adds itself as the child of a parent job.  When it terminates, it
     * removes itself from the parent list.  The multimap implementation automatically removes the
     * parent key from the table when its child collection is empty.
     * <p>
     * Breadth-first directories do not remove themselves from the map until all their children are
     * registered.
     * <p>
     * Depth-first directories wait for their immediate children to terminate.  Subdirectories of
     * the root expansion node do not add themselves as children, since the expansion is done by
     * recursion rather than exec'ing a new job (as in breadth-first).
     */","('addChild', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",103.0,"  When a job is submitted, it adds itself as the child of a parent job.",17.0,"['The child of a parent job is added when a job is submitted.', 'When a job is submitted, it becomes the child of a parent job.', 'When a job is submitted, it becomes the child of the parent job.']"
596,cdk,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,test,104-132,"/**
     * Is the {@code mapping} of the stereochemistry in the query preserved in
     * the target.
     *
     * @param mapping permutation of the query vertices
     * @return the stereo chemistry is value
     */
public boolean test(final int[] mapping){
    // n.b. not true for unspecified queries e.g. [C@?H](*)(*)*
    if (queryStereoIndices.length > targetStereoIndices.length)
        return false;
    // reset augment group config if it was initialised
    if (groupConfigAdjust != null)
        Arrays.fill(groupConfigAdjust, 0);
    for (final int u : queryStereoIndices) {
        switch(queryTypes[u]) {
            case Tetrahedral:
                if (!checkTetrahedral(u, mapping))
                    return false;
                break;
            case Geometric:
                if (!checkGeometric(u, otherIndex(u), mapping))
                    return false;
                break;
        }
    }
    return true;
}","public boolean test(final int[] mapping){
    // n.b. not true for unspecified queries e.g. [C@?H](*)(*)*
    if (queryStereoIndices.length > targetStereoIndices.length)
        return false;
    // reset augment group config if it was initialised
    if (groupConfigAdjust != null)
        Arrays.fill(groupConfigAdjust, 0);
    for (final int u : queryStereoIndices) {
        switch(queryTypes[u]) {
            case Tetrahedral:
                if (!checkTetrahedral(u, mapping))
                    return false;
                break;
            case Geometric:
                if (!checkGeometric(u, otherIndex(u), mapping))
                    return false;
                break;
        }
    }
    return true;
}","/**
     * Is the {@code mapping} of the stereochemistry in the query preserved in
     * the target.
     *
     * @param mapping permutation of the query vertices
     * @return the stereo chemistry is value
     */","('test', {'INSTRUCTION': {'covered': 56, 'missed': 4}, 'BRANCH': {'covered': 11, 'missed': 2}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",103.0,  Is the {@code mapping} of the stereochemistry in the query preserved in  the target.,18.0,"['Is the @code mapping of the stereochemistry in the query preserved in the target?', 'Is the stereochemistry in the query preserved in the target?', 'Is the @code mapping of the stereochemistry in the query in the target?']"
597,cdk,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,makeAtomsMapsOfBondsMaps,686-707,"/**
     *  This makes maps of matching atoms out of atom maps of matching bonds as produced by the get(Subgraph|Ismorphism)Maps methods.
     *
     * @param  list   The list produced by the getMap method.
     * @param  sourceGraph  The first atom container. Must not be atom IQueryAtomContainer.
     * @param  targetGraph  The second one (first and second as in getMap). May be an QueryAtomContaienr.
     * @return     A Vector of Vectors of CDKRMap objects of matching Atoms.
     */
public static List<List<CDKRMap>> makeAtomsMapsOfBondsMaps(List<List<CDKRMap>> list, IAtomContainer sourceGraph, IAtomContainer targetGraph){
    if (list == null) {
        return list;
    }
    if (targetGraph.getAtomCount() == 1) {
        return list;
    }
    List<List<CDKRMap>> result = new ArrayList<List<CDKRMap>>();
    for (List<CDKRMap> l2 : list) {
        result.add(makeAtomsMapOfBondsMap(l2, sourceGraph, targetGraph));
    }
    return result;
}","public static List<List<CDKRMap>> makeAtomsMapsOfBondsMaps(List<List<CDKRMap>> list, IAtomContainer sourceGraph, IAtomContainer targetGraph){
    if (list == null) {
        return list;
    }
    if (targetGraph.getAtomCount() == 1) {
        return list;
    }
    List<List<CDKRMap>> result = new ArrayList<List<CDKRMap>>();
    for (List<CDKRMap> l2 : list) {
        result.add(makeAtomsMapOfBondsMap(l2, sourceGraph, targetGraph));
    }
    return result;
}","/**
     *  This makes maps of matching atoms out of atom maps of matching bonds as produced by the get(Subgraph|Ismorphism)Maps methods.
     *
     * @param  list   The list produced by the getMap method.
     * @param  sourceGraph  The first atom container. Must not be atom IQueryAtomContainer.
     * @param  targetGraph  The second one (first and second as in getMap). May be an QueryAtomContaienr.
     * @return     A Vector of Vectors of CDKRMap objects of matching Atoms.
     */","('makeAtomsMapsOfBondsMaps', {'INSTRUCTION': {'covered': 32, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",103.0,  This makes maps of matching atoms out of atom maps of matching bonds as produced by the get(Subgraph|Ismorphism)Maps methods.,24.0,"['Maps of matching atoms and bonds are created by using the get(Subgraph)IsmorphismMaps methods.', 'Maps of matching atoms and bonds are produced by using the get(Subgraph)IsmorphismMaps methods.', 'Maps of matching atoms and bonds are created by using the get(subgraph)IsmorphismMaps methods.']"
600,cdk,org/openscience/cdk/geometry/cip/rules/CIPLigandRule.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/rules/CIPLigandRule.java,order,84-98,"/**
     * Order the ligands from high to low precedence according to atomic and mass numbers.
     */
private ILigand[] order(ILigand[] ligands){
    ILigand[] newLigands = new ILigand[ligands.length];
    System.arraycopy(ligands, 0, newLigands, 0, ligands.length);
    Arrays.sort(newLigands, numberRule);
    ILigand[] reverseLigands = new ILigand[newLigands.length];
    for (int i = 0; i < newLigands.length; i++) {
        reverseLigands[(newLigands.length - 1) - i] = newLigands[i];
    }
    return reverseLigands;
}","private ILigand[] order(ILigand[] ligands){
    ILigand[] newLigands = new ILigand[ligands.length];
    System.arraycopy(ligands, 0, newLigands, 0, ligands.length);
    Arrays.sort(newLigands, numberRule);
    ILigand[] reverseLigands = new ILigand[newLigands.length];
    for (int i = 0; i < newLigands.length; i++) {
        reverseLigands[(newLigands.length - 1) - i] = newLigands[i];
    }
    return reverseLigands;
}","/**
     * Order the ligands from high to low precedence according to atomic and mass numbers.
     */","('order', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",104.0,  Order the ligands from high to low precedence according to atomic and mass numbers.,15.0,"['According to mass and atomic numbers, order the ligands from high to low precedence.', 'The ligands should be ordered from high to low precedence.', 'The ligands should be ordered according to the mass and atomic numbers.']"
601,cdk,org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,usingCardinalDirection,238-267,"/**
     * By snapping to the cardinal direction (compass point) of the provided
     * vector, return the position opposite the 'snapped' coordinate.
     *
     * @param opposite position the hydrogen label opposite to this vector
     * @return the position
     */
 static HydrogenPosition usingCardinalDirection(final Vector2d opposite){
    final double theta = Math.atan2(opposite.y, opposite.x);
    final int direction = (int) Math.round(theta / (Math.PI / 4));
    switch(direction) {
        case -4:
        case -3:
            return Right;
        case -2:
            return Above;
        case -1:
        case 0:
        case 1:
            return Left;
        case 2:
            return Below;
        case 3:
        case 4:
            return Right;
    }
    return Right;
}","static HydrogenPosition usingCardinalDirection(final Vector2d opposite){
    final double theta = Math.atan2(opposite.y, opposite.x);
    final int direction = (int) Math.round(theta / (Math.PI / 4));
    switch(direction) {
        case -4:
        case -3:
            return Right;
        case -2:
            return Above;
        case -1:
        case 0:
        case 1:
            return Left;
        case 2:
            return Below;
        case 3:
        case 4:
            return Right;
    }
    return Right;
}","/**
     * By snapping to the cardinal direction (compass point) of the provided
     * vector, return the position opposite the 'snapped' coordinate.
     *
     * @param opposite position the hydrogen label opposite to this vector
     * @return the position
     */","('usingCardinalDirection', {'INSTRUCTION': {'covered': 24, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",104.0,"  By snapping to the cardinal direction (compass point) of the provided  vector, return the position opposite the 'snapped' coordinate.",24.0,"['The position opposite the snapped coordinate can be returned by snapping to the cardinal direction.', 'Return the position opposite the snapped coordinate by snapping to the cardinal direction.', 'Return the position opposite the snapped coordinate by snapping to the cardinal direction of the provided vector.']"
602,anserini,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,documentByField,509-536,"/**
   * Fetches the Lucene {@link Document} based on some field other than its unique collection docid. For example,
   * scientific articles might have DOIs. The method is named to be consistent with Lucene's
   * {@link IndexReader#document(int)}, contra Java's standard method naming conventions.
   *
   * @param reader index reader
   * @param field field
   * @param id unique id
   * @return corresponding Lucene {@link Document} based on the value of a specific field
   */
public static Document documentByField(IndexReader reader, String field, String id){
    try {
        IndexSearcher searcher = new IndexSearcher(reader);
        Query q = new TermQuery(new Term(field, id));
        TopDocs rs = searcher.search(q, 1);
        ScoreDoc[] hits = rs.scoreDocs;
        if (hits == null || hits.length == 0) {
            return null;
        }
        return reader.document(hits[0].doc);
    } catch (IOException e) {
        return null;
    }
}","public static Document documentByField(IndexReader reader, String field, String id){
    try {
        IndexSearcher searcher = new IndexSearcher(reader);
        Query q = new TermQuery(new Term(field, id));
        TopDocs rs = searcher.search(q, 1);
        ScoreDoc[] hits = rs.scoreDocs;
        if (hits == null || hits.length == 0) {
            return null;
        }
        return reader.document(hits[0].doc);
    } catch (IOException e) {
        return null;
    }
}","/**
   * Fetches the Lucene {@link Document} based on some field other than its unique collection docid. For example,
   * scientific articles might have DOIs. The method is named to be consistent with Lucene's
   * {@link IndexReader#document(int)}, contra Java's standard method naming conventions.
   *
   * @param reader index reader
   * @param field field
   * @param id unique id
   * @return corresponding Lucene {@link Document} based on the value of a specific field
   */","('documentByField', {'INSTRUCTION': {'covered': 34, 'missed': 5}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 6, 'missed': 3}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",104.0,  Fetches the Lucene {@link Document} based on some field other than its unique collection docid.,19.0,"['The Lucene @link Document is based on a field other than its unique collection.', 'The Lucene @link Document is based on some field other than its unique collection.', 'The Lucene @link Document is based on something other than its unique collection.']"
603,cdk,org/openscience/cdk/io/MDLRXNWriter.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLRXNWriter.java,formatMDLInt,323-344,"/**
     * Formats an int to fit into the connectiontable and changes it
     * to a String.
     *
     * @param   i  The int to be formated
     * @param   l  Length of the String
     * @return     The String to be written into the connectiontable
     */
private String formatMDLInt(int i, int l){
    String s = """", fs = """";
    NumberFormat nf = NumberFormat.getNumberInstance(Locale.ENGLISH);
    nf.setParseIntegerOnly(true);
    nf.setMinimumIntegerDigits(1);
    nf.setMaximumIntegerDigits(l);
    nf.setGroupingUsed(false);
    s = nf.format(i);
    l = l - s.length();
    for (int f = 0; f < l; f++) fs += "" "";
    fs += s;
    return fs;
}","private String formatMDLInt(int i, int l){
    String s = """", fs = """";
    NumberFormat nf = NumberFormat.getNumberInstance(Locale.ENGLISH);
    nf.setParseIntegerOnly(true);
    nf.setMinimumIntegerDigits(1);
    nf.setMaximumIntegerDigits(l);
    nf.setGroupingUsed(false);
    s = nf.format(i);
    l = l - s.length();
    for (int f = 0; f < l; f++) fs += "" "";
    fs += s;
    return fs;
}","/**
     * Formats an int to fit into the connectiontable and changes it
     * to a String.
     *
     * @param   i  The int to be formated
     * @param   l  Length of the String
     * @return     The String to be written into the connectiontable
     */","('formatMDLInt', {'INSTRUCTION': {'covered': 56, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,  Formats an int to fit into the connectiontable and changes it  to a String.,15.0,"['The int is formatted to fit into the connectiontable.', 'The int is formatted to fit into the connectiontable and changed to a String.', 'The int is formatted to fit into the connectiontable and changed to a string.']"
604,tablesaw,tech/tablesaw/io/FileReader.java,/core/src/main/java/tech/tablesaw/io/FileReader.java,renameDuplicateColumnHeaders,133-153,"/**
   * Renames any column header that appears more than once. Subsequent appearances have ""-[count]""
   * appended; For example, the first (or only) appearance of ""foo"" is named ""foo"", the second
   * appearance is named ""foo-2"" The header array is modified in place.
   *
   * @param headerNames The header names to be potentially adjusted.
   */
private void renameDuplicateColumnHeaders(String[] headerNames){
    Map<String, Integer> nameCounter = new HashMap<>();
    for (int i = 0; i < headerNames.length; i++) {
        String name = headerNames[i];
        Integer count = nameCounter.get(name);
        if (count == null) {
            nameCounter.put(name, 1);
        } else {
            count++;
            nameCounter.put(name, count);
            headerNames[i] = name + ""-"" + count;
        }
    }
}","private void renameDuplicateColumnHeaders(String[] headerNames){
    Map<String, Integer> nameCounter = new HashMap<>();
    for (int i = 0; i < headerNames.length; i++) {
        String name = headerNames[i];
        Integer count = nameCounter.get(name);
        if (count == null) {
            nameCounter.put(name, 1);
        } else {
            count++;
            nameCounter.put(name, count);
            headerNames[i] = name + ""-"" + count;
        }
    }
}","/**
   * Renames any column header that appears more than once. Subsequent appearances have ""-[count]""
   * appended; For example, the first (or only) appearance of ""foo"" is named ""foo"", the second
   * appearance is named ""foo-2"" The header array is modified in place.
   *
   * @param headerNames The header names to be potentially adjusted.
   */","('renameDuplicateColumnHeaders', {'INSTRUCTION': {'covered': 61, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,  Renames any column header that appears more than once.,10.0,"['Rename any column that appears more than once.', 'Rename column headings that appear more than once.', 'Rename any column that appears multiple times.']"
605,cdk,org/openscience/cdk/hash/HashGeneratorMaker.java,/tool/hash/src/main/java/org/openscience/cdk/hash/HashGeneratorMaker.java,makeStereoEncoderFactory,272-289,"/**
     * Combines the separate stereo encoder factories into a single factory.
     *
     * @return a single stereo encoder factory
     */
private StereoEncoderFactory makeStereoEncoderFactory(){
    if (stereoEncoders.isEmpty()) {
        return StereoEncoderFactory.EMPTY;
    } else if (stereoEncoders.size() == 1) {
        return stereoEncoders.get(0);
    } else {
        StereoEncoderFactory factory = new ConjugatedEncoderFactory(stereoEncoders.get(0), stereoEncoders.get(1));
        for (int i = 2; i < stereoEncoders.size(); i++) {
            factory = new ConjugatedEncoderFactory(factory, stereoEncoders.get(i));
        }
        return factory;
    }
}","private StereoEncoderFactory makeStereoEncoderFactory(){
    if (stereoEncoders.isEmpty()) {
        return StereoEncoderFactory.EMPTY;
    } else if (stereoEncoders.size() == 1) {
        return stereoEncoders.get(0);
    } else {
        StereoEncoderFactory factory = new ConjugatedEncoderFactory(stereoEncoders.get(0), stereoEncoders.get(1));
        for (int i = 2; i < stereoEncoders.size(); i++) {
            factory = new ConjugatedEncoderFactory(factory, stereoEncoders.get(i));
        }
        return factory;
    }
}","/**
     * Combines the separate stereo encoder factories into a single factory.
     *
     * @return a single stereo encoder factory
     */","('makeStereoEncoderFactory', {'INSTRUCTION': {'covered': 50, 'missed': 6}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,  Combines the separate stereo encoder factories into a single factory.,11.0,"['There are separate stereo Encoder factories.', 'A single factory is combined with the separate stereo Encoder factories.', 'A single factory is combined with the separate stereo encoder factories.']"
606,tablesaw,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,stratifiedSampleSplit,524-551,"/**
   * Splits the table into two stratified samples, this uses the specified column to divide the
   * table into groups, randomly assigning records to each according to the proportion given in
   * trainingProportion.
   *
   * @param column the column to be used for the stratified sampling
   * @param table1Proportion The proportion to go in the first table
   * @return An array two tables, with the first table having the proportion specified in the method
   *     parameter, and the second table having the balance of the rows
   */
public Table[] stratifiedSampleSplit(CategoricalColumn<?> column, double table1Proportion){
    Preconditions.checkArgument(containsColumn(column), ""The categorical column must be part of the table, you can create a string column and add it to this table before sampling."");
    final Table first = emptyCopy();
    final Table second = emptyCopy();
    splitOn(column).asTableList().forEach(tab -> {
        Table[] splits = tab.sampleSplit(table1Proportion);
        first.append(splits[0]);
        second.append(splits[1]);
    });
    return new Table[] { first, second };
}","public Table[] stratifiedSampleSplit(CategoricalColumn<?> column, double table1Proportion){
    Preconditions.checkArgument(containsColumn(column), ""The categorical column must be part of the table, you can create a string column and add it to this table before sampling."");
    final Table first = emptyCopy();
    final Table second = emptyCopy();
    splitOn(column).asTableList().forEach(tab -> {
        Table[] splits = tab.sampleSplit(table1Proportion);
        first.append(splits[0]);
        second.append(splits[1]);
    });
    return new Table[] { first, second };
}","/**
   * Splits the table into two stratified samples, this uses the specified column to divide the
   * table into groups, randomly assigning records to each according to the proportion given in
   * trainingProportion.
   *
   * @param column the column to be used for the stratified sampling
   * @param table1Proportion The proportion to go in the first table
   * @return An array two tables, with the first table having the proportion specified in the method
   *     parameter, and the second table having the balance of the rows
   */","('stratifiedSampleSplit', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,"  Splits the table into two stratified samples, this uses the specified column to divide the  table into groups, randomly assigning records to each according to the proportion given in  trainingProportion.",33.0,"['The specified column is used to divide the table into two samples and randomly assign records to each sample.', 'The specified column is used to divide the table into two samples and randomly assign records to each of them.', 'The specified column is used to divide the table into two samples and randomly assign records to each sample according to their proportion.']"
607,weblogic-kubernetes-operator,oracle/kubernetes/operator/helpers/KubernetesUtils.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/KubernetesUtils.java,addPatches,65-91,"/**
   * Adds patches to the specified patch builder to correct differences in the current vs required
   * maps.
   *
   * @param patchBuilder a builder for the patches
   * @param basePath     the base for the patch path (excluding the name)
   * @param current      a map of the values found in a Kubernetes resource
   * @param required     a map of the values specified for the resource by the domain
   */
 static void addPatches(JsonPatchBuilder patchBuilder, String basePath, Map<String, String> current, Map<String, String> required){
    for (String name : required.keySet()) {
        String encodedPath = basePath + name.replace(""~"", ""~0"").replace(""/"", ""~1"");
        if (!current.containsKey(name)) {
            patchBuilder.add(encodedPath, required.get(name));
        } else {
            patchBuilder.replace(encodedPath, required.get(name));
        }
    }
}","static void addPatches(JsonPatchBuilder patchBuilder, String basePath, Map<String, String> current, Map<String, String> required){
    for (String name : required.keySet()) {
        String encodedPath = basePath + name.replace(""~"", ""~0"").replace(""/"", ""~1"");
        if (!current.containsKey(name)) {
            patchBuilder.add(encodedPath, required.get(name));
        } else {
            patchBuilder.replace(encodedPath, required.get(name));
        }
    }
}","/**
   * Adds patches to the specified patch builder to correct differences in the current vs required
   * maps.
   *
   * @param patchBuilder a builder for the patches
   * @param basePath     the base for the patch path (excluding the name)
   * @param current      a map of the values found in a Kubernetes resource
   * @param required     a map of the values specified for the resource by the domain
   */","('addPatches', {'INSTRUCTION': {'covered': 44, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,  Adds patches to the specified patch builder to correct differences in the current vs required  maps.,17.0,"['The patches are added to the specified patch builder.', 'The patches are added to the patch builder to correct the differences.', 'The patches are added to the specified patch builder to correct the differences.']"
608,cdk,org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,fixNCNTypes,141-161,"/**
     * Special case, 'NCN+' matches entries that the validation suite say should actually be 'NC=N'.
     * We can achieve 100% compliance by checking if NCN+ is still next to CNN+ or CIM+ after
     * aromatic types are assigned
     *
     * @param symbs symbolic types
     * @param graph adjacency list graph
     */
private void fixNCNTypes(String[] symbs, int[][] graph){
    for (int v = 0; v < graph.length; v++) {
        if (""NCN+"".equals(symbs[v])) {
            boolean foundCNN = false;
            for (int w : graph[v]) {
                foundCNN = foundCNN || ""CNN+"".equals(symbs[w]) || ""CIM+"".equals(symbs[w]);
            }
            if (!foundCNN) {
                symbs[v] = ""NC=N"";
            }
        }
    }
}","private void fixNCNTypes(String[] symbs, int[][] graph){
    for (int v = 0; v < graph.length; v++) {
        if (""NCN+"".equals(symbs[v])) {
            boolean foundCNN = false;
            for (int w : graph[v]) {
                foundCNN = foundCNN || ""CNN+"".equals(symbs[w]) || ""CIM+"".equals(symbs[w]);
            }
            if (!foundCNN) {
                symbs[v] = ""NC=N"";
            }
        }
    }
}","/**
     * Special case, 'NCN+' matches entries that the validation suite say should actually be 'NC=N'.
     * We can achieve 100% compliance by checking if NCN+ is still next to CNN+ or CIM+ after
     * aromatic types are assigned
     *
     * @param symbs symbolic types
     * @param graph adjacency list graph
     */","('fixNCNTypes', {'INSTRUCTION': {'covered': 59, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,"  Special case, 'NCN+' matches entries that the validation suite say should actually be 'NC=N'.",18.0,"[""Special case, 'NCN+' matches entries that the validation suite say should be 'N'."", ""Special case, 'NCN+' matches entries that the validation suite say should be 'N'"", ""Special case, 'NCN+' matches entries that the validation suite say should be 'NC=N'.""]"
609,egeria,org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,/open-metadata-implementation/access-services/asset-lineage/asset-lineage-server/src/main/java/org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,buildRelationalTableContext,264-288,"/**
     * Builds the relational table context for a relational column.
     *
     * @param userId       the unique identifier for the user
     * @param entityDetail the entity for which the context is build
     *
     * @return the relational table context of the relational column
     *
     * @throws OCFCheckedExceptionBase checked exception for reporting errors found when using OCF connectors
     */
private RelationshipsContext buildRelationalTableContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
    Set<GraphContext> context = new HashSet<>();
    EntityDetail schemaType = handlerHelper.addContextForRelationships(userId, entityDetail, ATTRIBUTE_FOR_SCHEMA, context);
    EntityDetail deployedSchemaType = handlerHelper.addContextForRelationships(userId, schemaType, ASSET_SCHEMA_TYPE, context);
    EntityDetail database = handlerHelper.addContextForRelationships(userId, deployedSchemaType, DATA_CONTENT_FOR_DATA_SET, context);
    if (database != null) {
        addConnectionToAssetContext(userId, database, context);
    }
    return new RelationshipsContext(entityDetail.getGUID(), context);
}","private RelationshipsContext buildRelationalTableContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
    Set<GraphContext> context = new HashSet<>();
    EntityDetail schemaType = handlerHelper.addContextForRelationships(userId, entityDetail, ATTRIBUTE_FOR_SCHEMA, context);
    EntityDetail deployedSchemaType = handlerHelper.addContextForRelationships(userId, schemaType, ASSET_SCHEMA_TYPE, context);
    EntityDetail database = handlerHelper.addContextForRelationships(userId, deployedSchemaType, DATA_CONTENT_FOR_DATA_SET, context);
    if (database != null) {
        addConnectionToAssetContext(userId, database, context);
    }
    return new RelationshipsContext(entityDetail.getGUID(), context);
}","/**
     * Builds the relational table context for a relational column.
     *
     * @param userId       the unique identifier for the user
     * @param entityDetail the entity for which the context is build
     *
     * @return the relational table context of the relational column
     *
     * @throws OCFCheckedExceptionBase checked exception for reporting errors found when using OCF connectors
     */","('buildRelationalTableContext', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,  Builds the relational table context for a relational column.,10.0,"['The table context is built for a column.', 'The context for a column in the table is built.', 'The context for a column in a table.']"
610,cdk,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,multipleExtractor,1443-1469,"/**
     * The starting with numeric value is used to show a quantity by which a formula is multiplied.
     * For example: 2H2O really means that a H4O2 unit.
     *
     * @param formula Formula to correct
     * @return        Formula with the correction
     */
private static String multipleExtractor(String formula){
    String recentCompoundCount = ""0"";
    String recentCompound = """";
    boolean found = false;
    for (int f = 0; f < formula.length(); f++) {
        char thisChar = formula.charAt(f);
        if (thisChar >= '0' && thisChar <= '9') {
            if (!found)
                recentCompoundCount += thisChar;
            else
                recentCompound += thisChar;
        } else {
            found = true;
            recentCompound += thisChar;
        }
    }
    return muliplier(recentCompound, Integer.valueOf(recentCompoundCount));
}","private static String multipleExtractor(String formula){
    String recentCompoundCount = ""0"";
    String recentCompound = """";
    boolean found = false;
    for (int f = 0; f < formula.length(); f++) {
        char thisChar = formula.charAt(f);
        if (thisChar >= '0' && thisChar <= '9') {
            if (!found)
                recentCompoundCount += thisChar;
            else
                recentCompound += thisChar;
        } else {
            found = true;
            recentCompound += thisChar;
        }
    }
    return muliplier(recentCompound, Integer.valueOf(recentCompoundCount));
}","/**
     * The starting with numeric value is used to show a quantity by which a formula is multiplied.
     * For example: 2H2O really means that a H4O2 unit.
     *
     * @param formula Formula to correct
     * @return        Formula with the correction
     */","('multipleExtractor', {'INSTRUCTION': {'covered': 63, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,  The starting with numeric value is used to show a quantity by which a formula is multiplied.,18.0,"['The starting value is used to show a number.', 'The starting value is used to show a formula.', 'The starting value is used to show a quantity.']"
611,dataverse,edu/harvard/iq/dataverse/validation/PasswordValidatorUtil.java,/src/main/java/edu/harvard/iq/dataverse/validation/PasswordValidatorUtil.java,parseConfigString,40-55,"/**
     * Parses the list of character rules as defined in the database. Recall how
     * configString is formatted: ""UpperCase:1,LowerCase:1,Digit:1,Special:1""
     */
public static List<CharacterRule> parseConfigString(String configString){
    List<CharacterRule> characterRules = new ArrayList<>();
    String[] typePlusNums = configString.split("","");
    for (String typePlusNum : typePlusNums) {
        String[] configArray = typePlusNum.split("":"");
        String type = configArray[0];
        String num = configArray[1];
        EnglishCharacterData typeData = EnglishCharacterData.valueOf(type);
        characterRules.add(new CharacterRule(typeData, new Integer(num)));
    }
    return characterRules;
}","public static List<CharacterRule> parseConfigString(String configString){
    List<CharacterRule> characterRules = new ArrayList<>();
    String[] typePlusNums = configString.split("","");
    for (String typePlusNum : typePlusNums) {
        String[] configArray = typePlusNum.split("":"");
        String type = configArray[0];
        String num = configArray[1];
        EnglishCharacterData typeData = EnglishCharacterData.valueOf(type);
        characterRules.add(new CharacterRule(typeData, new Integer(num)));
    }
    return characterRules;
}","/**
     * Parses the list of character rules as defined in the database. Recall how
     * configString is formatted: ""UpperCase:1,LowerCase:1,Digit:1,Special:1""
     */","('parseConfigString', {'INSTRUCTION': {'covered': 53, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,  Parses the list of character rules as defined in the database.,12.0,"['The database has a list of character rules.', 'Parses the list of character rules.', 'Parses the list of rules.']"
612,jooby,io/jooby/Environment.java,/jooby/src/main/java/io/jooby/Environment.java,defaults,377-395,"/**
   * Creates a default configuration properties with some common values like: application.tmpdir,
   * application.charset and pid (process ID).
   *
   * @return A configuration object.
   */
public static Config defaults(){
    Path tmpdir = Paths.get(System.getProperty(""user.dir""), ""tmp"");
    Map<String, String> defaultMap = new HashMap<>();
    defaultMap.put(""application.tmpdir"", tmpdir.toString());
    defaultMap.put(""application.charset"", ""UTF-8"");
    String pid = pid();
    if (pid != null) {
        System.setProperty(""PID"", pid);
        defaultMap.put(""pid"", pid);
    }
    return ConfigFactory.parseMap(defaultMap, ""defaults"");
}","public static Config defaults(){
    Path tmpdir = Paths.get(System.getProperty(""user.dir""), ""tmp"");
    Map<String, String> defaultMap = new HashMap<>();
    defaultMap.put(""application.tmpdir"", tmpdir.toString());
    defaultMap.put(""application.charset"", ""UTF-8"");
    String pid = pid();
    if (pid != null) {
        System.setProperty(""PID"", pid);
        defaultMap.put(""pid"", pid);
    }
    return ConfigFactory.parseMap(defaultMap, ""defaults"");
}","/**
   * Creates a default configuration properties with some common values like: application.tmpdir,
   * application.charset and pid (process ID).
   *
   * @return A configuration object.
   */","('defaults', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,  Creates a default configuration properties with some common values like: application.,13.0,"['Default configuration properties are created with some common values.', 'The default configuration properties are: application.', 'Default configuration properties are created with some common values']"
613,jackson-databind,com/fasterxml/jackson/databind/ObjectReader.java,/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java,_prefetchRootDeserializer,2360-2386,"/**
     * Method called to locate deserializer ahead of time, if permitted
     * by configuration. Method also is NOT to throw an exception if
     * access fails.
     */
protected JsonDeserializer<Object> _prefetchRootDeserializer(JavaType valueType){
    if ((valueType == null) || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {
        return null;
    }
    JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);
    if (deser == null) {
        try {
            DeserializationContext ctxt = createDummyDeserializationContext();
            deser = ctxt.findRootValueDeserializer(valueType);
            if (deser != null) {
                _rootDeserializers.put(valueType, deser);
            }
            return deser;
        } catch (JacksonException e) {
        }
    }
    return deser;
}","protected JsonDeserializer<Object> _prefetchRootDeserializer(JavaType valueType){
    if ((valueType == null) || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {
        return null;
    }
    JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);
    if (deser == null) {
        try {
            DeserializationContext ctxt = createDummyDeserializationContext();
            deser = ctxt.findRootValueDeserializer(valueType);
            if (deser != null) {
                _rootDeserializers.put(valueType, deser);
            }
            return deser;
        } catch (JacksonException e) {
        }
    }
    return deser;
}","/**
     * Method called to locate deserializer ahead of time, if permitted
     * by configuration. Method also is NOT to throw an exception if
     * access fails.
     */","('_prefetchRootDeserializer', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",105.0,"  Method called to locate deserializer ahead of time, if permitted  by configuration.",14.0,"['If allowed by configuration, method called to locate deserializer ahead of time.', 'If allowed by configuration, method to locate deserializer ahead of time.', 'If allowed by configuration, method called to locate deserializer.']"
614,cdk,org/openscience/cdk/graph/invariant/InChINumbersTools.java,/storage/inchi/src/main/java/org/openscience/cdk/graph/invariant/InChINumbersTools.java,auxInfo,224-241,"/**
     * Obtain the InChI auxiliary info for the provided structure using
     * using the specified InChI options.
     *
     * @param  container the structure to obtain the numbers of
     * @return auxiliary info
     * @throws CDKException the inchi could not be generated
     */
 static String auxInfo(IAtomContainer container, INCHI_OPTION... options) throws CDKException{
    InChIGeneratorFactory factory = InChIGeneratorFactory.getInstance();
    boolean org = factory.getIgnoreAromaticBonds();
    factory.setIgnoreAromaticBonds(true);
    InChIGenerator gen = factory.getInChIGenerator(container, Arrays.asList(options));
    factory.setIgnoreAromaticBonds(org);
    if (gen.getReturnStatus() != INCHI_RET.OKAY && gen.getReturnStatus() != INCHI_RET.WARNING)
        throw new CDKException(""Could not generate InChI Numbers: "" + gen.getMessage());
    return gen.getAuxInfo();
}"," static String auxInfo(IAtomContainer container, INCHI_OPTION... options) throws CDKException{
    InChIGeneratorFactory factory = InChIGeneratorFactory.getInstance();
    boolean org = factory.getIgnoreAromaticBonds();
    factory.setIgnoreAromaticBonds(true);
    InChIGenerator gen = factory.getInChIGenerator(container, Arrays.asList(options));
    factory.setIgnoreAromaticBonds(org);
    if (gen.getReturnStatus() != INCHI_RET.OKAY && gen.getReturnStatus() != INCHI_RET.WARNING)
        throw new CDKException(""Could not generate InChI Numbers: "" + gen.getMessage());
    return gen.getAuxInfo();
}","/**
     * Obtain the InChI auxiliary info for the provided structure using
     * using the specified InChI options.
     *
     * @param  container the structure to obtain the numbers of
     * @return auxiliary info
     * @throws CDKException the inchi could not be generated
     */","('auxInfo', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",106.0,  Obtain the InChI auxiliary info for the provided structure using  using the specified InChI options.,16.0,"['The specified InChI options can be used to obtain the auxiliary info for the structure.', 'The specified InChI options can be used to obtain the auxiliary info for the provided structure.', 'The specified InChI options can be used to obtain the auxiliary info.']"
616,acs-aem-commons,com/adobe/acs/commons/exporters/impl/users/UsersSaveServlet.java,/bundle/src/main/java/com/adobe/acs/commons/exporters/impl/users/UsersSaveServlet.java,doPost,45-64,"/**
     * Persists the Users to CSV form data to the underlying jcr:content node.
     * @param request the Sling HTTP Request object
     * @param response the Sling HTTP Response object
     * @throws IOException
     * @throws ServletException
     */
public void doPost(SlingHttpServletRequest request, SlingHttpServletResponse response) throws IOException, ServletException{
    response.setContentType(""application/json"");
    response.setCharacterEncoding(""UTF-8"");
    final ValueMap properties = request.getResource().adaptTo(ModifiableValueMap.class);
    final Parameters parameters = new Parameters(request);
    properties.put(GROUP_FILTER, parameters.getGroupFilter());
    properties.put(GROUPS, parameters.getGroups());
    properties.put(CUSTOM_PROPERTIES, parameters.getCustomProperties());
    request.getResourceResolver().commit();
}","public void doPost(SlingHttpServletRequest request, SlingHttpServletResponse response) throws IOException, ServletException{
    response.setContentType(""application/json"");
    response.setCharacterEncoding(""UTF-8"");
    final ValueMap properties = request.getResource().adaptTo(ModifiableValueMap.class);
    final Parameters parameters = new Parameters(request);
    properties.put(GROUP_FILTER, parameters.getGroupFilter());
    properties.put(GROUPS, parameters.getGroups());
    properties.put(CUSTOM_PROPERTIES, parameters.getCustomProperties());
    request.getResourceResolver().commit();
}","/**
     * Persists the Users to CSV form data to the underlying jcr:content node.
     * @param request the Sling HTTP Request object
     * @param response the Sling HTTP Response object
     * @throws IOException
     * @throws ServletException
     */","('doPost', {'INSTRUCTION': {'covered': 39, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",106.0,  Persists the Users to CSV form data to the underlying jcr:content node.,15.0,"['Users form data to the underlying jcr:content.', 'Users form data to the jcr:content.', 'The Users form data to the jcr:content.']"
617,cdk,org/openscience/cdk/smiles/SmilesGenerator.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/SmilesGenerator.java,labels,668-689,"/**
     * Given a molecule (possibly disconnected) compute the labels which
     * would order the atoms by increasing canonical labelling. If the SMILES
     * are isomeric (i.e. stereo and isotope specific) the InChI numbers are
     * used. These numbers are loaded via reflection and the 'cdk-inchi' module
     * should be present on the classpath.
     *
     * @param molecule the molecule to
     * @return the permutation
     * @see Canon
     */
private static int[] labels(int flavour, final IAtomContainer molecule) throws CDKException{
    long[] labels = SmiFlavor.isSet(flavour, SmiFlavor.Isomeric) ? inchiNumbers(molecule) : Canon.label(molecule, GraphUtil.toAdjList(molecule), createComparator(molecule, flavour));
    int[] cpy = new int[labels.length];
    for (int i = 0; i < labels.length; i++) cpy[i] = (int) labels[i] - 1;
    return cpy;
}","private static int[] labels(int flavour, final IAtomContainer molecule) throws CDKException{
    long[] labels = SmiFlavor.isSet(flavour, SmiFlavor.Isomeric) ? inchiNumbers(molecule) : Canon.label(molecule, GraphUtil.toAdjList(molecule), createComparator(molecule, flavour));
    int[] cpy = new int[labels.length];
    for (int i = 0; i < labels.length; i++) cpy[i] = (int) labels[i] - 1;
    return cpy;
}","/**
     * Given a molecule (possibly disconnected) compute the labels which
     * would order the atoms by increasing canonical labelling. If the SMILES
     * are isomeric (i.e. stereo and isotope specific) the InChI numbers are
     * used. These numbers are loaded via reflection and the 'cdk-inchi' module
     * should be present on the classpath.
     *
     * @param molecule the molecule to
     * @return the permutation
     * @see Canon
     */","('labels', {'INSTRUCTION': {'covered': 35, 'missed': 3}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,  Given a molecule (possibly disconnected) compute the labels which  would order the atoms by increasing canonical labelling.,20.0,"['The labels which would order the atoms would be given by a molecule.', 'The labels which would order the atoms would be computed by increasing the number of labels.', 'The labels which would order the atoms would be calculated by increasing the number of labels.']"
618,cdk,org/openscience/cdk/io/MDLV2000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Writer.java,formatMDLInt,1327-1345,"/**
     * Formats an integer to fit into the connection table and changes it
     * to a String.
     *
     * @param x The int to be formated
     * @param n Length of the String
     * @return The String to be written into the connectiontable
     */
protected static String formatMDLInt(int x, int n){
    char[] buf = new char[n];
    Arrays.fill(buf, ' ');
    String val = Integer.toString(x);
    if (val.length() > n)
        val = ""0"";
    int off = n - val.length();
    for (int i = 0; i < val.length(); i++) buf[off + i] = val.charAt(i);
    return new String(buf);
}","protected static String formatMDLInt(int x, int n){
    char[] buf = new char[n];
    Arrays.fill(buf, ' ');
    String val = Integer.toString(x);
    if (val.length() > n)
        val = ""0"";
    int off = n - val.length();
    for (int i = 0; i < val.length(); i++) buf[off + i] = val.charAt(i);
    return new String(buf);
}","/**
     * Formats an integer to fit into the connection table and changes it
     * to a String.
     *
     * @param x The int to be formated
     * @param n Length of the String
     * @return The String to be written into the connectiontable
     */","('formatMDLInt', {'INSTRUCTION': {'covered': 39, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,  Formats an integer to fit into the connection table and changes it  to a String.,16.0,"['The connection table has an integer that can be formatted into a String.', 'The connection table has an integer that can be formatted to fit in.', 'The connection table has an integer that can be formatted to fit in it.']"
619,cdk,org/openscience/cdk/formula/AdductFormula.java,/base/data/src/main/java/org/openscience/cdk/formula/AdductFormula.java,isotopesList,194-212,"/**
     *  Returns a List for looping over all isotopes in this adduct formula.
     *
     * @return    A List with the isotopes in this adduct formula
     */
private List<IIsotope> isotopesList(){
    List<IIsotope> isotopes = new ArrayList<IIsotope>();
    Iterator<IMolecularFormula> componentIterator = components.iterator();
    while (componentIterator.hasNext()) {
        Iterator<IIsotope> compIsotopes = componentIterator.next().isotopes().iterator();
        while (compIsotopes.hasNext()) {
            IIsotope isotope = compIsotopes.next();
            if (!isotopes.contains(isotope)) {
                isotopes.add(isotope);
            }
        }
    }
    return isotopes;
}","private List<IIsotope> isotopesList(){
    List<IIsotope> isotopes = new ArrayList<IIsotope>();
    Iterator<IMolecularFormula> componentIterator = components.iterator();
    while (componentIterator.hasNext()) {
        Iterator<IIsotope> compIsotopes = componentIterator.next().isotopes().iterator();
        while (compIsotopes.hasNext()) {
            IIsotope isotope = compIsotopes.next();
            if (!isotopes.contains(isotope)) {
                isotopes.add(isotope);
            }
        }
    }
    return isotopes;
}","/**
     *  Returns a List for looping over all isotopes in this adduct formula.
     *
     * @return    A List with the isotopes in this adduct formula
     */","('isotopesList', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,  Returns a List for looping over all isotopes in this adduct formula.,13.0,"['This adduct formula returns a List for looping over all the isotopes.', 'This adduct formula has a List for looping over all the isotopes.', 'This adduct formula returns a List for looping over all of the isotopes.']"
620,cactoos,org/cactoos/io/TailOf.java,/src/main/java/org/cactoos/io/TailOf.java,copyPartial,117-140,"/**
     * Copy buffer to response for read count smaller then buffer size.
     * @param buffer The buffer array
     * @param response The response array
     * @param num Number of bytes in response array from previous read
     * @param read Number of bytes read in the buffer
     * @return New count of bytes in the response array
     * @checkstyle ParameterNumberCheck (3 lines)
     */
private int copyPartial(final byte[] buffer, final byte[] response, final int num, final int read){
    final int result;
    if (num > 0) {
        System.arraycopy(response, read, response, 0, this.count - read);
        System.arraycopy(buffer, 0, response, this.count - read, read);
        result = this.count;
    } else {
        System.arraycopy(buffer, 0, response, 0, read);
        result = read;
    }
    return result;
}","private int copyPartial(final byte[] buffer, final byte[] response, final int num, final int read){
    final int result;
    if (num > 0) {
        System.arraycopy(response, read, response, 0, this.count - read);
        System.arraycopy(buffer, 0, response, this.count - read, read);
        result = this.count;
    } else {
        System.arraycopy(buffer, 0, response, 0, read);
        result = read;
    }
    return result;
}","/**
     * Copy buffer to response for read count smaller then buffer size.
     * @param buffer The buffer array
     * @param response The response array
     * @param num Number of bytes in response array from previous read
     * @param read Number of bytes read in the buffer
     * @return New count of bytes in the response array
     * @checkstyle ParameterNumberCheck (3 lines)
     */","('copyPartial', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,  Copy buffer to response for read count smaller then buffer size.,12.0,"['To read count smaller, copy the buffer to the response.', 'The buffer size should be copied to the response for read count.', 'To read count smaller, copy buffer to response.']"
621,dataverse,edu/harvard/iq/dataverse/authorization/groups/impl/explicit/ExplicitGroup.java,/src/main/java/edu/harvard/iq/dataverse/authorization/groups/impl/explicit/ExplicitGroup.java,structuralContains,276-313,"/**
     * Looks at structural containment: whether {@code ra} is part of the
     * group's structure. It mostly the same as {@link #contains(edu.harvard.iq.dataverse.engine.command.DataverseRequest)},
     * except for logical containment. So if an ExplicitGroup contains {@link AuthenticatedUsers} but not
     * a specific {@link AuthenticatedUser} {@code u}, {@code structuralContains(u)}
     * would return {@code false} while {@code contains( request(u, ...) )} would return true;
     * 
     * @param ra
     * @return {@code true} iff the role assignee is structurally a part of the group.
     */
public boolean structuralContains(RoleAssignee ra){
    if (ra instanceof AuthenticatedUser) {
        if (containedAuthenticatedUsers.contains((AuthenticatedUser) ra)) {
            return true;
        }
    } else if (ra instanceof ExplicitGroup) {
        if (containedExplicitGroups.contains((ExplicitGroup) ra)) {
            return true;
        }
    } else {
        if (containedRoleAssignees.contains(ra.getIdentifier())) {
            return true;
        }
    }
    for (ExplicitGroup eg : containedExplicitGroups) {
        if (eg.structuralContains(ra)) {
            return true;
        }
    }
    return false;
}","public boolean structuralContains(RoleAssignee ra){
    if (ra instanceof AuthenticatedUser) {
        if (containedAuthenticatedUsers.contains((AuthenticatedUser) ra)) {
            return true;
        }
    } else if (ra instanceof ExplicitGroup) {
        if (containedExplicitGroups.contains((ExplicitGroup) ra)) {
            return true;
        }
    } else {
        if (containedRoleAssignees.contains(ra.getIdentifier())) {
            return true;
        }
    }
    for (ExplicitGroup eg : containedExplicitGroups) {
        if (eg.structuralContains(ra)) {
            return true;
        }
    }
    return false;
}","/**
     * Looks at structural containment: whether {@code ra} is part of the
     * group's structure. It mostly the same as {@link #contains(edu.harvard.iq.dataverse.engine.command.DataverseRequest)},
     * except for logical containment. So if an ExplicitGroup contains {@link AuthenticatedUsers} but not
     * a specific {@link AuthenticatedUser} {@code u}, {@code structuralContains(u)}
     * would return {@code false} while {@code contains( request(u, ...) )} would return true;
     * 
     * @param ra
     * @return {@code true} iff the role assignee is structurally a part of the group.
     */","('structuralContains', {'INSTRUCTION': {'covered': 50, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,  Looks at structural containment: whether {@code ra} is part of the  group's structure.,19.0,"[""Is @codera part of the group's structure?"", ""Structural containment is whether @codera is part of the group's structure."", ""Structural containment is whether @codera is in the group's structure.""]"
622,cdk,org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,findHeavyAtomsInChain,81-101,"/**
     *  Count and find first heavy atom(s) (non Hydrogens) in a chain.
     *
     * @param  molecule the reference molecule for searching the chain
     * @param  chain  chain to be searched
     * @return        the atom number of the first heavy atom the number of heavy atoms in the chain
     */
public int[] findHeavyAtomsInChain(IAtomContainer molecule, IAtomContainer chain){
    int[] heavy = { -1, -1 };
    int hc = 0;
    for (int i = 0; i < chain.getAtomCount(); i++) {
        if (isHeavyAtom(chain.getAtom(i))) {
            if (heavy[0] < 0) {
                heavy[0] = molecule.indexOf(chain.getAtom(i));
            }
            hc++;
        }
    }
    heavy[1] = hc;
    return heavy;
}","public int[] findHeavyAtomsInChain(IAtomContainer molecule, IAtomContainer chain){
    int[] heavy = { -1, -1 };
    int hc = 0;
    for (int i = 0; i < chain.getAtomCount(); i++) {
        if (isHeavyAtom(chain.getAtom(i))) {
            if (heavy[0] < 0) {
                heavy[0] = molecule.indexOf(chain.getAtom(i));
            }
            hc++;
        }
    }
    heavy[1] = hc;
    return heavy;
}","/**
     *  Count and find first heavy atom(s) (non Hydrogens) in a chain.
     *
     * @param  molecule the reference molecule for searching the chain
     * @param  chain  chain to be searched
     * @return        the atom number of the first heavy atom the number of heavy atoms in the chain
     */","('findHeavyAtomsInChain', {'INSTRUCTION': {'covered': 46, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",107.0,  Count and find first heavy atom(s) (non Hydrogens) in a chain.,17.0,"['Find the first heavy atom in a chain.', 'Find the first heavy atom in the chain.', 'Find the first heavy atom in a chain by counting it.']"
623,dcache,org/dcache/gplazma/plugins/Ldap.java,/modules/gplazma2-ldap/src/main/java/org/dcache/gplazma/plugins/Ldap.java,extractAttributes,632-656,"/**
     * Get set of attributes extracted from the search result.
     *
     * @param <T>    type of extracted type.
     * @param sre    ldap search result.
     * @param attr   search result attribute.
     * @param mapper mapping function to apply to each result element.
     * @return set of attributes.
     * @throws NamingException
     */
private static Set<T> extractAttributes(NamingEnumeration<SearchResult> sre, String attr, Function<String, T> mapper) throws NamingException{
    Set<T> attrs = new HashSet<>();
    while (sre.hasMore()) {
        T v = mapper.apply((String) sre.next().getAttributes().get(attr).get());
        attrs.add(v);
    }
    if (attrs.isEmpty()) {
        throw new NoSuchElementException();
    }
    return attrs;
}","private static Set<T> extractAttributes(NamingEnumeration<SearchResult> sre, String attr, Function<String, T> mapper) throws NamingException{
    Set<T> attrs = new HashSet<>();
    while (sre.hasMore()) {
        T v = mapper.apply((String) sre.next().getAttributes().get(attr).get());
        attrs.add(v);
    }
    if (attrs.isEmpty()) {
        throw new NoSuchElementException();
    }
    return attrs;
}","/**
     * Get set of attributes extracted from the search result.
     *
     * @param <T>    type of extracted type.
     * @param sre    ldap search result.
     * @param attr   search result attribute.
     * @param mapper mapping function to apply to each result element.
     * @return set of attributes.
     * @throws NamingException
     */","('extractAttributes', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",108.0,  Get set of attributes extracted from the search result.,10.0,"['Get the set of attributes from the search result.', 'Get the set of attributes from the search results.', 'Get a set of attributes from the search result.']"
624,tablesaw,tech/tablesaw/api/TimeColumn.java,/core/src/main/java/tech/tablesaw/api/TimeColumn.java,bottom,512-535,"/**
   * Returns the smallest (""bottom"") n values in the column, Does not change the order in this
   * column
   *
   * @param n The maximum number of records to return. The actual number will be smaller if n is
   *     greater than the number of observations in the column
   * @return A list, possibly empty, of the smallest n observations
   */
public List<LocalTime> bottom(int n){
    List<LocalTime> bottom = new ArrayList<>();
    int[] values = data.toIntArray();
    IntArrays.parallelQuickSort(values);
    int rowCount = 0;
    int validCount = 0;
    while (validCount < n && rowCount < size()) {
        int value = values[rowCount];
        if (value != TimeColumnType.missingValueIndicator()) {
            bottom.add(PackedLocalTime.asLocalTime(value));
            validCount++;
        }
        rowCount++;
    }
    return bottom;
}","public List<LocalTime> bottom(int n){
    List<LocalTime> bottom = new ArrayList<>();
    int[] values = data.toIntArray();
    IntArrays.parallelQuickSort(values);
    int rowCount = 0;
    int validCount = 0;
    while (validCount < n && rowCount < size()) {
        int value = values[rowCount];
        if (value != TimeColumnType.missingValueIndicator()) {
            bottom.add(PackedLocalTime.asLocalTime(value));
            validCount++;
        }
        rowCount++;
    }
    return bottom;
}","/**
   * Returns the smallest (""bottom"") n values in the column, Does not change the order in this
   * column
   *
   * @param n The maximum number of records to return. The actual number will be smaller if n is
   *     greater than the number of observations in the column
   * @return A list, possibly empty, of the smallest n observations
   */","('bottom', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",108.0,"  Returns the smallest (""bottom"") n values in the column, Does not change the order in this  column   @param n The maximum number of records to return.",33.0,"['The smallest values in the column are returned, and the maximum number of records to return.', 'The smallest values in the column are returned, but the order in this column is not changed.', 'The smallest values in the column are returned, and the maximum number of records returned.']"
625,cdk,org/openscience/cdk/smiles/BeamToCDK.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/BeamToCDK.java,insert,581-602,"/**
     * Insert the vertex 'v' into sorted position in the array 'vs'.
     *
     * @param v  a vertex (int id)
     * @param vs array of vertices (int ids)
     * @return array with 'u' inserted in sorted order
     */
private static int[] insert(int v, int[] vs){
    final int n = vs.length;
    final int[] ws = Arrays.copyOf(vs, n + 1);
    ws[n] = v;
    for (int i = n; i > 0 && ws[i] < ws[i - 1]; i--) {
        int tmp = ws[i];
        ws[i] = ws[i - 1];
        ws[i - 1] = tmp;
    }
    return ws;
}","private static int[] insert(int v, int[] vs){
    final int n = vs.length;
    final int[] ws = Arrays.copyOf(vs, n + 1);
    ws[n] = v;
    for (int i = n; i > 0 && ws[i] < ws[i - 1]; i--) {
        int tmp = ws[i];
        ws[i] = ws[i - 1];
        ws[i - 1] = tmp;
    }
    return ws;
}","/**
     * Insert the vertex 'v' into sorted position in the array 'vs'.
     *
     * @param v  a vertex (int id)
     * @param vs array of vertices (int ids)
     * @return array with 'u' inserted in sorted order
     */","('insert', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",109.0,  Insert the vertex 'v' into sorted position in the array 'vs'.,15.0,"[""The array 'vs' has the 'v' inserted into it."", ""The array 'vs' has the 'v' in it."", ""The array 'vs' has the 'v' placed into it.""]"
626,acs-aem-commons,com/adobe/acs/commons/util/BufferedServletOutput.java,/bundle/src/main/java/com/adobe/acs/commons/util/BufferedServletOutput.java,close,186-202,"/** 
     * Closing leads to flushing the buffered output stream or writer to the underlying/wrapped response but only in case {@link #flushBufferOnClose} is set to {@code true}.
     * Also this will automatically commit the response in case {@link #flushBuffer} has been called previously!
     * 
     * @throws IOException */
 void close() throws IOException{
    if (flushBufferOnClose) {
        if (ResponseWriteMethod.OUTPUTSTREAM.equals(this.writeMethod) && outputStream != null && getBufferedBytes().length > 0) {
            wrappedResponse.getOutputStream().write(getBufferedBytes());
        } else if (ResponseWriteMethod.WRITER.equals(this.writeMethod) && writer != null && getBufferedString().length() > 0) {
            wrappedResponse.getWriter().write(getBufferedString());
        }
    }
    if (flushWrappedBuffer) {
        wrappedResponse.flushBuffer();
    }
}","void close() throws IOException{
    if (flushBufferOnClose) {
        if (ResponseWriteMethod.OUTPUTSTREAM.equals(this.writeMethod) && outputStream != null && getBufferedBytes().length > 0) {
            wrappedResponse.getOutputStream().write(getBufferedBytes());
        } else if (ResponseWriteMethod.WRITER.equals(this.writeMethod) && writer != null && getBufferedString().length() > 0) {
            wrappedResponse.getWriter().write(getBufferedString());
        }
    }
    if (flushWrappedBuffer) {
        wrappedResponse.flushBuffer();
    }
}","/** 
     * Closing leads to flushing the buffered output stream or writer to the underlying/wrapped response but only in case {@link #flushBufferOnClose} is set to {@code true}.
     * Also this will automatically commit the response in case {@link #flushBuffer} has been called previously!
     * 
     * @throws IOException */","('close', {'INSTRUCTION': {'covered': 40, 'missed': 7}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",109.0,   Closing leads to flushing the buffered output stream or writer to the underlying/wrapped response but only in case {@link #flushBufferOnClose} is set to {@code true}.,33.0,"['If @link #flushBufferOnClose is set to true, the output stream will be flushed to the underlying response.', 'If @link #flushBufferOnClose is set to true, the output stream will be flushed to the underlying/wrapped response.', 'If @link #flushBufferOnClose is set to true, the output stream will be flushed.']"
627,dcache,org/dcache/services/info/base/StatePath.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StatePath.java,equals,135-165,"/**
     * Check whether another path points to the same location.
     *
     * @param otherPath: the other path to compare
     * @return: whether the other path point to the same location.
     */
public boolean equals(Object otherObject){
    if (!(otherObject instanceof StatePath)) {
        return false;
    }
    if (otherObject == this) {
        return true;
    }
    StatePath otherPath = (StatePath) otherObject;
    if (otherPath._elements.size() != _elements.size()) {
        return false;
    }
    for (int i = 0; i < _elements.size(); i++) {
        if (otherPath._elements.get(i) != _elements.get(i)) {
            return false;
        }
    }
    return true;
}","public boolean equals(Object otherObject){
    if (!(otherObject instanceof StatePath)) {
        return false;
    }
    if (otherObject == this) {
        return true;
    }
    StatePath otherPath = (StatePath) otherObject;
    if (otherPath._elements.size() != _elements.size()) {
        return false;
    }
    for (int i = 0; i < _elements.size(); i++) {
        if (otherPath._elements.get(i) != _elements.get(i)) {
            return false;
        }
    }
    return true;
}","/**
     * Check whether another path points to the same location.
     *
     * @param otherPath: the other path to compare
     * @return: whether the other path point to the same location.
     */","('equals', {'INSTRUCTION': {'covered': 44, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",109.0,  Check whether another path points to the same location.,10.0,"['If another path points to the same location, check it.', 'If another path points to the same location, you should check it.', 'If there is another path pointing to the same location, check it.']"
633,dcache,org/dcache/pool/movers/ChecksumChannel.java,/modules/dcache/src/main/java/org/dcache/pool/movers/ChecksumChannel.java,addType,116-145,"/**
     * Ensure that a Checksum is calculated for the supplied ChecksumType.  If the ChecksumType is
     * already registered then this method does nothing, otherwise the ChecksumChannel is updated to
     * calculate the new ChecksumType. If the ChecksumChannel has accepted a contiguous range of
     * data from offset 0 then this method will reread that contiguous range.
     *
     * @param type The algorithm this ChecksumChannel should calculate.
     * @throws IOException if the Channel has already started accepting data and an attempt to
     *                     reread data from disk fails.
     */
public void addType(ChecksumType type) throws IOException{
    synchronized (_digests) {
        if (_digests.stream().map(MessageDigest::getAlgorithm).noneMatch(t -> t.equals(type.getName()))) {
            MessageDigest digest = type.createMessageDigest();
            if (_isChecksumViable) {
                try {
                    updateFromChannel(Collections.singleton(digest), 0L, _nextChecksumOffset);
                } catch (IOException e) {
                    throw new IOException(""Failed when reading received data: "" + messageOrClassName(e), e);
                }
            }
            _digests.add(digest);
        }
    }
}","public void addType(ChecksumType type) throws IOException{
    synchronized (_digests) {
        if (_digests.stream().map(MessageDigest::getAlgorithm).noneMatch(t -> t.equals(type.getName()))) {
            MessageDigest digest = type.createMessageDigest();
            if (_isChecksumViable) {
                try {
                    updateFromChannel(Collections.singleton(digest), 0L, _nextChecksumOffset);
                } catch (IOException e) {
                    throw new IOException(""Failed when reading received data: "" + messageOrClassName(e), e);
                }
            }
            _digests.add(digest);
        }
    }
}","/**
     * Ensure that a Checksum is calculated for the supplied ChecksumType.  If the ChecksumType is
     * already registered then this method does nothing, otherwise the ChecksumChannel is updated to
     * calculate the new ChecksumType. If the ChecksumChannel has accepted a contiguous range of
     * data from offset 0 then this method will reread that contiguous range.
     *
     * @param type The algorithm this ChecksumChannel should calculate.
     * @throws IOException if the Channel has already started accepting data and an attempt to
     *                     reread data from disk fails.
     */","('addType', {'INSTRUCTION': {'covered': 37, 'missed': 9}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 11, 'missed': 3}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",110.0,  Ensure that a Checksum is calculated for the supplied ChecksumType.,11.0,"['The Checksum should be calculated for the supplied ChecksumType.', 'The Checksum should be calculated for the supplied type.', 'The Checksum should be calculated for the supplied check type.']"
634,cdk,org/openscience/cdk/hash/stereo/GeometryEncoder.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometryEncoder.java,encode,82-119,"/**
     * Encodes the {@code centres[]} specified in the constructor as either
     * clockwise/anticlockwise or none. If there is a permutation parity but no
     * geometric parity then we can not encode the configuration and 'true' is
     * returned to indicate the perception is done. If there is no permutation
     * parity this may changed with the next {@code current[]} values and so
     * 'false' is returned.
     *
     *{@inheritDoc}
     */
public boolean encode(long[] current, long[] next){
    int p = permutation.parity(current);
    // if is a permutation parity (all neighbors are different)
    if (p != 0) {
        // multiple with the geometric parity
        int q = geometric.parity() * p;
        // configure anticlockwise/clockwise
        if (q > 0) {
            for (int i : centres) {
                next[i] = current[i] * ANTICLOCKWISE;
            }
        } else if (q < 0) {
            for (int i : centres) {
                next[i] = current[i] * CLOCKWISE;
            }
        }
        // 0 parity ignored
        return true;
    }
    return false;
}","public boolean encode(long[] current, long[] next){
    int p = permutation.parity(current);
    // if is a permutation parity (all neighbors are different)
    if (p != 0) {
        // multiple with the geometric parity
        int q = geometric.parity() * p;
        // configure anticlockwise/clockwise
        if (q > 0) {
            for (int i : centres) {
                next[i] = current[i] * ANTICLOCKWISE;
            }
        } else if (q < 0) {
            for (int i : centres) {
                next[i] = current[i] * CLOCKWISE;
            }
        }
        // 0 parity ignored
        return true;
    }
    return false;
}","/**
     * Encodes the {@code centres[]} specified in the constructor as either
     * clockwise/anticlockwise or none. If there is a permutation parity but no
     * geometric parity then we can not encode the configuration and 'true' is
     * returned to indicate the perception is done. If there is no permutation
     * parity this may changed with the next {@code current[]} values and so
     * 'false' is returned.
     *
     *{@inheritDoc}
     */","('encode', {'INSTRUCTION': {'covered': 72, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",110.0,  Encodes the {@code centres[]} specified in the constructor as either  clockwise/anticlockwise or none.,19.0,"['The @code centres[] specified in the constructor is either clockwise or anticlockwise.', 'The @code centres[] is specified in the constructor as either clockwise or anticlockwise.', 'The @code centers[] specified in the constructor is either clockwise or anticlockwise.']"
635,acs-aem-commons,com/adobe/acs/commons/images/impl/NamedTransformImageServlet.java,/bundle/src/main/java/com/adobe/acs/commons/images/impl/NamedTransformImageServlet.java,transform,246-274,"/**
     * Execute the ImageTransformers as specified by the Request's suffix segments against the Image layer.
     *
     * @param layer the Image layer
     * @param imageTransformersWithParams the transforms and their params
     * @return the transformed Image layer
     */
protected final Layer transform(Layer layer, final ValueMap imageTransformersWithParams){
    for (final String type : imageTransformersWithParams.keySet()) {
        if (StringUtils.equals(TYPE_QUALITY, type)) {
            continue;
        }
        final ImageTransformer imageTransformer = this.imageTransformers.get(type);
        if (imageTransformer == null) {
            log.warn(""Skipping transform. Missing ImageTransformer for type: {}"", type);
            continue;
        }
        final ValueMap transformParams = imageTransformersWithParams.get(type, EMPTY_PARAMS);
        if (transformParams != null) {
            layer = imageTransformer.transform(layer, transformParams);
        }
    }
    return layer;
}","protected final Layer transform(Layer layer, final ValueMap imageTransformersWithParams){
    for (final String type : imageTransformersWithParams.keySet()) {
        if (StringUtils.equals(TYPE_QUALITY, type)) {
            continue;
        }
        final ImageTransformer imageTransformer = this.imageTransformers.get(type);
        if (imageTransformer == null) {
            log.warn(""Skipping transform. Missing ImageTransformer for type: {}"", type);
            continue;
        }
        final ValueMap transformParams = imageTransformersWithParams.get(type, EMPTY_PARAMS);
        if (transformParams != null) {
            layer = imageTransformer.transform(layer, transformParams);
        }
    }
    return layer;
}","/**
     * Execute the ImageTransformers as specified by the Request's suffix segments against the Image layer.
     *
     * @param layer the Image layer
     * @param imageTransformersWithParams the transforms and their params
     * @return the transformed Image layer
     */","('transform', {'INSTRUCTION': {'covered': 39, 'missed': 6}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 9, 'missed': 3}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",110.0,  Execute the ImageTransformers as specified by the Request's suffix segments against the Image layer.,16.0,"[""The image transformer is executed as specified by the Request's suffix segments."", 'The image transformer is executed as specified by the request.', ""The image transformer is executed as specified by the request's suffix segments.""]"
636,jackson-databind,com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java,/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java,withProperty,307-329,"/**
     * Fluent copy method that creates a new instance that is a copy
     * of this instance except for one additional property that is
     * passed as the argument.
     * Note that method does not modify this instance but constructs
     * and returns a new one.
     */
public BeanPropertyMap withProperty(SettableBeanProperty newProp){
    String key = getPropertyName(newProp);
    for (int i = 1, end = _hashArea.length; i < end; i += 2) {
        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];
        if ((prop != null) && prop.getName().equals(key)) {
            return new BeanPropertyMap(this, newProp, i, _findFromOrdered(prop));
        }
    }
    final int slot = _hashCode(key);
    return new BeanPropertyMap(this, newProp, key, slot);
}","public BeanPropertyMap withProperty(SettableBeanProperty newProp){
    String key = getPropertyName(newProp);
    for (int i = 1, end = _hashArea.length; i < end; i += 2) {
        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];
        if ((prop != null) && prop.getName().equals(key)) {
            return new BeanPropertyMap(this, newProp, i, _findFromOrdered(prop));
        }
    }
    final int slot = _hashCode(key);
    return new BeanPropertyMap(this, newProp, key, slot);
}","/**
     * Fluent copy method that creates a new instance that is a copy
     * of this instance except for one additional property that is
     * passed as the argument.
     * Note that method does not modify this instance but constructs
     * and returns a new one.
     */","('withProperty', {'INSTRUCTION': {'covered': 50, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",110.0,  Fluent copy method that creates a new instance that is a copy  of this instance except for one additional property that is  passed as the argument.,27.0,"['A fluent copy method creates a new instance that is a copy of this instance except for one additional property that is passed as the argument.', 'A fluent copy method creates a new instance that is a copy of this instance except for one property that is passed as the argument.', 'A fluent copy method creates a new instance that is a copy of this instance, except for one additional property that is passed as the argument.']"
637,cdk,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,orderList,417-436,"/**
     * Put the order the List of IIsotope according the probability occurrence.
     *
     * @param isotopes_TO  The List of IIsotope
     * @return             The list of IIsotope ordered
     */
private List<IIsotope> orderList(List<IIsotope> isotopes_TO){
    List<IIsotope> newOrderList = new ArrayList<IIsotope>();
    for (int i = 0; i < orderElements.length; i++) {
        String symbol = orderElements[i];
        Iterator<IIsotope> itIso = isotopes_TO.iterator();
        while (itIso.hasNext()) {
            IIsotope isotopeToCo = itIso.next();
            if (isotopeToCo.getSymbol().equals(symbol)) {
                newOrderList.add(isotopeToCo);
            }
        }
    }
    return newOrderList;
}","private List<IIsotope> orderList(List<IIsotope> isotopes_TO){
    List<IIsotope> newOrderList = new ArrayList<IIsotope>();
    for (int i = 0; i < orderElements.length; i++) {
        String symbol = orderElements[i];
        Iterator<IIsotope> itIso = isotopes_TO.iterator();
        while (itIso.hasNext()) {
            IIsotope isotopeToCo = itIso.next();
            if (isotopeToCo.getSymbol().equals(symbol)) {
                newOrderList.add(isotopeToCo);
            }
        }
    }
    return newOrderList;
}","/**
     * Put the order the List of IIsotope according the probability occurrence.
     *
     * @param isotopes_TO  The List of IIsotope
     * @return             The list of IIsotope ordered
     */","('orderList', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",111.0,  Put the order the List of IIsotope according the probability occurrence.,12.0,"['The order of the List of IIsotope should be determined by the probability occurrence.', 'The order of the List of IIsotope should be decided by the probability occurrence.', 'The order of the List of IIsotope should reflect the probability occurrence.']"
638,metrics,io/dropwizard/metrics5/collectd/PacketWriter.java,/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/PacketWriter.java,signPacket,140-168,"/**
     * Signs the provided packet, so a CollectD server can verify that its authenticity.
     * Wire format:
     * <pre>
     * +-------------------------------+-------------------------------+
     * ! Type (0x0200)                 ! Length                        !
     * +-------------------------------+-------------------------------+
     * ! Signature (SHA2(username + packet))                           \
     * +-------------------------------+-------------------------------+
     * ! Username                      ! Packet                        \
     * +---------------------------------------------------------------+
     * </pre>
     *
     * @see <a href=""https://collectd.org/wiki/index.php/Binary_protocol#Signature_part"">
     * Binary protocol - CollectD | Signature part</a>
     */
private ByteBuffer signPacket(ByteBuffer packet){
    final byte[] signature = sign(password, (ByteBuffer) ByteBuffer.allocate(packet.remaining() + username.length).put(username).put(packet).flip());
    return (ByteBuffer) ByteBuffer.allocate(BUFFER_SIZE).putShort((short) TYPE_SIGN_SHA256).putShort((short) (username.length + SIGNATURE_LEN)).put(signature).put(username).put((ByteBuffer) packet.flip()).flip();
}","private ByteBuffer signPacket(ByteBuffer packet){
    final byte[] signature = sign(password, (ByteBuffer) ByteBuffer.allocate(packet.remaining() + username.length).put(username).put(packet).flip());
    return (ByteBuffer) ByteBuffer.allocate(BUFFER_SIZE).putShort((short) TYPE_SIGN_SHA256).putShort((short) (username.length + SIGNATURE_LEN)).put(signature).put(username).put((ByteBuffer) packet.flip()).flip();
}","/**
     * Signs the provided packet, so a CollectD server can verify that its authenticity.
     * Wire format:
     * <pre>
     * +-------------------------------+-------------------------------+
     * ! Type (0x0200)                 ! Length                        !
     * +-------------------------------+-------------------------------+
     * ! Signature (SHA2(username + packet))                           \
     * +-------------------------------+-------------------------------+
     * ! Username                      ! Packet                        \
     * +---------------------------------------------------------------+
     * </pre>
     *
     * @see <a href=""https://collectd.org/wiki/index.php/Binary_protocol#Signature_part"">
     * Binary protocol - CollectD | Signature part</a>
     */","('signPacket', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",111.0,"  Signs the provided packet, so a CollectD server can verify that its authenticity.",15.0,"['A CollectD server can verify the authenticity of the packet if it is signs.', 'A CollectD server can verify the authenticity of the packet if it is signed.', 'A CollectD server can verify the authenticity of the provided packet if it is signs.']"
639,cdk,org/openscience/cdk/io/WriterFactory.java,/storage/io/src/main/java/org/openscience/cdk/io/WriterFactory.java,findChemFormats,73-93,"/**
     * Finds IChemFormats that provide a container for serialization for the
     * given features. The syntax of the integer is explained in the DataFeatures class.
     *
     * @param  features the data features for which a IChemFormat is searched
     * @return          an array of IChemFormat's that can contain the given features
     *
     * @see    org.openscience.cdk.tools.DataFeatures
     */
public IChemFormat[] findChemFormats(int features){
    if (formats == null)
        loadFormats();
    Iterator<IChemFormat> iter = formats.iterator();
    List<IChemFormat> matches = new ArrayList<IChemFormat>();
    while (iter.hasNext()) {
        IChemFormat format = (IChemFormat) iter.next();
        if ((format.getSupportedDataFeatures() & features) == features)
            matches.add(format);
    }
    return (IChemFormat[]) matches.toArray(new IChemFormat[matches.size()]);
}","public IChemFormat[] findChemFormats(int features){
    if (formats == null)
        loadFormats();
    Iterator<IChemFormat> iter = formats.iterator();
    List<IChemFormat> matches = new ArrayList<IChemFormat>();
    while (iter.hasNext()) {
        IChemFormat format = (IChemFormat) iter.next();
        if ((format.getSupportedDataFeatures() & features) == features)
            matches.add(format);
    }
    return (IChemFormat[]) matches.toArray(new IChemFormat[matches.size()]);
}","/**
     * Finds IChemFormats that provide a container for serialization for the
     * given features. The syntax of the integer is explained in the DataFeatures class.
     *
     * @param  features the data features for which a IChemFormat is searched
     * @return          an array of IChemFormat's that can contain the given features
     *
     * @see    org.openscience.cdk.tools.DataFeatures
     */","('findChemFormats', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",111.0,  Finds IChemFormats that provide a container for serialization for the  given features.,13.0,"['IChemFormats provide a container for serialization.', 'IChemFormats give a container for serialization for certain features.', 'IChemFormats give a container for serialization.']"
641,jacoco-plugin,hudson/plugins/jacoco/report/SourceAnnotator.java,/src/main/java/hudson/plugins/jacoco/report/SourceAnnotator.java,printHighlightedLine,77-102,"/**
     * Formats a source code line
     * 
     * @param buf
     *            source to write to.
     * @param lineNumber
     *            line number to output
     * @param cov
     *            branch coverage data for this line
     * @param sourceLine
     *            source code line
     * @param status
     *            coverage status of this line
     */
private void printHighlightedLine(StringBuilder buf, int lineNumber, ICounter cov, String sourceLine, int status){
    buf.append(lineNumber).append("":"");
    String tooltip = getTooltip(cov);
    if (tooltip != null) {
        buf.append(""<SPAN title=\"""").append(tooltip).append(""\"""");
    } else {
        buf.append("" <SPAN"");
    }
    buf.append("" style=\""BACKGROUND-COLOR: "").append(getStatusColor(status)).append(""\"">"").append(sourceLine).append(""</SPAN>"").append(""<br>"");
}","private void printHighlightedLine(StringBuilder buf, int lineNumber, ICounter cov, String sourceLine, int status){
    buf.append(lineNumber).append("":"");
    String tooltip = getTooltip(cov);
    if (tooltip != null) {
        buf.append(""<SPAN title=\"""").append(tooltip).append(""\"""");
    } else {
        buf.append("" <SPAN"");
    }
    buf.append("" style=\""BACKGROUND-COLOR: "").append(getStatusColor(status)).append(""\"">"").append(sourceLine).append(""</SPAN>"").append(""<br>"");
}","/**
     * Formats a source code line
     * 
     * @param buf
     *            source to write to.
     * @param lineNumber
     *            line number to output
     * @param cov
     *            branch coverage data for this line
     * @param sourceLine
     *            source code line
     * @param status
     *            coverage status of this line
     */","('printHighlightedLine', {'INSTRUCTION': {'covered': 38, 'missed': 4}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",111.0,  Formats a source code line    @param buf  source to write to.,13.0,"['Write a source code line to it.', 'A source code line is formatted.', 'The source code line is formatted.']"
642,dataverse,edu/harvard/iq/dataverse/authorization/providers/shib/ShibUtil.java,/src/main/java/edu/harvard/iq/dataverse/authorization/providers/shib/ShibUtil.java,findBestFirstAndLastName,76-109,"/**
     * @param firstName First or ""given"" name.
     * @param lastName Last or ""family"" name.
     * @param displayName Only used if first and last are not provided.
     * @return ShibUserNameFields contains separate first and last name fields.
     *
     * @todo Do something more intelligent with displayName. By comparing
     * displayName to the firstName and lastName strings, we should be able to
     * figure out where the proper split is, like this:
     *
     * - ""Guido|van Rossum""
     *
     * - ""Philip Seymour|Hoffman"" (see FirstNameTest.java)
     *
     * Also, we currently compel all Shibboleth IdPs to send us firstName and
     * lastName so the logic to handle null/empty values for firstName and
     * lastName is only currently exercised by the GitHub Identity Provider. As
     * such this method should be moved out of ShibUtil and somewhere that does
     * more generic processing of user information.
     */
public static ShibUserNameFields findBestFirstAndLastName(String firstName, String lastName, String displayName){
    firstName = findSingleValue(firstName);
    lastName = findSingleValue(lastName);
    if ((firstName == null || firstName.isEmpty()) && (lastName == null || lastName.isEmpty())) {
        if (displayName != null) {
            String[] parts = displayName.split("" "");
            if (parts.length > 1) {
                return new ShibUserNameFields(parts[0], parts[1]);
            }
        }
    }
    return new ShibUserNameFields(firstName, lastName);
}","public static ShibUserNameFields findBestFirstAndLastName(String firstName, String lastName, String displayName){
    firstName = findSingleValue(firstName);
    lastName = findSingleValue(lastName);
    if ((firstName == null || firstName.isEmpty()) && (lastName == null || lastName.isEmpty())) {
        if (displayName != null) {
            String[] parts = displayName.split("" "");
            if (parts.length > 1) {
                return new ShibUserNameFields(parts[0], parts[1]);
            }
        }
    }
    return new ShibUserNameFields(firstName, lastName);
}","/**
     * @param firstName First or ""given"" name.
     * @param lastName Last or ""family"" name.
     * @param displayName Only used if first and last are not provided.
     * @return ShibUserNameFields contains separate first and last name fields.
     *
     * @todo Do something more intelligent with displayName. By comparing
     * displayName to the firstName and lastName strings, we should be able to
     * figure out where the proper split is, like this:
     *
     * - ""Guido|van Rossum""
     *
     * - ""Philip Seymour|Hoffman"" (see FirstNameTest.java)
     *
     * Also, we currently compel all Shibboleth IdPs to send us firstName and
     * lastName so the logic to handle null/empty values for firstName and
     * lastName is only currently exercised by the GitHub Identity Provider. As
     * such this method should be moved out of ShibUtil and somewhere that does
     * more generic processing of user information.
     */","('findBestFirstAndLastName', {'INSTRUCTION': {'covered': 39, 'missed': 3}, 'BRANCH': {'covered': 7, 'missed': 5}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",112.0,"  @param firstName First or ""given"" name.",10.0,"['First or ""given"" name is used.', 'First name is given.', 'First or ""given"" is the name.']"
643,dcache,org/dcache/services/billing/text/BillingParserBuilder.java,/modules/dcache/src/main/java/org/dcache/services/billing/text/BillingParserBuilder.java,toAttributes,263-277,"/**
     * Returns names of all attributes in the provided billing format.
     */
private static Set<String> toAttributes(String format){
    Set<String> attributes = new HashSet<>();
    Matcher matcher = ATTRIBUTE_PATTERN.matcher(format);
    while (matcher.find()) {
        String expression = matcher.group(1);
        if (!isIf(expression) && !isElse(expression) && !isEndIf(expression)) {
            int pos = expression.indexOf(';');
            attributes.add(pos > -1 ? expression.substring(0, pos) : expression);
        }
    }
    return attributes;
}","private static Set<String> toAttributes(String format){
    Set<String> attributes = new HashSet<>();
    Matcher matcher = ATTRIBUTE_PATTERN.matcher(format);
    while (matcher.find()) {
        String expression = matcher.group(1);
        if (!isIf(expression) && !isElse(expression) && !isEndIf(expression)) {
            int pos = expression.indexOf(';');
            attributes.add(pos > -1 ? expression.substring(0, pos) : expression);
        }
    }
    return attributes;
}","/**
     * Returns names of all attributes in the provided billing format.
     */","('toAttributes', {'INSTRUCTION': {'covered': 38, 'missed': 5}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",112.0,  Returns names of all attributes in the provided billing format.,11.0,"['The names of all attributes are returned.', 'All attributes are returned in the provided billing format.', 'All attributes are returned in the billing format.']"
644,cdk,org/openscience/cdk/tools/diff/tree/Point3dDifference.java,/misc/diff/src/main/java/org/openscience/cdk/tools/diff/tree/Point3dDifference.java,toString,63-84,"/**
     * Returns a {@link String} representation for this {@link IDifference}.
     *
     * @return a {@link String}
     */
public String toString(){
    if (differences.size() == 0)
        return """";
    StringBuffer diffBuffer = new StringBuffer();
    diffBuffer.append(this.name).append('{');
    Iterator<IDifference> children = getChildren().iterator();
    while (children.hasNext()) {
        diffBuffer.append(children.next().toString());
        if (children.hasNext()) {
            diffBuffer.append("", "");
        }
    }
    diffBuffer.append('}');
    return diffBuffer.toString();
}","public String toString(){
    if (differences.size() == 0)
        return """";
    StringBuffer diffBuffer = new StringBuffer();
    diffBuffer.append(this.name).append('{');
    Iterator<IDifference> children = getChildren().iterator();
    while (children.hasNext()) {
        diffBuffer.append(children.next().toString());
        if (children.hasNext()) {
            diffBuffer.append("", "");
        }
    }
    diffBuffer.append('}');
    return diffBuffer.toString();
}","/**
     * Returns a {@link String} representation for this {@link IDifference}.
     *
     * @return a {@link String}
     */","('toString', {'INSTRUCTION': {'covered': 44, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",112.0,  Returns a {@link String} representation for this {@link IDifference}.,16.0,"['A @link String representation is returned.', 'The @link String representation is returned.', 'The @link String representation is for the difference.']"
645,cdk,org/openscience/cdk/smsd/algorithm/mcsplus/MCSPlusHandler.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/mcsplus/MCSPlusHandler.java,searchMCS,93-116,"/** {@inheritDoc}
     * Function is called by the main program and serves as a starting point for the comparison procedure.
     *
     * @param shouldMatchBonds
     */
public synchronized void searchMCS(boolean shouldMatchBonds){
    List<List<Integer>> mappings = null;
    try {
        if (source.getAtomCount() >= target.getAtomCount()) {
            mappings = new MCSPlus().getOverlaps(source, target, shouldMatchBonds);
        } else {
            flagExchange = true;
            mappings = new MCSPlus().getOverlaps(target, source, shouldMatchBonds);
        }
        PostFilter.filter(mappings);
        setAllMapping();
        setAllAtomMapping();
        setFirstMapping();
        setFirstAtomMapping();
    } catch (CDKException e) {
        mappings = null;
    }
}","public synchronized void searchMCS(boolean shouldMatchBonds){
    List<List<Integer>> mappings = null;
    try {
        if (source.getAtomCount() >= target.getAtomCount()) {
            mappings = new MCSPlus().getOverlaps(source, target, shouldMatchBonds);
        } else {
            flagExchange = true;
            mappings = new MCSPlus().getOverlaps(target, source, shouldMatchBonds);
        }
        PostFilter.filter(mappings);
        setAllMapping();
        setAllAtomMapping();
        setFirstMapping();
        setFirstAtomMapping();
    } catch (CDKException e) {
        mappings = null;
    }
}","/** {@inheritDoc}
     * Function is called by the main program and serves as a starting point for the comparison procedure.
     *
     * @param shouldMatchBonds
     */","('searchMCS', {'INSTRUCTION': {'covered': 46, 'missed': 3}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",113.0, {@inheritDoc}  Function is called by the main program and serves as a starting point for the comparison procedure.,22.0,"['The function is a starting point for the comparison procedure.', 'The function is called by the main program and serves as a starting point for the comparison procedure.', 'The function is called by the main program and serves as a starting point.']"
646,cdk,org/openscience/cdk/geometry/cip/CIPTool.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/CIPTool.java,defineLigancyFourChirality,280-305,"/**
     * Creates a ligancy for chirality around a single chiral atom, where the involved
     * atoms are identified by there index in the {@link IAtomContainer}. For the four ligand
     * atoms, {@link #HYDROGEN} can be passed as index, which will indicate the presence of
     * an implicit hydrogen, not explicitly present in the chemical graph of the
     * given <code>container</code>.
     *
     * @param container  {@link IAtomContainer} for which the returned {@link ILigand}s are defined
     * @param chiralAtom int pointing to the {@link IAtom} index of the chiral atom
     * @param ligand1    int pointing to the {@link IAtom} index of the first {@link ILigand}
     * @param ligand2    int pointing to the {@link IAtom} index of the second {@link ILigand}
     * @param ligand3    int pointing to the {@link IAtom} index of the third {@link ILigand}
     * @param ligand4    int pointing to the {@link IAtom} index of the fourth {@link ILigand}
     * @param stereo     {@link Stereo} for the chirality
     * @return           the created {@link LigancyFourChirality}
     */
public static LigancyFourChirality defineLigancyFourChirality(IAtomContainer container, int chiralAtom, int ligand1, int ligand2, int ligand3, int ligand4, Stereo stereo){
    int[] atomIndices = { ligand1, ligand2, ligand3, ligand4 };
    VisitedAtoms visitedAtoms = new VisitedAtoms();
    ILigand[] ligands = new ILigand[4];
    for (int i = 0; i < 4; i++) {
        ligands[i] = defineLigand(container, visitedAtoms, chiralAtom, atomIndices[i]);
    }
    return new LigancyFourChirality(container.getAtom(chiralAtom), ligands, stereo);
}","public static LigancyFourChirality defineLigancyFourChirality(IAtomContainer container, int chiralAtom, int ligand1, int ligand2, int ligand3, int ligand4, Stereo stereo){
    int[] atomIndices = { ligand1, ligand2, ligand3, ligand4 };
    VisitedAtoms visitedAtoms = new VisitedAtoms();
    ILigand[] ligands = new ILigand[4];
    for (int i = 0; i < 4; i++) {
        ligands[i] = defineLigand(container, visitedAtoms, chiralAtom, atomIndices[i]);
    }
    return new LigancyFourChirality(container.getAtom(chiralAtom), ligands, stereo);
}","/**
     * Creates a ligancy for chirality around a single chiral atom, where the involved
     * atoms are identified by there index in the {@link IAtomContainer}. For the four ligand
     * atoms, {@link #HYDROGEN} can be passed as index, which will indicate the presence of
     * an implicit hydrogen, not explicitly present in the chemical graph of the
     * given <code>container</code>.
     *
     * @param container  {@link IAtomContainer} for which the returned {@link ILigand}s are defined
     * @param chiralAtom int pointing to the {@link IAtom} index of the chiral atom
     * @param ligand1    int pointing to the {@link IAtom} index of the first {@link ILigand}
     * @param ligand2    int pointing to the {@link IAtom} index of the second {@link ILigand}
     * @param ligand3    int pointing to the {@link IAtom} index of the third {@link ILigand}
     * @param ligand4    int pointing to the {@link IAtom} index of the fourth {@link ILigand}
     * @param stereo     {@link Stereo} for the chirality
     * @return           the created {@link LigancyFourChirality}
     */","('defineLigancyFourChirality', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",113.0,"  Creates a ligancy for chirality around a single chiral atom, where the involved  atoms are identified by there index in the {@link IAtomContainer}.",28.0,"['There is a ligancy around a single atom, where the involved atoms are identified by there index in the IAtomContainer.', 'There is a ligancy around a single atom, where the involved atoms are identified by there index.', 'There is a ligancy around a single chiral atom, where the involved atoms are identified by there index in the IAtomContainer.']"
647,cdk,org/openscience/cdk/hash/stereo/BasicPermutationParity.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/BasicPermutationParity.java,parity,55-77,"/**
     * The number values to check is typically small ({@literal < 5}) and thus
     * we use brute-force to count the number of inversions.
     *
     *{@inheritDoc}
     */
public int parity(long[] current){
    int count = 0;
    for (int i = 0, n = indices.length; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int cmp = compare(current[indices[i]], current[indices[j]]);
            if (cmp == 0)
                return 0;
            else if (cmp > 0)
                count++;
        }
    }
    // value is odd, -1 or value is even +1
    return Integer.lowestOneBit(count) == 1 ? -1 : +1;
}","public int parity(long[] current){
    int count = 0;
    for (int i = 0, n = indices.length; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int cmp = compare(current[indices[i]], current[indices[j]]);
            if (cmp == 0)
                return 0;
            else if (cmp > 0)
                count++;
        }
    }
    // value is odd, -1 or value is even +1
    return Integer.lowestOneBit(count) == 1 ? -1 : +1;
}","/**
     * The number values to check is typically small ({@literal < 5}) and thus
     * we use brute-force to count the number of inversions.
     *
     *{@inheritDoc}
     */","('parity', {'INSTRUCTION': {'covered': 51, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",113.0,The number values to check is typically small ({@literal < 5}) and thus  we use brute-force to count the number of inversions.,28.0,"['The number values to check are usually small and so we use brute force to count the number of inversions.', 'The number values to check are usually small and so we use brute- force to count the number of inversions.', 'The number values to check are usually small and therefore we use brute- force to count the number of inversions.']"
648,matsim-libs,org/matsim/core/trafficmonitoring/TravelTimeCalculator.java,/matsim/src/main/java/org/matsim/core/trafficmonitoring/TravelTimeCalculator.java,consolidateData,439-488,"/**
	 * Makes sure that the travel times ""make sense"".
	 * <p></p>
	 * Imagine short bin sizes (e.g. 5min), small links (e.g. 300 veh/hour)
	 * and small sample sizes (e.g. 2%). This would mean that effectively
	 * in the simulation only 6 vehicles can pass the link in one hour,
	 * one every 10min. So, the travel time in one time slot could be 
	 * >= 10min if two cars enter the link at the same time. If no car
	 * enters in the next time bin, the travel time in that time bin should
	 * still be >=5 minutes (10min - binSize), and not freespeedTraveltime,
	 * because actually every car entering the link in this bin will be behind
	 * the car entered before, which still needs >=5min until it can leave.
	 * <p></p>
	 * This method ensures that the travel time in a time bin
	 * cannot be smaller than the travel time in the bin before minus the
	 * bin size.
	 *
	 */
private void consolidateData(final TravelTimeData data){
    synchronized (data) {
        if (data.isNeedingConsolidation()) {
            // initialize prevTravelTime with ttime from time bin 0 and time 0.  (The interface comment already states that
            // having both as argument does not make sense.)
            double prevTravelTime = data.getTravelTime(0, 0.0);
            // changed (1, 0.0) to (0, 0.0) since Michal has convinced me (by a test) that using ""1"" is wrong
            // because you get the wrong result for time slot number 1.  This change does not affect the existing
            // unit tests.  kai, oct'11
            // go from time slot 1 forward in time:
            for (int i = 1; i < this.numSlots; i++) {
                // once more the getter is weird since it needs both the time slot and the time:
                double travelTime = data.getTravelTime(i, i * this.timeSlice);
                // if the travel time in the previous time slice was X, then now it is X-S, where S is the time slice:
                double minTravelTime = prevTravelTime - this.timeSlice;
                // if the travel time that has been measured so far is less than that minimum travel time, then do something:
                if (travelTime < minTravelTime) {
                    // (set the travel time to the smallest possible travel time that makes sense according to the argument above)
                    travelTime = minTravelTime;
                    data.setTravelTime(i, travelTime);
                }
                prevTravelTime = travelTime;
            }
            data.setNeedsConsolidation(false);
        }
    }
}","private void consolidateData(final TravelTimeData data){
    synchronized (data) {
        if (data.isNeedingConsolidation()) {
            // initialize prevTravelTime with ttime from time bin 0 and time 0.  (The interface comment already states that
            // having both as argument does not make sense.)
            double prevTravelTime = data.getTravelTime(0, 0.0);
            // changed (1, 0.0) to (0, 0.0) since Michal has convinced me (by a test) that using ""1"" is wrong
            // because you get the wrong result for time slot number 1.  This change does not affect the existing
            // unit tests.  kai, oct'11
            // go from time slot 1 forward in time:
            for (int i = 1; i < this.numSlots; i++) {
                // once more the getter is weird since it needs both the time slot and the time:
                double travelTime = data.getTravelTime(i, i * this.timeSlice);
                // if the travel time in the previous time slice was X, then now it is X-S, where S is the time slice:
                double minTravelTime = prevTravelTime - this.timeSlice;
                // if the travel time that has been measured so far is less than that minimum travel time, then do something:
                if (travelTime < minTravelTime) {
                    // (set the travel time to the smallest possible travel time that makes sense according to the argument above)
                    travelTime = minTravelTime;
                    data.setTravelTime(i, travelTime);
                }
                prevTravelTime = travelTime;
            }
            data.setNeedsConsolidation(false);
        }
    }
}","/**
	 * Makes sure that the travel times ""make sense"".
	 * <p></p>
	 * Imagine short bin sizes (e.g. 5min), small links (e.g. 300 veh/hour)
	 * and small sample sizes (e.g. 2%). This would mean that effectively
	 * in the simulation only 6 vehicles can pass the link in one hour,
	 * one every 10min. So, the travel time in one time slot could be 
	 * >= 10min if two cars enter the link at the same time. If no car
	 * enters in the next time bin, the travel time in that time bin should
	 * still be >=5 minutes (10min - binSize), and not freespeedTraveltime,
	 * because actually every car entering the link in this bin will be behind
	 * the car entered before, which still needs >=5min until it can leave.
	 * <p></p>
	 * This method ensures that the travel time in a time bin
	 * cannot be smaller than the travel time in the bin before minus the
	 * bin size.
	 *
	 */","('consolidateData', {'INSTRUCTION': {'covered': 54, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",113.0,"  Makes sure that the travel times ""make sense"".",11.0,"[""It's important that the travel times make sense."", 'Make sure that the travel times are understandable.', 'Make sure the travel times are understandable.']"
649,cdk,org/openscience/cdk/geometry/GeometryTools.java,/legacy/src/main/java/org/openscience/cdk/geometry/GeometryTools.java,shiftContainer,1637-1660,"/**
     * Shift the container horizontally to the right to make its bounds not
     * overlap with the other bounds.
     *
     * @param container the {@link IAtomContainer} to shift to the right
     * @param bounds    the {@link Rectangle2D} of the {@link IAtomContainer}
     *                  to shift
     * @param last      the bounds that is used as reference
     * @param gap       the gap between the two {@link Rectangle2D}s
     * @return          the {@link Rectangle2D} of the {@link IAtomContainer}
     *                  after the shift
     */
public static Rectangle2D shiftContainer(IAtomContainer container, Rectangle2D bounds, Rectangle2D last, double gap){
    if (last.getMaxX() + gap >= bounds.getMinX()) {
        double xShift = last.getMaxX() + gap - bounds.getMinX();
        Vector2d shift = new Vector2d(xShift, 0.0);
        GeometryTools.translate2D(container, shift);
        return new Rectangle2D.Double(bounds.getX() + xShift, bounds.getY(), bounds.getWidth(), bounds.getHeight());
    } else {
        return bounds;
    }
}","public static Rectangle2D shiftContainer(IAtomContainer container, Rectangle2D bounds, Rectangle2D last, double gap){
    if (last.getMaxX() + gap >= bounds.getMinX()) {
        double xShift = last.getMaxX() + gap - bounds.getMinX();
        Vector2d shift = new Vector2d(xShift, 0.0);
        GeometryTools.translate2D(container, shift);
        return new Rectangle2D.Double(bounds.getX() + xShift, bounds.getY(), bounds.getWidth(), bounds.getHeight());
    } else {
        return bounds;
    }
}","/**
     * Shift the container horizontally to the right to make its bounds not
     * overlap with the other bounds.
     *
     * @param container the {@link IAtomContainer} to shift to the right
     * @param bounds    the {@link Rectangle2D} of the {@link IAtomContainer}
     *                  to shift
     * @param last      the bounds that is used as reference
     * @param gap       the gap between the two {@link Rectangle2D}s
     * @return          the {@link Rectangle2D} of the {@link IAtomContainer}
     *                  after the shift
     */","('shiftContainer', {'INSTRUCTION': {'covered': 39, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",113.0,  Shift the container horizontally to the right to make its bounds not  overlap with the other bounds.,18.0,"[""The container's bounds should not overlap with the other bounds."", ""To make the container's bounds not overlap with the other bounds, shift the container horizontally to the right."", ""To make the container's bounds not overlap with the other bounds, shift the container to the right.""]"
650,acs-aem-commons,com/adobe/acs/commons/synth/children/ChildrenAsPropertyResource.java,/bundle/src/main/java/com/adobe/acs/commons/synth/children/ChildrenAsPropertyResource.java,deserialize,294-318,"/**
     * Convert the serialized JSON data found in the node property to Resources.
     *
     * @return the list of children sorting using the comparator.
     * @throws InvalidDataFormatException
     */
private List<SyntheticChildAsPropertyResource> deserialize() throws InvalidDataFormatException{
    final long start = System.currentTimeMillis();
    final String propertyData = this.resource.getValueMap().get(this.propertyName, EMPTY_JSON);
    List<SyntheticChildAsPropertyResource> resources;
    resources = deserializeToSyntheticChildResources(JsonObjectUtil.toJsonObject(propertyData));
    if (this.comparator != null) {
        Collections.sort(resources, this.comparator);
    }
    log.debug(""Get operation for [ {} ] in [ {} ms ]"", this.resource.getPath() + ""/"" + this.propertyName, System.currentTimeMillis() - start);
    return resources;
}","private List<SyntheticChildAsPropertyResource> deserialize() throws InvalidDataFormatException{
    final long start = System.currentTimeMillis();
    final String propertyData = this.resource.getValueMap().get(this.propertyName, EMPTY_JSON);
    List<SyntheticChildAsPropertyResource> resources;
    resources = deserializeToSyntheticChildResources(JsonObjectUtil.toJsonObject(propertyData));
    if (this.comparator != null) {
        Collections.sort(resources, this.comparator);
    }
    log.debug(""Get operation for [ {} ] in [ {} ms ]"", this.resource.getPath() + ""/"" + this.propertyName, System.currentTimeMillis() - start);
    return resources;
}","/**
     * Convert the serialized JSON data found in the node property to Resources.
     *
     * @return the list of children sorting using the comparator.
     * @throws InvalidDataFormatException
     */","('deserialize', {'INSTRUCTION': {'covered': 45, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,  Convert the serialized JSON data found in the node property to Resources.,13.0,"['The data in the property can be converted to resources.', 'The data in the property can be converted to Resources.', 'The data in the property is serialized.']"
651,jackson-databind,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,findSuperClasses,83-108,"/**
     * Method for finding all super classes (but not super interfaces) of given class,
     * starting with the immediate super class and ending in the most distant one.
     * Class itself is included if <code>addClassItself</code> is true.
     *<p>
     * NOTE: mostly/only called to resolve mix-ins as that's where we do not care
     * about fully-resolved types, just associated annotations.
     *
     * @since 2.7
     */
public static List<Class<?>> findSuperClasses(Class<?> cls, Class<?> endBefore, boolean addClassItself){
    List<Class<?>> result = new ArrayList<Class<?>>(8);
    if ((cls != null) && (cls != endBefore)) {
        if (addClassItself) {
            result.add(cls);
        }
        while ((cls = cls.getSuperclass()) != null) {
            if (cls == endBefore) {
                break;
            }
            result.add(cls);
        }
    }
    return result;
}","public static List<Class<?>> findSuperClasses(Class<?> cls, Class<?> endBefore, boolean addClassItself){
    List<Class<?>> result = new ArrayList<Class<?>>(8);
    if ((cls != null) && (cls != endBefore)) {
        if (addClassItself) {
            result.add(cls);
        }
        while ((cls = cls.getSuperclass()) != null) {
            if (cls == endBefore) {
                break;
            }
            result.add(cls);
        }
    }
    return result;
}","/**
     * Method for finding all super classes (but not super interfaces) of given class,
     * starting with the immediate super class and ending in the most distant one.
     * Class itself is included if <code>addClassItself</code> is true.
     *<p>
     * NOTE: mostly/only called to resolve mix-ins as that's where we do not care
     * about fully-resolved types, just associated annotations.
     *
     * @since 2.7
     */","('findSuperClasses', {'INSTRUCTION': {'covered': 32, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,"  Method for finding all super classes (but not super interfaces) of given class,  starting with the immediate super class and ending in the most distant one.",30.0,"['The method for finding all super classes in a given class starts with the immediate super class and ends in the most distant one.', 'The method for finding all super classes in a given class starts with the immediate super class and ends with the most distant one.', 'The method for finding all the super classes in a class is starting with the immediate super class and ending in the most distant one.']"
652,cdk,org/openscience/cdk/layout/IdentityTemplateLibrary.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/IdentityTemplateLibrary.java,assignLayout,336-364,"/**
     * Assign a 2D layout to the atom container using the contents of the library. If multiple
     * coordinates are available the first is choosen.
     *
     * @param container structure representation
     * @return a layout was assigned
     */
 boolean assignLayout(IAtomContainer container){
    try {
        int n = container.getAtomCount();
        int[] ordering = new int[n];
        String smiles = cansmi(container, ordering);
        for (Point2d[] points : templateMap.getOrDefault(smiles, Collections.emptyList())) {
            for (int i = 0; i < n; i++) {
                container.getAtom(i).setPoint2d(new Point2d(points[ordering[i]]));
            }
            return true;
        }
    } catch (CDKException e) {
    }
    return false;
}","boolean assignLayout(IAtomContainer container){
    try {
        int n = container.getAtomCount();
        int[] ordering = new int[n];
        String smiles = cansmi(container, ordering);
        for (Point2d[] points : templateMap.getOrDefault(smiles, Collections.emptyList())) {
            for (int i = 0; i < n; i++) {
                container.getAtom(i).setPoint2d(new Point2d(points[ordering[i]]));
            }
            return true;
        }
    } catch (CDKException e) {
    }
    return false;
}","/**
     * Assign a 2D layout to the atom container using the contents of the library. If multiple
     * coordinates are available the first is choosen.
     *
     * @param container structure representation
     * @return a layout was assigned
     */","('assignLayout', {'INSTRUCTION': {'covered': 50, 'missed': 1}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,Assign a 2D layout to the atom container using the contents of the library.,15.0,"['The contents of the library should be used to assign a 2D layout to the atom container.', 'The contents of the library should be used to assign a layout to the atom container.', 'Use the contents of the library to assign a layout to the atom container.']"
653,cdk,org/openscience/cdk/smiles/DeduceBondSystemTool.java,/legacy/src/main/java/org/openscience/cdk/smiles/DeduceBondSystemTool.java,storeRingSystem,804-819,"/**
     * Stores an IRingSet corresponding to a AtomContainer using the bond numbers.
     *
     * @param mol      The IAtomContainer for which to store the IRingSet.
     * @param ringSet  The IRingSet to store
     */
private void storeRingSystem(IAtomContainer mol, IRingSet ringSet){
    listOfRings = new ArrayList<Integer[]>();
    for (int r = 0; r < ringSet.getAtomContainerCount(); ++r) {
        IRing ring = (IRing) ringSet.getAtomContainer(r);
        Integer[] bondNumbers = new Integer[ring.getBondCount()];
        for (int i = 0; i < ring.getBondCount(); ++i) bondNumbers[i] = mol.indexOf(ring.getBond(i));
        listOfRings.add(bondNumbers);
    }
}","private void storeRingSystem(IAtomContainer mol, IRingSet ringSet){
    listOfRings = new ArrayList<Integer[]>();
    for (int r = 0; r < ringSet.getAtomContainerCount(); ++r) {
        IRing ring = (IRing) ringSet.getAtomContainer(r);
        Integer[] bondNumbers = new Integer[ring.getBondCount()];
        for (int i = 0; i < ring.getBondCount(); ++i) bondNumbers[i] = mol.indexOf(ring.getBond(i));
        listOfRings.add(bondNumbers);
    }
}","/**
     * Stores an IRingSet corresponding to a AtomContainer using the bond numbers.
     *
     * @param mol      The IAtomContainer for which to store the IRingSet.
     * @param ringSet  The IRingSet to store
     */","('storeRingSystem', {'INSTRUCTION': {'covered': 45, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,  Stores an IRingSet corresponding to a AtomContainer using the bond numbers.,12.0,"['Bond numbers are used to store an IRingSet with a AtomContainer.', 'Bond numbers are used to store an IRingSet for a AtomContainer.', 'Bond numbers are used to store an IRingSet that is related to a AtomContainer.']"
655,cdk,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,normaliseCycle,332-353,"/**
     * Normalises a 5-member 'cycle' such that the hetroatom contributing the lone-pair is in
     * position 1 (index 0). The alpha atoms are then in index 1 and 4 whilst the beta atoms are in
     * index 2 and 3. If the ring contains more than one hetroatom the cycle is not normalised
     * (return=false).
     *
     * @param cycle        aromatic cycle to normalise, |C| = 5
     * @param contribution vector of p electron contributions from each vertex (size |V|)
     * @return whether the cycle was normalised
     */
 static boolean normaliseCycle(int[] cycle, int[] contribution){
    int offset = indexOfHetro(cycle, contribution);
    if (offset < 0)
        return false;
    if (offset == 0)
        return true;
    int[] cpy = Arrays.copyOf(cycle, cycle.length);
    int len = cycle.length - 1;
    for (int j = 0; j < len; j++) {
        cycle[j] = cpy[(offset + j) % len];
    }
    cycle[len] = cycle[0];
    return true;
}","static boolean normaliseCycle(int[] cycle, int[] contribution){
    int offset = indexOfHetro(cycle, contribution);
    if (offset < 0)
        return false;
    if (offset == 0)
        return true;
    int[] cpy = Arrays.copyOf(cycle, cycle.length);
    int len = cycle.length - 1;
    for (int j = 0; j < len; j++) {
        cycle[j] = cpy[(offset + j) % len];
    }
    cycle[len] = cycle[0];
    return true;
}","/**
     * Normalises a 5-member 'cycle' such that the hetroatom contributing the lone-pair is in
     * position 1 (index 0). The alpha atoms are then in index 1 and 4 whilst the beta atoms are in
     * index 2 and 3. If the ring contains more than one hetroatom the cycle is not normalised
     * (return=false).
     *
     * @param cycle        aromatic cycle to normalise, |C| = 5
     * @param contribution vector of p electron contributions from each vertex (size |V|)
     * @return whether the cycle was normalised
     */","('normaliseCycle', {'INSTRUCTION': {'covered': 47, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,Normalises a 5-member 'cycle' such that the hetroatom contributing the lone-pair is in  position 1 (index 0).,21.0,"[""The hetroatom contributing the lone-pair is in position 1 and normalises a 5-member 'cycle'."", 'The hetroatom contributing the lone-pair is in position 1 and normalises a 5-member cycle.', 'The hetroatom contributing the lone-pair is in position 1 on the 5-membercycle.']"
656,cdk,org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,loadHydrogenDefinitions,243-268,"/**
     * Hydrogen atom types are assigned based on their parent types. The mmff-symb-mapping file
     * provides this mapping.
     *
     * @param hdefIn input stream of mmff-symb-mapping.tsv
     * @return mapping of parent to hydrogen definitions
     * @throws IOException
     */
private Map<String, String> loadHydrogenDefinitions(InputStream hdefIn) throws IOException{
    final Map<String, String> hdefs = new HashMap<String, String>(200);
    BufferedReader br = new BufferedReader(new InputStreamReader(hdefIn));
    br.readLine();
    String line = null;
    while ((line = br.readLine()) != null) {
        String[] cols = line.split(""\t"");
        hdefs.put(cols[0].trim(), cols[3].trim());
    }
    return hdefs;
}","private Map<String, String> loadHydrogenDefinitions(InputStream hdefIn) throws IOException{
    final Map<String, String> hdefs = new HashMap<String, String>(200);
    BufferedReader br = new BufferedReader(new InputStreamReader(hdefIn));
    br.readLine();
    String line = null;
    while ((line = br.readLine()) != null) {
        String[] cols = line.split(""\t"");
        hdefs.put(cols[0].trim(), cols[3].trim());
    }
    return hdefs;
}","/**
     * Hydrogen atom types are assigned based on their parent types. The mmff-symb-mapping file
     * provides this mapping.
     *
     * @param hdefIn input stream of mmff-symb-mapping.tsv
     * @return mapping of parent to hydrogen definitions
     * @throws IOException
     */","('loadHydrogenDefinitions', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",114.0,  Hydrogen atom types are assigned based on their parent types.,11.0,"['The parent types of hydrogen atom types are assigned.', 'The hydrogen atom types are assigned based on their parent types.', 'The hydrogen atom types are assigned based on their parents types.']"
658,acs-aem-commons,com/adobe/acs/commons/util/OverridePathSlingRequestWrapper.java,/bundle/src/main/java/com/adobe/acs/commons/util/OverridePathSlingRequestWrapper.java,adaptTo,129-152,"/**
     * Overriding `adaptTo` to avoid using the original request as the adaptable.
     */
public AdapterType adaptTo(Class<AdapterType> type){
    AdapterType result = null;
    synchronized (this) {
        result = (AdapterType) this.adaptersCache.get(type);
        if (result == null) {
            AdapterManager mgr = Activator.getAdapterManager();
            if (mgr == null) {
                LOG.warn(""Unable to adapt request for path {} to {} because AdapterManager is null"", this.resource.getPath(), type);
            } else {
                result = mgr.getAdapter(this, type);
            }
            if (result != null) {
                this.adaptersCache.put(type, result);
            }
        }
        return result;
    }
}","public AdapterType adaptTo(Class<AdapterType> type){
    AdapterType result = null;
    synchronized (this) {
        result = (AdapterType) this.adaptersCache.get(type);
        if (result == null) {
            AdapterManager mgr = Activator.getAdapterManager();
            if (mgr == null) {
                LOG.warn(""Unable to adapt request for path {} to {} because AdapterManager is null"", this.resource.getPath(), type);
            } else {
                result = mgr.getAdapter(this, type);
            }
            if (result != null) {
                this.adaptersCache.put(type, result);
            }
        }
        return result;
    }
}","/**
     * Overriding `adaptTo` to avoid using the original request as the adaptable.
     */","('adaptTo', {'INSTRUCTION': {'covered': 34, 'missed': 8}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 10, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",115.0,  Overriding `adaptTo` to avoid using the original request as the adaptable.,14.0,"['To avoid using the original request as an adapted one.', 'To avoid using the original request as an adaptable.', 'To avoid using the original request as the adaptable, overriding adaptTo.']"
659,dataverse,edu/harvard/iq/dataverse/metrics/MetricsUtil.java,/src/main/java/edu/harvard/iq/dataverse/metrics/MetricsUtil.java,sanitizeYearMonthUserInput,239-265,"/**
     *
     * @param userInput A year and month in YYYY-MM format.
     * @return A year and month in YYYY-M     
     * Note that along with sanitization, this checks that the requested month is
     * not after the current one. This will need to be made more robust if we
     * start writing metrics for farther in the future (e.g. the current year) the current year)
     */
public static String sanitizeYearMonthUserInput(String userInput) throws BadRequestException{
    logger.fine(""string from user to sanitize (hopefully YYYY-MM format): "" + userInput);
    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(YEAR_AND_MONTH_PATTERN);
    LocalDate inputLocalDate = null;
    try {
        inputLocalDate = YearMonth.parse(userInput, dateTimeFormatter).atDay(1);
    } catch (DateTimeParseException ex) {
        throw new BadRequestException(""The expected format is YYYY-MM but an exception was thrown: "" + ex.getLocalizedMessage());
    }
    LocalDate currentDate = LocalDate.now();
    if (inputLocalDate.isAfter(currentDate)) {
        throw new BadRequestException(""The requested date is set past the current month."");
    }
    String sanitized = inputLocalDate.format(dateTimeFormatter);
    return sanitized;
}","public static String sanitizeYearMonthUserInput(String userInput) throws BadRequestException{
    logger.fine(""string from user to sanitize (hopefully YYYY-MM format): "" + userInput);
    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(YEAR_AND_MONTH_PATTERN);
    LocalDate inputLocalDate = null;
    try {
        inputLocalDate = YearMonth.parse(userInput, dateTimeFormatter).atDay(1);
    } catch (DateTimeParseException ex) {
        throw new BadRequestException(""The expected format is YYYY-MM but an exception was thrown: "" + ex.getLocalizedMessage());
    }
    LocalDate currentDate = LocalDate.now();
    if (inputLocalDate.isAfter(currentDate)) {
        throw new BadRequestException(""The requested date is set past the current month."");
    }
    String sanitized = inputLocalDate.format(dateTimeFormatter);
    return sanitized;
}","/**
     *
     * @param userInput A year and month in YYYY-MM format.
     * @return A year and month in YYYY-M     
     * Note that along with sanitization, this checks that the requested month is
     * not after the current one. This will need to be made more robust if we
     * start writing metrics for farther in the future (e.g. the current year) the current year)
     */","('sanitizeYearMonthUserInput', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",115.0,   @param userInput A year and month in YYYY-MM format.,11.0,"['The year and month are in YYYY-MM format.', 'A year and a month in YYYY-MM format.', 'A year and month in YYYY-MM format is what user input is.']"
660,shardingsphere-elasticjob,org/apache/shardingsphere/elasticjob/lite/lifecycle/internal/reg/RegistryCenterFactory.java,/elasticjob-lite/elasticjob-lite-lifecycle/src/main/java/org/apache/shardingsphere/elasticjob/lite/lifecycle/internal/reg/RegistryCenterFactory.java,createCoordinatorRegistryCenter,43-62,"/**
     * Create a {@link CoordinatorRegistryCenter} or return the existing one if there is one set up with the same {@code connectionString}, {@code namespace} and {@code digest} already.
     *
     * @param connectString registry center connect string
     * @param namespace registry center namespace
     * @param digest registry center digest
     * @return registry center
     */
public static CoordinatorRegistryCenter createCoordinatorRegistryCenter(final String connectString, final String namespace, final String digest){
    Hasher hasher = Hashing.sha256().newHasher().putString(connectString, StandardCharsets.UTF_8).putString(namespace, StandardCharsets.UTF_8);
    if (!Strings.isNullOrEmpty(digest)) {
        hasher.putString(digest, StandardCharsets.UTF_8);
    }
    HashCode hashCode = hasher.hash();
    return REG_CENTER_REGISTRY.computeIfAbsent(hashCode, unused -> {
        CoordinatorRegistryCenter result = newCoordinatorRegistryCenter(connectString, namespace, digest);
        result.init();
        return result;
    });
}","public static CoordinatorRegistryCenter createCoordinatorRegistryCenter(final String connectString, final String namespace, final String digest){
    Hasher hasher = Hashing.sha256().newHasher().putString(connectString, StandardCharsets.UTF_8).putString(namespace, StandardCharsets.UTF_8);
    if (!Strings.isNullOrEmpty(digest)) {
        hasher.putString(digest, StandardCharsets.UTF_8);
    }
    HashCode hashCode = hasher.hash();
    return REG_CENTER_REGISTRY.computeIfAbsent(hashCode, unused -> {
        CoordinatorRegistryCenter result = newCoordinatorRegistryCenter(connectString, namespace, digest);
        result.init();
        return result;
    });
}","/**
     * Create a {@link CoordinatorRegistryCenter} or return the existing one if there is one set up with the same {@code connectionString}, {@code namespace} and {@code digest} already.
     *
     * @param connectString registry center connect string
     * @param namespace registry center namespace
     * @param digest registry center digest
     * @return registry center
     */","('createCoordinatorRegistryCenter', {'INSTRUCTION': {'covered': 29, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",116.0,"  Create a {@link CoordinatorRegistryCenter} or return the existing one if there is one set up with the same {@code connectionString}, {@code namespace} and {@code digest} already.",40.0,"['If there is one set up with the same @code connectionString, @code namespace and @code digest already, then create a @linkRegistryCenter or return the existing one.', 'If there is one set up with the same @code connectionString, @code namespace and @code digest already, then create a @link CoordinatorRegistryCenter or return the existing one.', 'If there is one set up with the same @code connectionString, @code namespace and @code digest already, then create a @linkRegistryCenter.']"
661,acs-aem-commons,com/adobe/acs/commons/dam/impl/AssetsFolderPropertiesSupport.java,/bundle/src/main/java/com/adobe/acs/commons/dam/impl/AssetsFolderPropertiesSupport.java,accepts,148-174,"/**
     * Gateway method the Filter uses to determine if the request is a candidate for processing by Assets Folder Properties Support.
     * These checks should be fast and fail broadest and fastest first.
     *
     * @param request the request
     * @return true if Assets Folder Properties Support should process this request.
     */
protected boolean accepts(SlingHttpServletRequest request){
    if (!StringUtils.equalsIgnoreCase(POST_METHOD, request.getMethod())) {
        return false;
    } else if (!DAM_FOLDER_SHARE_OPERATION.equals(request.getParameter(OPERATION))) {
        return false;
    } else if (!StringUtils.startsWith(request.getResource().getPath(), DAM_PATH_PREFIX)) {
        return false;
    } else if (!request.getResource().isResourceType(JcrResourceConstants.NT_SLING_FOLDER) && !request.getResource().isResourceType(JcrResourceConstants.NT_SLING_ORDERED_FOLDER)) {
        return false;
    }
    return true;
}","protected boolean accepts(SlingHttpServletRequest request){
    if (!StringUtils.equalsIgnoreCase(POST_METHOD, request.getMethod())) {
        return false;
    } else if (!DAM_FOLDER_SHARE_OPERATION.equals(request.getParameter(OPERATION))) {
        return false;
    } else if (!StringUtils.startsWith(request.getResource().getPath(), DAM_PATH_PREFIX)) {
        return false;
    } else if (!request.getResource().isResourceType(JcrResourceConstants.NT_SLING_FOLDER) && !request.getResource().isResourceType(JcrResourceConstants.NT_SLING_ORDERED_FOLDER)) {
        return false;
    }
    return true;
}","/**
     * Gateway method the Filter uses to determine if the request is a candidate for processing by Assets Folder Properties Support.
     * These checks should be fast and fail broadest and fastest first.
     *
     * @param request the request
     * @return true if Assets Folder Properties Support should process this request.
     */","('accepts', {'INSTRUCTION': {'covered': 37, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",116.0,  Gateway method the Filter uses to determine if the request is a candidate for processing by Assets Folder Properties Support.,21.0,"['The Filter uses a gateway method to determine if the request is a candidate for processing.', 'The Filter uses a gateway method to determine if a request is a candidate for processing.', 'The Filter uses a gateway method to determine if the request is a good candidate for processing.']"
662,logstash-logback-encoder,net/logstash/logback/pattern/AbstractJsonPatternParser.java,/src/main/java/net/logstash/logback/pattern/AbstractJsonPatternParser.java,parse,279-305,"/**
     * Parse a JSON pattern and produce the corresponding {@link NodeWriter}.
     * Returns <em>null</em> if the pattern is invalid, null or empty. An error status is
     * logged when the pattern is invalid and parsing failed.
     * 
     * @param pattern the JSON pattern to parse
     * @return a {@link NodeWriter} configured according to the pattern
     * @throws JsonPatternException denotes an invalid pattern
     */
public NodeWriter<Event> parse(String pattern) throws JsonPatternException{
    if (StringUtils.isEmpty(pattern)) {
        return null;
    }
    final ObjectNode node;
    try (JsonParser jsonParser = jsonFactory.createParser(pattern)) {
        node = JsonReadingUtils.readFullyAsObjectNode(jsonFactory, pattern);
    } catch (IOException e) {
        throw new JsonPatternException(""pattern is not a valid JSON object"", e);
    }
    NodeWriter<Event> nodeWriter = new RootWriter<>(parseObject(JsonPointer.compile(""/""), node));
    if (omitEmptyFields) {
        nodeWriter = new OmitEmptyFieldWriter<>(nodeWriter);
    }
    return nodeWriter;
}","public NodeWriter<Event> parse(String pattern) throws JsonPatternException{
    if (StringUtils.isEmpty(pattern)) {
        return null;
    }
    final ObjectNode node;
    try (JsonParser jsonParser = jsonFactory.createParser(pattern)) {
        node = JsonReadingUtils.readFullyAsObjectNode(jsonFactory, pattern);
    } catch (IOException e) {
        throw new JsonPatternException(""pattern is not a valid JSON object"", e);
    }
    NodeWriter<Event> nodeWriter = new RootWriter<>(parseObject(JsonPointer.compile(""/""), node));
    if (omitEmptyFields) {
        nodeWriter = new OmitEmptyFieldWriter<>(nodeWriter);
    }
    return nodeWriter;
}","/**
     * Parse a JSON pattern and produce the corresponding {@link NodeWriter}.
     * Returns <em>null</em> if the pattern is invalid, null or empty. An error status is
     * logged when the pattern is invalid and parsing failed.
     * 
     * @param pattern the JSON pattern to parse
     * @return a {@link NodeWriter} configured according to the pattern
     * @throws JsonPatternException denotes an invalid pattern
     */","('parse', {'INSTRUCTION': {'covered': 40, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",116.0,  Parse a JSON pattern and produce the corresponding {@link NodeWriter}.,14.0,"['The corresponding @link NodeWriter will be produced when youParse a JSON pattern.', 'The corresponding @link NodeWriter can be produced by Parse a JSON pattern.', 'The corresponding @link NodeWriter can be produced by Parse a pattern.']"
663,acs-aem-commons,com/adobe/acs/commons/mcp/impl/processes/WorkflowRemover.java,/bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/WorkflowRemover.java,parseParameters,164-188,"/**
     * Parse the input parameters into the form needed to call workflowInstanceRemover. The results are set into
     * instance variables.  Method is package scope for unit testing.
     *
     * @throws ParseException
     *             if the date is in an invalid format.
     * @throws PatternSyntaxException
     *          if the payloads contain illegal patterns
     */
 void parseParameters() throws ParseException{
    if (payloadPaths != null) {
        payloads = payloadPaths.stream().map(Pattern::compile).collect(Collectors.toList());
    }
    if (StringUtils.isNotEmpty(olderThanVal)) {
        final SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss"");
        Date d = sdf.parse(olderThanVal);
        olderThan = Calendar.getInstance();
        olderThan.setTime(d);
    }
    workflowRemovalConfig = new WorkflowRemovalConfig(modelIds, statuses, payloads, olderThan, olderThanMillis);
    workflowRemovalConfig.setBatchSize(BATCH_SIZE);
    workflowRemovalConfig.setMaxDurationInMins(MAX_DURATION_MINS);
}"," void parseParameters() throws ParseException{
    if (payloadPaths != null) {
        payloads = payloadPaths.stream().map(Pattern::compile).collect(Collectors.toList());
    }
    if (StringUtils.isNotEmpty(olderThanVal)) {
        final SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss"");
        Date d = sdf.parse(olderThanVal);
        olderThan = Calendar.getInstance();
        olderThan.setTime(d);
    }
    workflowRemovalConfig = new WorkflowRemovalConfig(modelIds, statuses, payloads, olderThan, olderThanMillis);
    workflowRemovalConfig.setBatchSize(BATCH_SIZE);
    workflowRemovalConfig.setMaxDurationInMins(MAX_DURATION_MINS);
}","/**
     * Parse the input parameters into the form needed to call workflowInstanceRemover. The results are set into
     * instance variables.  Method is package scope for unit testing.
     *
     * @throws ParseException
     *             if the date is in an invalid format.
     * @throws PatternSyntaxException
     *          if the payloads contain illegal patterns
     */","('parseParameters', {'INSTRUCTION': {'covered': 58, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",116.0,  Parse the input parameters into the form needed to call workflowInstanceRemover.,12.0,"['Parse the input parameters into the form.', 'Parse the input parameters into a form.', 'Parse the input parameters into the form']"
664,matsim-libs,org/matsim/contrib/freight/utils/FreightUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/utils/FreightUtils.java,createShipmentVRPCarrierFromServiceVRPSolution,143-174,"/**
	 * Creates a new {@link Carriers} container only with {@link CarrierShipment}s
	 * for creating a new VRP. As consequence of the transformation of
	 * {@link CarrierService}s to {@link CarrierShipment}s the solution of the VRP
	 * can have tours with vehicles returning to the depot and load for another tour
	 * instead of creating another vehicle with additional (fix) costs. <br/>
	 * The method is meant for multi-depot problems. Here, the original ""services""
	 * input does not have an assignment of services to depots. The solution to the
	 * problem, however, does. So the assignment is taken from that solution, and
	 * each returned {@link Carrier} has that depot as pickup location in each
	 * shipment.
	 *
	 * @param carriers carriers with a Solution (result of solving the VRP).
	 * @return Carriers carriersWithShipments
	 */
public static Carriers createShipmentVRPCarrierFromServiceVRPSolution(Carriers carriers){
    Carriers carriersWithShipments = new Carriers();
    for (Carrier carrier : carriers.getCarriers().values()) {
        Carrier carrierWS = CarrierUtils.createCarrier(carrier.getId());
        if (carrier.getShipments().size() > 0) {
            copyShipments(carrierWS, carrier);
        }
        if (carrier.getServices().size() > 0) {
            createShipmentsFromServices(carrierWS, carrier);
        }
        carrierWS.setCarrierCapabilities(carrier.getCarrierCapabilities());
        carriersWithShipments.addCarrier(carrierWS);
    }
    return carriersWithShipments;
}","public static Carriers createShipmentVRPCarrierFromServiceVRPSolution(Carriers carriers){
    Carriers carriersWithShipments = new Carriers();
    for (Carrier carrier : carriers.getCarriers().values()) {
        Carrier carrierWS = CarrierUtils.createCarrier(carrier.getId());
        if (carrier.getShipments().size() > 0) {
            copyShipments(carrierWS, carrier);
        }
        if (carrier.getServices().size() > 0) {
            createShipmentsFromServices(carrierWS, carrier);
        }
        carrierWS.setCarrierCapabilities(carrier.getCarrierCapabilities());
        carriersWithShipments.addCarrier(carrierWS);
    }
    return carriersWithShipments;
}","/**
	 * Creates a new {@link Carriers} container only with {@link CarrierShipment}s
	 * for creating a new VRP. As consequence of the transformation of
	 * {@link CarrierService}s to {@link CarrierShipment}s the solution of the VRP
	 * can have tours with vehicles returning to the depot and load for another tour
	 * instead of creating another vehicle with additional (fix) costs. <br/>
	 * The method is meant for multi-depot problems. Here, the original ""services""
	 * input does not have an assignment of services to depots. The solution to the
	 * problem, however, does. So the assignment is taken from that solution, and
	 * each returned {@link Carrier} has that depot as pickup location in each
	 * shipment.
	 *
	 * @param carriers carriers with a Solution (result of solving the VRP).
	 * @return Carriers carriersWithShipments
	 */","('createShipmentVRPCarrierFromServiceVRPSolution', {'INSTRUCTION': {'covered': 44, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",116.0,  Creates a new {@link Carriers} container only with {@link CarrierShipment}s  for creating a new VRP.,23.0,"['It creates a new @link Carriers container only with @link CarrierShipments.', 'It creates a new @link Carriers container with @link CarrierShipments for creating a new VRP.', 'It creates a new @link Carriers container only with @link CarrierShipments for creating a new VRP.']"
665,dataverse,edu/harvard/iq/dataverse/authorization/groups/GroupServiceBean.java,/src/main/java/edu/harvard/iq/dataverse/authorization/groups/GroupServiceBean.java,collectAncestors,180-206,"/**
     * Returns all the groups that are in, of are ancestors of a group in
     * the passed group collection.
     * 
     * @param groups 
     * @return {@code groups} and their ancestors.
     */
public Set<Group> collectAncestors(Collection<Group> groups){
    Set<Group> retVal = new HashSet<>();
    Set<Group> perimeter = new HashSet<>(groups);
    while (!perimeter.isEmpty()) {
        Group next = perimeter.iterator().next();
        retVal.add(next);
        perimeter.remove(next);
        explicitGroupService.findDirectlyContainingGroups(next).forEach(g -> {
            if (!retVal.contains(g)) {
                perimeter.add(g);
            }
        });
    }
    return retVal;
}","public Set<Group> collectAncestors(Collection<Group> groups){
    Set<Group> retVal = new HashSet<>();
    Set<Group> perimeter = new HashSet<>(groups);
    while (!perimeter.isEmpty()) {
        Group next = perimeter.iterator().next();
        retVal.add(next);
        perimeter.remove(next);
        explicitGroupService.findDirectlyContainingGroups(next).forEach(g -> {
            if (!retVal.contains(g)) {
                perimeter.add(g);
            }
        });
    }
    return retVal;
}","/**
     * Returns all the groups that are in, of are ancestors of a group in
     * the passed group collection.
     * 
     * @param groups 
     * @return {@code groups} and their ancestors.
     */","('collectAncestors', {'INSTRUCTION': {'covered': 36, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",117.0,"  Returns all the groups that are in, of are ancestors of a group in  the passed group collection.",20.0,"['All the groups that are in are descendants of a group in the passed group collection.', 'All the groups that are in are descendants of a group in the passed collection.', 'All the groups that are in are descendants of the group that passed.']"
666,matsim-libs,org/matsim/core/population/PopulationUtils.java,/matsim/src/main/java/org/matsim/core/population/PopulationUtils.java,insertLegAct,1057-1076,"/**
	 * Inserts a leg and a following act at position <code>pos</code> into the plan.
	 * @param pos the position where to insert the leg-act-combo. acts and legs are both counted from the beginning starting at 0.
	 * @param leg the leg to insert
	 * @param act the act to insert, following the leg
	 *
	 * @throws IllegalArgumentException If the leg and act cannot be inserted at the specified position without retaining the correct order of legs and acts.
	 */
public static void insertLegAct(Plan plan, int pos, Leg leg, Activity act){
    if (pos < plan.getPlanElements().size()) {
        Object o = plan.getPlanElements().get(pos);
        if (!(o instanceof Leg)) {
            throw new IllegalArgumentException(""Position to insert leg and act is not valid (act instead of leg at position)."");
        }
    } else if (pos > plan.getPlanElements().size()) {
        throw new IllegalArgumentException(""Position to insert leg and act is not valid."");
    }
    plan.getPlanElements().add(pos, act);
    plan.getPlanElements().add(pos, leg);
}","public static void insertLegAct(Plan plan, int pos, Leg leg, Activity act){
    if (pos < plan.getPlanElements().size()) {
        Object o = plan.getPlanElements().get(pos);
        if (!(o instanceof Leg)) {
            throw new IllegalArgumentException(""Position to insert leg and act is not valid (act instead of leg at position)."");
        }
    } else if (pos > plan.getPlanElements().size()) {
        throw new IllegalArgumentException(""Position to insert leg and act is not valid."");
    }
    plan.getPlanElements().add(pos, act);
    plan.getPlanElements().add(pos, leg);
}","/**
	 * Inserts a leg and a following act at position <code>pos</code> into the plan.
	 * @param pos the position where to insert the leg-act-combo. acts and legs are both counted from the beginning starting at 0.
	 * @param leg the leg to insert
	 * @param act the act to insert, following the leg
	 *
	 * @throws IllegalArgumentException If the leg and act cannot be inserted at the specified position without retaining the correct order of legs and acts.
	 */","('insertLegAct', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",117.0,  Inserts a leg and a following act at position <code>pos</code> into the plan.,20.0,"['A leg and a following act are inserted into the plan.', 'A leg and act are inserted into the plan.', 'A leg and a following act is inserted into the plan.']"
667,matsim-libs,org/matsim/core/network/algorithms/NetworkCleaner.java,/matsim/src/main/java/org/matsim/core/network/algorithms/NetworkCleaner.java,reduceToBiggestCluster,144-158,"/** 
	 * Reducing the network so it only contains nodes included in the biggest Cluster.
	 * Loop over all nodes and check if they are in the cluster, if not, remove them from the network
	 */
public static void reduceToBiggestCluster(Network network, Map<Id<Node>, Node> biggestCluster){
    List<Node> allNodes2 = new ArrayList<>(network.getNodes().values());
    for (Node node : allNodes2) {
        if (!biggestCluster.containsKey(node.getId())) {
            network.removeNode(node.getId());
        }
    }
    log.info(""  resulting network contains "" + network.getNodes().size() + "" nodes and "" + network.getLinks().size() + "" links."");
    log.info(""done."");
}","public static void reduceToBiggestCluster(Network network, Map<Id<Node>, Node> biggestCluster){
    List<Node> allNodes2 = new ArrayList<>(network.getNodes().values());
    for (Node node : allNodes2) {
        if (!biggestCluster.containsKey(node.getId())) {
            network.removeNode(node.getId());
        }
    }
    log.info(""  resulting network contains "" + network.getNodes().size() + "" nodes and "" + network.getLinks().size() + "" links."");
    log.info(""done."");
}","/** 
	 * Reducing the network so it only contains nodes included in the biggest Cluster.
	 * Loop over all nodes and check if they are in the cluster, if not, remove them from the network
	 */","('reduceToBiggestCluster', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",117.0,   Reducing the network so it only contains nodes included in the biggest Cluster.,14.0,"['The network should only contain the smallest part of the biggest Cluster.', 'The network should only contain the smallest part of the biggest cluster.', 'The network should only contain the smallest part of the largest Cluster.']"
668,cdk,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,findChargePosition,805-825,"/**
     * Extract the charge position given a molecular formula format [O3S]2-.
     *
     * @param formula The formula to inspect
     * @return        The charge position in the string
     */
private static int findChargePosition(String formula){
    int end = formula.length() - 1;
    int pos = end;
    while (pos >= 0 && isSign(formula.charAt(pos))) pos--;
    int mark1 = pos;
    while (pos >= 0 && isDigit(formula.charAt(pos))) pos--;
    int mark2 = pos;
    while (pos >= 0 && isSign(formula.charAt(pos))) pos--;
    if (pos == mark2 && formula.charAt(pos) != ']')
        pos = mark1;
    return pos + 1;
}","private static int findChargePosition(String formula){
    int end = formula.length() - 1;
    int pos = end;
    while (pos >= 0 && isSign(formula.charAt(pos))) pos--;
    int mark1 = pos;
    while (pos >= 0 && isDigit(formula.charAt(pos))) pos--;
    int mark2 = pos;
    while (pos >= 0 && isSign(formula.charAt(pos))) pos--;
    if (pos == mark2 && formula.charAt(pos) != ']')
        pos = mark1;
    return pos + 1;
}","/**
     * Extract the charge position given a molecular formula format [O3S]2-.
     *
     * @param formula The formula to inspect
     * @return        The charge position in the string
     */","('findChargePosition', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",117.0,Extract the charge position given a molecular formula format [O3S]2-.,14.0,"['The charge position is given in a formula format.', 'The charge position is given in a formula.', 'The charge position is given in the formula format.']"
669,cdk,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,sortClockwise,1135-1157,"/**
     * Sort the {@code indices}, which correspond to an index in the {@code atoms} array in
     * clockwise order.
     *
     * @param indices indices, 0 to n
     * @param focus   the central atom
     * @param atoms   the neighbors of the focus
     * @param n       the number of neighbors
     * @return the permutation parity of the sort
     */
private int sortClockwise(int[] indices, IAtom focus, IAtom[] atoms, int n){
    int x = 0;
    for (int j = 1; j < n; j++) {
        int v = indices[j];
        int i = j - 1;
        while ((i >= 0) && less(v, indices[i], atoms, focus.getPoint2d())) {
            indices[i + 1] = indices[i--];
            x++;
        }
        indices[i + 1] = v;
    }
    return indexParity(x);
}","private int sortClockwise(int[] indices, IAtom focus, IAtom[] atoms, int n){
    int x = 0;
    for (int j = 1; j < n; j++) {
        int v = indices[j];
        int i = j - 1;
        while ((i >= 0) && less(v, indices[i], atoms, focus.getPoint2d())) {
            indices[i + 1] = indices[i--];
            x++;
        }
        indices[i + 1] = v;
    }
    return indexParity(x);
}","/**
     * Sort the {@code indices}, which correspond to an index in the {@code atoms} array in
     * clockwise order.
     *
     * @param indices indices, 0 to n
     * @param focus   the central atom
     * @param atoms   the neighbors of the focus
     * @param n       the number of neighbors
     * @return the permutation parity of the sort
     */","('sortClockwise', {'INSTRUCTION': {'covered': 49, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",117.0,"  Sort the {@code indices}, which correspond to an index in the {@code atoms} array in  clockwise order.",25.0,"['The @code indices correspond to an index in the @code atoms array.', 'The @code indices correspond to an index in the @code atoms array in a clockwise order.', 'Sort the @code indices by their index in the @code atoms array.']"
670,acs-aem-commons,com/adobe/acs/commons/util/impl/QueryHelperImpl.java,/bundle/src/main/java/com/adobe/acs/commons/util/impl/QueryHelperImpl.java,findResources,60-87,"/**
     * Find all the resources needed for the package definition.
     *
     * @param resourceResolver the resource resolver to find the resources
     * @param language         the Query language
     * @param statement        the Query statement
     * @param relPath          the relative path to resolve against query result nodes for package resources
     * @return a unique set of paths to include in the package
     * @throws RepositoryException
     */
public List<Resource> findResources(final ResourceResolver resourceResolver, final String language, final String statement, final String relPath) throws RepositoryException{
    if (StringUtils.isEmpty(statement)) {
        return Collections.emptyList();
    }
    final String[] lines = StringUtils.split(statement, '\n');
    if (QUERY_BUILDER.equalsIgnoreCase(language)) {
        return getResourcesFromQueryBuilder(resourceResolver, lines, relPath);
    } else if (LIST.equalsIgnoreCase(language)) {
        return getResourcesFromList(resourceResolver, lines, relPath);
    } else {
        return getResourcesFromQuery(resourceResolver, language, statement, relPath);
    }
}","public List<Resource> findResources(final ResourceResolver resourceResolver, final String language, final String statement, final String relPath) throws RepositoryException{
    if (StringUtils.isEmpty(statement)) {
        return Collections.emptyList();
    }
    final String[] lines = StringUtils.split(statement, '\n');
    if (QUERY_BUILDER.equalsIgnoreCase(language)) {
        return getResourcesFromQueryBuilder(resourceResolver, lines, relPath);
    } else if (LIST.equalsIgnoreCase(language)) {
        return getResourcesFromList(resourceResolver, lines, relPath);
    } else {
        return getResourcesFromQuery(resourceResolver, language, statement, relPath);
    }
}","/**
     * Find all the resources needed for the package definition.
     *
     * @param resourceResolver the resource resolver to find the resources
     * @param language         the Query language
     * @param statement        the Query statement
     * @param relPath          the relative path to resolve against query result nodes for package resources
     * @return a unique set of paths to include in the package
     * @throws RepositoryException
     */","('findResources', {'INSTRUCTION': {'covered': 34, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",118.0,  Find all the resources needed for the package definition.,10.0,"['The package definition requires resources.', 'The package definition needs all the resources found here.', 'The package definition requires all the resources found here.']"
671,matsim-libs,org/matsim/core/router/priorityqueue/BinaryMinHeap.java,/matsim/src/main/java/org/matsim/core/router/priorityqueue/BinaryMinHeap.java,remove,275-311,"/**
	 * Removes a single instance of the specified element from this
	 * queue, if it is present.
	 *
	 * @return <tt>true</tt> if the queue contained the specified
	 *         element.
	 */
public boolean remove(E value){
    if (value == null)
        return false;
    int index = indices[this.getIndex(value)];
    if (index < 0) {
        return false;
    } else {
        if (classicalRemove) {
            boolean decreasedKey = decreaseKey(value, Double.NEGATIVE_INFINITY);
            if (decreasedKey && data[0] == value) {
                this.poll();
                return true;
            } else
                return false;
        } else {
            siftDownUp(index);
            indices[this.getIndex(value)] = -1;
            this.modCount++;
            return true;
        }
    }
}","public boolean remove(E value){
    if (value == null)
        return false;
    int index = indices[this.getIndex(value)];
    if (index < 0) {
        return false;
    } else {
        if (classicalRemove) {
            boolean decreasedKey = decreaseKey(value, Double.NEGATIVE_INFINITY);
            if (decreasedKey && data[0] == value) {
                this.poll();
                return true;
            } else
                return false;
        } else {
            siftDownUp(index);
            indices[this.getIndex(value)] = -1;
            this.modCount++;
            return true;
        }
    }
}","/**
	 * Removes a single instance of the specified element from this
	 * queue, if it is present.
	 *
	 * @return <tt>true</tt> if the queue contained the specified
	 *         element.
	 */","('remove', {'INSTRUCTION': {'covered': 54, 'missed': 2}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 13, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",118.0,"  Removes a single instance of the specified element from this  queue, if it is present.",17.0,"['If there is a single instance of the specified element in this queue, it is removed.', ""If there is a single instance of the specified element in this queue, it's removed."", 'If there is a single instance of the specified element present, it is removed.']"
672,cdk,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,splitAfter,242-269,"/**
     * Splits this partition by taking the cell at cellIndex and making two
     * new cells - the first with the the rest of the elements from that cell
     * and the second with the singleton splitElement.
     *
     * @param cellIndex the index of the cell to split on
     * @param splitElement the element to put in its own cell
     * @return a new (finer) Partition
     */
public Partition splitAfter(int cellIndex, int splitElement){
    Partition r = new Partition();
    for (int j = 0; j < cellIndex; j++) {
        r.addCell(this.copyBlock(j));
    }
    SortedSet<Integer> splitBlock = this.copyBlock(cellIndex);
    splitBlock.remove(splitElement);
    r.addCell(splitBlock);
    r.addSingletonCell(splitElement);
    for (int j = cellIndex + 1; j < this.size(); j++) {
        r.addCell(this.copyBlock(j));
    }
    return r;
}","public Partition splitAfter(int cellIndex, int splitElement){
    Partition r = new Partition();
    for (int j = 0; j < cellIndex; j++) {
        r.addCell(this.copyBlock(j));
    }
    SortedSet<Integer> splitBlock = this.copyBlock(cellIndex);
    splitBlock.remove(splitElement);
    r.addCell(splitBlock);
    r.addSingletonCell(splitElement);
    for (int j = cellIndex + 1; j < this.size(); j++) {
        r.addCell(this.copyBlock(j));
    }
    return r;
}","/**
     * Splits this partition by taking the cell at cellIndex and making two
     * new cells - the first with the the rest of the elements from that cell
     * and the second with the singleton splitElement.
     *
     * @param cellIndex the index of the cell to split on
     * @param splitElement the element to put in its own cell
     * @return a new (finer) Partition
     */","('splitAfter', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",119.0,  Splits this partition by taking the cell at cellIndex and making two  new cells - the first with the the rest of the elements from that cell  and the second with the singleton splitElement.,35.0,"['The partition can be split by taking the cell at cellIndex and making two new cells, one with the rest of the elements from that cell and the other with the singleton splitElement.', 'The partition can be split by taking the cell at cellIndex and making two new cells with the rest of the elements from that cell.', 'The partition can be split by taking the cell at cellIndex and making two new cells, one with the rest of the elements from that cell and the other with a singleton splitElement.']"
673,cdk,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,splitBefore,213-240,"/**
     * Splits this partition by taking the cell at cellIndex and making two
     * new cells - the first with the singleton splitElement and the second
     * with the rest of the elements from that cell.
     *
     * @param cellIndex the index of the cell to split on
     * @param splitElement the element to put in its own cell
     * @return a new (finer) Partition
     */
public Partition splitBefore(int cellIndex, int splitElement){
    Partition r = new Partition();
    for (int j = 0; j < cellIndex; j++) {
        r.addCell(this.copyBlock(j));
    }
    r.addSingletonCell(splitElement);
    SortedSet<Integer> splitBlock = this.copyBlock(cellIndex);
    splitBlock.remove(splitElement);
    r.addCell(splitBlock);
    for (int j = cellIndex + 1; j < this.size(); j++) {
        r.addCell(this.copyBlock(j));
    }
    return r;
}","public Partition splitBefore(int cellIndex, int splitElement){
    Partition r = new Partition();
    for (int j = 0; j < cellIndex; j++) {
        r.addCell(this.copyBlock(j));
    }
    r.addSingletonCell(splitElement);
    SortedSet<Integer> splitBlock = this.copyBlock(cellIndex);
    splitBlock.remove(splitElement);
    r.addCell(splitBlock);
    for (int j = cellIndex + 1; j < this.size(); j++) {
        r.addCell(this.copyBlock(j));
    }
    return r;
}","/**
     * Splits this partition by taking the cell at cellIndex and making two
     * new cells - the first with the singleton splitElement and the second
     * with the rest of the elements from that cell.
     *
     * @param cellIndex the index of the cell to split on
     * @param splitElement the element to put in its own cell
     * @return a new (finer) Partition
     */","('splitBefore', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",119.0,  Splits this partition by taking the cell at cellIndex and making two  new cells - the first with the singleton splitElement and the second  with the rest of the elements from that cell.,34.0,"['The first cell with the singleton splitElement and the second with the rest of the elements from that cell are split into two new cells.', 'The first cell with the singleton splitElement is used to split the partition and the second with the rest of the elements from that cell.', 'The first cell with the singleton splitElement is used to split the partition and the second with the rest of the elements from that cell is used.']"
674,liquibase,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,isNoArgCommand,680-699,"/**
     * Returns true if the given main command arg needs no special parameters.
     *
     * @param arg the main command to test
     * @return true if arg is a valid main command and needs no special parameters, false in all other cases
     */
private static boolean isNoArgCommand(String arg){
    return COMMANDS.MIGRATE.equals(arg) || COMMANDS.MIGRATE_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE.equalsIgnoreCase(arg) || COMMANDS.UPDATE_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE_TESTING_ROLLBACK.equalsIgnoreCase(arg) || COMMANDS.LIST_LOCKS.equalsIgnoreCase(arg) || COMMANDS.RELEASE_LOCKS.equalsIgnoreCase(arg) || COMMANDS.VALIDATE.equalsIgnoreCase(arg) || COMMANDS.HELP.equalsIgnoreCase(arg) || COMMANDS.CLEAR_CHECKSUMS.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(arg);
}","private static boolean isNoArgCommand(String arg){
    return COMMANDS.MIGRATE.equals(arg) || COMMANDS.MIGRATE_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE.equalsIgnoreCase(arg) || COMMANDS.UPDATE_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE_TESTING_ROLLBACK.equalsIgnoreCase(arg) || COMMANDS.LIST_LOCKS.equalsIgnoreCase(arg) || COMMANDS.RELEASE_LOCKS.equalsIgnoreCase(arg) || COMMANDS.VALIDATE.equalsIgnoreCase(arg) || COMMANDS.HELP.equalsIgnoreCase(arg) || COMMANDS.CLEAR_CHECKSUMS.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(arg);
}","/**
     * Returns true if the given main command arg needs no special parameters.
     *
     * @param arg the main command to test
     * @return true if arg is a valid main command and needs no special parameters, false in all other cases
     */","('isNoArgCommand', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'BRANCH': {'covered': 24, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 13, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",119.0,  Returns true if the given main command arg needs no special parameters.,13.0,"['If the main command needs no special parameters, this is true.', 'If the main command does not need any special parameters, this is true.', 'If the main command does not need any special parameters, it is true.']"
675,cdk,org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,axial3DEncoder,188-213,"/**
     * Create an encoder for axial 3D stereochemistry for the given start and
     * end atoms.
     *
     * @param container  the molecule
     * @param start      start of the cumulated system
     * @param startBonds bonds connected to the start
     * @param end        end of the cumulated system
     * @param endBonds   bonds connected to the end
     * @return an encoder
     */
private static StereoEncoder axial3DEncoder(IAtomContainer container, IAtom start, List<IBond> startBonds, IAtom end, List<IBond> endBonds){
    Point3d[] coordinates = new Point3d[4];
    PermutationParity perm = new CombinedPermutationParity(fill3DCoordinates(container, start, startBonds, coordinates, 0), fill3DCoordinates(container, end, endBonds, coordinates, 2));
    GeometricParity geom = new Tetrahedral3DParity(coordinates);
    int u = container.indexOf(start);
    int v = container.indexOf(end);
    return new GeometryEncoder(new int[] { u, v }, perm, geom);
}","private static StereoEncoder axial3DEncoder(IAtomContainer container, IAtom start, List<IBond> startBonds, IAtom end, List<IBond> endBonds){
    Point3d[] coordinates = new Point3d[4];
    PermutationParity perm = new CombinedPermutationParity(fill3DCoordinates(container, start, startBonds, coordinates, 0), fill3DCoordinates(container, end, endBonds, coordinates, 2));
    GeometricParity geom = new Tetrahedral3DParity(coordinates);
    int u = container.indexOf(start);
    int v = container.indexOf(end);
    return new GeometryEncoder(new int[] { u, v }, perm, geom);
}","/**
     * Create an encoder for axial 3D stereochemistry for the given start and
     * end atoms.
     *
     * @param container  the molecule
     * @param start      start of the cumulated system
     * @param startBonds bonds connected to the start
     * @param end        end of the cumulated system
     * @param endBonds   bonds connected to the end
     * @return an encoder
     */","('axial3DEncoder', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",120.0,Create an encoder for axial 3D stereochemistry for the given start and  end atoms.,15.0,"['The given start and end atoms need an Encoder for 3D stereochemistry.', 'The given start and end atoms should be given a 3D stereochemistry.', 'The given start and end atoms need an Encoder for 3D Stereochemistry.']"
676,openapi-generator,org/openapitools/codegen/validations/oas/OpenApiParameterValidations.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/validations/oas/OpenApiParameterValidations.java,apacheNginxHeaderCheck,29-47,"/**
     * Apache and Nginx default to legacy CGI behavior in which header with underscore are ignored. Raise this for awareness to the user.
     *
     * @param parameter Any spec doc parameter. The method will handle {@link HeaderParameter} evaluation.
     * @return {@link ValidationRule.Pass} if the check succeeds, otherwise {@link ValidationRule.Fail} with details ""[key] contains an underscore.""
     */
private static ValidationRule.Result apacheNginxHeaderCheck(ParameterWrapper parameterWrapper){
    Parameter parameter = parameterWrapper.getParameter();
    if (parameter == null || !""header"".equals(parameter.getIn()))
        return ValidationRule.Pass.empty();
    ValidationRule.Result result = ValidationRule.Pass.empty();
    String headerName = parameter.getName();
    if (StringUtils.isNotEmpty(headerName) && StringUtils.contains(headerName, '_')) {
        result = new ValidationRule.Fail();
        result.setDetails(String.format(Locale.ROOT, ""%s contains an underscore."", headerName));
    }
    return result;
}","private static ValidationRule.Result apacheNginxHeaderCheck(ParameterWrapper parameterWrapper){
    Parameter parameter = parameterWrapper.getParameter();
    if (parameter == null || !""header"".equals(parameter.getIn()))
        return ValidationRule.Pass.empty();
    ValidationRule.Result result = ValidationRule.Pass.empty();
    String headerName = parameter.getName();
    if (StringUtils.isNotEmpty(headerName) && StringUtils.contains(headerName, '_')) {
        result = new ValidationRule.Fail();
        result.setDetails(String.format(Locale.ROOT, ""%s contains an underscore."", headerName));
    }
    return result;
}","/**
     * Apache and Nginx default to legacy CGI behavior in which header with underscore are ignored. Raise this for awareness to the user.
     *
     * @param parameter Any spec doc parameter. The method will handle {@link HeaderParameter} evaluation.
     * @return {@link ValidationRule.Pass} if the check succeeds, otherwise {@link ValidationRule.Fail} with details ""[key] contains an underscore.""
     */","('apacheNginxHeaderCheck', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",120.0,  Apache and Nginx default to legacy CGI behavior in which header with underscore are ignored.,16.0,"['The legacy behavior of Apache and Nginx is ignored.', 'The default behavior of Apache and Nginx is to ignore the underscore.', 'Apache and Nginx default to legacy behavior.']"
677,cdk,org/openscience/cdk/ConformerContainer.java,/base/data/src/main/java/org/openscience/cdk/ConformerContainer.java,add,220-252,"/**
     * Add a conformer to the end of the list.
     * 
     * This method allows you to add a IAtomContainer object as another conformer.
     * Before adding it ensures that the title of specific object matches the
     * stored title for these conformers. It will also check that the number of
     * atoms in the specified molecule match the number of atoms in the current set
     * of conformers.
     * 
     * This method will not check for duplicate conformers.
     *
     * @param atomContainer The new conformer to add.
     * @return true
     */
public boolean add(IAtomContainer atomContainer){
    if (this.atomContainer == null) {
        this.atomContainer = atomContainer;
        title = (String) atomContainer.getTitle();
    }
    if (title == null) {
        throw new IllegalArgumentException(""At least one of the input molecules does not have a title"");
    }
    if (!title.equals(atomContainer.getTitle()))
        throw new IllegalArgumentException(""The input molecules does not have the same title ('"" + title + ""') as the other conformers ('"" + atomContainer.getTitle() + ""')"");
    if (atomContainer.getAtomCount() != this.atomContainer.getAtomCount())
        throw new IllegalArgumentException(""Doesn't have the same number of atoms as the rest of the conformers"");
    coordinates.add(getCoordinateList(atomContainer));
    return true;
}","public boolean add(IAtomContainer atomContainer){
    if (this.atomContainer == null) {
        this.atomContainer = atomContainer;
        title = (String) atomContainer.getTitle();
    }
    if (title == null) {
        throw new IllegalArgumentException(""At least one of the input molecules does not have a title"");
    }
    if (!title.equals(atomContainer.getTitle()))
        throw new IllegalArgumentException(""The input molecules does not have the same title ('"" + title + ""') as the other conformers ('"" + atomContainer.getTitle() + ""')"");
    if (atomContainer.getAtomCount() != this.atomContainer.getAtomCount())
        throw new IllegalArgumentException(""Doesn't have the same number of atoms as the rest of the conformers"");
    coordinates.add(getCoordinateList(atomContainer));
    return true;
}","/**
     * Add a conformer to the end of the list.
     * 
     * This method allows you to add a IAtomContainer object as another conformer.
     * Before adding it ensures that the title of specific object matches the
     * stored title for these conformers. It will also check that the number of
     * atoms in the specified molecule match the number of atoms in the current set
     * of conformers.
     * 
     * This method will not check for duplicate conformers.
     *
     * @param atomContainer The new conformer to add.
     * @return true
     */","('add', {'INSTRUCTION': {'covered': 54, 'missed': 10}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 10, 'missed': 2}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",120.0,  Add a conformer to the end of the list.,10.0,"['The end of the list should have a conformer added to it.', 'A conformer is added to the end of the list.', 'The end of the list should have a conformer added.']"
678,jackson-databind,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,findFirstAnnotatedEnumValue,1093-1121,"/**
     * A method that will look for the first Enum value annotated with the given Annotation.
     * <p>
     * If there's more than one value annotated, the first one found will be returned. Which one exactly is used is undetermined.
     *
     * @param enumClass The Enum class to scan for a value with the given annotation
     * @param annotationClass The annotation to look for.
     * @return the Enum value annotated with the given Annotation or {@code null} if none is found.
     * @throws IllegalArgumentException if there's a reflection issue accessing the Enum
     * @since 2.8
     */
public static Enum<?> findFirstAnnotatedEnumValue(Class<Enum<?>> enumClass, Class<T> annotationClass){
    Field[] fields = enumClass.getDeclaredFields();
    for (Field field : fields) {
        if (field.isEnumConstant()) {
            Annotation defaultValueAnnotation = field.getAnnotation(annotationClass);
            if (defaultValueAnnotation != null) {
                final String name = field.getName();
                for (Enum<?> enumValue : enumClass.getEnumConstants()) {
                    if (name.equals(enumValue.name())) {
                        return enumValue;
                    }
                }
            }
        }
    }
    return null;
}","public static Enum<?> findFirstAnnotatedEnumValue(Class<Enum<?>> enumClass, Class<T> annotationClass){
    Field[] fields = enumClass.getDeclaredFields();
    for (Field field : fields) {
        if (field.isEnumConstant()) {
            Annotation defaultValueAnnotation = field.getAnnotation(annotationClass);
            if (defaultValueAnnotation != null) {
                final String name = field.getName();
                for (Enum<?> enumValue : enumClass.getEnumConstants()) {
                    if (name.equals(enumValue.name())) {
                        return enumValue;
                    }
                }
            }
        }
    }
    return null;
}","/**
     * A method that will look for the first Enum value annotated with the given Annotation.
     * <p>
     * If there's more than one value annotated, the first one found will be returned. Which one exactly is used is undetermined.
     *
     * @param enumClass The Enum class to scan for a value with the given annotation
     * @param annotationClass The annotation to look for.
     * @return the Enum value annotated with the given Annotation or {@code null} if none is found.
     * @throws IllegalArgumentException if there's a reflection issue accessing the Enum
     * @since 2.8
     */","('findFirstAnnotatedEnumValue', {'INSTRUCTION': {'covered': 58, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",120.0,  A method that will look for the first Enum value annotated with the given Annotation.,16.0,"['The method will look for the first Enum value.', 'The method will look for the first Enum value in the Annotation.', 'A method that will look for the first Enum value.']"
685,dcache,org/dcache/pool/movers/ChecksumChannel.java,/modules/dcache/src/main/java/org/dcache/pool/movers/ChecksumChannel.java,finalizeChecksums,239-271,"/**
     * Returns the computed digest or null if overlapping writes have been detected.
     *
     * @return Checksum
     */
private Set<Checksum> finalizeChecksums(){
    _ioStateWriteLock.lock();
    try {
        _isWritable = false;
    } finally {
        _ioStateWriteLock.unlock();
    }
    synchronized (_dataRangeSet) {
        synchronized (_digests) {
            try {
                if (_dataRangeSet.asRanges().size() != 1 || _nextChecksumOffset == 0) {
                    feedZerosToDigesterForRangeGaps();
                }
                return _digests.stream().map(Checksum::new).collect(Collectors.toSet());
            } catch (IOException e) {
                _log.info(""Unable to generate checksum of sparse file: {}"", e.toString());
                return Collections.emptySet();
            }
        }
    }
}","private Set<Checksum> finalizeChecksums(){
    _ioStateWriteLock.lock();
    try {
        _isWritable = false;
    } finally {
        _ioStateWriteLock.unlock();
    }
    synchronized (_dataRangeSet) {
        synchronized (_digests) {
            try {
                if (_dataRangeSet.asRanges().size() != 1 || _nextChecksumOffset == 0) {
                    feedZerosToDigesterForRangeGaps();
                }
                return _digests.stream().map(Checksum::new).collect(Collectors.toSet());
            } catch (IOException e) {
                _log.info(""Unable to generate checksum of sparse file: {}"", e.toString());
                return Collections.emptySet();
            }
        }
    }
}","/**
     * Returns the computed digest or null if overlapping writes have been detected.
     *
     * @return Checksum
     */","('finalizeChecksums', {'INSTRUCTION': {'covered': 43, 'missed': 10}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 3}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",121.0,  Returns the computed digest or null if overlapping writes have been detected.,13.0,"['If a write has been detected, returns the computed digest or null.', 'If there are overlap writes, returns the computed digest or null.', 'If a write has been detected, returns the computed digest.']"
686,dcache,org/dcache/services/info/base/StatePath.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StatePath.java,calcHashCode,104-132,"/**
     * Calculate the hash code and store it for later quick reference.
     */
 void calcHashCode(){
    int code = 0;
    int elementCount = 0;
    for (String element : _elements) {
        int stringHash = 0;
        if (element == null) {
            stringHash = NULL_ELEMENT_HASH;
        } else {
            byte[] bytes = element.getBytes();
            int len = bytes.length > 10 ? 10 : bytes.length;
            for (int i = 0; i < len; i++) {
                stringHash ^= (bytes[i]) << (i * 5 + elementCount) % 24;
            }
        }
        code ^= stringHash;
        elementCount++;
    }
    _myHashCode = code;
    _haveHashCode = true;
}","void calcHashCode(){
    int code = 0;
    int elementCount = 0;
    for (String element : _elements) {
        int stringHash = 0;
        if (element == null) {
            stringHash = NULL_ELEMENT_HASH;
        } else {
            byte[] bytes = element.getBytes();
            int len = bytes.length > 10 ? 10 : bytes.length;
            for (int i = 0; i < len; i++) {
                stringHash ^= (bytes[i]) << (i * 5 + elementCount) % 24;
            }
        }
        code ^= stringHash;
        elementCount++;
    }
    _myHashCode = code;
    _haveHashCode = true;
}","/**
     * Calculate the hash code and store it for later quick reference.
     */","('calcHashCode', {'INSTRUCTION': {'covered': 68, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",121.0,  Calculate the hash code and store it for later quick reference.,12.0,"['Store the code for later reference.', 'Store the hash code for later reference.', 'Store the code for reference.']"
687,cdk,org/openscience/cdk/group/AbstractDiscretePartitionRefiner.java,/tool/group/src/main/java/org/openscience/cdk/group/AbstractDiscretePartitionRefiner.java,compareRowwise,335-353,"/**
     * Check a permutation to see if it is better, equal, or worse than the
     * current best.
     *
     * @param perm the permutation to check
     * @return BETTER, EQUAL, or WORSE
     */
private Result compareRowwise(Permutation perm){
    int m = perm.size();
    for (int i = 0; i < m - 1; i++) {
        for (int j = i + 1; j < m; j++) {
            int x = getConnectivity(best.get(i), best.get(j));
            int y = getConnectivity(perm.get(i), perm.get(j));
            if (x > y)
                return Result.WORSE;
            if (x < y)
                return Result.BETTER;
        }
    }
    return Result.EQUAL;
}","private Result compareRowwise(Permutation perm){
    int m = perm.size();
    for (int i = 0; i < m - 1; i++) {
        for (int j = i + 1; j < m; j++) {
            int x = getConnectivity(best.get(i), best.get(j));
            int y = getConnectivity(perm.get(i), perm.get(j));
            if (x > y)
                return Result.WORSE;
            if (x < y)
                return Result.BETTER;
        }
    }
    return Result.EQUAL;
}","/**
     * Check a permutation to see if it is better, equal, or worse than the
     * current best.
     *
     * @param perm the permutation to check
     * @return BETTER, EQUAL, or WORSE
     */","('compareRowwise', {'INSTRUCTION': {'covered': 49, 'missed': 4}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",121.0,"  Check a permutation to see if it is better, equal, or worse than the  current best.",19.0,"['To find out if it is better, equal, or worse than the current best, check a permutation.', 'To find out if it is better, equal or worse than the current best, check a permutation.', 'To see if a permutation is better, equal, or worse than the current best, check it.']"
688,cdk,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,contribution,355-382,"/**
     * Electron contribution of an element with the specified connectivity and valence.
     *
     * @param elem atomic number
     * @param x    connectivity
     * @param v    bonded valence
     * @return p electrons
     */
 static int contribution(int elem, int x, int v){
    switch(elem) {
        case 6:
            if (x == 3 && v == 4)
                return 1;
            break;
        case 7:
            if (x == 2 && v == 3)
                return 1;
            if (x == 3 && v == 4)
                return 1;
            if (x == 3 && v == 3)
                return 2;
            if (x == 2 && v == 2)
                return 2;
            break;
        case 8:
        case 16:
            if (x == 2 && v == 2)
                return 2;
            break;
    }
    return -1;
}","static int contribution(int elem, int x, int v){
    switch(elem) {
        case 6:
            if (x == 3 && v == 4)
                return 1;
            break;
        case 7:
            if (x == 2 && v == 3)
                return 1;
            if (x == 3 && v == 4)
                return 1;
            if (x == 3 && v == 3)
                return 2;
            if (x == 2 && v == 2)
                return 2;
            break;
        case 8:
        case 16:
            if (x == 2 && v == 2)
                return 2;
            break;
    }
    return -1;
}","/**
     * Electron contribution of an element with the specified connectivity and valence.
     *
     * @param elem atomic number
     * @param x    connectivity
     * @param v    bonded valence
     * @return p electrons
     */","('contribution', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'BRANCH': {'covered': 28, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 16, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",121.0,  Electron contribution of an element with the specified connectivity and valence.,12.0,"[""The element's electron contribution is determined by the connection and valence of the element."", ""The element's electron contribution is determined by the connection and valence."", ""The element's electron contribution is determined by the connected and the valence.""]"
689,acs-aem-commons,com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,/bundle/src/main/java/com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,create,350-375,"/**
     * Create the oak index based on the ensure definition.
     *
     * @param ensuredDefinition the ensure definition
     * @param oakIndexes        the parent oak index folder
     * @return the updated oak index resource
     * @throws PersistenceException
     * @throws RepositoryException
     */
public Resource create(@Nonnull final Resource ensuredDefinition, @Nonnull final Resource oakIndexes) throws RepositoryException{
    final Node oakIndex = JcrUtil.copy(ensuredDefinition.adaptTo(Node.class), oakIndexes.adaptTo(Node.class), ensuredDefinition.getName());
    oakIndex.setPrimaryType(NT_OAK_QUERY_INDEX_DEFINITION);
    oakIndex.setProperty(JcrConstants.JCR_CREATED, Calendar.getInstance());
    oakIndex.setProperty(JcrConstants.JCR_CREATED_BY, ENSURE_OAK_INDEX_USER_NAME);
    log.info(""Created Oak Index at [ {} ] with Ensure Definition [ {} ]"", oakIndex.getPath(), ensuredDefinition.getPath());
    return ensuredDefinition.getResourceResolver().getResource(oakIndex.getPath());
}","public Resource create(@Nonnull final Resource ensuredDefinition, @Nonnull final Resource oakIndexes) throws RepositoryException{
    final Node oakIndex = JcrUtil.copy(ensuredDefinition.adaptTo(Node.class), oakIndexes.adaptTo(Node.class), ensuredDefinition.getName());
    oakIndex.setPrimaryType(NT_OAK_QUERY_INDEX_DEFINITION);
    oakIndex.setProperty(JcrConstants.JCR_CREATED, Calendar.getInstance());
    oakIndex.setProperty(JcrConstants.JCR_CREATED_BY, ENSURE_OAK_INDEX_USER_NAME);
    log.info(""Created Oak Index at [ {} ] with Ensure Definition [ {} ]"", oakIndex.getPath(), ensuredDefinition.getPath());
    return ensuredDefinition.getResourceResolver().getResource(oakIndex.getPath());
}","/**
     * Create the oak index based on the ensure definition.
     *
     * @param ensuredDefinition the ensure definition
     * @param oakIndexes        the parent oak index folder
     * @return the updated oak index resource
     * @throws PersistenceException
     * @throws RepositoryException
     */","('create', {'INSTRUCTION': {'covered': 38, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",121.0,  Create the oak index based on the ensure definition.,10.0,"['The oak index can be created based on the ensure definition.', 'The oak index should be created based on the ensure definition.', 'The oak index is created based on the ensure definition.']"
690,cdk,org/openscience/cdk/isomorphism/UllmannState.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/UllmannState.java,refine,161-194,"/**
     * Refines the compatibility removing any mappings which have now become
     * invalid (since the last mapping). The matrix is refined from the row
     * after the current {@code row} - all previous rows are fixed. If when
     * refined we find a query vertex has no more candidates left in the target
     * we can never reach a feasible matching and refinement is aborted (false
     * is returned).
     *
     * @param row refine from here
     * @return match is still feasible
     */
private boolean refine(int row){
    int marking = -(row + 1);
    boolean changed;
    do {
        changed = false;
        for (int n = row + 1; n < matrix.nRows; n++) {
            for (int m = 0; m < matrix.mCols; m++) {
                if (matrix.get(n, m) && !verify(n, m)) {
                    matrix.mark(n, m, marking);
                    changed = true;
                    if (!hasCandidate(n))
                        return false;
                }
            }
        }
    } while (changed);
    return true;
}","private boolean refine(int row){
    int marking = -(row + 1);
    boolean changed;
    do {
        changed = false;
        for (int n = row + 1; n < matrix.nRows; n++) {
            for (int m = 0; m < matrix.mCols; m++) {
                if (matrix.get(n, m) && !verify(n, m)) {
                    matrix.mark(n, m, marking);
                    changed = true;
                    if (!hasCandidate(n))
                        return false;
                }
            }
        }
    } while (changed);
    return true;
}","/**
     * Refines the compatibility removing any mappings which have now become
     * invalid (since the last mapping). The matrix is refined from the row
     * after the current {@code row} - all previous rows are fixed. If when
     * refined we find a query vertex has no more candidates left in the target
     * we can never reach a feasible matching and refinement is aborted (false
     * is returned).
     *
     * @param row refine from here
     * @return match is still feasible
     */","('refine', {'INSTRUCTION': {'covered': 56, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",122.0,  Refines the compatibility removing any mappings which have now become  invalid (since the last mapping).,18.0,"['Since the last mapping, any mappings that have become invalid have been removed.', 'Since the last mapping, any mappings that have become invalid are removed.', 'Since the last mapping, any mappings which have become invalid are removed.']"
691,cdk,org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,showCarbon,372-397,"/**
     * Checks a carbon atom to see if it should be shown.
     *
     * @param carbonAtom the carbon atom to check
     * @param container the atom container
     * @param model the renderer model
     * @return true if the carbon should be shown
     */
protected boolean showCarbon(IAtom carbonAtom, IAtomContainer container, RendererModel model){
    if ((Boolean) model.get(KekuleStructure.class))
        return true;
    if (carbonAtom.getFormalCharge() != 0)
        return true;
    int connectedBondCount = container.getConnectedBondsList(carbonAtom).size();
    if (connectedBondCount < 1)
        return true;
    if ((Boolean) model.get(ShowEndCarbons.class) && connectedBondCount == 1)
        return true;
    if (carbonAtom.getProperty(ProblemMarker.ERROR_MARKER) != null)
        return true;
    if (container.getConnectedSingleElectronsCount(carbonAtom) > 0)
        return true;
    return false;
}","protected boolean showCarbon(IAtom carbonAtom, IAtomContainer container, RendererModel model){
    if ((Boolean) model.get(KekuleStructure.class))
        return true;
    if (carbonAtom.getFormalCharge() != 0)
        return true;
    int connectedBondCount = container.getConnectedBondsList(carbonAtom).size();
    if (connectedBondCount < 1)
        return true;
    if ((Boolean) model.get(ShowEndCarbons.class) && connectedBondCount == 1)
        return true;
    if (carbonAtom.getProperty(ProblemMarker.ERROR_MARKER) != null)
        return true;
    if (container.getConnectedSingleElectronsCount(carbonAtom) > 0)
        return true;
    return false;
}","/**
     * Checks a carbon atom to see if it should be shown.
     *
     * @param carbonAtom the carbon atom to check
     * @param container the atom container
     * @param model the renderer model
     * @return true if the carbon should be shown
     */","('showCarbon', {'INSTRUCTION': {'covered': 49, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",122.0,  Checks a carbon atom to see if it should be shown.,12.0,"['A carbon atom is checked to see if it should be shown.', 'A carbon atom is looked at to see if it should be shown.', 'The carbon atom is checked to see if it should be shown.']"
693,cdk,org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,accept,235-269,"/**
     * Test whether we accept atom and it's connected bonds for inclusion in a
     * double bond configuration. This method checks for query bonds (up/down)
     * as well as double bond counts. If there is more then one double bond in
     * the connect bonds then it cannot have Z/E configuration.
     *
     * @param atom  a double bonded atom
     * @param bonds all bonds connected to the atom
     * @return whether the atom is accepted for configuration
     */
 static boolean accept(IAtom atom, List<IBond> bonds){
    int dbCount = 0;
    if (!IAtomType.Hybridization.SP2.equals(atom.getHybridization()))
        return false;
    if (bonds.size() == 1)
        return false;
    for (IBond bond : bonds) {
        if (DOUBLE.equals(bond.getOrder()))
            dbCount++;
        IBond.Stereo stereo = bond.getStereo();
        if (IBond.Stereo.UP_OR_DOWN.equals(stereo) || IBond.Stereo.UP_OR_DOWN_INVERTED.equals(stereo))
            return false;
    }
    return dbCount == 1;
}","static boolean accept(IAtom atom, List<IBond> bonds){
    int dbCount = 0;
    if (!IAtomType.Hybridization.SP2.equals(atom.getHybridization()))
        return false;
    if (bonds.size() == 1)
        return false;
    for (IBond bond : bonds) {
        if (DOUBLE.equals(bond.getOrder()))
            dbCount++;
        IBond.Stereo stereo = bond.getStereo();
        if (IBond.Stereo.UP_OR_DOWN.equals(stereo) || IBond.Stereo.UP_OR_DOWN_INVERTED.equals(stereo))
            return false;
    }
    return dbCount == 1;
}","/**
     * Test whether we accept atom and it's connected bonds for inclusion in a
     * double bond configuration. This method checks for query bonds (up/down)
     * as well as double bond counts. If there is more then one double bond in
     * the connect bonds then it cannot have Z/E configuration.
     *
     * @param atom  a double bonded atom
     * @param bonds all bonds connected to the atom
     * @return whether the atom is accepted for configuration
     */","('accept', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",122.0,  Test whether we accept atom and it's connected bonds for inclusion in a  double bond configuration.,18.0,"['If we accept atom, it will be connected bonds for inclusion in a double bond configuration.', 'If we accept atom, it will be connected bonds that will be included in a double bond configuration.', 'If we accept atom, it will be connected bonds for inclusion in a double bond configuration']"
694,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,addPortSchemaRelationship,218-246,"/**
     * Create a PortSchema relationship between a Port and the corresponding SchemaType. Verifies that the
     * relationship is not present before creating it
     *
     * @param userId             the name of the calling user
     * @param portGUID           the unique identifier of the port
     * @param schemaTypeGUID     the unique identifier of the schema type
     * @param externalSourceName the unique name of the external source
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */
public void addPortSchemaRelationship(String userId, String portGUID, String schemaTypeGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    final String methodName = ""addPortSchemaRelationship"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateGUID(portGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    invalidParameterHandler.validateGUID(schemaTypeGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    if (!dataEngineCommonHandler.findRelationship(userId, portGUID, schemaTypeGUID, PORT_TYPE_NAME, PORT_SCHEMA_RELATIONSHIP_TYPE_NAME).isPresent()) {
        String externalSourceGUID = registrationHandler.getExternalDataEngine(userId, externalSourceName);
        portHandler.setupPortSchemaType(userId, externalSourceGUID, externalSourceName, portGUID, PORT_GUID_PARAMETER_NAME, schemaTypeGUID, SCHEMA_TYPE_GUID_PARAMETER_NAME, methodName);
    }
}","public void addPortSchemaRelationship(String userId, String portGUID, String schemaTypeGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    final String methodName = ""addPortSchemaRelationship"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateGUID(portGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    invalidParameterHandler.validateGUID(schemaTypeGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    if (!dataEngineCommonHandler.findRelationship(userId, portGUID, schemaTypeGUID, PORT_TYPE_NAME, PORT_SCHEMA_RELATIONSHIP_TYPE_NAME).isPresent()) {
        String externalSourceGUID = registrationHandler.getExternalDataEngine(userId, externalSourceName);
        portHandler.setupPortSchemaType(userId, externalSourceGUID, externalSourceName, portGUID, PORT_GUID_PARAMETER_NAME, schemaTypeGUID, SCHEMA_TYPE_GUID_PARAMETER_NAME, methodName);
    }
}","/**
     * Create a PortSchema relationship between a Port and the corresponding SchemaType. Verifies that the
     * relationship is not present before creating it
     *
     * @param userId             the name of the calling user
     * @param portGUID           the unique identifier of the port
     * @param schemaTypeGUID     the unique identifier of the schema type
     * @param externalSourceName the unique name of the external source
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */","('addPortSchemaRelationship', {'INSTRUCTION': {'covered': 47, 'missed': 0}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",122.0,  Create a PortSchema relationship between a Port and the corresponding SchemaType.,12.0,"['A Port and a corresponding SchemaType can be created with a PortSchema relationship.', 'A Port and corresponding SchemaType can be created with a PortSchema relationship.', 'A Port and a corresponding SchemaType can be created.']"
695,cdk,org/openscience/cdk/smiles/BeamToCDK.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/BeamToCDK.java,findDirectionalEdge,419-442,"/**
     * Utility for find the first directional edge incident to a vertex. If
     * there are no directional labels then null is returned.
     *
     * @param g graph from Beam
     * @param u the vertex for which to find
     * @return first directional edge (or null if none)
     */
private Edge findDirectionalEdge(Graph g, int u){
    List<Edge> edges = g.edges(u);
    if (edges.size() == 1)
        return null;
    Edge first = null;
    for (Edge e : edges) {
        Bond b = e.bond();
        if (b == Bond.UP || b == Bond.DOWN) {
            if (first == null)
                first = e;
            else if (((first.either() == e.either()) == (first.bond() == b)))
                return null;
        }
    }
    return first;
}","private Edge findDirectionalEdge(Graph g, int u){
    List<Edge> edges = g.edges(u);
    if (edges.size() == 1)
        return null;
    Edge first = null;
    for (Edge e : edges) {
        Bond b = e.bond();
        if (b == Bond.UP || b == Bond.DOWN) {
            if (first == null)
                first = e;
            else if (((first.either() == e.either()) == (first.bond() == b)))
                return null;
        }
    }
    return first;
}","/**
     * Utility for find the first directional edge incident to a vertex. If
     * there are no directional labels then null is returned.
     *
     * @param g graph from Beam
     * @param u the vertex for which to find
     * @return first directional edge (or null if none)
     */","('findDirectionalEdge', {'INSTRUCTION': {'covered': 54, 'missed': 3}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",122.0,  Utility for find the first directional edge incident to a vertex.,12.0,"['There is a utility that can be used to find the first directional edge incident.', 'There is a utility to find the first edge incident.', 'There is a utility that can be used to find the first edge incident.']"
696,tablesaw,tech/tablesaw/columns/dates/DateMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/dates/DateMapFunctions.java,yearQuarter,125-146,"/**
   * Returns a StringColumn with the year and quarter from this column concatenated into a String
   * that will sort lexicographically in temporal order.
   *
   * <p>This simplifies the production of plots and tables that aggregate values into standard
   * temporal units (e.g., you want monthly data but your source data is more than a year long and
   * you don't want months from different years aggregated together).
   */
 StringColumn yearQuarter(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & quarter"");
    for (int r = 0; r < this.size(); r++) {
        int c1 = this.getIntInternal(r);
        if (DateColumn.valueIsMissing(c1)) {
            newColumn.appendMissing();
        } else {
            String yq = String.valueOf(PackedLocalDate.getYear(c1));
            yq = yq + ""-"" + Strings.padStart(String.valueOf(PackedLocalDate.getQuarter(c1)), 2, '0');
            newColumn.append(yq);
        }
    }
    return newColumn;
}","StringColumn yearQuarter(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & quarter"");
    for (int r = 0; r < this.size(); r++) {
        int c1 = this.getIntInternal(r);
        if (DateColumn.valueIsMissing(c1)) {
            newColumn.appendMissing();
        } else {
            String yq = String.valueOf(PackedLocalDate.getYear(c1));
            yq = yq + ""-"" + Strings.padStart(String.valueOf(PackedLocalDate.getQuarter(c1)), 2, '0');
            newColumn.append(yq);
        }
    }
    return newColumn;
}","/**
   * Returns a StringColumn with the year and quarter from this column concatenated into a String
   * that will sort lexicographically in temporal order.
   *
   * <p>This simplifies the production of plots and tables that aggregate values into standard
   * temporal units (e.g., you want monthly data but your source data is more than a year long and
   * you don't want months from different years aggregated together).
   */","('yearQuarter', {'INSTRUCTION': {'covered': 52, 'missed': 4}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",124.0,  Returns a StringColumn with the year and quarter from this column concatenated into a String  that will sort lexicographically in temporal order.,23.0,"['The year and quarter from this column will be concatenated into a String that will sort lexicographically in temporal order.', 'The year and quarter from this column will be combined into a String that will sort lexicographically in temporal order.', 'The year and quarter from this column will be concatenated into a string that will sort lexicographically in temporal order.']"
697,jackson-databind,com/fasterxml/jackson/databind/node/ObjectNode.java,/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java,serialize,301-331,"/**
     * Method that can be called to serialize this node and
     * all of its descendants using specified JSON generator.
     */
public void serialize(JsonGenerator g, SerializerProvider provider) throws IOException{
    @SuppressWarnings(""deprecation"")
    boolean trimEmptyArray = (provider != null) && !provider.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS);
    g.writeStartObject(this);
    for (Map.Entry<String, JsonNode> en : _children.entrySet()) {
        BaseJsonNode value = (BaseJsonNode) en.getValue();
        if (trimEmptyArray && value.isArray() && value.isEmpty(provider)) {
            continue;
        }
        g.writeFieldName(en.getKey());
        value.serialize(g, provider);
    }
    g.writeEndObject();
}","public void serialize(JsonGenerator g, SerializerProvider provider) throws IOException{
    @SuppressWarnings(""deprecation"")
    boolean trimEmptyArray = (provider != null) && !provider.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS);
    g.writeStartObject(this);
    for (Map.Entry<String, JsonNode> en : _children.entrySet()) {
        BaseJsonNode value = (BaseJsonNode) en.getValue();
        if (trimEmptyArray && value.isArray() && value.isEmpty(provider)) {
            continue;
        }
        g.writeFieldName(en.getKey());
        value.serialize(g, provider);
    }
    g.writeEndObject();
}","/**
     * Method that can be called to serialize this node and
     * all of its descendants using specified JSON generator.
     */","('serialize', {'INSTRUCTION': {'covered': 52, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",124.0,  Method that can be called to serialize this node and  all of its descendants using specified JSON generator.,19.0,"['This method can be used to serialize this and all of its descendants.', 'This method can be used to serialize all of the descendants.', 'This method can be used to serialize this and all of its descendants using a specified generator.']"
698,acs-aem-commons,com/adobe/acs/commons/mcp/impl/processes/WorkflowRemover.java,/bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/WorkflowRemover.java,report,145-162,"/**
     * Collect and return a report row for the workflow status.  Method is package scope for unit tests.
     * @param status the status to report upon.
     * @return the row of data
     */
 EnumMap<ReportColumns, Object> report(WorkflowRemovalStatus status){
    final EnumMap<ReportColumns, Object> row = new EnumMap<>(ReportColumns.class);
    row.put(ReportColumns.STARTED, status.getStartedAt());
    row.put(ReportColumns.CHECKED, status.getChecked());
    row.put(ReportColumns.REMOVED, status.getRemoved());
    row.put(ReportColumns.COMPLETED, status.getCompletedAt());
    row.put(ReportColumns.ERRED, status.getErredAt());
    row.put(ReportColumns.INITIATED_BY, status.getInitiatedBy());
    return row;
}"," EnumMap<ReportColumns, Object> report(WorkflowRemovalStatus status){
    final EnumMap<ReportColumns, Object> row = new EnumMap<>(ReportColumns.class);
    row.put(ReportColumns.STARTED, status.getStartedAt());
    row.put(ReportColumns.CHECKED, status.getChecked());
    row.put(ReportColumns.REMOVED, status.getRemoved());
    row.put(ReportColumns.COMPLETED, status.getCompletedAt());
    row.put(ReportColumns.ERRED, status.getErredAt());
    row.put(ReportColumns.INITIATED_BY, status.getInitiatedBy());
    return row;
}","/**
     * Collect and return a report row for the workflow status.  Method is package scope for unit tests.
     * @param status the status to report upon.
     * @return the row of data
     */","('report', {'INSTRUCTION': {'covered': 45, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",125.0,  Collect and return a report row for the workflow status.,11.0,"['Return a report row for the status.', 'Return the report row for the status.', 'Return a report row for the status of the workflow.']"
699,tablesaw,tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,yearDay,238-259,"/**
   * Returns a StringColumn with the year and day-of-year derived from this column concatenated into
   * a String that will sort lexicographically in temporal order.
   *
   * <p>This simplifies the production of plots and tables that aggregate values into standard
   * temporal units (e.g., you want monthly data but your source data is more than a year long and
   * you don't want months from different years aggregated together).
   */
 StringColumn yearDay(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & month"");
    for (int r = 0; r < this.size(); r++) {
        long c1 = this.getLongInternal(r);
        if (DateTimeColumn.valueIsMissing(c1)) {
            newColumn.append(StringColumnType.missingValueIndicator());
        } else {
            String ym = String.valueOf(getYear(c1));
            ym = ym + ""-"" + Strings.padStart(String.valueOf(getDayOfYear(c1)), 3, '0');
            newColumn.append(ym);
        }
    }
    return newColumn;
}","StringColumn yearDay(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & month"");
    for (int r = 0; r < this.size(); r++) {
        long c1 = this.getLongInternal(r);
        if (DateTimeColumn.valueIsMissing(c1)) {
            newColumn.append(StringColumnType.missingValueIndicator());
        } else {
            String ym = String.valueOf(getYear(c1));
            ym = ym + ""-"" + Strings.padStart(String.valueOf(getDayOfYear(c1)), 3, '0');
            newColumn.append(ym);
        }
    }
    return newColumn;
}","/**
   * Returns a StringColumn with the year and day-of-year derived from this column concatenated into
   * a String that will sort lexicographically in temporal order.
   *
   * <p>This simplifies the production of plots and tables that aggregate values into standard
   * temporal units (e.g., you want monthly data but your source data is more than a year long and
   * you don't want months from different years aggregated together).
   */","('yearDay', {'INSTRUCTION': {'covered': 52, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",125.0,  Returns a StringColumn with the year and day-of-year derived from this column concatenated into  a String that will sort lexicographically in temporal order.,24.0,"['The year and day-of-year derived from this column will be used to sort the lexicographically in temporal order.', 'The year and day-of-year derived from this column will be used to sort the string by temporal order.', 'The year and day-of-year derived from this column will be returned as a string.']"
700,egeria,org/odpi/openmetadata/accessservices/assetconsumer/rest/LogRecordRequestBody.java,/open-metadata-implementation/access-services/asset-consumer/asset-consumer-api/src/main/java/org/odpi/openmetadata/accessservices/assetconsumer/rest/LogRecordRequestBody.java,equals,186-209,"/**
     * Equals method that returns true if containing properties are the same.
     *
     * @param objectToCompare object to compare
     * @return boolean result of comparison
     */
public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
        return false;
    }
    LogRecordRequestBody that = (LogRecordRequestBody) objectToCompare;
    return Objects.equals(getConnectorInstanceId(), that.getConnectorInstanceId()) && Objects.equals(getConnectionName(), that.getConnectionName()) && Objects.equals(getConnectorType(), that.getConnectorType()) && Objects.equals(getContextId(), that.getContextId()) && Objects.equals(getMessage(), that.getMessage());
}","public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
        return false;
    }
    LogRecordRequestBody that = (LogRecordRequestBody) objectToCompare;
    return Objects.equals(getConnectorInstanceId(), that.getConnectorInstanceId()) && Objects.equals(getConnectionName(), that.getConnectionName()) && Objects.equals(getConnectorType(), that.getConnectorType()) && Objects.equals(getContextId(), that.getContextId()) && Objects.equals(getMessage(), that.getMessage());
}","/**
     * Equals method that returns true if containing properties are the same.
     *
     * @param objectToCompare object to compare
     * @return boolean result of comparison
     */","('equals', {'INSTRUCTION': {'covered': 51, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 5}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",125.0,  Equals method that returns true if containing properties are the same.,12.0,"['If the properties are the same, the equal method returns true.', 'If the properties are the same, Equals method returns true.', 'If the properties are the same, equal method returns true.']"
701,openapi-generator,org/openapitools/codegen/validations/oas/OpenApiSchemaValidations.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/validations/oas/OpenApiSchemaValidations.java,checkOneOfWithProperties,55-85,"/**
     * JSON Schema defines oneOf as a validation property which can be applied to any schema.
     * <p>
     * OpenAPI Specification is a variant of JSON Schema for which oneOf is defined as:
     * ""Inline or referenced schema MUST be of a Schema Object and not a standard JSON Schema.""
     * <p>
     * Where the only examples of oneOf in OpenAPI Specification are used to define either/or type structures rather than validations.
     * Because of this ambiguity in the spec about what is non-standard about oneOf support, we'll warn as a recommendation that
     * properties on the schema defining oneOf relationships may not be intentional in the OpenAPI Specification.
     *
     * @param schemaWrapper An input schema, regardless of the type of schema
     * @return {@link ValidationRule.Pass} if the check succeeds, otherwise {@link ValidationRule.Fail}
     */
private static ValidationRule.Result checkOneOfWithProperties(SchemaWrapper schemaWrapper){
    Schema schema = schemaWrapper.getSchema();
    ValidationRule.Result result = ValidationRule.Pass.empty();
    if (schema instanceof ComposedSchema) {
        final ComposedSchema composed = (ComposedSchema) schema;
        // check for loosely defined oneOf extension requirements.
        // This is a recommendation because the 3.0.x spec is not clear enough on usage of oneOf.
        // see https://json-schema.org/draft/2019-09/json-schema-core.html#rfc.section.9.2.1.3 and the OAS section on 'Composition and Inheritance'.
        if (composed.getOneOf() != null && composed.getOneOf().size() > 0) {
            if (composed.getProperties() != null && composed.getProperties().size() >= 1 && composed.getProperties().get(""discriminator"") == null) {
                // not necessarily ""invalid"" here, but we trigger the recommendation which requires the method to return false.
                result = ValidationRule.Fail.empty();
            }
        }
    }
    return result;
}","private static ValidationRule.Result checkOneOfWithProperties(SchemaWrapper schemaWrapper){
    Schema schema = schemaWrapper.getSchema();
    ValidationRule.Result result = ValidationRule.Pass.empty();
    if (schema instanceof ComposedSchema) {
        final ComposedSchema composed = (ComposedSchema) schema;
        // check for loosely defined oneOf extension requirements.
        // This is a recommendation because the 3.0.x spec is not clear enough on usage of oneOf.
        // see https://json-schema.org/draft/2019-09/json-schema-core.html#rfc.section.9.2.1.3 and the OAS section on 'Composition and Inheritance'.
        if (composed.getOneOf() != null && composed.getOneOf().size() > 0) {
            if (composed.getProperties() != null && composed.getProperties().size() >= 1 && composed.getProperties().get(""discriminator"") == null) {
                // not necessarily ""invalid"" here, but we trigger the recommendation which requires the method to return false.
                result = ValidationRule.Fail.empty();
            }
        }
    }
    return result;
}","/**
     * JSON Schema defines oneOf as a validation property which can be applied to any schema.
     * <p>
     * OpenAPI Specification is a variant of JSON Schema for which oneOf is defined as:
     * ""Inline or referenced schema MUST be of a Schema Object and not a standard JSON Schema.""
     * <p>
     * Where the only examples of oneOf in OpenAPI Specification are used to define either/or type structures rather than validations.
     * Because of this ambiguity in the spec about what is non-standard about oneOf support, we'll warn as a recommendation that
     * properties on the schema defining oneOf relationships may not be intentional in the OpenAPI Specification.
     *
     * @param schemaWrapper An input schema, regardless of the type of schema
     * @return {@link ValidationRule.Pass} if the check succeeds, otherwise {@link ValidationRule.Fail}
     */","('checkOneOfWithProperties', {'INSTRUCTION': {'covered': 35, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",125.0,  JSON Schema defines oneOf as a validation property which can be applied to any schema.,16.0,"['OneOf is defined as a validation property which can be applied to any database.', 'OneOf is defined as a validation property which can be applied to any other database.', 'OneOf is defined as a validation property which can be applied to any of the other databases.']"
702,tablesaw,tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,yearMonth,215-236,"/**
   * Returns a StringColumn with the year and month from this column concatenated into a String that
   * will sort lexicographically in temporal order.
   *
   * <p>This simplifies the production of plots and tables that aggregate values into standard
   * temporal units (e.g., you want monthly data but your source data is more than a year long and
   * you don't want months from different years aggregated together).
   */
 StringColumn yearMonth(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & month"");
    for (int r = 0; r < this.size(); r++) {
        long c1 = this.getLongInternal(r);
        if (DateTimeColumn.valueIsMissing(c1)) {
            newColumn.append(StringColumnType.missingValueIndicator());
        } else {
            String ym = String.valueOf(getYear(c1));
            ym = ym + ""-"" + Strings.padStart(String.valueOf(getMonthValue(c1)), 2, '0');
            newColumn.append(ym);
        }
    }
    return newColumn;
}","StringColumn yearMonth(){
    StringColumn newColumn = StringColumn.create(this.name() + "" year & month"");
    for (int r = 0; r < this.size(); r++) {
        long c1 = this.getLongInternal(r);
        if (DateTimeColumn.valueIsMissing(c1)) {
            newColumn.append(StringColumnType.missingValueIndicator());
        } else {
            String ym = String.valueOf(getYear(c1));
            ym = ym + ""-"" + Strings.padStart(String.valueOf(getMonthValue(c1)), 2, '0');
            newColumn.append(ym);
        }
    }
    return newColumn;
}","/**
   * Returns a StringColumn with the year and month from this column concatenated into a String that
   * will sort lexicographically in temporal order.
   *
   * <p>This simplifies the production of plots and tables that aggregate values into standard
   * temporal units (e.g., you want monthly data but your source data is more than a year long and
   * you don't want months from different years aggregated together).
   */","('yearMonth', {'INSTRUCTION': {'covered': 52, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",125.0,  Returns a StringColumn with the year and month from this column concatenated into a String that  will sort lexicographically in temporal order.,23.0,"['The year and month from this column will be combined into a String that will sort lexicographically in temporal order.', 'The year and month from this column are combined into a String that will sort lexicographically in temporal order.', 'The year and month from this column will be combined into a string that will sort lexicographically in temporal order.']"
703,cdk,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,isCisTransEndPoint,1258-1287,"/**
     * Checks if the atom can be involved in a double-bond.
     * @param idx atom idx
     * @return the atom at index (idx) is valid for a double bond
     * @see <a href=""http://www.inchi-trust.org/download/104/InChI_TechMan.pdf"">Double bond stereochemistry, InChI Technical Manual</a>
     */
private boolean isCisTransEndPoint(int idx){
    IAtom atom = container.getAtom(idx);
    if (atom.getAtomicNumber() == null || atom.getFormalCharge() == null || atom.getImplicitHydrogenCount() == null)
        return false;
    final int chg = atom.getFormalCharge();
    final int btypes = getBondTypes(idx);
    switch(atom.getAtomicNumber()) {
        case 6:
        case 14:
        case 32:
            return chg == 0 && btypes == 0x0102;
        case 7:
            if (chg == 0)
                return btypes == 0x0101;
            if (chg == +1)
                return btypes == 0x0102;
        default:
            return false;
    }
}","private boolean isCisTransEndPoint(int idx){
    IAtom atom = container.getAtom(idx);
    if (atom.getAtomicNumber() == null || atom.getFormalCharge() == null || atom.getImplicitHydrogenCount() == null)
        return false;
    final int chg = atom.getFormalCharge();
    final int btypes = getBondTypes(idx);
    switch(atom.getAtomicNumber()) {
        case 6:
        case 14:
        case 32:
            return chg == 0 && btypes == 0x0102;
        case 7:
            if (chg == 0)
                return btypes == 0x0101;
            if (chg == +1)
                return btypes == 0x0102;
        default:
            return false;
    }
}","/**
     * Checks if the atom can be involved in a double-bond.
     * @param idx atom idx
     * @return the atom at index (idx) is valid for a double bond
     * @see <a href=""http://www.inchi-trust.org/download/104/InChI_TechMan.pdf"">Double bond stereochemistry, InChI Technical Manual</a>
     */","('isCisTransEndPoint', {'INSTRUCTION': {'covered': 57, 'missed': 1}, 'BRANCH': {'covered': 16, 'missed': 5}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",126.0,  Checks if the atom can be involved in a double-bond.,11.0,"['The atom can be involved in a double-bond.', 'If the atom can be involved in a double-bond.', 'The atom is checked if it can be involved in a double-bond.']"
705,dataverse,edu/harvard/iq/dataverse/authorization/groups/impl/explicit/ExplicitGroup.java,/src/main/java/edu/harvard/iq/dataverse/authorization/groups/impl/explicit/ExplicitGroup.java,containsDirectly,315-346,"/**
     * @param req
     * @return {@code true} iff the request is contained in the group or in an included non-explicit group.
     */
protected boolean containsDirectly(DataverseRequest req){
    User ra = req.getUser();
    if (ra instanceof AuthenticatedUser) {
        AuthenticatedUser au = (AuthenticatedUser) ra;
        if (containedAuthenticatedUsers.contains(au)) {
            return true;
        }
    }
    if (containedRoleAssignees.contains(ra.getIdentifier())) {
        return true;
    }
    for (String craIdtf : containedRoleAssignees) {
        RoleAssignee cra = provider.findRoleAssignee(craIdtf);
        if (cra != null) {
            if (cra instanceof Group) {
                Group cgrp = (Group) cra;
                if (cgrp.contains(req)) {
                    return true;
                }
            }
        }
    }
    return false;
}","protected boolean containsDirectly(DataverseRequest req){
    User ra = req.getUser();
    if (ra instanceof AuthenticatedUser) {
        AuthenticatedUser au = (AuthenticatedUser) ra;
        if (containedAuthenticatedUsers.contains(au)) {
            return true;
        }
    }
    if (containedRoleAssignees.contains(ra.getIdentifier())) {
        return true;
    }
    for (String craIdtf : containedRoleAssignees) {
        RoleAssignee cra = provider.findRoleAssignee(craIdtf);
        if (cra != null) {
            if (cra instanceof Group) {
                Group cgrp = (Group) cra;
                if (cgrp.contains(req)) {
                    return true;
                }
            }
        }
    }
    return false;
}","/**
     * @param req
     * @return {@code true} iff the request is contained in the group or in an included non-explicit group.
     */","('containsDirectly', {'INSTRUCTION': {'covered': 57, 'missed': 0}, 'BRANCH': {'covered': 13, 'missed': 1}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",126.0,  @param req  @return {@code true} iff the request is contained in the group or in an included non-explicit group.,25.0,"[""If the request is contained in the group or in an included non-explicit group, it's true."", ""If the request is contained in the group or in an included non-explicit group, then it's true."", 'If the request is contained in the group or in an included non-explicit group, you can return @code true.']"
706,cdk,org/openscience/cdk/fingerprint/ShortestPathWalker.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/ShortestPathWalker.java,encode,136-154,"/**
     * Encode the provided path of atoms to a string.
     *
     * @param path inclusive array of vertex indices
     * @return encoded path
     */
private String encode(int[] path){
    StringBuilder sb = new StringBuilder(path.length * 3);
    for (int i = 0, n = path.length - 1; i <= n; i++) {
        IAtom atom = container.getAtom(path[i]);
        sb.append(toAtomPattern(atom));
        if (i < n) {
            IBond bond = container.getBond(container.getAtom(path[i]), container.getAtom(path[i + 1]));
            sb.append(getBondSymbol(bond));
        }
    }
    return sb.toString();
}","private String encode(int[] path){
    StringBuilder sb = new StringBuilder(path.length * 3);
    for (int i = 0, n = path.length - 1; i <= n; i++) {
        IAtom atom = container.getAtom(path[i]);
        sb.append(toAtomPattern(atom));
        if (i < n) {
            IBond bond = container.getBond(container.getAtom(path[i]), container.getAtom(path[i + 1]));
            sb.append(getBondSymbol(bond));
        }
    }
    return sb.toString();
}","/**
     * Encode the provided path of atoms to a string.
     *
     * @param path inclusive array of vertex indices
     * @return encoded path
     */","('encode', {'INSTRUCTION': {'covered': 63, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",126.0,  Encode the provided path of atoms to a string.,10.0,"['The path of atoms is provided.', 'The provided path of atoms can be converted to a string.', 'The path of atoms can be found in the provided text.']"
707,dcache,org/dcache/util/CompletableFutures.java,/modules/common/src/main/java/org/dcache/util/CompletableFutures.java,fromListenableFuture,80-112,"/**
     * Create a CompletableFuture from guava's ListenableFuture to help migration from Guava to
     * Java8.
     *
     * @param listenable ListenableFuture to convert.
     * @return new CompletableFuture.
     */
public static CompletableFuture<T> fromListenableFuture(ListenableFuture<T> listenable){
    final CompletableFuture<T> completable = new CompletableFuture<T>() {

        @Override
        public boolean cancel(boolean mayInterruptIfRunning) {
            boolean result = listenable.cancel(mayInterruptIfRunning);
            super.cancel(mayInterruptIfRunning);
            return result;
        }
    };
    Futures.addCallback(listenable, new FutureCallback<T>() {

        @Override
        public void onSuccess(T result) {
            completable.complete(result);
        }

        @Override
        public void onFailure(Throwable t) {
            completable.completeExceptionally(t);
        }
    }, MoreExecutors.directExecutor());
    return completable;
}","public static CompletableFuture<T> fromListenableFuture(ListenableFuture<T> listenable){
    final CompletableFuture<T> completable = new CompletableFuture<T>() {

        @Override
        public boolean cancel(boolean mayInterruptIfRunning) {
            boolean result = listenable.cancel(mayInterruptIfRunning);
            super.cancel(mayInterruptIfRunning);
            return result;
        }
    };
    Futures.addCallback(listenable, new FutureCallback<T>() {

        @Override
        public void onSuccess(T result) {
            completable.complete(result);
        }

        @Override
        public void onFailure(Throwable t) {
            completable.completeExceptionally(t);
        }
    }, MoreExecutors.directExecutor());
    return completable;
}","/**
     * Create a CompletableFuture from guava's ListenableFuture to help migration from Guava to
     * Java8.
     *
     * @param listenable ListenableFuture to convert.
     * @return new CompletableFuture.
     */","('fromListenableFuture', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 4, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",126.0,Create a CompletableFuture from guava's ListenableFuture to help migration from Guava to  Java8.,15.0,"['The ListenableFuture can be used to help migrate from Guava to Java8.', 'It is possible to create a future from ListenableFuture to help migrate from Guava to Java8.', 'The ListenableFuture can be used to help migration from Guava to Java8.']"
708,cdk,org/openscience/cdk/formula/MolecularFormulaRange.java,/tool/formula/src/main/java/org/openscience/cdk/formula/MolecularFormulaRange.java,addIsotope,58-86,"/**
     *  Adds an Isotope to this MolecularFormulaExpand in a number of
     *  maximum and minimum occurrences allowed.
     *
     * @param  isotope  The isotope to be added to this MolecularFormulaExpand
     * @param  countMax The maximal number of occurrences to add
     * @param  countMin The minimal number of occurrences to add
     *
     */
public void addIsotope(IIsotope isotope, int countMin, int countMax){
    if (isotope == null)
        throw new IllegalArgumentException(""Isotope must not be null"");
    boolean flag = false;
    for (Iterator<IIsotope> it = isotopes().iterator(); it.hasNext(); ) {
        IIsotope thisIsotope = it.next();
        if (isTheSame(thisIsotope, isotope)) {
            isotopesMax.put(thisIsotope, countMax);
            isotopesMin.put(thisIsotope, countMin);
            flag = true;
            break;
        }
    }
    if (!flag) {
        isotopesMax.put(isotope, countMax);
        isotopesMin.put(isotope, countMin);
    }
}","public void addIsotope(IIsotope isotope, int countMin, int countMax){
    if (isotope == null)
        throw new IllegalArgumentException(""Isotope must not be null"");
    boolean flag = false;
    for (Iterator<IIsotope> it = isotopes().iterator(); it.hasNext(); ) {
        IIsotope thisIsotope = it.next();
        if (isTheSame(thisIsotope, isotope)) {
            isotopesMax.put(thisIsotope, countMax);
            isotopesMin.put(thisIsotope, countMin);
            flag = true;
            break;
        }
    }
    if (!flag) {
        isotopesMax.put(isotope, countMax);
        isotopesMin.put(isotope, countMin);
    }
}","/**
     *  Adds an Isotope to this MolecularFormulaExpand in a number of
     *  maximum and minimum occurrences allowed.
     *
     * @param  isotope  The isotope to be added to this MolecularFormulaExpand
     * @param  countMax The maximal number of occurrences to add
     * @param  countMin The minimal number of occurrences to add
     *
     */","('addIsotope', {'INSTRUCTION': {'covered': 60, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",127.0,  Adds an Isotope to this MolecularFormulaExpand in a number of  maximum and minimum occurrences allowed.,16.0,"['There are a number of maximum and minimum occurrences allowed.', 'A number of maximum and minimum occurrences are allowed.', 'A number of maximum and minimum occurrences can be allowed.']"
709,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEnginePortHandler.java,createPort,157-183,"/**
     * Create the port and attach it to the process.
     *
     * @param userId             the name of the calling user
     * @param port               the port values
     * @param entityTpeName      the type name
     * @param externalSourceName the unique name of the external source
     * @param processGUID        the unique identifier of the process containing the port
     *
     * @return unique identifier of the port in the repository
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */
private String createPort(String userId, Port port, String entityTpeName, String processGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    final String methodName = ""createPort"";
    validatePortParameters(userId, port.getQualifiedName(), port.getDisplayName(), methodName);
    invalidParameterHandler.validateGUID(processGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    String externalSourceGUID = registrationHandler.getExternalDataEngine(userId, externalSourceName);
    return portHandler.createPort(userId, externalSourceGUID, externalSourceName, processGUID, PROCESS_GUID_PARAMETER_NAME, port.getQualifiedName(), port.getDisplayName(), port.getPortType().getOrdinal(), port.getAdditionalProperties(), entityTpeName, null, methodName);
}","private String createPort(String userId, Port port, String entityTpeName, String processGUID, String externalSourceName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    final String methodName = ""createPort"";
    validatePortParameters(userId, port.getQualifiedName(), port.getDisplayName(), methodName);
    invalidParameterHandler.validateGUID(processGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    String externalSourceGUID = registrationHandler.getExternalDataEngine(userId, externalSourceName);
    return portHandler.createPort(userId, externalSourceGUID, externalSourceName, processGUID, PROCESS_GUID_PARAMETER_NAME, port.getQualifiedName(), port.getDisplayName(), port.getPortType().getOrdinal(), port.getAdditionalProperties(), entityTpeName, null, methodName);
}","/**
     * Create the port and attach it to the process.
     *
     * @param userId             the name of the calling user
     * @param port               the port values
     * @param entityTpeName      the type name
     * @param externalSourceName the unique name of the external source
     * @param processGUID        the unique identifier of the process containing the port
     *
     * @return unique identifier of the port in the repository
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */","('createPort', {'INSTRUCTION': {'covered': 43, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",127.0,  Create the port and attach it to the process.,10.0,"['Attach the port to the process.', 'Attach the port to the process by creating it.', 'Attach the port to the process by creating one.']"
710,tablesaw,tech/tablesaw/analytic/AnalyticQueryEngine.java,/core/src/main/java/tech/tablesaw/analytic/AnalyticQueryEngine.java,processAggregateFunctions,54-72,"/**
   * Execute all aggregate functions for the given slice setting values in the appropriate
   * destination column.
   */
private void processAggregateFunctions(TableSlice slice){
    for (String toColumn : query.getArgumentList().getAggregateFunctions().keySet()) {
        FunctionCall<AggregateFunctions> functionCall = query.getArgumentList().getAggregateFunctions().get(toColumn);
        AggregateFunctions aggregateFunction = functionCall.getFunction();
        Column<?> sourceColumn = query.getTable().column(functionCall.getSourceColumnName());
        validateColumn(aggregateFunction, sourceColumn);
        Column<?> destinationColumn = destination.column(functionCall.getDestinationColumnName());
        new WindowSlider(query.getWindowFrame(), aggregateFunction, slice, sourceColumn, destinationColumn).execute();
    }
}","private void processAggregateFunctions(TableSlice slice){
    for (String toColumn : query.getArgumentList().getAggregateFunctions().keySet()) {
        FunctionCall<AggregateFunctions> functionCall = query.getArgumentList().getAggregateFunctions().get(toColumn);
        AggregateFunctions aggregateFunction = functionCall.getFunction();
        Column<?> sourceColumn = query.getTable().column(functionCall.getSourceColumnName());
        validateColumn(aggregateFunction, sourceColumn);
        Column<?> destinationColumn = destination.column(functionCall.getDestinationColumnName());
        new WindowSlider(query.getWindowFrame(), aggregateFunction, slice, sourceColumn, destinationColumn).execute();
    }
}","/**
   * Execute all aggregate functions for the given slice setting values in the appropriate
   * destination column.
   */","('processAggregateFunctions', {'INSTRUCTION': {'covered': 56, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",127.0,  Execute all aggregate functions for the given slice setting values in the appropriate  destination column.,16.0,"['Aggregate functions for the slice setting values should be executed.', 'Aggregate functions for slice setting values can be executed.', 'Aggregate functions for the slice setting values are executed.']"
711,cdk,org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,makeElevationMap,250-282,"/**
     * Maps the input bonds to a map of Atom->Elevation where the elevation is
     * whether the bond is off the plane with respect to the central atom.
     *
     * @param atom  central atom
     * @param bonds bonds connected to the central atom
     * @param map   map to load with elevation values (can be reused)
     */
private static void makeElevationMap(IAtom atom, List<IBond> bonds, Map<IAtom, Integer> map){
    map.clear();
    for (IBond bond : bonds) {
        int elevation = 0;
        switch(bond.getStereo()) {
            case UP:
            case DOWN_INVERTED:
                elevation = +1;
                break;
            case DOWN:
            case UP_INVERTED:
                elevation = -1;
                break;
        }
        if (bond.getBegin().equals(atom)) {
            map.put(bond.getEnd(), elevation);
        } else {
            map.put(bond.getBegin(), -1 * elevation);
        }
    }
}","private static void makeElevationMap(IAtom atom, List<IBond> bonds, Map<IAtom, Integer> map){
    map.clear();
    for (IBond bond : bonds) {
        int elevation = 0;
        switch(bond.getStereo()) {
            case UP:
            case DOWN_INVERTED:
                elevation = +1;
                break;
            case DOWN:
            case UP_INVERTED:
                elevation = -1;
                break;
        }
        if (bond.getBegin().equals(atom)) {
            map.put(bond.getEnd(), elevation);
        } else {
            map.put(bond.getBegin(), -1 * elevation);
        }
    }
}","/**
     * Maps the input bonds to a map of Atom->Elevation where the elevation is
     * whether the bond is off the plane with respect to the central atom.
     *
     * @param atom  central atom
     * @param bonds bonds connected to the central atom
     * @param map   map to load with elevation values (can be reused)
     */","('makeElevationMap', {'INSTRUCTION': {'covered': 49, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",127.0,  Maps the input bonds to a map of Atom->Elevation where the elevation is  whether the bond is off the plane with respect to the central atom.,29.0,"['If the bond is off the plane with respect to the central atom, the input bonds can be mapped to a map.', 'If the bond is off the plane with respect to the central atom, the input bonds can be mapped to a map of Atom.', 'If the bond is off the plane with respect to the central atom, the input bonds should be mapped to a map of Atom.']"
712,dataverse,edu/harvard/iq/dataverse/engine/command/impl/AbstractDatasetCommand.java,/src/main/java/edu/harvard/iq/dataverse/engine/command/impl/AbstractDatasetCommand.java,tidyUpFields,118-138,"/**
     * Removed empty fields, sets field value display order.
     *
     * @param dsv the dataset version show fields we want to tidy up.
     */
protected void tidyUpFields(DatasetVersion dsv){
    Iterator<DatasetField> dsfIt = dsv.getDatasetFields().iterator();
    while (dsfIt.hasNext()) {
        if (dsfIt.next().removeBlankDatasetFieldValues()) {
            dsfIt.remove();
        }
    }
    Iterator<DatasetField> dsfItSort = dsv.getDatasetFields().iterator();
    while (dsfItSort.hasNext()) {
        dsfItSort.next().setValueDisplayOrder();
    }
    Iterator<DatasetField> dsfItTrim = dsv.getDatasetFields().iterator();
    while (dsfItTrim.hasNext()) {
        dsfItTrim.next().trimTrailingSpaces();
    }
}","protected void tidyUpFields(DatasetVersion dsv){
    Iterator<DatasetField> dsfIt = dsv.getDatasetFields().iterator();
    while (dsfIt.hasNext()) {
        if (dsfIt.next().removeBlankDatasetFieldValues()) {
            dsfIt.remove();
        }
    }
    Iterator<DatasetField> dsfItSort = dsv.getDatasetFields().iterator();
    while (dsfItSort.hasNext()) {
        dsfItSort.next().setValueDisplayOrder();
    }
    Iterator<DatasetField> dsfItTrim = dsv.getDatasetFields().iterator();
    while (dsfItTrim.hasNext()) {
        dsfItTrim.next().trimTrailingSpaces();
    }
}","/**
     * Removed empty fields, sets field value display order.
     *
     * @param dsv the dataset version show fields we want to tidy up.
     */","('tidyUpFields', {'INSTRUCTION': {'covered': 30, 'missed': 10}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 9, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",127.0,"  Removed empty fields, sets field value display order.",10.0,"['The field value display order is set.', 'The field value display order was changed.', 'The field value display order was set.']"
713,cdk,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,putInOrder,499-519,"/**
     * Put in order the elements of the molecular formula.
     *
     * @param formula The IMolecularFormula to put in order
     * @return        IMolecularFormula object
     */
private IMolecularFormula putInOrder(IMolecularFormula formula){
    IMolecularFormula new_formula = formula.getBuilder().newInstance(IMolecularFormula.class);
    for (int i = 0; i < orderElements.length; i++) {
        IElement element = builder.newInstance(IElement.class, orderElements[i]);
        if (MolecularFormulaManipulator.containsElement(formula, element)) {
            Iterator<IIsotope> isotopes = MolecularFormulaManipulator.getIsotopes(formula, element).iterator();
            while (isotopes.hasNext()) {
                IIsotope isotope = isotopes.next();
                new_formula.addIsotope(isotope, formula.getIsotopeCount(isotope));
            }
        }
    }
    return new_formula;
}","private IMolecularFormula putInOrder(IMolecularFormula formula){
    IMolecularFormula new_formula = formula.getBuilder().newInstance(IMolecularFormula.class);
    for (int i = 0; i < orderElements.length; i++) {
        IElement element = builder.newInstance(IElement.class, orderElements[i]);
        if (MolecularFormulaManipulator.containsElement(formula, element)) {
            Iterator<IIsotope> isotopes = MolecularFormulaManipulator.getIsotopes(formula, element).iterator();
            while (isotopes.hasNext()) {
                IIsotope isotope = isotopes.next();
                new_formula.addIsotope(isotope, formula.getIsotopeCount(isotope));
            }
        }
    }
    return new_formula;
}","/**
     * Put in order the elements of the molecular formula.
     *
     * @param formula The IMolecularFormula to put in order
     * @return        IMolecularFormula object
     */","('putInOrder', {'INSTRUCTION': {'covered': 58, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",128.0,  Put in order the elements of the molecular formula.,10.0,"['Put the elements of the formula in order.', 'The elements of the formula should be put in order.', 'The elements of the formula should be placed in order.']"
714,matsim-libs,org/matsim/core/config/Config.java,/matsim/src/main/java/org/matsim/core/config/Config.java,addModule,245-279,"/**
	 * Adds the specified module / config-group with the specified name to the
	 * configuration.
	 * <p></p>
	 * This is the typical way to ""materialize"" material that, so far, exists only as Map, into a specialized module.
	 * @param specializedConfigModule
	 *
	 * @throws IllegalArgumentException
	 *             if a config-group with the specified name already exists.
	 */
public final void addModule(final ConfigGroup specializedConfigModule){
    String name = specializedConfigModule.getName();
    if (name == null || name.isEmpty()) {
        throw new RuntimeException(""cannot insert module with empty name"");
    }
    ConfigGroup m = this.modules.get(name);
    if (m != null) {
        if (m.getClass() == ConfigGroup.class && specializedConfigModule.getClass() != ConfigGroup.class) {
            copyTo(m, specializedConfigModule);
            this.modules.put(name, specializedConfigModule);
        } else {
            throw new IllegalArgumentException(""Module "" + name + "" exists already."");
        }
    }
    this.modules.put(name, specializedConfigModule);
}","public final void addModule(final ConfigGroup specializedConfigModule){
    String name = specializedConfigModule.getName();
    if (name == null || name.isEmpty()) {
        throw new RuntimeException(""cannot insert module with empty name"");
    }
    ConfigGroup m = this.modules.get(name);
    if (m != null) {
        if (m.getClass() == ConfigGroup.class && specializedConfigModule.getClass() != ConfigGroup.class) {
            copyTo(m, specializedConfigModule);
            this.modules.put(name, specializedConfigModule);
        } else {
            throw new IllegalArgumentException(""Module "" + name + "" exists already."");
        }
    }
    this.modules.put(name, specializedConfigModule);
}","/**
	 * Adds the specified module / config-group with the specified name to the
	 * configuration.
	 * <p></p>
	 * This is the typical way to ""materialize"" material that, so far, exists only as Map, into a specialized module.
	 * @param specializedConfigModule
	 *
	 * @throws IllegalArgumentException
	 *             if a config-group with the specified name already exists.
	 */","('addModule', {'INSTRUCTION': {'covered': 41, 'missed': 11}, 'BRANCH': {'covered': 6, 'missed': 4}, 'LINE': {'covered': 9, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",128.0,  Adds the specified module / config-group with the specified name to the  configuration.,14.0,"['The specified module is added to the configuration.', 'The specified module or config-group is added to the configuration.', 'Adds the specified module to the configuration.']"
715,egeria,org/odpi/openmetadata/accessservices/assetlineage/listeners/AssetLineageOMRSTopicListener.java,/open-metadata-implementation/access-services/asset-lineage/asset-lineage-server/src/main/java/org/odpi/openmetadata/accessservices/assetlineage/listeners/AssetLineageOMRSTopicListener.java,processUpdatedEntity,170-197,"/**
     * Determine whether an updated entity is an lineage entity and publish the update entity for lineage
     *
     * @param entityDetail   entity object that has just been updated.
     * @param originalEntity original entity
     *
     * @throws OCFCheckedExceptionBase checked exception for reporting errors found when using OCF connectors
     * @throws JsonProcessingException exception parsing the event json
     */
private void processUpdatedEntity(EntityDetail entityDetail, EntityDetail originalEntity) throws OCFCheckedExceptionBase, JsonProcessingException{
    if (!immutableValidLineageEntityEvents.contains(entityDetail.getType().getTypeDefName())) {
        return;
    }
    log.debug(PROCESSING_ENTITY_DETAIL_DEBUG_MESSAGE, AssetLineageEventType.UPDATE_ENTITY_EVENT.getEventTypeName(), entityDetail.getGUID(), entityDetail.getType().getTypeDefName());
    if (isProcessStatusChangedToActive(entityDetail, originalEntity)) {
        if (publisher.publishProcessContext(entityDetail).isEmpty()) {
            publishEntityEvent(entityDetail, AssetLineageEventType.UPDATE_ENTITY_EVENT);
        }
        log.info(""Asset Lineage OMAS published the context for process with guid {}"", entityDetail.getGUID());
    } else {
        publishEntityEvent(entityDetail, AssetLineageEventType.UPDATE_ENTITY_EVENT);
    }
}","private void processUpdatedEntity(EntityDetail entityDetail, EntityDetail originalEntity) throws OCFCheckedExceptionBase, JsonProcessingException{
    if (!immutableValidLineageEntityEvents.contains(entityDetail.getType().getTypeDefName())) {
        return;
    }
    log.debug(PROCESSING_ENTITY_DETAIL_DEBUG_MESSAGE, AssetLineageEventType.UPDATE_ENTITY_EVENT.getEventTypeName(), entityDetail.getGUID(), entityDetail.getType().getTypeDefName());
    if (isProcessStatusChangedToActive(entityDetail, originalEntity)) {
        if (publisher.publishProcessContext(entityDetail).isEmpty()) {
            publishEntityEvent(entityDetail, AssetLineageEventType.UPDATE_ENTITY_EVENT);
        }
        log.info(""Asset Lineage OMAS published the context for process with guid {}"", entityDetail.getGUID());
    } else {
        publishEntityEvent(entityDetail, AssetLineageEventType.UPDATE_ENTITY_EVENT);
    }
}","/**
     * Determine whether an updated entity is an lineage entity and publish the update entity for lineage
     *
     * @param entityDetail   entity object that has just been updated.
     * @param originalEntity original entity
     *
     * @throws OCFCheckedExceptionBase checked exception for reporting errors found when using OCF connectors
     * @throws JsonProcessingException exception parsing the event json
     */","('processUpdatedEntity', {'INSTRUCTION': {'covered': 54, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",129.0,  Determine whether an updated entity is an lineage entity and publish the update entity for lineage   @param entityDetail entity object that has just been updated.,27.0,"['Determine if an updated entity is a lineage entity and publish the update entity for the object that has just been updated.', 'Determine if an updated entity is a lineage entity and publish the updated entity for the object that has just been updated.', 'Determine if an updated entity is a lineage entity and publish the update entity for the object that has just been updated']"
716,matsim-libs,org/matsim/core/router/priorityqueue/BinaryMinHeap.java,/matsim/src/main/java/org/matsim/core/router/priorityqueue/BinaryMinHeap.java,poll,151-179,"/**
	 * Retrieves and removes the head of this queue, or <tt>null</tt> if this
	 * queue is empty.
	 * 
	 * @return the head of this queue, or <tt>null</tt> if this queue is empty.
	 */
public E poll(){
    E minValue;
    if (isEmpty())
        return null;
    else {
        this.modCount++;
        minValue = data[0];
        if (classicalRemove) {
            data[0] = data[heapSize - 1];
            costs[0] = costs[heapSize - 1];
            indices[this.getIndex(data[0])] = 0;
            indices[this.getIndex(minValue)] = -1;
            heapSize--;
            if (heapSize > 0)
                siftDown(0);
        } else {
            siftDownUp(0);
            indices[this.getIndex(minValue)] = -1;
        }
        return minValue;
    }
}","public E poll(){
    E minValue;
    if (isEmpty())
        return null;
    else {
        this.modCount++;
        minValue = data[0];
        if (classicalRemove) {
            data[0] = data[heapSize - 1];
            costs[0] = costs[heapSize - 1];
            indices[this.getIndex(data[0])] = 0;
            indices[this.getIndex(minValue)] = -1;
            heapSize--;
            if (heapSize > 0)
                siftDown(0);
        } else {
            siftDownUp(0);
            indices[this.getIndex(minValue)] = -1;
        }
        return minValue;
    }
}","/**
	 * Retrieves and removes the head of this queue, or <tt>null</tt> if this
	 * queue is empty.
	 * 
	 * @return the head of this queue, or <tt>null</tt> if this queue is empty.
	 */","('poll', {'INSTRUCTION': {'covered': 83, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",130.0,"  Retrieves and removes the head of this queue, or <tt>null</tt> if this  queue is empty.",23.0,"['If the queue is empty, Retrieves and removes the head of it.', 'If the queue is empty, Retrieves and removes the head.', 'If the queue is empty, Retrieves and removes the head of the queue.']"
717,cdk,org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/BasicAtomGenerator.java,generateCompactElement,333-351,"/**
     * Generate a compact element for an atom, such as a circle or a square,
     * rather than text element.
     *
     * @param atom the atom to generate the compact element for
     * @param model the renderer model
     * @return a compact rendering element
     */
public IRenderingElement generateCompactElement(IAtom atom, RendererModel model){
    Point2d point = atom.getPoint2d();
    double radius = (Double) model.get(AtomRadius.class) / model.getParameter(Scale.class).getValue();
    double distance = 2 * radius;
    if (model.get(CompactShape.class) == Shape.SQUARE) {
        return new RectangleElement(point.x - radius, point.y - radius, distance, distance, true, getAtomColor(atom, model));
    } else {
        return new OvalElement(point.x, point.y, radius, true, getAtomColor(atom, model));
    }
}","public IRenderingElement generateCompactElement(IAtom atom, RendererModel model){
    Point2d point = atom.getPoint2d();
    double radius = (Double) model.get(AtomRadius.class) / model.getParameter(Scale.class).getValue();
    double distance = 2 * radius;
    if (model.get(CompactShape.class) == Shape.SQUARE) {
        return new RectangleElement(point.x - radius, point.y - radius, distance, distance, true, getAtomColor(atom, model));
    } else {
        return new OvalElement(point.x, point.y, radius, true, getAtomColor(atom, model));
    }
}","/**
     * Generate a compact element for an atom, such as a circle or a square,
     * rather than text element.
     *
     * @param atom the atom to generate the compact element for
     * @param model the renderer model
     * @return a compact rendering element
     */","('generateCompactElement', {'INSTRUCTION': {'covered': 59, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",130.0,"  Generate a compact element for an atom, such as a circle or a square,  rather than text element.",21.0,"['A circle or a square is a better fit for an atom than a text element.', 'A circle or a square is a more compact element for an atom.', 'A circle or a square is a better form of a compact element for an atom.']"
718,dcache,org/dcache/resilience/data/PoolInfoMap.java,/modules/dcache-resilience/src/main/java/org/dcache/resilience/data/PoolInfoMap.java,verify,1166-1191,"/**
     * Called under read lock
     *
     * @param index     of pool group.
     * @param extractor configured for the specific tag constraints.
     * @param required  specific to this group or storage unit.
     * @throws IllegalStateException upon encountering the first set of constraints which cannot be
     *                               met.
     */
private void verify(Integer index, CopyLocationExtractor extractor, int required) throws IllegalStateException{
    Set<String> members = poolGroupToPool.get(index).stream().map(i -> safeGet(i, pools)).collect(Collectors.toSet());
    for (int i = 0; i < required; i++) {
        Collection<String> candidates = extractor.getCandidateLocations(members);
        if (candidates.isEmpty()) {
            throw new IllegalStateException(getGroup(index));
        }
        String selected = RandomSelectionStrategy.SELECTOR.apply(candidates);
        members.remove(selected);
        extractor.addSeenTagsFor(selected);
    }
}","private void verify(Integer index, CopyLocationExtractor extractor, int required) throws IllegalStateException{
    Set<String> members = poolGroupToPool.get(index).stream().map(i -> safeGet(i, pools)).collect(Collectors.toSet());
    for (int i = 0; i < required; i++) {
        Collection<String> candidates = extractor.getCandidateLocations(members);
        if (candidates.isEmpty()) {
            throw new IllegalStateException(getGroup(index));
        }
        String selected = RandomSelectionStrategy.SELECTOR.apply(candidates);
        members.remove(selected);
        extractor.addSeenTagsFor(selected);
    }
}","/**
     * Called under read lock
     *
     * @param index     of pool group.
     * @param extractor configured for the specific tag constraints.
     * @param required  specific to this group or storage unit.
     * @throws IllegalStateException upon encountering the first set of constraints which cannot be
     *                               met.
     */","('verify', {'INSTRUCTION': {'covered': 45, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",130.0,  Called under read lock   @param index of pool group.,11.0,"['Called under the read lock.', 'Called under the read lock, which is the index of the pool group.', 'Called under the read lock, the index of the pool group.']"
719,cdk,org/openscience/cdk/formula/IsotopePatternManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/IsotopePatternManipulator.java,sortByIntensity,69-104,"/**
     * Return the isotope pattern sorted by intensity
     * to the highest abundance.
     *
     * @param isotopeP  The IsotopePattern object to sort
     * @return          The IsotopePattern sorted
     */
public static IsotopePattern sortByIntensity(IsotopePattern isotopeP){
    try {
        IsotopePattern isoSort = (IsotopePattern) isotopeP.clone();
        if (isoSort.getNumberOfIsotopes() == 0)
            return isoSort;
        List<IsotopeContainer> listISO = isoSort.getIsotopes();
        Collections.sort(listISO, new Comparator<IsotopeContainer>() {

            @Override
            public int compare(IsotopeContainer o1, IsotopeContainer o2) {
                return Double.compare(o2.getIntensity(), o1.getIntensity());
            }
        });
        isoSort.setMonoIsotope(listISO.get(0));
        return isoSort;
    } catch (CloneNotSupportedException e) {
        e.printStackTrace();
    }
    return null;
}","public static IsotopePattern sortByIntensity(IsotopePattern isotopeP){
    try {
        IsotopePattern isoSort = (IsotopePattern) isotopeP.clone();
        if (isoSort.getNumberOfIsotopes() == 0)
            return isoSort;
        List<IsotopeContainer> listISO = isoSort.getIsotopes();
        Collections.sort(listISO, new Comparator<IsotopeContainer>() {

            @Override
            public int compare(IsotopeContainer o1, IsotopeContainer o2) {
                return Double.compare(o2.getIntensity(), o1.getIntensity());
            }
        });
        isoSort.setMonoIsotope(listISO.get(0));
        return isoSort;
    } catch (CloneNotSupportedException e) {
        e.printStackTrace();
    }
    return null;
}","/**
     * Return the isotope pattern sorted by intensity
     * to the highest abundance.
     *
     * @param isotopeP  The IsotopePattern object to sort
     * @return          The IsotopePattern sorted
     */","('sortByIntensity', {'INSTRUCTION': {'covered': 23, 'missed': 7}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 4}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",130.0,  Return the isotope pattern sorted by intensity  to the highest abundance.,12.0,"['The pattern is sorted by intensity.', 'Return the pattern by intensity.', 'Return the pattern by intensity to the highest abundance.']"
720,matsim-libs,org/matsim/core/controler/ControlerListenerManagerImpl.java,/matsim/src/main/java/org/matsim/core/controler/ControlerListenerManagerImpl.java,fireControlerShutdownEvent,113-130,"/**
	 * Notifies all ControlerListeners
	 * @param unexpected Whether the shutdown is unexpected or not.
	 */
public void fireControlerShutdownEvent(final boolean unexpected, int iteration){
    ShutdownEvent event = new ShutdownEvent(this.controler, unexpected, iteration);
    ShutdownListener[] listener = this.coreListenerList.getListeners(ShutdownListener.class);
    for (ShutdownListener aListener : listener) {
        log.info(""calling notifyShutdown on "" + aListener.getClass().getName());
        aListener.notifyShutdown(event);
    }
    listener = this.listenerList.getListeners(ShutdownListener.class);
    for (ShutdownListener aListener : listener) {
        log.info(""calling notifyShutdown on "" + aListener.getClass().getName());
        aListener.notifyShutdown(event);
    }
    log.info(""all ControlerShutdownListeners called."");
}","public void fireControlerShutdownEvent(final boolean unexpected, int iteration){
    ShutdownEvent event = new ShutdownEvent(this.controler, unexpected, iteration);
    ShutdownListener[] listener = this.coreListenerList.getListeners(ShutdownListener.class);
    for (ShutdownListener aListener : listener) {
        log.info(""calling notifyShutdown on "" + aListener.getClass().getName());
        aListener.notifyShutdown(event);
    }
    listener = this.listenerList.getListeners(ShutdownListener.class);
    for (ShutdownListener aListener : listener) {
        log.info(""calling notifyShutdown on "" + aListener.getClass().getName());
        aListener.notifyShutdown(event);
    }
    log.info(""all ControlerShutdownListeners called."");
}","/**
	 * Notifies all ControlerListeners
	 * @param unexpected Whether the shutdown is unexpected or not.
	 */","('fireControlerShutdownEvent', {'INSTRUCTION': {'covered': 74, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",130.0,  Notifies all ControlerListeners  @param unexpected Whether the shutdown is unexpected or not.,14.0,"['ControlerListeners are not notified if the shutdown is unexpected or not.', 'Notifies all ControlerListeners if the shutdown is unexpected or not.', 'ControlerListeners are not notified if the shutdown is unexpected.']"
721,cdk,org/openscience/cdk/formula/IsotopePatternManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/IsotopePatternManipulator.java,sortByMass,106-140,"/**
     * Return the isotope pattern sorted by mass
     * to the highest abundance.
     *
     * @param isotopeP  The IsotopePattern object to sort
     * @return          The IsotopePattern sorted
     */
public static IsotopePattern sortByMass(IsotopePattern isotopeP){
    try {
        IsotopePattern isoSort = (IsotopePattern) isotopeP.clone();
        if (isoSort.getNumberOfIsotopes() == 0)
            return isoSort;
        List<IsotopeContainer> listISO = isoSort.getIsotopes();
        Collections.sort(listISO, new Comparator<IsotopeContainer>() {

            @Override
            public int compare(IsotopeContainer o1, IsotopeContainer o2) {
                return Double.compare(o1.getMass(), o2.getMass());
            }
        });
        isoSort.setMonoIsotope(listISO.get(0));
        return isoSort;
    } catch (CloneNotSupportedException e) {
        e.printStackTrace();
    }
    return null;
}","public static IsotopePattern sortByMass(IsotopePattern isotopeP){
    try {
        IsotopePattern isoSort = (IsotopePattern) isotopeP.clone();
        if (isoSort.getNumberOfIsotopes() == 0)
            return isoSort;
        List<IsotopeContainer> listISO = isoSort.getIsotopes();
        Collections.sort(listISO, new Comparator<IsotopeContainer>() {

            @Override
            public int compare(IsotopeContainer o1, IsotopeContainer o2) {
                return Double.compare(o1.getMass(), o2.getMass());
            }
        });
        isoSort.setMonoIsotope(listISO.get(0));
        return isoSort;
    } catch (CloneNotSupportedException e) {
        e.printStackTrace();
    }
    return null;
}","/**
     * Return the isotope pattern sorted by mass
     * to the highest abundance.
     *
     * @param isotopeP  The IsotopePattern object to sort
     * @return          The IsotopePattern sorted
     */","('sortByMass', {'INSTRUCTION': {'covered': 23, 'missed': 7}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 6, 'missed': 4}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",130.0,  Return the isotope pattern sorted by mass  to the highest abundance.,12.0,"['The pattern is sorted by mass.', 'Return the pattern by mass.', 'Return the pattern by mass to the highest abundance.']"
722,acs-aem-commons,com/adobe/acs/commons/httpcache/store/jcr/impl/writer/EntryNodeWriter.java,/bundle/src/main/java/com/adobe/acs/commons/httpcache/store/jcr/impl/writer/EntryNodeWriter.java,populateHeaders,114-128,"/**
     * Save the headers into a headers node under the cache entry node.
     * @throws RepositoryException
     */
private void populateHeaders() throws RepositoryException{
    final Node headers = getOrCreateByPath(entryNode, JCRHttpCacheStoreConstants.PATH_HEADERS, OAK_UNSTRUCTURED, OAK_UNSTRUCTURED);
    for (Iterator<Map.Entry<String, List<String>>> entryIterator = cacheContent.getHeaders().entrySet().iterator(); entryIterator.hasNext(); ) {
        Map.Entry<String, List<String>> entry = entryIterator.next();
        final String key = entry.getKey();
        final List<String> values = entry.getValue();
        headers.setProperty(key, values.toArray(new String[values.size()]));
    }
}","private void populateHeaders() throws RepositoryException{
    final Node headers = getOrCreateByPath(entryNode, JCRHttpCacheStoreConstants.PATH_HEADERS, OAK_UNSTRUCTURED, OAK_UNSTRUCTURED);
    for (Iterator<Map.Entry<String, List<String>>> entryIterator = cacheContent.getHeaders().entrySet().iterator(); entryIterator.hasNext(); ) {
        Map.Entry<String, List<String>> entry = entryIterator.next();
        final String key = entry.getKey();
        final List<String> values = entry.getValue();
        headers.setProperty(key, values.toArray(new String[values.size()]));
    }
}","/**
     * Save the headers into a headers node under the cache entry node.
     * @throws RepositoryException
     */","('populateHeaders', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",131.0,  Save the headers into a headers node under the cache entry node.,13.0,"['Under the cache entry node, save the headers.', 'Under the cache entry nodes, save the headers.', 'Under the cache entry node, put the headers into it.']"
723,matsim-libs,org/matsim/core/replanning/selectors/ExpBetaPlanSelector.java,/matsim/src/main/java/org/matsim/core/replanning/selectors/ExpBetaPlanSelector.java,selectPlan,51-81,"/**
	 * @return a random plan from the person, random but according to its weight.
	 */
public T selectPlan(final HasPlansAndId<T, I> person){
    // get the weights of all plans
    Map<T, Double> weights = this.calcWeights(person);
    double sumWeights = 0.0;
    for (Double weight : weights.values()) {
        sumWeights += weight;
    }
    // choose a random number over interval [0, sumWeights[
    double selnum = sumWeights * MatsimRandom.getRandom().nextDouble();
    for (T plan : person.getPlans()) {
        selnum -= weights.get(plan);
        if (selnum <= 0.0) {
            return plan;
        }
    }
    // hmm, no plan returned... either the person has no plans, or the plan(s) have no score.
    if (person.getPlans().size() > 0) {
        return person.getPlans().get(0);
    }
    // this case should never happen, except a person has no plans at all.
    return null;
}","public T selectPlan(final HasPlansAndId<T, I> person){
    // get the weights of all plans
    Map<T, Double> weights = this.calcWeights(person);
    double sumWeights = 0.0;
    for (Double weight : weights.values()) {
        sumWeights += weight;
    }
    // choose a random number over interval [0, sumWeights[
    double selnum = sumWeights * MatsimRandom.getRandom().nextDouble();
    for (T plan : person.getPlans()) {
        selnum -= weights.get(plan);
        if (selnum <= 0.0) {
            return plan;
        }
    }
    // hmm, no plan returned... either the person has no plans, or the plan(s) have no score.
    if (person.getPlans().size() > 0) {
        return person.getPlans().get(0);
    }
    // this case should never happen, except a person has no plans at all.
    return null;
}","/**
	 * @return a random plan from the person, random but according to its weight.
	 */","('selectPlan', {'INSTRUCTION': {'covered': 66, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",131.0,"  @return a random plan from the person, random but according to its weight.",16.0,"[""Random but according to the person's weight."", 'Return a random plan from the person.', 'Return a random plan from the person, but according to their weight.']"
724,cron-utils,com/cronutils/mapper/WeekDay.java,/src/main/java/com/cronutils/mapper/WeekDay.java,mapTo,43-66,"/**
     * Maps given WeekDay to representation hold by this instance.
     *
     * @param targetWeekDayDefinition - referred weekDay
     * @param dayOfWeek               - day of week to be mapped.
     *                                Value corresponds to this instance mapping.
     * @return - int result
     */
public int mapTo(final int dayOfWeek, final WeekDay targetWeekDayDefinition){
    if (firstDayZero && targetWeekDayDefinition.isFirstDayZero()) {
        return bothSameStartOfRange(0, 6, this, targetWeekDayDefinition).apply(dayOfWeek);
    }
    if (!firstDayZero && !targetWeekDayDefinition.isFirstDayZero()) {
        return bothSameStartOfRange(1, 7, this, targetWeekDayDefinition).apply(dayOfWeek);
    }
    // start range is different for each case. We need to normalize ranges
    if (targetWeekDayDefinition.isFirstDayZero()) {
        // my range is 1-7. I normalize ranges, get the ""zero"" mapping and turn result into original scale
        return mapTo(dayOfWeek, new WeekDay(targetWeekDayDefinition.getMondayDoWValue() + 1, false)) - 1;
    } else {
        // my range is 0-6. I normalize ranges, get the ""one"" mapping and turn result into original scale
        return mapTo(dayOfWeek, new WeekDay(targetWeekDayDefinition.getMondayDoWValue() - 1, true)) + 1;
    }
}","public int mapTo(final int dayOfWeek, final WeekDay targetWeekDayDefinition){
    if (firstDayZero && targetWeekDayDefinition.isFirstDayZero()) {
        return bothSameStartOfRange(0, 6, this, targetWeekDayDefinition).apply(dayOfWeek);
    }
    if (!firstDayZero && !targetWeekDayDefinition.isFirstDayZero()) {
        return bothSameStartOfRange(1, 7, this, targetWeekDayDefinition).apply(dayOfWeek);
    }
    // start range is different for each case. We need to normalize ranges
    if (targetWeekDayDefinition.isFirstDayZero()) {
        // my range is 1-7. I normalize ranges, get the ""zero"" mapping and turn result into original scale
        return mapTo(dayOfWeek, new WeekDay(targetWeekDayDefinition.getMondayDoWValue() + 1, false)) - 1;
    } else {
        // my range is 0-6. I normalize ranges, get the ""one"" mapping and turn result into original scale
        return mapTo(dayOfWeek, new WeekDay(targetWeekDayDefinition.getMondayDoWValue() - 1, true)) + 1;
    }
}","/**
     * Maps given WeekDay to representation hold by this instance.
     *
     * @param targetWeekDayDefinition - referred weekDay
     * @param dayOfWeek               - day of week to be mapped.
     *                                Value corresponds to this instance mapping.
     * @return - int result
     */","('mapTo', {'INSTRUCTION': {'covered': 67, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",131.0,  Maps given WeekDay to representation hold by this instance.,10.0,"['Maps given WeekDay hold by this instance.', 'Maps given to representation hold by this instance.', 'Maps given WeekDay to representation hold this instance.']"
725,matsim-libs,org/matsim/core/router/Dijkstra.java,/matsim/src/main/java/org/matsim/core/router/Dijkstra.java,relaxNode,371-398,"/**
	 * Expands the given Node in the routing algorithm; may be overridden in
	 * sub-classes.
	 *
	 * @param outNode
	 *            The Node to be expanded.
	 * @param toNode
	 *            The target Node of the route.
	 * @param pendingNodes
	 *            The set of pending nodes so far.
	 */
protected void relaxNode(final Node outNode, final Node toNode, final RouterPriorityQueue<Node> pendingNodes){
    DijkstraNodeData outData = getData(outNode);
    double currTime = outData.getTime();
    double currCost = outData.getCost();
    if (this.pruneDeadEnds) {
        PreProcessDijkstra.DeadEndData ddOutData = getPreProcessData(outNode);
        for (Link l : outNode.getOutLinks().values()) {
            relaxNodeLogic(l, pendingNodes, currTime, currCost, toNode, ddOutData);
        }
    } else {
        for (Link l : outNode.getOutLinks().values()) {
            relaxNodeLogic(l, pendingNodes, currTime, currCost, toNode, null);
        }
    }
}","protected void relaxNode(final Node outNode, final Node toNode, final RouterPriorityQueue<Node> pendingNodes){
    DijkstraNodeData outData = getData(outNode);
    double currTime = outData.getTime();
    double currCost = outData.getCost();
    if (this.pruneDeadEnds) {
        PreProcessDijkstra.DeadEndData ddOutData = getPreProcessData(outNode);
        for (Link l : outNode.getOutLinks().values()) {
            relaxNodeLogic(l, pendingNodes, currTime, currCost, toNode, ddOutData);
        }
    } else {
        for (Link l : outNode.getOutLinks().values()) {
            relaxNodeLogic(l, pendingNodes, currTime, currCost, toNode, null);
        }
    }
}","/**
	 * Expands the given Node in the routing algorithm; may be overridden in
	 * sub-classes.
	 *
	 * @param outNode
	 *            The Node to be expanded.
	 * @param toNode
	 *            The target Node of the route.
	 * @param pendingNodes
	 *            The set of pending nodes so far.
	 */","('relaxNode', {'INSTRUCTION': {'covered': 61, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",132.0,  Expands the given Node in the routing algorithm; may be overridden in  sub-classes.,15.0,"['It may be overridden in sub-classes.', 'It may be overridden in sub-classes if the given Node is expanded.', 'It may be overridden in sub-classes if it expands the given Node.']"
726,jackson-databind,com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java,/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java,_removeUnwantedProperties,884-914,"/**
     * Method called to get rid of candidate properties that are marked
     * as ignored.
     */
protected void _removeUnwantedProperties(Map<String, POJOPropertyBuilder> props){
    Iterator<POJOPropertyBuilder> it = props.values().iterator();
    while (it.hasNext()) {
        POJOPropertyBuilder prop = it.next();
        if (!prop.anyVisible()) {
            it.remove();
            continue;
        }
        if (prop.anyIgnorals()) {
            if (!prop.isExplicitlyIncluded()) {
                it.remove();
                _collectIgnorals(prop.getName());
                continue;
            }
            prop.removeIgnored();
            if (!prop.couldDeserialize()) {
                _collectIgnorals(prop.getName());
            }
        }
    }
}","protected void _removeUnwantedProperties(Map<String, POJOPropertyBuilder> props){
    Iterator<POJOPropertyBuilder> it = props.values().iterator();
    while (it.hasNext()) {
        POJOPropertyBuilder prop = it.next();
        if (!prop.anyVisible()) {
            it.remove();
            continue;
        }
        if (prop.anyIgnorals()) {
            if (!prop.isExplicitlyIncluded()) {
                it.remove();
                _collectIgnorals(prop.getName());
                continue;
            }
            prop.removeIgnored();
            if (!prop.couldDeserialize()) {
                _collectIgnorals(prop.getName());
            }
        }
    }
}","/**
     * Method called to get rid of candidate properties that are marked
     * as ignored.
     */","('_removeUnwantedProperties', {'INSTRUCTION': {'covered': 41, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",132.0,  Method called to get rid of candidate properties that are marked  as ignored.,14.0,"['Candidate properties that are marked as ignored should be removed.', 'Candidate properties that are marked as ignored should be eliminated.', 'Candidate properties that are marked as ignored can be removed.']"
727,jeromq,zmq/io/Msgs.java,/src/main/java/zmq/io/Msgs.java,startsWith,12-39,"/**
     * Checks if the message starts with the given string.
     *
     * @param msg the message to check.
     * @param data the string to check the message with. Shall be shorter than 256 characters.
     * @param includeLength true if the string in the message is prefixed with the length, false if not.
     * @return true if the message starts with the given string, otherwise false.
     */
public static boolean startsWith(Msg msg, String data, boolean includeLength){
    final int length = data.length();
    assert (length < 256);
    int start = includeLength ? 1 : 0;
    if (msg.size() < length + start) {
        return false;
    }
    boolean comparison = includeLength ? length == (msg.get(0) & 0xff) : true;
    if (comparison) {
        for (int idx = start; idx < length; ++idx) {
            comparison = (msg.get(idx) == data.charAt(idx - start));
            if (!comparison) {
                break;
            }
        }
    }
    return comparison;
}","public static boolean startsWith(Msg msg, String data, boolean includeLength){
    final int length = data.length();
    assert (length < 256);
    int start = includeLength ? 1 : 0;
    if (msg.size() < length + start) {
        return false;
    }
    boolean comparison = includeLength ? length == (msg.get(0) & 0xff) : true;
    if (comparison) {
        for (int idx = start; idx < length; ++idx) {
            comparison = (msg.get(idx) == data.charAt(idx - start));
            if (!comparison) {
                break;
            }
        }
    }
    return comparison;
}","/**
     * Checks if the message starts with the given string.
     *
     * @param msg the message to check.
     * @param data the string to check the message with. Shall be shorter than 256 characters.
     * @param includeLength true if the string in the message is prefixed with the length, false if not.
     * @return true if the message starts with the given string, otherwise false.
     */","('startsWith', {'INSTRUCTION': {'covered': 62, 'missed': 6}, 'BRANCH': {'covered': 17, 'missed': 3}, 'LINE': {'covered': 11, 'missed': 1}, 'COMPLEXITY': {'covered': 8, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",133.0,  Checks if the message starts with the given string.,10.0,"[""If the message starts with a string, it's checked."", ""If the message starts with the given string, it's checked."", ""If the message begins with the given string, it's checked.""]"
728,matsim-libs,org/matsim/core/network/LinkQuadTree.java,/matsim/src/main/java/org/matsim/core/network/LinkQuadTree.java,calcDistanceIndicator,284-310,"/**
		 * Calculates the distance of a given point to the border of the
		 * rectangle. If the point lies within the rectangle, the distance
		 * is zero.
		 *
		 * @param x left-right location
		 * @param y up-down location
		 * @return distance to border, 0 if inside rectangle or on border
		 */
private double calcDistanceIndicator(final double x, final double y){
    double distanceX;
    double distanceY;
    if (this.minX <= x && x <= this.maxX) {
        distanceX = 0;
    } else {
        distanceX = Math.min(Math.abs(this.minX - x), Math.abs(this.maxX - x));
    }
    if (this.minY <= y && y <= this.maxY) {
        distanceY = 0;
    } else {
        distanceY = Math.min(Math.abs(this.minY - y), Math.abs(this.maxY - y));
    }
    return distanceX * distanceX + distanceY * distanceY;
}","private double calcDistanceIndicator(final double x, final double y){
    double distanceX;
    double distanceY;
    if (this.minX <= x && x <= this.maxX) {
        distanceX = 0;
    } else {
        distanceX = Math.min(Math.abs(this.minX - x), Math.abs(this.maxX - x));
    }
    if (this.minY <= y && y <= this.maxY) {
        distanceY = 0;
    } else {
        distanceY = Math.min(Math.abs(this.minY - y), Math.abs(this.maxY - y));
    }
    return distanceX * distanceX + distanceY * distanceY;
}","/**
		 * Calculates the distance of a given point to the border of the
		 * rectangle. If the point lies within the rectangle, the distance
		 * is zero.
		 *
		 * @param x left-right location
		 * @param y up-down location
		 * @return distance to border, 0 if inside rectangle or on border
		 */","('calcDistanceIndicator', {'INSTRUCTION': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",133.0,  Calculates the distance of a given point to the border of the  rectangle.,14.0,"['The distance to the border of the rectangle is calculated.', 'The distance is calculated from the point to the border.', 'The distance is calculated from a point to the border.']"
729,acs-aem-commons,com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,/bundle/src/main/java/com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,replaceInObject,196-217,"/**
     * Iterates over keys to replace any placeholders in the values.
     *
     * @param node Object node
     * @param contentVariableReplacements current map of content variables
     */
private void replaceInObject(JsonNode node, Map<String, Object> contentVariableReplacements){
    Iterator<String> fieldNames = node.fieldNames();
    while (fieldNames.hasNext()) {
        String name = fieldNames.next();
        JsonNode nodeValue = node.get(name);
        if (nodeValue.isContainerNode()) {
            replaceInElements(nodeValue, contentVariableReplacements);
        } else if (nodeValue.isTextual()) {
            String current = nodeValue.asText();
            String replaced = replaceInString(current, contentVariableReplacements);
            if (!StringUtils.equals(current, replaced)) {
                ((ObjectNode) node).put(name, replaced);
            }
        }
    }
}","private void replaceInObject(JsonNode node, Map<String, Object> contentVariableReplacements){
    Iterator<String> fieldNames = node.fieldNames();
    while (fieldNames.hasNext()) {
        String name = fieldNames.next();
        JsonNode nodeValue = node.get(name);
        if (nodeValue.isContainerNode()) {
            replaceInElements(nodeValue, contentVariableReplacements);
        } else if (nodeValue.isTextual()) {
            String current = nodeValue.asText();
            String replaced = replaceInString(current, contentVariableReplacements);
            if (!StringUtils.equals(current, replaced)) {
                ((ObjectNode) node).put(name, replaced);
            }
        }
    }
}","/**
     * Iterates over keys to replace any placeholders in the values.
     *
     * @param node Object node
     * @param contentVariableReplacements current map of content variables
     */","('replaceInObject', {'INSTRUCTION': {'covered': 45, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",133.0,  Iterates over keys to replace any placeholders in the values.,11.0,"['Iterates the keys to replace the values.', 'Iterates over keys to replace the values.', 'Iterates over keys to replace the values with new ones.']"
731,cdk,org/openscience/cdk/geometry/GeometryTools.java,/legacy/src/main/java/org/openscience/cdk/geometry/GeometryTools.java,shiftReactionVertical,1699-1723,"/**
     * Shift the containers in a reaction vertically upwards to not overlap
     * with the reference Rectangle2D. The shift is such that the given
     * gap is realized, but only if the reactions are actually overlapping.
     *
     * @param reaction the reaction to shift
     * @param bounds   the bounds of the reaction to shift
     * @param last     the bounds of the last reaction
     * @return         the Rectangle2D of the shifted reaction
     */
public static Rectangle2D shiftReactionVertical(IReaction reaction, Rectangle2D bounds, Rectangle2D last, double gap){
    if (last.getMaxY() + gap >= bounds.getMinY()) {
        double yShift = bounds.getHeight() + last.getHeight() + gap;
        Vector2d shift = new Vector2d(0, yShift);
        List<IAtomContainer> containers = ReactionManipulator.getAllAtomContainers(reaction);
        for (IAtomContainer container : containers) {
            translate2D(container, shift);
        }
        return new Rectangle2D.Double(bounds.getX(), bounds.getY() + yShift, bounds.getWidth(), bounds.getHeight());
    } else {
        return bounds;
    }
}","public static Rectangle2D shiftReactionVertical(IReaction reaction, Rectangle2D bounds, Rectangle2D last, double gap){
    if (last.getMaxY() + gap >= bounds.getMinY()) {
        double yShift = bounds.getHeight() + last.getHeight() + gap;
        Vector2d shift = new Vector2d(0, yShift);
        List<IAtomContainer> containers = ReactionManipulator.getAllAtomContainers(reaction);
        for (IAtomContainer container : containers) {
            translate2D(container, shift);
        }
        return new Rectangle2D.Double(bounds.getX(), bounds.getY() + yShift, bounds.getWidth(), bounds.getHeight());
    } else {
        return bounds;
    }
}","/**
     * Shift the containers in a reaction vertically upwards to not overlap
     * with the reference Rectangle2D. The shift is such that the given
     * gap is realized, but only if the reactions are actually overlapping.
     *
     * @param reaction the reaction to shift
     * @param bounds   the bounds of the reaction to shift
     * @param last     the bounds of the last reaction
     * @return         the Rectangle2D of the shifted reaction
     */","('shiftReactionVertical', {'INSTRUCTION': {'covered': 53, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",133.0,Shift the containers in a reaction vertically upwards to not overlap  with the reference Rectangle2D.,16.0,"['To avoid overlap with the reference, shift the containers vertically upwards.', 'To avoid overlap with the reference, shift the containers in a reaction vertically upwards.', 'The containers should be shifted vertically upwards to not overlap with the reference.']"
732,tablesaw,tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,hourMinute,261-282,"/**
   * Returns a StringColumn with the year and week-of-year derived from this column concatenated
   * into a String that will sort lexicographically in temporal order.
   *
   * <p>This simplifies the production of plots and tables that aggregate values into standard
   * temporal units (e.g., you want monthly data but your source data is more than a year long and
   * you don't want months from different years aggregated together).
   */
 StringColumn hourMinute(){
    StringColumn newColumn = StringColumn.create(this.name() + "" hour & minute"");
    for (int r = 0; r < this.size(); r++) {
        long c1 = this.getLongInternal(r);
        if (DateTimeColumn.valueIsMissing(c1)) {
            newColumn.append(StringColumnType.missingValueIndicator());
        } else {
            String hm = Strings.padStart(String.valueOf(getHour(c1)), 2, '0');
            hm = hm + "":"" + Strings.padStart(String.valueOf(getMinute(c1)), 2, '0');
            newColumn.append(hm);
        }
    }
    return newColumn;
}","StringColumn hourMinute(){
    StringColumn newColumn = StringColumn.create(this.name() + "" hour & minute"");
    for (int r = 0; r < this.size(); r++) {
        long c1 = this.getLongInternal(r);
        if (DateTimeColumn.valueIsMissing(c1)) {
            newColumn.append(StringColumnType.missingValueIndicator());
        } else {
            String hm = Strings.padStart(String.valueOf(getHour(c1)), 2, '0');
            hm = hm + "":"" + Strings.padStart(String.valueOf(getMinute(c1)), 2, '0');
            newColumn.append(hm);
        }
    }
    return newColumn;
}","/**
   * Returns a StringColumn with the year and week-of-year derived from this column concatenated
   * into a String that will sort lexicographically in temporal order.
   *
   * <p>This simplifies the production of plots and tables that aggregate values into standard
   * temporal units (e.g., you want monthly data but your source data is more than a year long and
   * you don't want months from different years aggregated together).
   */","('hourMinute', {'INSTRUCTION': {'covered': 55, 'missed': 5}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 8, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",134.0,  Returns a StringColumn with the year and week-of-year derived from this column concatenated  into a String that will sort lexicographically in temporal order.,24.0,"['The year and week-of-year derived from this column will be returned as a string.', 'The year and week-of-year derived from this column will be used to sort the string by temporal order.', 'The year and week-of-year derived from this column will be returned as a String.']"
733,tablesaw,tech/tablesaw/io/fixed/FixedWidthReader.java,/core/src/main/java/tech/tablesaw/io/fixed/FixedWidthReader.java,detectColumnTypes,134-166,"/**
   * Estimates and returns the type for each column in the delimited text file {@code file}
   *
   * <p>The type is determined by checking a sample of the data in the file. Because only a sample
   * of the data is checked, the types may be incorrect. If that is the case a Parse Exception will
   * be thrown.
   *
   * <p>The method {@code printColumnTypes()} can be used to print a list of the detected columns
   * that can be corrected and used to explicitly specify the correct column types.
   */
public ColumnType[] detectColumnTypes(Reader reader, FixedWidthReadOptions options){
    boolean header = options.header();
    int linesToSkip = header ? 1 : 0;
    AbstractParser<?> parser = fixedWidthParser(options);
    try {
        String[] columnNames = Optional.ofNullable(options.columnSpecs()).flatMap(specs -> Optional.ofNullable(specs.getFieldNames())).map(fieldNames -> Arrays.stream(fieldNames).map(NormalizedString::toString).toArray(String[]::new)).orElse(null);
        return getColumnTypes(reader, options, linesToSkip, parser, columnNames);
    } finally {
        parser.stopParsing();
    }
}","public ColumnType[] detectColumnTypes(Reader reader, FixedWidthReadOptions options){
    boolean header = options.header();
    int linesToSkip = header ? 1 : 0;
    AbstractParser<?> parser = fixedWidthParser(options);
    try {
        String[] columnNames = Optional.ofNullable(options.columnSpecs()).flatMap(specs -> Optional.ofNullable(specs.getFieldNames())).map(fieldNames -> Arrays.stream(fieldNames).map(NormalizedString::toString).toArray(String[]::new)).orElse(null);
        return getColumnTypes(reader, options, linesToSkip, parser, columnNames);
    } finally {
        parser.stopParsing();
    }
}","/**
   * Estimates and returns the type for each column in the delimited text file {@code file}
   *
   * <p>The type is determined by checking a sample of the data in the file. Because only a sample
   * of the data is checked, the types may be incorrect. If that is the case a Parse Exception will
   * be thrown.
   *
   * <p>The method {@code printColumnTypes()} can be used to print a list of the detected columns
   * that can be corrected and used to explicitly specify the correct column types.
   */","('detectColumnTypes', {'INSTRUCTION': {'covered': 35, 'missed': 1}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",134.0,  Estimates and returns the type for each column in the delimited text file {@code file}   <p>The type is determined by checking a sample of the data in the file.,36.0,"['The type is determined by checking a sample of the data in the file.', 'The type is determined by checking a sample of the data in the file, estimates and returns the type for each column.', 'The type is determined by checking a sample of the data in the file, estimates and returns.']"
735,cdk,org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,rescaleBondLength,123-148,"/**
     *  Rescales Point2 so that length 1-2 is sum of covalent radii.
     *  If covalent radii cannot be found, use bond length of 1.0
     *
     *@param  atom1          stationary atom
     *@param  atom2          movable atom
     *@param  point2         coordinates for atom 2
     *@return                new coordinates for atom 2
     */
public Point3d rescaleBondLength(IAtom atom1, IAtom atom2, Point3d point2){
    Point3d point1 = atom1.getPoint3d();
    Double d1 = atom1.getCovalentRadius();
    Double d2 = atom2.getCovalentRadius();
    double distance = (d1 == null || d2 == null) ? 1.0 : d1 + d2;
    if (pSet != null) {
        distance = getDistanceValue(atom1.getAtomTypeName(), atom2.getAtomTypeName());
    }
    Vector3d vect = new Vector3d(point2);
    vect.sub(point1);
    vect.normalize();
    vect.scale(distance);
    Point3d newPoint = new Point3d(point1);
    newPoint.add(vect);
    return newPoint;
}","public Point3d rescaleBondLength(IAtom atom1, IAtom atom2, Point3d point2){
    Point3d point1 = atom1.getPoint3d();
    Double d1 = atom1.getCovalentRadius();
    Double d2 = atom2.getCovalentRadius();
    double distance = (d1 == null || d2 == null) ? 1.0 : d1 + d2;
    if (pSet != null) {
        distance = getDistanceValue(atom1.getAtomTypeName(), atom2.getAtomTypeName());
    }
    Vector3d vect = new Vector3d(point2);
    vect.sub(point1);
    vect.normalize();
    vect.scale(distance);
    Point3d newPoint = new Point3d(point1);
    newPoint.add(vect);
    return newPoint;
}","/**
     *  Rescales Point2 so that length 1-2 is sum of covalent radii.
     *  If covalent radii cannot be found, use bond length of 1.0
     *
     *@param  atom1          stationary atom
     *@param  atom2          movable atom
     *@param  point2         coordinates for atom 2
     *@return                new coordinates for atom 2
     */","('rescaleBondLength', {'INSTRUCTION': {'covered': 54, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",134.0,Rescales Point2 so that length 1-2 is sum of covalent radii.,12.0,"['Rescales Point2 so that the length is a sum of the covalent radii.', 'Rescales Point2 so that the length is a sum of the two bonds.', 'Rescales Point2 so that the length is a sum of the two sides of a circle.']"
736,cdk,org/openscience/cdk/io/MDLV2000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Writer.java,formatMDLFloat,1347-1372,"/**
     * Formats a float to fit into the connectiontable and changes it
     * to a String.
     *
     * @param fl The float to be formated
     * @return The String to be written into the connectiontable
     */
protected static String formatMDLFloat(float fl){
    String s = """", fs = """";
    int l;
    NumberFormat nf = NumberFormat.getNumberInstance(Locale.ENGLISH);
    nf.setMinimumIntegerDigits(1);
    nf.setMaximumIntegerDigits(4);
    nf.setMinimumFractionDigits(4);
    nf.setMaximumFractionDigits(4);
    nf.setGroupingUsed(false);
    if (Double.isNaN(fl) || Double.isInfinite(fl))
        s = ""0.0000"";
    else
        s = nf.format(fl);
    l = 10 - s.length();
    for (int f = 0; f < l; f++) fs += "" "";
    fs += s;
    return fs;
}","protected static String formatMDLFloat(float fl){
    String s = """", fs = """";
    int l;
    NumberFormat nf = NumberFormat.getNumberInstance(Locale.ENGLISH);
    nf.setMinimumIntegerDigits(1);
    nf.setMaximumIntegerDigits(4);
    nf.setMinimumFractionDigits(4);
    nf.setMaximumFractionDigits(4);
    nf.setGroupingUsed(false);
    if (Double.isNaN(fl) || Double.isInfinite(fl))
        s = ""0.0000"";
    else
        s = nf.format(fl);
    l = 10 - s.length();
    for (int f = 0; f < l; f++) fs += "" "";
    fs += s;
    return fs;
}","/**
     * Formats a float to fit into the connectiontable and changes it
     * to a String.
     *
     * @param fl The float to be formated
     * @return The String to be written into the connectiontable
     */","('formatMDLFloat', {'INSTRUCTION': {'covered': 67, 'missed': 3}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 14, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",134.0,  Formats a float to fit into the connectiontable and changes it  to a String.,15.0,"['A float is formatted to fit into the connectiontable and changed to a string.', 'A float is formatted to fit into the connectiontable and changed to a String.', 'The float is formatted to fit into the connectiontable and changed to a String.']"
737,cdk,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,updateAromaticTypesInSixMemberRing,219-236,"/**
     * Update aromatic atom types in a six member ring. The aromatic types here are hard coded from
     * the 'MMFFAROM.PAR' file.
     *
     * @param cycle 6-member aromatic cycle / ring
     * @param symbs vector of symbolic types for the whole structure
     */
 static void updateAromaticTypesInSixMemberRing(int[] cycle, String[] symbs){
    for (final int v : cycle) {
        if (NCN_PLUS.equals(symbs[v]) || ""N+=C"".equals(symbs[v]) || ""N=+C"".equals(symbs[v]))
            symbs[v] = ""NPD+"";
        else if (""N2OX"".equals(symbs[v]))
            symbs[v] = ""NPOX"";
        else if (""N=C"".equals(symbs[v]) || ""N=N"".equals(symbs[v]))
            symbs[v] = ""NPYD"";
        else if (symbs[v].startsWith(""C""))
            symbs[v] = ""CB"";
    }
}","static void updateAromaticTypesInSixMemberRing(int[] cycle, String[] symbs){
    for (final int v : cycle) {
        if (NCN_PLUS.equals(symbs[v]) || ""N+=C"".equals(symbs[v]) || ""N=+C"".equals(symbs[v]))
            symbs[v] = ""NPD+"";
        else if (""N2OX"".equals(symbs[v]))
            symbs[v] = ""NPOX"";
        else if (""N=C"".equals(symbs[v]) || ""N=N"".equals(symbs[v]))
            symbs[v] = ""NPYD"";
        else if (symbs[v].startsWith(""C""))
            symbs[v] = ""CB"";
    }
}","/**
     * Update aromatic atom types in a six member ring. The aromatic types here are hard coded from
     * the 'MMFFAROM.PAR' file.
     *
     * @param cycle 6-member aromatic cycle / ring
     * @param symbs vector of symbolic types for the whole structure
     */","('updateAromaticTypesInSixMemberRing', {'INSTRUCTION': {'covered': 78, 'missed': 0}, 'BRANCH': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",135.0,  Update aromatic atom types in a six member ring.,10.0,"['A six member ring has aromatic atom types.', 'A six member ring has aromatic atom types updated.', 'The aromatic atom types are updated.']"
738,dcache,org/dcache/resilience/handlers/FileOperationHandler.java,/modules/dcache-resilience/src/main/java/org/dcache/resilience/handlers/FileOperationHandler.java,shouldEvictALocation,1366-1405,"/**
     * <p>Checks for necessary eviction due to pool tag changes or
     * constraint change.  This call will automatically set the offending location as the target for
     * a remove operation, and will increment the operation count so that there will be a chance to
     * repeat the operation in order to make a new copy.</p>
     *
     * <p> Note that the extractor algorithm will never remove the last replica,
     * because a singleton will always satisfy any equivalence relation. But we short-circuit this
     * check anyway (for location size < 2).</p>
     */
private boolean shouldEvictALocation(FileOperation operation, Collection<String> readableLocations, Collection verified){
    if (readableLocations.size() < 2) {
        return false;
    }
    Integer sunit = operation.getStorageUnit();
    if (sunit == null) {
        return false;
    }
    StorageUnitConstraints constraints = poolInfoMap.getStorageUnitConstraints(sunit);
    RemoveLocationExtractor extractor = new RemoveLocationExtractor(constraints.getOneCopyPer(), poolInfoMap);
    String toEvict = extractor.findALocationToEvict(readableLocations, verified, verifier);
    if (toEvict != null) {
        operation.setTarget(poolInfoMap.getPoolIndex(toEvict));
        int count = operation.getOpCount();
        operation.setOpCount(++count);
        return true;
    }
    return false;
}","private boolean shouldEvictALocation(FileOperation operation, Collection<String> readableLocations, Collection verified){
    if (readableLocations.size() < 2) {
        return false;
    }
    Integer sunit = operation.getStorageUnit();
    if (sunit == null) {
        return false;
    }
    StorageUnitConstraints constraints = poolInfoMap.getStorageUnitConstraints(sunit);
    RemoveLocationExtractor extractor = new RemoveLocationExtractor(constraints.getOneCopyPer(), poolInfoMap);
    String toEvict = extractor.findALocationToEvict(readableLocations, verified, verifier);
    if (toEvict != null) {
        operation.setTarget(poolInfoMap.getPoolIndex(toEvict));
        int count = operation.getOpCount();
        operation.setOpCount(++count);
        return true;
    }
    return false;
}","/**
     * <p>Checks for necessary eviction due to pool tag changes or
     * constraint change.  This call will automatically set the offending location as the target for
     * a remove operation, and will increment the operation count so that there will be a chance to
     * repeat the operation in order to make a new copy.</p>
     *
     * <p> Note that the extractor algorithm will never remove the last replica,
     * because a singleton will always satisfy any equivalence relation. But we short-circuit this
     * check anyway (for location size < 2).</p>
     */","('shouldEvictALocation', {'INSTRUCTION': {'covered': 50, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 15, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",135.0,  <p>Checks for necessary eviction due to pool tag changes or  constraint change.,16.0,"['Checks for evictions due to pool tag changes.', 'Checks for necessary evictions due to pool tag changes.', 'Checks for evictions due to pool tag changes or constraint changes.']"
739,cdk,org/openscience/cdk/similarity/LingoSimilarity.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/similarity/LingoSimilarity.java,calculate,45-69,"/**
     * Evaluate the LINGO similarity between two key,value sty;e fingerprints.
     *
     * The value will range from 0.0 to 1.0.
     *
     * @param features1
     * @param features2
     * @return similarity
     */
public static float calculate(Map<String, Integer> features1, Map<String, Integer> features2){
    TreeSet<String> keys = new TreeSet<String>(features1.keySet());
    keys.addAll(features2.keySet());
    float sum = 0.0f;
    for (String key : keys) {
        Integer c1 = features1.get(key);
        Integer c2 = features2.get(key);
        c1 = c1 == null ? 0 : c1;
        c2 = c2 == null ? 0 : c2;
        sum += 1.0 - Math.abs(c1 - c2) / (c1 + c2);
    }
    return sum / keys.size();
}","public static float calculate(Map<String, Integer> features1, Map<String, Integer> features2){
    TreeSet<String> keys = new TreeSet<String>(features1.keySet());
    keys.addAll(features2.keySet());
    float sum = 0.0f;
    for (String key : keys) {
        Integer c1 = features1.get(key);
        Integer c2 = features2.get(key);
        c1 = c1 == null ? 0 : c1;
        c2 = c2 == null ? 0 : c2;
        sum += 1.0 - Math.abs(c1 - c2) / (c1 + c2);
    }
    return sum / keys.size();
}","/**
     * Evaluate the LINGO similarity between two key,value sty;e fingerprints.
     *
     * The value will range from 0.0 to 1.0.
     *
     * @param features1
     * @param features2
     * @return similarity
     */","('calculate', {'INSTRUCTION': {'covered': 72, 'missed': 4}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",135.0,"  Evaluate the LINGO similarity between two key,value sty;e fingerprints.",14.0,"['Evaluate the similarity of two fingerprints.', 'Evaluate the similarity between two fingerprints.', 'Evaluate the LINGO similarity between fingerprints.']"
741,dataverse,edu/harvard/iq/dataverse/search/SearchUtil.java,/src/main/java/edu/harvard/iq/dataverse/search/SearchUtil.java,sanitizeQuery,13-46,"/**
     * @param query The query string that might be mutated before feeding it
     * into Solr.
     * @return The query string that may have been mutated or null if null was
     * passed in.
     */
public static String sanitizeQuery(String query){
    if (query == null) {
        return null;
    }
    String[] colonParts = query.split("":"");
    if (colonParts.length > 0) {
        String first = colonParts[0];
        if (first.startsWith(""doi"")) {
            query = query.replaceAll(""doi:"", ""doi\\\\:"");
        } else if (first.startsWith(""hdl"")) {
            query = query.replaceAll(""hdl:"", ""hdl\\\\:"");
        } else if (first.startsWith(""datasetPersistentIdentifier"")) {
            query = query.replaceAll(""datasetPersistentIdentifier:doi:"", ""datasetPersistentIdentifier:doi\\\\:"");
            query = query.replaceAll(""datasetPersistentIdentifier:hdl:"", ""datasetPersistentIdentifier:hdl\\\\:"");
        } else {
            /**
             * No-op, don't mutate the query.
             *
             * Because we want to support advanced search queries like
             * ""title:foo"" we can't simply escape the whole query with
             * `ClientUtils.escapeQueryChars(query)`:
             *
             * http://lucene.apache.org/solr/4_6_0/solr-solrj/org/apache/solr/client/solrj/util/ClientUtils.html#escapeQueryChars%28java.lang.String%29
             */
        }
    }
    return query;
}","public static String sanitizeQuery(String query){
    if (query == null) {
        return null;
    }
    String[] colonParts = query.split("":"");
    if (colonParts.length > 0) {
        String first = colonParts[0];
        if (first.startsWith(""doi"")) {
            query = query.replaceAll(""doi:"", ""doi\\\\:"");
        } else if (first.startsWith(""hdl"")) {
            query = query.replaceAll(""hdl:"", ""hdl\\\\:"");
        } else if (first.startsWith(""datasetPersistentIdentifier"")) {
            query = query.replaceAll(""datasetPersistentIdentifier:doi:"", ""datasetPersistentIdentifier:doi\\\\:"");
            query = query.replaceAll(""datasetPersistentIdentifier:hdl:"", ""datasetPersistentIdentifier:hdl\\\\:"");
        } else {
            /**
             * No-op, don't mutate the query.
             *
             * Because we want to support advanced search queries like
             * ""title:foo"" we can't simply escape the whole query with
             * `ClientUtils.escapeQueryChars(query)`:
             *
             * http://lucene.apache.org/solr/4_6_0/solr-solrj/org/apache/solr/client/solrj/util/ClientUtils.html#escapeQueryChars%28java.lang.String%29
             */
        }
    }
    return query;
}","/**
     * @param query The query string that might be mutated before feeding it
     * into Solr.
     * @return The query string that may have been mutated or null if null was
     * passed in.
     */","('sanitizeQuery', {'INSTRUCTION': {'covered': 51, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",136.0,  @param query The query string that might be mutated before feeding it  into Solr.,16.0,"['The query string that might be changed before feeding it into Solr.', 'The string that might be changed before feeding it into Solr.', 'The query string that might be changed before it is fed into Solr.']"
743,jackson-databind,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,valueToTree,3344-3396,"/**
     * Method that is reverse of {@link #treeToValue}: it
     * will convert given Java value (usually bean) into its
     * equivalent Tree mode {@link JsonNode} representation.
     * Functionally similar to serializing value into token stream and parsing that
     * stream back as tree model node,
     * but more efficient as {@link TokenBuffer} is used to contain the intermediate
     * representation instead of fully serialized contents.
     *<p>
     * NOTE: while results are usually identical to that of serialization followed
     * by deserialization, this is not always the case. In some cases serialization
     * into intermediate representation will retain encapsulation of things like
     * raw value ({@link com.fasterxml.jackson.databind.util.RawValue}) or basic
     * node identity ({@link JsonNode}). If so, result is a valid tree, but values
     * are not re-constructed through actual format representation. So if transformation
     * requires actual materialization of encoded content,
     * it will be necessary to do actual serialization.
     * 
     * @param <T> Actual node type; usually either basic {@link JsonNode} or
     *  {@link com.fasterxml.jackson.databind.node.ObjectNode}
     * @param fromValue Java value to convert
     *
     * @return (non-null) Root node of the resulting content tree: in case of
     *   {@code null} value node for which {@link JsonNode#isNull()} returns {@code true}.
     */
public T valueToTree(Object fromValue) throws IllegalArgumentException{
    if (fromValue == null) {
        return (T) getNodeFactory().nullNode();
    }
    final SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);
    final DefaultSerializerProvider context = _serializerProvider(config);
    TokenBuffer buf = context.bufferForValueConversion(this);
    if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
        buf = buf.forceUseOfBigDecimal(true);
    }
    try {
        context.serializeValue(buf, fromValue);
        try (JsonParser p = buf.asParser()) {
            return readTree(p);
        }
    } catch (IOException e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}","public T valueToTree(Object fromValue) throws IllegalArgumentException{
    if (fromValue == null) {
        return (T) getNodeFactory().nullNode();
    }
    final SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);
    final DefaultSerializerProvider context = _serializerProvider(config);
    TokenBuffer buf = context.bufferForValueConversion(this);
    if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
        buf = buf.forceUseOfBigDecimal(true);
    }
    try {
        context.serializeValue(buf, fromValue);
        try (JsonParser p = buf.asParser()) {
            return readTree(p);
        }
    } catch (IOException e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}","/**
     * Method that is reverse of {@link #treeToValue}: it
     * will convert given Java value (usually bean) into its
     * equivalent Tree mode {@link JsonNode} representation.
     * Functionally similar to serializing value into token stream and parsing that
     * stream back as tree model node,
     * but more efficient as {@link TokenBuffer} is used to contain the intermediate
     * representation instead of fully serialized contents.
     *<p>
     * NOTE: while results are usually identical to that of serialization followed
     * by deserialization, this is not always the case. In some cases serialization
     * into intermediate representation will retain encapsulation of things like
     * raw value ({@link com.fasterxml.jackson.databind.util.RawValue}) or basic
     * node identity ({@link JsonNode}). If so, result is a valid tree, but values
     * are not re-constructed through actual format representation. So if transformation
     * requires actual materialization of encoded content,
     * it will be necessary to do actual serialization.
     * 
     * @param <T> Actual node type; usually either basic {@link JsonNode} or
     *  {@link com.fasterxml.jackson.databind.node.ObjectNode}
     * @param fromValue Java value to convert
     *
     * @return (non-null) Root node of the resulting content tree: in case of
     *   {@code null} value node for which {@link JsonNode#isNull()} returns {@code true}.
     */","('valueToTree', {'INSTRUCTION': {'covered': 41, 'missed': 8}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 2}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",136.0,  Method that is reverse of {@link #treeToValue}: it  will convert given Java value (usually bean) into its  equivalent Tree mode {@link JsonNode} representation.,34.0,"['The method that is reverse of @link #treeToValue is called @link JsonNode representation.', 'The method that is reverse of @link #treeToValue is called the Tree mode @link JsonNode representation.', 'The method that is reverse of @link #treeToValue is called @link JsonNode.']"
744,acs-aem-commons,com/adobe/acs/commons/remoteassets/impl/RemoteAssetDecorator.java,/bundle/src/main/java/com/adobe/acs/commons/remoteassets/impl/RemoteAssetDecorator.java,isAllowedUser,154-188,"/**
     * Check if the user is allowed to sync binaries.
     *
     * Service users, as well as the admin user, are prevented from sync'ing
     * binaries to ensure that some back end procress traversing the DAM doesn't
     * trigger a sync of the entire DAM, thus subverting the benefits of
     * remote assets.
     *
     * Service users can be whitelisted via remote aseets configuration if it
     * is desired for a particular service user to be able to sync binaries.
     *
     * @param resource The asset content Resource to sync binaries for.
     * @return True if user is allowed to sync binaries, else false.
     * @throws RepositoryException
     */
private boolean isAllowedUser(Resource resource) throws RepositoryException{
    ResourceResolver resourceResolver = resource.getResourceResolver();
    String userId = resourceResolver.getUserID();
    if (!userId.equals(ADMIN_ID)) {
        if (this.config.getWhitelistedServiceUsers().contains(userId)) {
            return true;
        }
        Session session = resourceResolver.adaptTo(Session.class);
        User currentUser = (User) getUserManager(session).getAuthorizable(userId);
        if (currentUser != null && !currentUser.isSystemUser()) {
            return true;
        } else {
            LOG.trace(""Avoiding binary sync b/c this is a non-whitelisted service user: {}"", session.getUserID());
        }
    } else {
        LOG.trace(""Avoiding binary sync for admin user"");
    }
    return false;
}","private boolean isAllowedUser(Resource resource) throws RepositoryException{
    ResourceResolver resourceResolver = resource.getResourceResolver();
    String userId = resourceResolver.getUserID();
    if (!userId.equals(ADMIN_ID)) {
        if (this.config.getWhitelistedServiceUsers().contains(userId)) {
            return true;
        }
        Session session = resourceResolver.adaptTo(Session.class);
        User currentUser = (User) getUserManager(session).getAuthorizable(userId);
        if (currentUser != null && !currentUser.isSystemUser()) {
            return true;
        } else {
            LOG.trace(""Avoiding binary sync b/c this is a non-whitelisted service user: {}"", session.getUserID());
        }
    } else {
        LOG.trace(""Avoiding binary sync for admin user"");
    }
    return false;
}","/**
     * Check if the user is allowed to sync binaries.
     *
     * Service users, as well as the admin user, are prevented from sync'ing
     * binaries to ensure that some back end procress traversing the DAM doesn't
     * trigger a sync of the entire DAM, thus subverting the benefits of
     * remote assets.
     *
     * Service users can be whitelisted via remote aseets configuration if it
     * is desired for a particular service user to be able to sync binaries.
     *
     * @param resource The asset content Resource to sync binaries for.
     * @return True if user is allowed to sync binaries, else false.
     * @throws RepositoryException
     */","('isAllowedUser', {'INSTRUCTION': {'covered': 48, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",136.0,  Check if the user is allowed to sync binaries.,10.0,"['If the user is allowed to sync, check it.', 'If the user is allowed to sync the binaries.', 'If the user is allowed to sync, check it out.']"
745,acs-aem-commons,com/adobe/acs/commons/remoteassets/impl/RemoteAssetDecorator.java,/bundle/src/main/java/com/adobe/acs/commons/remoteassets/impl/RemoteAssetDecorator.java,decorate,76-108,"/**
     * When resolving a remote asset, first sync the asset from the remote server.
     * @param resource The resource being resolved.
     * @return The current resource.  If the resource is a ""remote"" asset, it will
     * first be converted to a true local AEM asset by sync'ing in the rendition
     * binaries from the remote server.
     */
public Resource decorate(final Resource resource){
    try {
        if (!this.accepts(resource)) {
            return resource;
        }
    } catch (Exception e) {
        // Logging at debug level b/c if this happens it could represent a ton of logging
        LOG.debug(""Failed binary sync check for remote asset: {}"", resource.getPath());
        return resource;
    }
    boolean syncSuccessful = false;
    if (isAlreadySyncing(resource.getPath())) {
        syncSuccessful = waitForSyncInProgress(resource);
    } else {
        syncSuccessful = syncAssetBinaries(resource);
    }
    if (syncSuccessful) {
        LOG.trace(""Refreshing resource after binary sync of {}"", resource.getPath());
        resource.getResourceResolver().refresh();
        return resource.getResourceResolver().getResource(resource.getPath());
    } else {
        return resource;
    }
}","public Resource decorate(final Resource resource){
    try {
        if (!this.accepts(resource)) {
            return resource;
        }
    } catch (Exception e) {
        // Logging at debug level b/c if this happens it could represent a ton of logging
        LOG.debug(""Failed binary sync check for remote asset: {}"", resource.getPath());
        return resource;
    }
    boolean syncSuccessful = false;
    if (isAlreadySyncing(resource.getPath())) {
        syncSuccessful = waitForSyncInProgress(resource);
    } else {
        syncSuccessful = syncAssetBinaries(resource);
    }
    if (syncSuccessful) {
        LOG.trace(""Refreshing resource after binary sync of {}"", resource.getPath());
        resource.getResourceResolver().refresh();
        return resource.getResourceResolver().getResource(resource.getPath());
    } else {
        return resource;
    }
}","/**
     * When resolving a remote asset, first sync the asset from the remote server.
     * @param resource The resource being resolved.
     * @return The current resource.  If the resource is a ""remote"" asset, it will
     * first be converted to a true local AEM asset by sync'ing in the rendition
     * binaries from the remote server.
     */","('decorate', {'INSTRUCTION': {'covered': 49, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",137.0,"  When resolving a remote asset, first sync the asset from the remote server.",15.0,"['First, sync the asset from the remote server.', 'First, sync the asset from the server.', 'First, sync the asset from the remote server']"
746,cdk,org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,axial2DEncoder,160-186,"/**
     * Create an encoder for axial 2D stereochemistry for the given start and
     * end atoms.
     *
     * @param container  the molecule
     * @param start      start of the cumulated system
     * @param startBonds bonds connected to the start
     * @param end        end of the cumulated system
     * @param endBonds   bonds connected to the end
     * @return an encoder
     */
private static StereoEncoder axial2DEncoder(IAtomContainer container, IAtom start, List<IBond> startBonds, IAtom end, List<IBond> endBonds){
    Point2d[] ps = new Point2d[4];
    int[] es = new int[4];
    PermutationParity perm = new CombinedPermutationParity(fill2DCoordinates(container, start, startBonds, ps, es, 0), fill2DCoordinates(container, end, endBonds, ps, es, 2));
    GeometricParity geom = new Tetrahedral2DParity(ps, es);
    int u = container.indexOf(start);
    int v = container.indexOf(end);
    return new GeometryEncoder(new int[] { u, v }, perm, geom);
}","private static StereoEncoder axial2DEncoder(IAtomContainer container, IAtom start, List<IBond> startBonds, IAtom end, List<IBond> endBonds){
    Point2d[] ps = new Point2d[4];
    int[] es = new int[4];
    PermutationParity perm = new CombinedPermutationParity(fill2DCoordinates(container, start, startBonds, ps, es, 0), fill2DCoordinates(container, end, endBonds, ps, es, 2));
    GeometricParity geom = new Tetrahedral2DParity(ps, es);
    int u = container.indexOf(start);
    int v = container.indexOf(end);
    return new GeometryEncoder(new int[] { u, v }, perm, geom);
}","/**
     * Create an encoder for axial 2D stereochemistry for the given start and
     * end atoms.
     *
     * @param container  the molecule
     * @param start      start of the cumulated system
     * @param startBonds bonds connected to the start
     * @param end        end of the cumulated system
     * @param endBonds   bonds connected to the end
     * @return an encoder
     */","('axial2DEncoder', {'INSTRUCTION': {'covered': 54, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",137.0,Create an encoder for axial 2D stereochemistry for the given start and  end atoms.,15.0,"['The given start and end atoms need an Encoder for 2D stereochemistry.', 'The given start and end atoms can be stereochemistry.', 'The given start and end atoms need an Encoder for 2D Stereochemistry.']"
747,cdk,org/openscience/cdk/geometry/cip/CIPTool.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/CIPTool.java,permParity,249-278,"/**
     * Obtain the permutation parity (-1,0,+1) to put the ligands in descending
     * order (highest first). A parity of 0 indicates two or more ligands were
     * equivalent.
     *
     * @param ligands the ligands to sort
     * @return parity, odd (-1), even (+1) or none (0)
     */
private static int permParity(final ILigand[] ligands){
    int swaps = 0;
    for (int j = 1, hi = ligands.length; j < hi; j++) {
        ILigand ligand = ligands[j];
        int i = j - 1;
        int cmp = 0;
        while ((i >= 0) && (cmp = cipRule.compare(ligand, ligands[i])) > 0) {
            ligands[i + 1] = ligands[i--];
            swaps++;
        }
        if (cmp == 0)
            return 0;
        ligands[i + 1] = ligand;
    }
    return (swaps & 0x1) == 0x1 ? -1 : +1;
}","private static int permParity(final ILigand[] ligands){
    int swaps = 0;
    for (int j = 1, hi = ligands.length; j < hi; j++) {
        ILigand ligand = ligands[j];
        int i = j - 1;
        int cmp = 0;
        while ((i >= 0) && (cmp = cipRule.compare(ligand, ligands[i])) > 0) {
            ligands[i + 1] = ligands[i--];
            swaps++;
        }
        if (cmp == 0)
            return 0;
        ligands[i + 1] = ligand;
    }
    return (swaps & 0x1) == 0x1 ? -1 : +1;
}","/**
     * Obtain the permutation parity (-1,0,+1) to put the ligands in descending
     * order (highest first). A parity of 0 indicates two or more ligands were
     * equivalent.
     *
     * @param ligands the ligands to sort
     * @return parity, odd (-1), even (+1) or none (0)
     */","('permParity', {'INSTRUCTION': {'covered': 63, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",137.0,"Obtain the permutation parity (-1,0,+1) to put the ligands in descending  order (highest first).",21.0,"['To put the ligands in descending order, you need the permutation parity.', 'To place the ligands in descending order, you need the permutation parity.', 'To put the ligands in descending order, you have to get the permutation parity.']"
748,metrics,io/dropwizard/metrics5/collectd/PacketWriter.java,/metrics-collectd/src/main/java/io/dropwizard/metrics5/collectd/PacketWriter.java,encryptPacket,170-202,"/**
     * Encrypts the provided packet, so it's can't be eavesdropped during a transfer
     * to a CollectD server. Wire format:
     * <pre>
     * +---------------------------------+-------------------------------+
     * ! Type (0x0210)                   ! Length                        !
     * +---------------------------------+-------------------------------+
     * ! Username length in bytes        ! Username                      \
     * +-----------------------------------------------------------------+
     * ! Initialization Vector (IV)      !                               \
     * +---------------------------------+-------------------------------+
     * ! Encrypted bytes (AES (SHA1(packet) + packet))                   \
     * +---------------------------------+-------------------------------+
     * </pre>
     *
     * @see <a href=""https://collectd.org/wiki/index.php/Binary_protocol#Encrypted_part"">
     * Binary protocol - CollectD | Encrypted part</a>
     */
private ByteBuffer encryptPacket(ByteBuffer packet){
    final ByteBuffer payload = (ByteBuffer) ByteBuffer.allocate(SHA1_LENGTH + packet.remaining()).put(sha1(packet)).put((ByteBuffer) packet.flip()).flip();
    final EncryptionResult er = encrypt(password, payload);
    return (ByteBuffer) ByteBuffer.allocate(BUFFER_SIZE).putShort((short) TYPE_ENCR_AES256).putShort((short) (ENCRYPT_DATA_LEN + username.length + er.output.remaining())).putShort((short) username.length).put(username).put(er.iv).put(er.output).flip();
}","private ByteBuffer encryptPacket(ByteBuffer packet){
    final ByteBuffer payload = (ByteBuffer) ByteBuffer.allocate(SHA1_LENGTH + packet.remaining()).put(sha1(packet)).put((ByteBuffer) packet.flip()).flip();
    final EncryptionResult er = encrypt(password, payload);
    return (ByteBuffer) ByteBuffer.allocate(BUFFER_SIZE).putShort((short) TYPE_ENCR_AES256).putShort((short) (ENCRYPT_DATA_LEN + username.length + er.output.remaining())).putShort((short) username.length).put(username).put(er.iv).put(er.output).flip();
}","/**
     * Encrypts the provided packet, so it's can't be eavesdropped during a transfer
     * to a CollectD server. Wire format:
     * <pre>
     * +---------------------------------+-------------------------------+
     * ! Type (0x0210)                   ! Length                        !
     * +---------------------------------+-------------------------------+
     * ! Username length in bytes        ! Username                      \
     * +-----------------------------------------------------------------+
     * ! Initialization Vector (IV)      !                               \
     * +---------------------------------+-------------------------------+
     * ! Encrypted bytes (AES (SHA1(packet) + packet))                   \
     * +---------------------------------+-------------------------------+
     * </pre>
     *
     * @see <a href=""https://collectd.org/wiki/index.php/Binary_protocol#Encrypted_part"">
     * Binary protocol - CollectD | Encrypted part</a>
     */","('encryptPacket', {'INSTRUCTION': {'covered': 49, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",138.0,"  Encrypts the provided packet, so it's can't be eavesdropped during a transfer  to a CollectD server.",20.0,"[""The packet can't be eavesdropped on during a transfer to a CollectD server."", ""The packet can't be eavesdropped during a transfer to a CollectD server."", ""The provided packet can't be eavesdropped on during a transfer to a CollectD server.""]"
749,tablesaw,tech/tablesaw/joining/DataFrameJoiner.java,/core/src/main/java/tech/tablesaw/joining/DataFrameJoiner.java,withMissingLeftJoin,875-901,"/**
   * Adds rows to destination for each row in table1 with the columns from table2 added as missing
   * values.
   */
private void withMissingLeftJoin(Table destination, Table table1, Selection table1Rows, Set<Integer> ignoreColumns, boolean keepTable2JoinKeyColumns){
    for (int c = 0; c < destination.columnCount(); c++) {
        if (!keepTable2JoinKeyColumns && ignoreColumns.contains(c)) {
            continue;
        }
        if (c < table1.columnCount()) {
            Column t1Col = table1.column(c);
            for (int index : table1Rows) {
                destination.column(c).append(t1Col, index);
            }
        } else {
            for (int r1 = 0; r1 < table1Rows.size(); r1++) {
                destination.column(c).appendMissing();
            }
        }
    }
}","private void withMissingLeftJoin(Table destination, Table table1, Selection table1Rows, Set<Integer> ignoreColumns, boolean keepTable2JoinKeyColumns){
    for (int c = 0; c < destination.columnCount(); c++) {
        if (!keepTable2JoinKeyColumns && ignoreColumns.contains(c)) {
            continue;
        }
        if (c < table1.columnCount()) {
            Column t1Col = table1.column(c);
            for (int index : table1Rows) {
                destination.column(c).append(t1Col, index);
            }
        } else {
            for (int r1 = 0; r1 < table1Rows.size(); r1++) {
                destination.column(c).appendMissing();
            }
        }
    }
}","/**
   * Adds rows to destination for each row in table1 with the columns from table2 added as missing
   * values.
   */","('withMissingLeftJoin', {'INSTRUCTION': {'covered': 58, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",139.0,Adds rows to destination for each row in table1 with the columns from table2 added as missing  values.,19.0,"['The columns from table2 are added as missing values.', 'Adding rows to destination for each row in table1 with columns from table2 added as missing values.', 'Adding rows to destination for each row in table1 with columns from table2 added as missing values']"
750,cdk,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,hydrogenXDodge,543-569,"/**
     * If the hydrogens are position in from of the element we may need to move the hydrogen and
     * hydrogen count labels. This code assesses the positions of the mass, hydrogen, and hydrogen
     * count labels and determines the x-axis adjustment needed for the hydrogen label to dodge a
     * collision.
     *
     * @param hydrogens     number of hydrogens
     * @param mass          atomic mass
     * @param elementLabel  element label outline
     * @param hydrogenLabel hydrogen label outline
     * @param hydrogenCount hydrogen count label outline
     * @param massLabel     the mass label outline
     * @return required adjustment to x-axis
     */
private double hydrogenXDodge(int hydrogens, int mass, TextOutline elementLabel, TextOutline hydrogenLabel, TextOutline hydrogenCount, TextOutline massLabel){
    if (mass < 0 && hydrogens > 1) {
        return (elementLabel.getBounds().getMinX() - padding) - hydrogenCount.getBounds().getMaxX();
    } else if (mass >= 0) {
        if (hydrogens > 1) {
            return (massLabel.getBounds().getMinX() + padding) - hydrogenCount.getBounds().getMaxX();
        } else if (hydrogens > 0) {
            return (massLabel.getBounds().getMinX() - padding) - hydrogenLabel.getBounds().getMaxX();
        }
    }
    return 0;
}","private double hydrogenXDodge(int hydrogens, int mass, TextOutline elementLabel, TextOutline hydrogenLabel, TextOutline hydrogenCount, TextOutline massLabel){
    if (mass < 0 && hydrogens > 1) {
        return (elementLabel.getBounds().getMinX() - padding) - hydrogenCount.getBounds().getMaxX();
    } else if (mass >= 0) {
        if (hydrogens > 1) {
            return (massLabel.getBounds().getMinX() + padding) - hydrogenCount.getBounds().getMaxX();
        } else if (hydrogens > 0) {
            return (massLabel.getBounds().getMinX() - padding) - hydrogenLabel.getBounds().getMaxX();
        }
    }
    return 0;
}","/**
     * If the hydrogens are position in from of the element we may need to move the hydrogen and
     * hydrogen count labels. This code assesses the positions of the mass, hydrogen, and hydrogen
     * count labels and determines the x-axis adjustment needed for the hydrogen label to dodge a
     * collision.
     *
     * @param hydrogens     number of hydrogens
     * @param mass          atomic mass
     * @param elementLabel  element label outline
     * @param hydrogenLabel hydrogen label outline
     * @param hydrogenCount hydrogen count label outline
     * @param massLabel     the mass label outline
     * @return required adjustment to x-axis
     */","('hydrogenXDodge', {'INSTRUCTION': {'covered': 47, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 8, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",140.0,  If the hydrogens are position in from of the element we may need to move the hydrogen and  hydrogen count labels.,22.0,"['The hydrogen and hydrogen count labels may need to be moved if the hydrogens are in the element.', 'We may need to change the hydrogen and hydrogen count labels if the hydrogens are in the element.', 'The hydrogen and hydrogen count labels may need to be moved if the hydrogen is in the element.']"
751,logstash-logback-encoder,net/logstash/logback/appender/WaitStrategyFactory.java,/src/main/java/net/logstash/logback/appender/WaitStrategyFactory.java,findParamEndIndex,192-222,"/**
     * Finds the end character index of the parameter within the paramsString that starts at startIndex.
     *
     * Takes into account nesting of parameters.
     *
     * @param paramsString
     * @param startIndex index within paramsString to start looking
     * @return index at which the parameter string ends (e.g. the next comma, or paramsString length if no comma found)
     *
     * @throws IllegalArgumentException if the parameter is not well formed
     */
private static int findParamEndIndex(String paramsString, int startIndex){
    int nestLevel = 0;
    for (int c = startIndex; c < paramsString.length(); c++) {
        char character = paramsString.charAt(c);
        if (character == PARAM_START_CHAR) {
            nestLevel++;
        } else if (character == PARAM_END_CHAR) {
            nestLevel--;
            if (nestLevel < 0) {
                throw new IllegalArgumentException(String.format(""Unbalanced '}' at character position %d in %s"", c, paramsString));
            }
        } else if (character == PARAM_SEPARATOR_CHAR && nestLevel == 0) {
            return c;
        }
    }
    if (nestLevel != 0) {
        throw new IllegalArgumentException(String.format(""Unbalanced '{' in %s"", paramsString));
    }
    return paramsString.length();
}","private static int findParamEndIndex(String paramsString, int startIndex){
    int nestLevel = 0;
    for (int c = startIndex; c < paramsString.length(); c++) {
        char character = paramsString.charAt(c);
        if (character == PARAM_START_CHAR) {
            nestLevel++;
        } else if (character == PARAM_END_CHAR) {
            nestLevel--;
            if (nestLevel < 0) {
                throw new IllegalArgumentException(String.format(""Unbalanced '}' at character position %d in %s"", c, paramsString));
            }
        } else if (character == PARAM_SEPARATOR_CHAR && nestLevel == 0) {
            return c;
        }
    }
    if (nestLevel != 0) {
        throw new IllegalArgumentException(String.format(""Unbalanced '{' in %s"", paramsString));
    }
    return paramsString.length();
}","/**
     * Finds the end character index of the parameter within the paramsString that starts at startIndex.
     *
     * Takes into account nesting of parameters.
     *
     * @param paramsString
     * @param startIndex index within paramsString to start looking
     * @return index at which the parameter string ends (e.g. the next comma, or paramsString length if no comma found)
     *
     * @throws IllegalArgumentException if the parameter is not well formed
     */","('findParamEndIndex', {'INSTRUCTION': {'covered': 66, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",140.0,  Finds the end character index of the parameter within the paramsString that starts at startIndex.,16.0,"['The end character index of the parameter is found by looking at the startIndex.', 'The end character index of the parameter is found.', 'The end character index of the parameters is found by looking at the startIndex.']"
752,cdk,org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,deltavPhosphorous,219-244,"/**
     * Checks whether the P atom is in a PO environment.
     * 
     * This environment is noted in Kier & Hall (1986), page 20
     *
     * @param atom          The P atom in question
     * @param atomContainer The molecule containing the P atom
     * @return The empirical delta V if present in the above environment,
     *         -1 otherwise
     */
private static double deltavPhosphorous(IAtom atom, IAtomContainer atomContainer){
    if (atom.getAtomicNumber() != IElement.P)
        return -1;
    List<IAtom> connected = atomContainer.getConnectedAtomsList(atom);
    int conditions = 0;
    if (connected.size() == 4)
        conditions++;
    for (IAtom connectedAtom : connected) {
        if (connectedAtom.getAtomicNumber() == IElement.O && atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.DOUBLE)
            conditions++;
        if (atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.SINGLE)
            conditions++;
    }
    if (conditions == 5)
        return 2.22;
    return -1;
}","private static double deltavPhosphorous(IAtom atom, IAtomContainer atomContainer){
    if (atom.getAtomicNumber() != IElement.P)
        return -1;
    List<IAtom> connected = atomContainer.getConnectedAtomsList(atom);
    int conditions = 0;
    if (connected.size() == 4)
        conditions++;
    for (IAtom connectedAtom : connected) {
        if (connectedAtom.getAtomicNumber() == IElement.O && atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.DOUBLE)
            conditions++;
        if (atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.SINGLE)
            conditions++;
    }
    if (conditions == 5)
        return 2.22;
    return -1;
}","/**
     * Checks whether the P atom is in a PO environment.
     * 
     * This environment is noted in Kier & Hall (1986), page 20
     *
     * @param atom          The P atom in question
     * @param atomContainer The molecule containing the P atom
     * @return The empirical delta V if present in the above environment,
     *         -1 otherwise
     */","('deltavPhosphorous', {'INSTRUCTION': {'covered': 53, 'missed': 4}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 10, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",140.0,  Checks whether the P atom is in a PO environment.,11.0,"['The P atom is checked to see if it is in a PO environment.', ""The P atom is checked to see if it's in a PO environment."", 'The P atom is checked out to see if it is in a PO environment.']"
753,tablesaw,tech/tablesaw/analytic/ArgumentList.java,/core/src/main/java/tech/tablesaw/analytic/ArgumentList.java,createEmptyDestinationColumns,74-92,"/** @return an ordered list of new columns this analytic query will generate. */
 List<Column<?>> createEmptyDestinationColumns(int rowCount){
    List<Column<?>> newColumns = new ArrayList<>();
    for (String toColumn : newColumnNames) {
        FunctionCall<? extends FunctionMetaData> functionCall = Stream.of(aggregateFunctions.get(toColumn), numberingFunctions.get(toColumn)).filter(java.util.Objects::nonNull).findFirst().get();
        ColumnType type = functionCall.function.returnType();
        Column<?> resultColumn = type.create(toColumn);
        newColumns.add(resultColumn);
        for (int i = 0; i < rowCount; i++) {
            resultColumn.appendMissing();
        }
    }
    return newColumns;
}","List<Column<?>> createEmptyDestinationColumns(int rowCount){
    List<Column<?>> newColumns = new ArrayList<>();
    for (String toColumn : newColumnNames) {
        FunctionCall<? extends FunctionMetaData> functionCall = Stream.of(aggregateFunctions.get(toColumn), numberingFunctions.get(toColumn)).filter(java.util.Objects::nonNull).findFirst().get();
        ColumnType type = functionCall.function.returnType();
        Column<?> resultColumn = type.create(toColumn);
        newColumns.add(resultColumn);
        for (int i = 0; i < rowCount; i++) {
            resultColumn.appendMissing();
        }
    }
    return newColumns;
}",/** @return an ordered list of new columns this analytic query will generate. */,"('createEmptyDestinationColumns', {'INSTRUCTION': {'covered': 65, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",141.0, @return an ordered list of new columns this analytic query will generate.,14.0,"['An ordered list of new columns will be generated by this analytic query.', 'An ordered list of new columns will be generated by this query.', 'An ordered list of new columns will be generated.']"
754,matsim-libs,org/matsim/contrib/drt/analysis/zonal/DrtGridUtils.java,/contribs/drt/src/main/java/org/matsim/contrib/drt/analysis/zonal/DrtGridUtils.java,createGridFromNetworkWithinServiceArea,75-101,"/**
	 * First creates a grid based on the network bounding box. Then removes all zones that do not intersect the service area.
	 * Result may contain zones that are barely included in the service area. But as passengers may walk into the service area,
	 * it seems appropriate that the DrtZonalSystem, which is used for demand estimation, is larger than the service area.
	 * The {@code cellsize} indirectly determines, how much larger the DrtZonalSystem may get.
	 *
	 * @param network
	 * @param cellsize
	 * @param serviceAreaGeoms geometries that define the service area
	 * @return
	 */
public static Map<String, PreparedGeometry> createGridFromNetworkWithinServiceArea(Network network, double cellsize, List<PreparedGeometry> serviceAreaGeoms){
    Map<String, PreparedGeometry> grid = createGridFromNetwork(network, cellsize);
    log.info(""total number of created grid zones = "" + grid.size());
    log.info(""searching for grid zones within the drt service area..."");
    Counter counter = new Counter(""dealt with zone "");
    Map<String, PreparedGeometry> zonesWithinServiceArea = EntryStream.of(grid).peekKeys(id -> counter.incCounter()).filterValues(cell -> serviceAreaGeoms.stream().anyMatch(serviceArea -> serviceArea.intersects(cell.getGeometry()))).toMap();
    log.info(""number of remaining grid zones = "" + zonesWithinServiceArea.size());
    return zonesWithinServiceArea;
}","public static Map<String, PreparedGeometry> createGridFromNetworkWithinServiceArea(Network network, double cellsize, List<PreparedGeometry> serviceAreaGeoms){
    Map<String, PreparedGeometry> grid = createGridFromNetwork(network, cellsize);
    log.info(""total number of created grid zones = "" + grid.size());
    log.info(""searching for grid zones within the drt service area..."");
    Counter counter = new Counter(""dealt with zone "");
    Map<String, PreparedGeometry> zonesWithinServiceArea = EntryStream.of(grid).peekKeys(id -> counter.incCounter()).filterValues(cell -> serviceAreaGeoms.stream().anyMatch(serviceArea -> serviceArea.intersects(cell.getGeometry()))).toMap();
    log.info(""number of remaining grid zones = "" + zonesWithinServiceArea.size());
    return zonesWithinServiceArea;
}","/**
	 * First creates a grid based on the network bounding box. Then removes all zones that do not intersect the service area.
	 * Result may contain zones that are barely included in the service area. But as passengers may walk into the service area,
	 * it seems appropriate that the DrtZonalSystem, which is used for demand estimation, is larger than the service area.
	 * The {@code cellsize} indirectly determines, how much larger the DrtZonalSystem may get.
	 *
	 * @param network
	 * @param cellsize
	 * @param serviceAreaGeoms geometries that define the service area
	 * @return
	 */","('createGridFromNetworkWithinServiceArea', {'INSTRUCTION': {'covered': 34, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",141.0,  First creates a grid based on the network bounding box.,11.0,"['The network bounding box is used to create a grid.', 'The network bounding box is used to create the grid.', 'The grid is based on the network box.']"
755,cdk,org/openscience/cdk/isomorphism/StateStream.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StateStream.java,map,95-117,"/**
     * Progress the state-machine - the function return false when a mapping is
     * found on the mapping is done.
     *
     * @return the state is partial
     */
private boolean map(){
    if ((n == state.nMax() || m == state.mMax()) && !stack.empty())
        state.remove(n = stack.popN(), m = stack.popM());
    while ((m = state.nextM(n, m)) < state.mMax()) {
        if (state.add(n, m)) {
            stack.push(n, m);
            n = state.nextN(-1);
            m = -1;
            return n < state.nMax();
        }
    }
    return state.size() > 0 || m < state.mMax();
}","private boolean map(){
    if ((n == state.nMax() || m == state.mMax()) && !stack.empty())
        state.remove(n = stack.popN(), m = stack.popM());
    while ((m = state.nextM(n, m)) < state.mMax()) {
        if (state.add(n, m)) {
            stack.push(n, m);
            n = state.nextN(-1);
            m = -1;
            return n < state.nMax();
        }
    }
    return state.size() > 0 || m < state.mMax();
}","/**
     * Progress the state-machine - the function return false when a mapping is
     * found on the mapping is done.
     *
     * @return the state is partial
     */","('map', {'INSTRUCTION': {'covered': 93, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",141.0,  Progress the state-machine - the function return false when a mapping is  found on the mapping is done.,19.0,"['When a mapping is done, the function return false.', 'When a mapping is done, the function will return false.', 'When a mapping is done, the state-machine function returns false.']"
756,dataverse,edu/harvard/iq/dataverse/ingest/tabulardata/impl/plugins/csv/CSVFileReader.java,/src/main/java/edu/harvard/iq/dataverse/ingest/tabulardata/impl/plugins/csv/CSVFileReader.java,read,105-137,"/**
     * Reads a CSV file, converts it into a dataverse DataTable.
     *
     * @param stream a <code>BufferedInputStream</code>.
     * @return an <code>TabularDataIngest</code> object
     * @throws java.io.IOException if a reading error occurs.
     */
public TabularDataIngest read(BufferedInputStream stream, File dataFile) throws IOException{
    init();
    if (stream == null) {
        throw new IOException(BundleUtil.getStringFromBundle(""ingest.csv.nullStream""));
    }
    TabularDataIngest ingesteddata = new TabularDataIngest();
    DataTable dataTable = new DataTable();
    BufferedReader localBufferedReader = new BufferedReader(new InputStreamReader(stream));
    File tabFileDestination = File.createTempFile(""data-"", "".tab"");
    PrintWriter tabFileWriter = new PrintWriter(tabFileDestination.getAbsolutePath());
    int lineCount = readFile(localBufferedReader, dataTable, tabFileWriter);
    logger.fine(""Tab file produced: "" + tabFileDestination.getAbsolutePath());
    dataTable.setUnf(""UNF:6:NOTCALCULATED"");
    ingesteddata.setTabDelimitedFile(tabFileDestination);
    ingesteddata.setDataTable(dataTable);
    return ingesteddata;
}","public TabularDataIngest read(BufferedInputStream stream, File dataFile) throws IOException{
    init();
    if (stream == null) {
        throw new IOException(BundleUtil.getStringFromBundle(""ingest.csv.nullStream""));
    }
    TabularDataIngest ingesteddata = new TabularDataIngest();
    DataTable dataTable = new DataTable();
    BufferedReader localBufferedReader = new BufferedReader(new InputStreamReader(stream));
    File tabFileDestination = File.createTempFile(""data-"", "".tab"");
    PrintWriter tabFileWriter = new PrintWriter(tabFileDestination.getAbsolutePath());
    int lineCount = readFile(localBufferedReader, dataTable, tabFileWriter);
    logger.fine(""Tab file produced: "" + tabFileDestination.getAbsolutePath());
    dataTable.setUnf(""UNF:6:NOTCALCULATED"");
    ingesteddata.setTabDelimitedFile(tabFileDestination);
    ingesteddata.setDataTable(dataTable);
    return ingesteddata;
}","/**
     * Reads a CSV file, converts it into a dataverse DataTable.
     *
     * @param stream a <code>BufferedInputStream</code>.
     * @return an <code>TabularDataIngest</code> object
     * @throws java.io.IOException if a reading error occurs.
     */","('read', {'INSTRUCTION': {'covered': 58, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",141.0,"  Reads a CSV file, converts it into a dataverse DataTable.",12.0,"['A person reads a file and converts it into a data table.', 'A person reads a file and converts it into a table.', 'A person reads a file and converts it to a data table.']"
757,acs-aem-commons,com/adobe/acs/commons/wcm/vanity/impl/VanityURLServiceImpl.java,/bundle/src/main/java/com/adobe/acs/commons/wcm/vanity/impl/VanityURLServiceImpl.java,isVanityPath,108-135,"/**
     * Checks if the provided vanity path is a valid redirect
     *
     * @param pathScope  The content path to scope the vanity path too.
     * @param vanityPath Vanity path that needs to be validated.
     * @param request    SlingHttpServletRequest object used for performing query/lookup
     * @return return true if the vanityPath is a registered sling:vanityPath under /content
     */
protected boolean isVanityPath(String pathScope, String vanityPath, SlingHttpServletRequest request) throws RepositoryException{
    final Resource vanityResource = request.getResourceResolver().resolve(vanityPath);
    if (vanityResource != null) {
        String targetPath = null;
        if (vanityResource.isResourceType(""sling:redirect"")) {
            targetPath = vanityResource.getValueMap().get(""sling:target"", String.class);
        } else if (!StringUtils.equals(vanityPath, vanityResource.getPath())) {
            targetPath = vanityResource.getPath();
        }
        if (targetPath != null && StringUtils.startsWith(targetPath, StringUtils.defaultIfEmpty(pathScope, DEFAULT_PATH_SCOPE))) {
            log.debug(""Found vanity resource at [ {} ] for sling:vanityPath [ {} ]"", targetPath, vanityPath);
            return true;
        }
    }
    return false;
}","protected boolean isVanityPath(String pathScope, String vanityPath, SlingHttpServletRequest request) throws RepositoryException{
    final Resource vanityResource = request.getResourceResolver().resolve(vanityPath);
    if (vanityResource != null) {
        String targetPath = null;
        if (vanityResource.isResourceType(""sling:redirect"")) {
            targetPath = vanityResource.getValueMap().get(""sling:target"", String.class);
        } else if (!StringUtils.equals(vanityPath, vanityResource.getPath())) {
            targetPath = vanityResource.getPath();
        }
        if (targetPath != null && StringUtils.startsWith(targetPath, StringUtils.defaultIfEmpty(pathScope, DEFAULT_PATH_SCOPE))) {
            log.debug(""Found vanity resource at [ {} ] for sling:vanityPath [ {} ]"", targetPath, vanityPath);
            return true;
        }
    }
    return false;
}","/**
     * Checks if the provided vanity path is a valid redirect
     *
     * @param pathScope  The content path to scope the vanity path too.
     * @param vanityPath Vanity path that needs to be validated.
     * @param request    SlingHttpServletRequest object used for performing query/lookup
     * @return return true if the vanityPath is a registered sling:vanityPath under /content
     */","('isVanityPath', {'INSTRUCTION': {'covered': 43, 'missed': 3}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 10, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",141.0,  Checks if the provided vanity path is a valid redirect   @param pathScope The content path to scope the vanity path too.,23.0,"['The content path to scope the vanity path is checked.', 'The content path to scope the vanity path is checked as well.', 'The content path to scope the vanity path is checked if the provided path is valid.']"
758,cdk,org/openscience/cdk/smiles/FixBondOrdersTool.java,/legacy/src/main/java/org/openscience/cdk/smiles/FixBondOrdersTool.java,removeExtraRings,233-261,"/**
     * Removes rings which do not have all sp2/planar3 aromatic atoms.
     * and also gets rid of rings that have more than 8 atoms in them.
     *
     * @param m The {@link IAtomContainer} from which we want to remove rings
     * @return The set of reduced rings
     */
private IRingSet removeExtraRings(IAtomContainer m) throws Exception{
    IRingSet rs = Cycles.sssr(m).toRingSet();
    Iterator<IAtomContainer> i = rs.atomContainers().iterator();
    while (i.hasNext()) {
        IRing r = (IRing) i.next();
        if (r.getAtomCount() > 8) {
            i.remove();
        } else {
            for (IAtom a : r.atoms()) {
                Hybridization h = a.getHybridization();
                if (h == CDKConstants.UNSET || !(h == Hybridization.SP2 || h == Hybridization.PLANAR3)) {
                    i.remove();
                    break;
                }
            }
        }
    }
    return rs;
}","private IRingSet removeExtraRings(IAtomContainer m) throws Exception{
    IRingSet rs = Cycles.sssr(m).toRingSet();
    Iterator<IAtomContainer> i = rs.atomContainers().iterator();
    while (i.hasNext()) {
        IRing r = (IRing) i.next();
        if (r.getAtomCount() > 8) {
            i.remove();
        } else {
            for (IAtom a : r.atoms()) {
                Hybridization h = a.getHybridization();
                if (h == CDKConstants.UNSET || !(h == Hybridization.SP2 || h == Hybridization.PLANAR3)) {
                    i.remove();
                    break;
                }
            }
        }
    }
    return rs;
}","/**
     * Removes rings which do not have all sp2/planar3 aromatic atoms.
     * and also gets rid of rings that have more than 8 atoms in them.
     *
     * @param m The {@link IAtomContainer} from which we want to remove rings
     * @return The set of reduced rings
     */","('removeExtraRings', {'INSTRUCTION': {'covered': 49, 'missed': 3}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 13, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",142.0,Removes rings which do not have all sp2/planar3 aromatic atoms.,11.0,"['The rings do not have all the aromatic atoms.', ""Removes rings that don't have all the aromatic atoms."", 'The rings do not have all the aromatic atoms that sp2/planar3 does.']"
759,weblogic-kubernetes-operator,oracle/kubernetes/json/SchemaGenerator.java,/json-schema-generator/src/main/java/oracle/kubernetes/json/SchemaGenerator.java,generate,167-191,"/**
   * Generates an object representing a JSON schema for the specified class.
   *
   * @param someClass the class for which the schema should be generated
   * @return a map of maps, representing the computed JSON
   */
public Map<String, Object> generate(Class<?> someClass){
    Map<String, Object> result = new HashMap<>();
    if (includeSchemaReference) {
        result.put(""$schema"", JSON_SCHEMA_REFERENCE);
    }
    generateObjectTypeIn(result, someClass);
    if (!definedObjects.isEmpty()) {
        Map<String, Object> definitions = new TreeMap<>();
        result.put(""definitions"", definitions);
        for (Class<?> type : definedObjects.keySet()) {
            if (!definedObjects.get(type).equals(EXTERNAL_CLASS)) {
                definitions.put(getDefinitionKey(type), definedObjects.get(type));
            }
        }
    }
    return result;
}","public Map<String, Object> generate(Class<?> someClass){
    Map<String, Object> result = new HashMap<>();
    if (includeSchemaReference) {
        result.put(""$schema"", JSON_SCHEMA_REFERENCE);
    }
    generateObjectTypeIn(result, someClass);
    if (!definedObjects.isEmpty()) {
        Map<String, Object> definitions = new TreeMap<>();
        result.put(""definitions"", definitions);
        for (Class<?> type : definedObjects.keySet()) {
            if (!definedObjects.get(type).equals(EXTERNAL_CLASS)) {
                definitions.put(getDefinitionKey(type), definedObjects.get(type));
            }
        }
    }
    return result;
}","/**
   * Generates an object representing a JSON schema for the specified class.
   *
   * @param someClass the class for which the schema should be generated
   * @return a map of maps, representing the computed JSON
   */","('generate', {'INSTRUCTION': {'covered': 61, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",142.0,  Generates an object representing a JSON schema for the specified class.,12.0,"['An object is generated for a specified class.', 'An object is generated for a class.', 'An object is generated for the class.']"
760,acs-aem-commons,com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/impl/RefetchFlushContentBuilderImpl.java,checkValidity,274-299,"/**
     * Check the validity of the parameters received for this activation.
     *
     * @param action The replication action specifying properties of the activation.
     * @param path The path to the item to be activated.
     * @throws ReplicationException Throws a replication exception if invalid.
     */
private void checkValidity(ReplicationAction action, String path) throws ReplicationException{
    if (action.getType() != ReplicationActionType.ACTIVATE && action.getType() != ReplicationActionType.TEST) {
        logErrorMessage(""No re-fetch handling for replication action "" + action.getType().getName());
        throw new ReplicationException(""No re-fetch handling for replication action "" + action.getType().getName());
    }
    if (StringUtils.isEmpty(path)) {
        logErrorMessage(""No path found for re-fetch replication."");
        throw new ReplicationException(""No path found for re-fetch replication."");
    }
    if (!CONTENT_BUILDER_NAME.equals(action.getConfig().getSerializationType())) {
        String message = ""Serialization type '"" + action.getConfig().getSerializationType() + ""' not supported by Flush Re-Fetch Content Builder."";
        logErrorMessage(message);
        throw new ReplicationException(message);
    }
}","private void checkValidity(ReplicationAction action, String path) throws ReplicationException{
    if (action.getType() != ReplicationActionType.ACTIVATE && action.getType() != ReplicationActionType.TEST) {
        logErrorMessage(""No re-fetch handling for replication action "" + action.getType().getName());
        throw new ReplicationException(""No re-fetch handling for replication action "" + action.getType().getName());
    }
    if (StringUtils.isEmpty(path)) {
        logErrorMessage(""No path found for re-fetch replication."");
        throw new ReplicationException(""No path found for re-fetch replication."");
    }
    if (!CONTENT_BUILDER_NAME.equals(action.getConfig().getSerializationType())) {
        String message = ""Serialization type '"" + action.getConfig().getSerializationType() + ""' not supported by Flush Re-Fetch Content Builder."";
        logErrorMessage(message);
        throw new ReplicationException(message);
    }
}","/**
     * Check the validity of the parameters received for this activation.
     *
     * @param action The replication action specifying properties of the activation.
     * @param path The path to the item to be activated.
     * @throws ReplicationException Throws a replication exception if invalid.
     */","('checkValidity', {'INSTRUCTION': {'covered': 73, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",142.0,  Check the validity of the parameters received for this activation.,11.0,"['Check the validity of the parameters received.', 'Check the validity of the parameters that were received.', 'Check the validity of the parameters that were sent.']"
762,glowstone,net/glowstone/entity/GlowPlayer.java,/src/main/java/net/glowstone/entity/GlowPlayer.java,findSafeSpawnLocation,633-663,"/**
     * Find a a Location obove or below the specified Location, which is on ground.
     *
     * <p>The returned Location will be at the center of the block, X and Y wise.
     *
     * @param spawn The Location a safe spawn position should be found at.
     * @return The location to spawn the player at.
     */
private static Location findSafeSpawnLocation(Location spawn){
    World world = spawn.getWorld();
    int blockX = spawn.getBlockX();
    int blockY = spawn.getBlockY();
    int blockZ = spawn.getBlockZ();
    int highestY = world.getHighestBlockYAt(blockX, blockZ);
    int y = blockY;
    boolean wasPreviousSafe = false;
    for (; y <= highestY; y++) {
        Material type = world.getBlockAt(blockX, y, blockZ).getType();
        boolean safe = Material.AIR.equals(type);
        if (wasPreviousSafe && safe) {
            y--;
            break;
        }
        wasPreviousSafe = safe;
    }
    return new Location(world, blockX + 0.5, y, blockZ + 0.5);
}","private static Location findSafeSpawnLocation(Location spawn){
    World world = spawn.getWorld();
    int blockX = spawn.getBlockX();
    int blockY = spawn.getBlockY();
    int blockZ = spawn.getBlockZ();
    int highestY = world.getHighestBlockYAt(blockX, blockZ);
    int y = blockY;
    boolean wasPreviousSafe = false;
    for (; y <= highestY; y++) {
        Material type = world.getBlockAt(blockX, y, blockZ).getType();
        boolean safe = Material.AIR.equals(type);
        if (wasPreviousSafe && safe) {
            y--;
            break;
        }
        wasPreviousSafe = safe;
    }
    return new Location(world, blockX + 0.5, y, blockZ + 0.5);
}","/**
     * Find a a Location obove or below the specified Location, which is on ground.
     *
     * <p>The returned Location will be at the center of the block, X and Y wise.
     *
     * @param spawn The Location a safe spawn position should be found at.
     * @return The location to spawn the player at.
     */","('findSafeSpawnLocation', {'INSTRUCTION': {'covered': 56, 'missed': 4}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 13, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",144.0,"  Find a a Location obove or below the specified Location, which is on ground.",16.0,"['The location is on the ground.', 'You can find a location on the ground.', 'You can find a location below the specified location.']"
763,cron-utils,com/cronutils/model/time/generator/OnDayOfWeekValueGenerator.java,/src/main/java/com/cronutils/model/time/generator/OnDayOfWeekValueGenerator.java,generateNoneValues,124-161,"/**
     * Generate valid days of the month for the days of week expression. This method requires that you
     * pass it a -1 for the reference value when starting to generate a sequence of day values. That allows
     * it to handle the special case of which day of the month is the initial matching value.
     *
     * @param on        The expression object giving us the particular day of week we need.
     * @param year      The year for the calculation.
     * @param month     The month for the calculation.
     * @param reference This value must either be -1 indicating you are starting the sequence generation or an actual
     *                  day of month that meets the day of week criteria. So a value previously returned by this method.
     * @return
     */
private int generateNoneValues(final On on, final int year, final int month, final int reference){
    // the day of week the first of the month is on
    // 1-7
    final int dowForFirstDoM = LocalDate.of(year, month, 1).getDayOfWeek().getValue();
    // the day of week we need, normalize to jdk8time
    final int requiredDoW = ConstantsMapper.weekDayMapping(mondayDoWValue, ConstantsMapper.JAVA8, on.getTime().getValue());
    // the first day of the month
    // day 1 from given month
    int baseDay = 1;
    // the difference between the days of week
    final int diff = dowForFirstDoM - requiredDoW;
    // //base day remains the same if diff is zero
    if (diff < 0) {
        baseDay = baseDay + Math.abs(diff);
    }
    if (diff > 0) {
        baseDay = baseDay + 7 - diff;
    }
    // if baseDay is greater than the reference, we are returning the initial matching day value
    // Fix issue #92
    if (reference < 1) {
        return baseDay;
    }
    while (baseDay <= reference) {
        baseDay += 7;
    }
    return baseDay;
}","private int generateNoneValues(final On on, final int year, final int month, final int reference){
    // the day of week the first of the month is on
    // 1-7
    final int dowForFirstDoM = LocalDate.of(year, month, 1).getDayOfWeek().getValue();
    // the day of week we need, normalize to jdk8time
    final int requiredDoW = ConstantsMapper.weekDayMapping(mondayDoWValue, ConstantsMapper.JAVA8, on.getTime().getValue());
    // the first day of the month
    // day 1 from given month
    int baseDay = 1;
    // the difference between the days of week
    final int diff = dowForFirstDoM - requiredDoW;
    // //base day remains the same if diff is zero
    if (diff < 0) {
        baseDay = baseDay + Math.abs(diff);
    }
    if (diff > 0) {
        baseDay = baseDay + 7 - diff;
    }
    // if baseDay is greater than the reference, we are returning the initial matching day value
    // Fix issue #92
    if (reference < 1) {
        return baseDay;
    }
    while (baseDay <= reference) {
        baseDay += 7;
    }
    return baseDay;
}","/**
     * Generate valid days of the month for the days of week expression. This method requires that you
     * pass it a -1 for the reference value when starting to generate a sequence of day values. That allows
     * it to handle the special case of which day of the month is the initial matching value.
     *
     * @param on        The expression object giving us the particular day of week we need.
     * @param year      The year for the calculation.
     * @param month     The month for the calculation.
     * @param reference This value must either be -1 indicating you are starting the sequence generation or an actual
     *                  day of month that meets the day of week criteria. So a value previously returned by this method.
     * @return
     */","('generateNoneValues', {'INSTRUCTION': {'covered': 49, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",144.0,  Generate valid days of the month for the days of week expression.,13.0,"['For the days of week expression, generate valid days of the month.', 'For the days of week expression, you can generate valid days of the month.', 'For the days of week expression you can generate valid days of the month.']"
764,cdk,org/openscience/cdk/qsar/descriptors/atomic/ProtonAffinityHOSEDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/ProtonAffinityHOSEDescriptor.java,extractInfo,307-328,"/**
     * Extract the information from a line which contains HOSE_ID & energy.
     *
     * @param str  String with the information
     * @return     List with String = HOSECode and String = energy
     */
private static List<String> extractInfo(String str){
    int beg = 0;
    int end = 0;
    int len = str.length();
    List<String> parts = new ArrayList<>();
    while (end < len && !Character.isSpaceChar(str.charAt(end))) end++;
    parts.add(str.substring(beg, end));
    while (end < len && Character.isSpaceChar(str.charAt(end))) end++;
    beg = end;
    while (end < len && !Character.isSpaceChar(str.charAt(end))) end++;
    parts.add(str.substring(beg, end));
    return parts;
}","private static List<String> extractInfo(String str){
    int beg = 0;
    int end = 0;
    int len = str.length();
    List<String> parts = new ArrayList<>();
    while (end < len && !Character.isSpaceChar(str.charAt(end))) end++;
    parts.add(str.substring(beg, end));
    while (end < len && Character.isSpaceChar(str.charAt(end))) end++;
    beg = end;
    while (end < len && !Character.isSpaceChar(str.charAt(end))) end++;
    parts.add(str.substring(beg, end));
    return parts;
}","/**
     * Extract the information from a line which contains HOSE_ID & energy.
     *
     * @param str  String with the information
     * @return     List with String = HOSECode and String = energy
     */","('extractInfo', {'INSTRUCTION': {'covered': 59, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",145.0,  Extract the information from a line which contains HOSE_ID & energy.,12.0,"['The line contains HOSE_ID and energy.', 'The information is contained in a line.', 'The information can be found in a line with HOSE_ID.']"
765,lettuce-core,io/lettuce/core/AbstractRedisClient.java,/src/main/java/io/lettuce/core/AbstractRedisClient.java,initializeChannelAsync,346-377,"/**
     * Connect and initialize a channel from {@link ConnectionBuilder}.
     *
     * @param connectionBuilder must not be {@code null}.
     * @return the {@link ConnectionFuture} to synchronize the connection process.
     * @since 4.4
     */
protected ConnectionFuture<T> initializeChannelAsync(ConnectionBuilder connectionBuilder){
    Mono<SocketAddress> socketAddressSupplier = connectionBuilder.socketAddress();
    if (clientResources.eventExecutorGroup().isShuttingDown()) {
        throw new IllegalStateException(""Cannot connect, Event executor group is terminated."");
    }
    CompletableFuture<SocketAddress> socketAddressFuture = new CompletableFuture<>();
    CompletableFuture<Channel> channelReadyFuture = new CompletableFuture<>();
    socketAddressSupplier.doOnError(socketAddressFuture::completeExceptionally).doOnNext(socketAddressFuture::complete).subscribe(redisAddress -> {
        if (channelReadyFuture.isCancelled()) {
            return;
        }
        initializeChannelAsync0(connectionBuilder, channelReadyFuture, redisAddress);
    }, channelReadyFuture::completeExceptionally);
    return new DefaultConnectionFuture<>(socketAddressFuture, channelReadyFuture.thenApply(channel -> (T) connectionBuilder.connection()));
}","protected ConnectionFuture<T> initializeChannelAsync(ConnectionBuilder connectionBuilder){
    Mono<SocketAddress> socketAddressSupplier = connectionBuilder.socketAddress();
    if (clientResources.eventExecutorGroup().isShuttingDown()) {
        throw new IllegalStateException(""Cannot connect, Event executor group is terminated."");
    }
    CompletableFuture<SocketAddress> socketAddressFuture = new CompletableFuture<>();
    CompletableFuture<Channel> channelReadyFuture = new CompletableFuture<>();
    socketAddressSupplier.doOnError(socketAddressFuture::completeExceptionally).doOnNext(socketAddressFuture::complete).subscribe(redisAddress -> {
        if (channelReadyFuture.isCancelled()) {
            return;
        }
        initializeChannelAsync0(connectionBuilder, channelReadyFuture, redisAddress);
    }, channelReadyFuture::completeExceptionally);
    return new DefaultConnectionFuture<>(socketAddressFuture, channelReadyFuture.thenApply(channel -> (T) connectionBuilder.connection()));
}","/**
     * Connect and initialize a channel from {@link ConnectionBuilder}.
     *
     * @param connectionBuilder must not be {@code null}.
     * @return the {@link ConnectionFuture} to synchronize the connection process.
     * @since 4.4
     */","('initializeChannelAsync', {'INSTRUCTION': {'covered': 49, 'missed': 5}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 9, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",145.0,  Connect and initialize a channel from {@link ConnectionBuilder}.,12.0,"['Establish a channel from @link ConnectionBuilder.', 'Establish a channel from the @link ConnectionBuilder.', 'Establish a channel from @link ConnectionBuilder']"
766,cdk,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,priority,1009-1031,"/**
     * Obtain a prioritised array where the indices 0 to n which correspond to
     * the provided {@code atoms}.
     *
     * @param focus focus of the tetrahedral atom
     * @param atoms the atom
     * @param n     number of atoms
     * @return prioritised indices
     */
private int[] priority(int focus, IAtom[] atoms, int n){
    int[] rank = new int[n];
    for (int i = 0; i < n; i++) rank[i] = i;
    for (int j = 1; j < n; j++) {
        int v = rank[j];
        int i = j - 1;
        while ((i >= 0) && hasPriority(focus, atomToIndex.get(atoms[v]), atomToIndex.get(atoms[rank[i]]))) {
            rank[i + 1] = rank[i--];
        }
        rank[i + 1] = v;
    }
    return rank;
}","private int[] priority(int focus, IAtom[] atoms, int n){
    int[] rank = new int[n];
    for (int i = 0; i < n; i++) rank[i] = i;
    for (int j = 1; j < n; j++) {
        int v = rank[j];
        int i = j - 1;
        while ((i >= 0) && hasPriority(focus, atomToIndex.get(atoms[v]), atomToIndex.get(atoms[rank[i]]))) {
            rank[i + 1] = rank[i--];
        }
        rank[i + 1] = v;
    }
    return rank;
}","/**
     * Obtain a prioritised array where the indices 0 to n which correspond to
     * the provided {@code atoms}.
     *
     * @param focus focus of the tetrahedral atom
     * @param atoms the atom
     * @param n     number of atoms
     * @return prioritised indices
     */","('priority', {'INSTRUCTION': {'covered': 71, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",145.0,Obtain a prioritised array where the indices 0 to n which correspond to  the provided {@code atoms}.,21.0,"['Obtain a prioritised array where the indices 0 to n correspond to the provided code atoms.', 'Obtain a prioritised array where the indices 0 to n correspond to the code atoms.', 'Obtain a prioritised array where the @code atoms correspond to the indices.']"
767,dcache,org/dcache/auth/LoAs.java,/modules/common/src/main/java/org/dcache/auth/LoAs.java,withImpliedLoA,68-94,"/**
     * Convert a set of asserted LoAs so it includes all equivalent LoAs.
     *
     * @param entity   the kind of identity asserted, if known.
     * @param asserted a collection of LoA asserted by some external agent.
     * @return all LoAs for this identity.
     */
public static EnumSet<LoA> withImpliedLoA(Optional<EntityDefinition> entity, Collection<LoA> asserted){
    Map<LoA, LoA> mapping = entity.filter(PERSON::equals).map(e -> PERSONAL_EQUIVALENT_LOA).orElse(GENERIC_EQUIVALENT_LOA);
    EnumSet<LoA> result = EnumSet.copyOf(asserted);
    Collection<LoA> considered = asserted;
    do {
        EnumSet<LoA> additional = considered.stream().map(mapping::get).filter(Objects::nonNull).collect(Collectors.toCollection(() -> EnumSet.noneOf(LoA.class)));
        result.addAll(additional);
        considered = additional;
    } while (!considered.isEmpty());
    return result;
}","public static EnumSet<LoA> withImpliedLoA(Optional<EntityDefinition> entity, Collection<LoA> asserted){
    Map<LoA, LoA> mapping = entity.filter(PERSON::equals).map(e -> PERSONAL_EQUIVALENT_LOA).orElse(GENERIC_EQUIVALENT_LOA);
    EnumSet<LoA> result = EnumSet.copyOf(asserted);
    Collection<LoA> considered = asserted;
    do {
        EnumSet<LoA> additional = considered.stream().map(mapping::get).filter(Objects::nonNull).collect(Collectors.toCollection(() -> EnumSet.noneOf(LoA.class)));
        result.addAll(additional);
        considered = additional;
    } while (!considered.isEmpty());
    return result;
}","/**
     * Convert a set of asserted LoAs so it includes all equivalent LoAs.
     *
     * @param entity   the kind of identity asserted, if known.
     * @param asserted a collection of LoA asserted by some external agent.
     * @return all LoAs for this identity.
     */","('withImpliedLoA', {'INSTRUCTION': {'covered': 44, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",145.0,  Convert a set of asserted LoAs so it includes all equivalent LoAs.,13.0,"['If you convert a set of asserted loAs, it will include all equivalent loAs.', 'If you convert a set of asserted loAs, it will include all of them.', 'If you convert a set of asserted loAs, it will include all of the equivalent loAs.']"
768,cdk,org/openscience/cdk/io/MDLV3000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV3000Writer.java,pushHydrogensToBack,478-508,"/**
     * CTfile specification is ambiguous as to how parity values should be written
     * for implicit hydrogens. Old applications (Symyx Draw) seem to push any
     * hydrogen to (implied) the last position but newer applications
     * (Accelrys/BioVia Draw) only do so for implicit hydrogens (makes more sense).
     * 
     * To avoid the ambiguity for those who read 0D stereo (bad anyways) we
     * actually do push all hydrogens atoms to the back of the atom list giving
     * them highest value (4) when writing parity values.
     *
     * @param mol       molecule
     * @param atomToIdx mapping that will be filled with the output index
     * @return the output order of atoms
     */
private IAtom[] pushHydrogensToBack(IAtomContainer mol, Map<IChemObject, Integer> atomToIdx){
    assert atomToIdx.isEmpty();
    IAtom[] atoms = new IAtom[mol.getAtomCount()];
    for (IAtom atom : mol.atoms()) {
        if (atom.getAtomicNumber() == 1)
            continue;
        atoms[atomToIdx.size()] = atom;
        atomToIdx.put(atom, atomToIdx.size() + 1);
    }
    for (IAtom atom : mol.atoms()) {
        if (atom.getAtomicNumber() != 1)
            continue;
        atoms[atomToIdx.size()] = atom;
        atomToIdx.put(atom, atomToIdx.size() + 1);
    }
    return atoms;
}","private IAtom[] pushHydrogensToBack(IAtomContainer mol, Map<IChemObject, Integer> atomToIdx){
    assert atomToIdx.isEmpty();
    IAtom[] atoms = new IAtom[mol.getAtomCount()];
    for (IAtom atom : mol.atoms()) {
        if (atom.getAtomicNumber() == 1)
            continue;
        atoms[atomToIdx.size()] = atom;
        atomToIdx.put(atom, atomToIdx.size() + 1);
    }
    for (IAtom atom : mol.atoms()) {
        if (atom.getAtomicNumber() != 1)
            continue;
        atoms[atomToIdx.size()] = atom;
        atomToIdx.put(atom, atomToIdx.size() + 1);
    }
    return atoms;
}","/**
     * CTfile specification is ambiguous as to how parity values should be written
     * for implicit hydrogens. Old applications (Symyx Draw) seem to push any
     * hydrogen to (implied) the last position but newer applications
     * (Accelrys/BioVia Draw) only do so for implicit hydrogens (makes more sense).
     * 
     * To avoid the ambiguity for those who read 0D stereo (bad anyways) we
     * actually do push all hydrogens atoms to the back of the atom list giving
     * them highest value (4) when writing parity values.
     *
     * @param mol       molecule
     * @param atomToIdx mapping that will be filled with the output index
     * @return the output order of atoms
     */","('pushHydrogensToBack', {'INSTRUCTION': {'covered': 75, 'missed': 4}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",146.0,  CTfile specification is ambiguous as to how parity values should be written  for implicit hydrogens.,16.0,"['There is no clear way to write parity values for implicit hydrogens.', 'There is no clear idea as to how parity values should be written.', 'There is no clear idea of how parity values should be written.']"
769,cdk,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,compare,1256-1283,"/**
     * Compare two IMolecularFormula looking at type and number of IIsotope and
     * charge of the formula.
     *
     * @param formula1   The first IMolecularFormula
     * @param formula2   The second IMolecularFormula
     * @return           True, if the both IMolecularFormula are the same
     */
public static boolean compare(IMolecularFormula formula1, IMolecularFormula formula2){
    if (!Objects.equals(formula1.getCharge(), formula2.getCharge()))
        return false;
    if (formula1.getIsotopeCount() != formula2.getIsotopeCount())
        return false;
    for (IIsotope isotope : formula1.isotopes()) {
        if (!formula2.contains(isotope))
            return false;
        if (formula1.getIsotopeCount(isotope) != formula2.getIsotopeCount(isotope))
            return false;
    }
    for (IIsotope isotope : formula2.isotopes()) {
        if (!formula1.contains(isotope))
            return false;
        if (formula2.getIsotopeCount(isotope) != formula1.getIsotopeCount(isotope))
            return false;
    }
    return true;
}","public static boolean compare(IMolecularFormula formula1, IMolecularFormula formula2){
    if (!Objects.equals(formula1.getCharge(), formula2.getCharge()))
        return false;
    if (formula1.getIsotopeCount() != formula2.getIsotopeCount())
        return false;
    for (IIsotope isotope : formula1.isotopes()) {
        if (!formula2.contains(isotope))
            return false;
        if (formula1.getIsotopeCount(isotope) != formula2.getIsotopeCount(isotope))
            return false;
    }
    for (IIsotope isotope : formula2.isotopes()) {
        if (!formula1.contains(isotope))
            return false;
        if (formula2.getIsotopeCount(isotope) != formula1.getIsotopeCount(isotope))
            return false;
    }
    return true;
}","/**
     * Compare two IMolecularFormula looking at type and number of IIsotope and
     * charge of the formula.
     *
     * @param formula1   The first IMolecularFormula
     * @param formula2   The second IMolecularFormula
     * @return           True, if the both IMolecularFormula are the same
     */","('compare', {'INSTRUCTION': {'covered': 67, 'missed': 4}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",146.0,  Compare two IMolecularFormula looking at type and number of IIsotope and  charge of the formula.,16.0,"['The type and number of IIsotope are compared with the charge of the formula.', 'Two IMolecularFormula are looking at type and number of IIsotope.', 'The type and number of IIsotope and charge of the formula are compared.']"
770,mybatis-3,org/apache/ibatis/io/ResolverUtil.java,/src/main/java/org/apache/ibatis/io/ResolverUtil.java,addIfMatching,274-298,"/**
   * Add the class designated by the fully qualified class name provided to the set of
   * resolved classes if and only if it is approved by the Test supplied.
   *
   * @param test the test used to determine if the class matches
   * @param fqn the fully qualified name of a class
   */
protected void addIfMatching(Test test, String fqn){
    try {
        String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');
        ClassLoader loader = getClassLoader();
        if (log.isDebugEnabled()) {
            log.debug(""Checking to see if class "" + externalName + "" matches criteria ["" + test + ""]"");
        }
        Class<?> type = loader.loadClass(externalName);
        if (test.matches(type)) {
            matches.add((Class<T>) type);
        }
    } catch (Throwable t) {
        log.warn(""Could not examine class '"" + fqn + ""'"" + "" due to a "" + t.getClass().getName() + "" with message: "" + t.getMessage());
    }
}","protected void addIfMatching(Test test, String fqn){
    try {
        String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');
        ClassLoader loader = getClassLoader();
        if (log.isDebugEnabled()) {
            log.debug(""Checking to see if class "" + externalName + "" matches criteria ["" + test + ""]"");
        }
        Class<?> type = loader.loadClass(externalName);
        if (test.matches(type)) {
            matches.add((Class<T>) type);
        }
    } catch (Throwable t) {
        log.warn(""Could not examine class '"" + fqn + ""'"" + "" due to a "" + t.getClass().getName() + "" with message: "" + t.getMessage());
    }
}","/**
   * Add the class designated by the fully qualified class name provided to the set of
   * resolved classes if and only if it is approved by the Test supplied.
   *
   * @param test the test used to determine if the class matches
   * @param fqn the fully qualified name of a class
   */","('addIfMatching', {'INSTRUCTION': {'covered': 53, 'missed': 16}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 11, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",146.0,  Add the class designated by the fully qualified class name provided to the set of  resolved classes if and only if it is approved by the Test supplied.,29.0,"['If the class is approved by the test, add it to the set of resolved classes.', 'If the class is approved by the test, you can add it to the set of resolved classes.', 'If the class is approved by the test, add it to the resolved classes.']"
771,cdk,org/openscience/cdk/ringsearch/cyclebasis/SimpleCycle.java,/legacy/src/main/java/org/openscience/cdk/ringsearch/cyclebasis/SimpleCycle.java,vertexList,100-135,"/**
     * Returns a list of the vertices contained in this cycle.
     * The vertices are in the order of a traversal of the cycle.
     *
     * @return a list of the vertices contained in this cycle
     */
public List vertexList(){
    List vertices = new ArrayList(edgeSet().size());
    Object startVertex = vertexSet().iterator().next();
    Object vertex = startVertex;
    Object previousVertex = null;
    Object nextVertex = null;
    while (nextVertex != startVertex) {
        assert (degreeOf(vertex) == 2);
        List edges = edgesOf(vertex);
        vertices.add(vertex);
        Edge edge = (Edge) edges.get(0);
        nextVertex = edge.oppositeVertex(vertex);
        if (nextVertex == previousVertex) {
            edge = (Edge) edges.get(1);
            nextVertex = edge.oppositeVertex(vertex);
        }
        previousVertex = vertex;
        vertex = nextVertex;
    }
    return vertices;
}","public List vertexList(){
    List vertices = new ArrayList(edgeSet().size());
    Object startVertex = vertexSet().iterator().next();
    Object vertex = startVertex;
    Object previousVertex = null;
    Object nextVertex = null;
    while (nextVertex != startVertex) {
        assert (degreeOf(vertex) == 2);
        List edges = edgesOf(vertex);
        vertices.add(vertex);
        Edge edge = (Edge) edges.get(0);
        nextVertex = edge.oppositeVertex(vertex);
        if (nextVertex == previousVertex) {
            edge = (Edge) edges.get(1);
            nextVertex = edge.oppositeVertex(vertex);
        }
        previousVertex = vertex;
        vertex = nextVertex;
    }
    return vertices;
}","/**
     * Returns a list of the vertices contained in this cycle.
     * The vertices are in the order of a traversal of the cycle.
     *
     * @return a list of the vertices contained in this cycle
     */","('vertexList', {'INSTRUCTION': {'covered': 64, 'missed': 4}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",147.0,  Returns a list of the vertices contained in this cycle.,11.0,"['This cycle contains a list of the vertices.', 'A list of the vertices is returned.', 'This cycle contains a list of vertices.']"
772,logstash-logback-encoder,net/logstash/logback/pattern/AbstractJsonPatternParser.java,/src/main/java/net/logstash/logback/pattern/AbstractJsonPatternParser.java,parseNode,307-333,"/**
     * Parse a {@link JsonNode} and produce the corresponding {@link NodeWriter}.
     * 
     * @param node the {@link JsonNode} to parse.
     * @return a {@link NodeWriter} corresponding to the given JSON node
     * @throws JsonPatternException denotes an invalid pattern
     */
private NodeWriter<Event> parseNode(JsonPointer location, JsonNode node) throws JsonPatternException{
    if (node.isTextual()) {
        try {
            ValueGetter<Event, ?> getter = makeComputableValueGetter(node.asText());
            return new ValueWriter<>(getter);
        } catch (RuntimeException e) {
            String msg = ""Invalid JSON property '"" + location + ""' (was '"" + node.asText() + ""'): "" + e.getMessage();
            throw new JsonPatternException(msg, e);
        }
    }
    if (node.isArray()) {
        return parseArray(location, (ArrayNode) node);
    }
    if (node.isObject()) {
        return parseObject(location, (ObjectNode) node);
    }
    return new ValueWriter<>(g -> node);
}","private NodeWriter<Event> parseNode(JsonPointer location, JsonNode node) throws JsonPatternException{
    if (node.isTextual()) {
        try {
            ValueGetter<Event, ?> getter = makeComputableValueGetter(node.asText());
            return new ValueWriter<>(getter);
        } catch (RuntimeException e) {
            String msg = ""Invalid JSON property '"" + location + ""' (was '"" + node.asText() + ""'): "" + e.getMessage();
            throw new JsonPatternException(msg, e);
        }
    }
    if (node.isArray()) {
        return parseArray(location, (ArrayNode) node);
    }
    if (node.isObject()) {
        return parseObject(location, (ObjectNode) node);
    }
    return new ValueWriter<>(g -> node);
}","/**
     * Parse a {@link JsonNode} and produce the corresponding {@link NodeWriter}.
     * 
     * @param node the {@link JsonNode} to parse.
     * @return a {@link NodeWriter} corresponding to the given JSON node
     * @throws JsonPatternException denotes an invalid pattern
     */","('parseNode', {'INSTRUCTION': {'covered': 63, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",148.0,  Parse a {@link JsonNode} and produce the corresponding {@link NodeWriter}.,17.0,"['Parse a @link JsonNode and produce the corresponding @link NodeWriter.', 'Parse a @link JsonNode and then produce the corresponding @link NodeWriter.', 'Parse a @link JsonNode and produce a corresponding @link NodeWriter.']"
773,cdk,org/openscience/cdk/geometry/GeometryTools.java,/legacy/src/main/java/org/openscience/cdk/geometry/GeometryTools.java,translateAllPositive,102-128,"/**
     *  Adds an automatically calculated offset to the coordinates of all atoms
     *  such that all coordinates are positive and the smallest x or y coordinate
     *  is exactly zero.
     *  See comment for center(IAtomContainer atomCon, Dimension areaDim, HashMap renderingCoordinates) for details on coordinate sets
     *
     *@param  atomCon  AtomContainer for which all the atoms are translated to
     *      positive coordinates
     */
public static void translateAllPositive(IAtomContainer atomCon){
    double minX = Double.MAX_VALUE;
    double minY = Double.MAX_VALUE;
    Iterator<IAtom> atoms = atomCon.atoms().iterator();
    while (atoms.hasNext()) {
        IAtom atom = (IAtom) atoms.next();
        if (atom.getPoint2d() != null) {
            if (atom.getPoint2d().x < minX) {
                minX = atom.getPoint2d().x;
            }
            if (atom.getPoint2d().y < minY) {
                minY = atom.getPoint2d().y;
            }
        }
    }
    logger.debug(""Translating: minx="" + minX + "", minY="" + minY);
    translate2D(atomCon, minX * -1, minY * -1);
}","public static void translateAllPositive(IAtomContainer atomCon){
    double minX = Double.MAX_VALUE;
    double minY = Double.MAX_VALUE;
    Iterator<IAtom> atoms = atomCon.atoms().iterator();
    while (atoms.hasNext()) {
        IAtom atom = (IAtom) atoms.next();
        if (atom.getPoint2d() != null) {
            if (atom.getPoint2d().x < minX) {
                minX = atom.getPoint2d().x;
            }
            if (atom.getPoint2d().y < minY) {
                minY = atom.getPoint2d().y;
            }
        }
    }
    logger.debug(""Translating: minx="" + minX + "", minY="" + minY);
    translate2D(atomCon, minX * -1, minY * -1);
}","/**
     *  Adds an automatically calculated offset to the coordinates of all atoms
     *  such that all coordinates are positive and the smallest x or y coordinate
     *  is exactly zero.
     *  See comment for center(IAtomContainer atomCon, Dimension areaDim, HashMap renderingCoordinates) for details on coordinate sets
     *
     *@param  atomCon  AtomContainer for which all the atoms are translated to
     *      positive coordinates
     */","('translateAllPositive', {'INSTRUCTION': {'covered': 62, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",150.0,  Adds an automatically calculated offset to the coordinates of all atoms  such that all coordinates are positive and the smallest x or y coordinate  is exactly zero.,28.0,"['The smallest x or y coordinate is exactly zero when calculating the offset.', 'The smallest x or y coordinate of all the atoms is exactly zero, and an automatically calculated offset is added to the coordinates.', 'The smallest x or y coordinate of all the atoms is exactly zero, and an automatically calculated offset to the coordinates is added.']"
774,logstash-logback-encoder,net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,/src/main/java/net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,appendRootCauseLast,320-347,"/**
     * Appends a throwable and recursively appends its causedby/suppressed throwables
     * in ""normal"" order (Root cause last).
     */
private void appendRootCauseLast(StringBuilder builder, String prefix, int indent, IThrowableProxy throwableProxy, Deque<String> stackHashes){
    if (throwableProxy == null || builder.length() > maxLength) {
        return;
    }
    String hash = stackHashes == null || stackHashes.isEmpty() ? null : stackHashes.removeFirst();
    appendFirstLine(builder, prefix, indent, throwableProxy, hash);
    appendStackTraceElements(builder, indent, throwableProxy);
    IThrowableProxy[] suppressedThrowableProxies = throwableProxy.getSuppressed();
    if (suppressedThrowableProxies != null) {
        for (IThrowableProxy suppressedThrowableProxy : suppressedThrowableProxies) {
            appendRootCauseLast(builder, CoreConstants.SUPPRESSED, indent + ThrowableProxyUtil.SUPPRESSED_EXCEPTION_INDENT, suppressedThrowableProxy, null);
        }
    }
    appendRootCauseLast(builder, CoreConstants.CAUSED_BY, indent, throwableProxy.getCause(), stackHashes);
}","private void appendRootCauseLast(StringBuilder builder, String prefix, int indent, IThrowableProxy throwableProxy, Deque<String> stackHashes){
    if (throwableProxy == null || builder.length() > maxLength) {
        return;
    }
    String hash = stackHashes == null || stackHashes.isEmpty() ? null : stackHashes.removeFirst();
    appendFirstLine(builder, prefix, indent, throwableProxy, hash);
    appendStackTraceElements(builder, indent, throwableProxy);
    IThrowableProxy[] suppressedThrowableProxies = throwableProxy.getSuppressed();
    if (suppressedThrowableProxies != null) {
        for (IThrowableProxy suppressedThrowableProxy : suppressedThrowableProxies) {
            appendRootCauseLast(builder, CoreConstants.SUPPRESSED, indent + ThrowableProxyUtil.SUPPRESSED_EXCEPTION_INDENT, suppressedThrowableProxy, null);
        }
    }
    appendRootCauseLast(builder, CoreConstants.CAUSED_BY, indent, throwableProxy.getCause(), stackHashes);
}","/**
     * Appends a throwable and recursively appends its causedby/suppressed throwables
     * in ""normal"" order (Root cause last).
     */","('appendRootCauseLast', {'INSTRUCTION': {'covered': 70, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",151.0,"  Appends a throwable and recursively appends its causedby/suppressed throwables  in ""normal"" order (Root cause last).",20.0,"['Appends a throwable and puts it in normal order.', 'Appends a throwable and puts it in the normal order.', 'Appends a throwable and puts it in the ""normal"" order.']"
775,jackson-databind,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,wrapperType,876-909,"/**
     * Helper method for finding wrapper type for given primitive type (why isn't
     * there one in JDK?).
     * NOTE: throws {@link IllegalArgumentException} if given type is NOT primitive
     * type (caller has to check).
     */
public static Class<?> wrapperType(Class<?> primitiveType){
    if (primitiveType == Integer.TYPE) {
        return Integer.class;
    }
    if (primitiveType == Long.TYPE) {
        return Long.class;
    }
    if (primitiveType == Boolean.TYPE) {
        return Boolean.class;
    }
    if (primitiveType == Double.TYPE) {
        return Double.class;
    }
    if (primitiveType == Float.TYPE) {
        return Float.class;
    }
    if (primitiveType == Byte.TYPE) {
        return Byte.class;
    }
    if (primitiveType == Short.TYPE) {
        return Short.class;
    }
    if (primitiveType == Character.TYPE) {
        return Character.class;
    }
    throw new IllegalArgumentException(""Class "" + primitiveType.getName() + "" is not a primitive type"");
}","public static Class<?> wrapperType(Class<?> primitiveType){
    if (primitiveType == Integer.TYPE) {
        return Integer.class;
    }
    if (primitiveType == Long.TYPE) {
        return Long.class;
    }
    if (primitiveType == Boolean.TYPE) {
        return Boolean.class;
    }
    if (primitiveType == Double.TYPE) {
        return Double.class;
    }
    if (primitiveType == Float.TYPE) {
        return Float.class;
    }
    if (primitiveType == Byte.TYPE) {
        return Byte.class;
    }
    if (primitiveType == Short.TYPE) {
        return Short.class;
    }
    if (primitiveType == Character.TYPE) {
        return Character.class;
    }
    throw new IllegalArgumentException(""Class "" + primitiveType.getName() + "" is not a primitive type"");
}","/**
     * Helper method for finding wrapper type for given primitive type (why isn't
     * there one in JDK?).
     * NOTE: throws {@link IllegalArgumentException} if given type is NOT primitive
     * type (caller has to check).
     */","('wrapperType', {'INSTRUCTION': {'covered': 55, 'missed': 0}, 'BRANCH': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",151.0,  Helper method for finding wrapper type for given primitive type (why isn't  there one in JDK?).,21.0,"['There is a method for finding a wrapper type.', ""Why isn't there a method for finding a wrapper type in the JDK?"", ""Why isn't there a method for finding a wrapper type in JDK?""]"
776,matsim-libs,org/matsim/core/router/TripRouter.java,/matsim/src/main/java/org/matsim/core/router/TripRouter.java,calcRoute,145-190,"/**
	 * Routes a trip between the given O/D pair, with the given main mode.
	 *
	 * @param mainMode the main mode for the trip
	 * @param fromFacility a {@link Facility} representing the departure location
	 * @param toFacility a {@link Facility} representing the arrival location
	 * @param departureTime the departure time
	 * @param person the {@link Person} to route
	 * @return a list of {@link PlanElement}, in proper order, representing the trip.
	 *
	 * @throws UnknownModeException if no RoutingModule is registered for the
	 * given mode.
	 */
public synchronized List<? extends PlanElement> calcRoute(final String mainMode, final Facility fromFacility, final Facility toFacility, final double departureTime, final Person person){
    Gbl.assertNotNull(fromFacility);
    Gbl.assertNotNull(toFacility);
    RoutingModule module = routingModules.get(mainMode);
    if (module != null) {
        List<? extends PlanElement> trip = module.calcRoute(fromFacility, toFacility, departureTime, person);
        if (trip == null) {
            trip = fallbackRoutingModule.calcRoute(fromFacility, toFacility, departureTime, person);
        }
        for (Leg leg : TripStructureUtils.getLegs(trip)) {
            TripStructureUtils.setRoutingMode(leg, mainMode);
        }
        return trip;
    }
    throw new UnknownModeException(""unregistered main mode |"" + mainMode + ""|: does not pertain to "" + routingModules.keySet());
}","public synchronized List<? extends PlanElement> calcRoute(final String mainMode, final Facility fromFacility, final Facility toFacility, final double departureTime, final Person person){
    Gbl.assertNotNull(fromFacility);
    Gbl.assertNotNull(toFacility);
    RoutingModule module = routingModules.get(mainMode);
    if (module != null) {
        List<? extends PlanElement> trip = module.calcRoute(fromFacility, toFacility, departureTime, person);
        if (trip == null) {
            trip = fallbackRoutingModule.calcRoute(fromFacility, toFacility, departureTime, person);
        }
        for (Leg leg : TripStructureUtils.getLegs(trip)) {
            TripStructureUtils.setRoutingMode(leg, mainMode);
        }
        return trip;
    }
    throw new UnknownModeException(""unregistered main mode |"" + mainMode + ""|: does not pertain to "" + routingModules.keySet());
}","/**
	 * Routes a trip between the given O/D pair, with the given main mode.
	 *
	 * @param mainMode the main mode for the trip
	 * @param fromFacility a {@link Facility} representing the departure location
	 * @param toFacility a {@link Facility} representing the arrival location
	 * @param departureTime the departure time
	 * @param person the {@link Person} to route
	 * @return a list of {@link PlanElement}, in proper order, representing the trip.
	 *
	 * @throws UnknownModeException if no RoutingModule is registered for the
	 * given mode.
	 */","('calcRoute', {'INSTRUCTION': {'covered': 46, 'missed': 9}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",151.0,"  Routes a trip between the given O/D pair, with the given main mode.",15.0,"['A trip between the O/D pair with the main mode.', 'A trip between the O/D pair with main mode.', 'A trip between the O/D pair with the given main mode.']"
777,cdk,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,positionHydrogenLabel,438-460,"/**
     * Position the hydrogen label relative to the element label.
     *
     * @param position relative position where the hydrogen is placed
     * @param element  the outline of the element label
     * @param hydrogen the outline of the hydrogen
     * @return positioned hydrogen label
     */
 TextOutline positionHydrogenLabel(HydrogenPosition position, TextOutline element, TextOutline hydrogen){
    final Rectangle2D elementBounds = element.getBounds();
    final Rectangle2D hydrogenBounds = hydrogen.getBounds();
    switch(position) {
        case Above:
            return hydrogen.translate(0, (elementBounds.getMinY() - padding) - hydrogenBounds.getMaxY());
        case Right:
            return hydrogen.translate((elementBounds.getMaxX() + padding) - hydrogenBounds.getMinX(), 0);
        case Below:
            return hydrogen.translate(0, (elementBounds.getMaxY() + padding) - hydrogenBounds.getMinY());
        case Left:
            return hydrogen.translate((elementBounds.getMinX() - padding) - hydrogenBounds.getMaxX(), 0);
    }
    return hydrogen;
}","TextOutline positionHydrogenLabel(HydrogenPosition position, TextOutline element, TextOutline hydrogen){
    final Rectangle2D elementBounds = element.getBounds();
    final Rectangle2D hydrogenBounds = hydrogen.getBounds();
    switch(position) {
        case Above:
            return hydrogen.translate(0, (elementBounds.getMinY() - padding) - hydrogenBounds.getMaxY());
        case Right:
            return hydrogen.translate((elementBounds.getMaxX() + padding) - hydrogenBounds.getMinX(), 0);
        case Below:
            return hydrogen.translate(0, (elementBounds.getMaxY() + padding) - hydrogenBounds.getMinY());
        case Left:
            return hydrogen.translate((elementBounds.getMinX() - padding) - hydrogenBounds.getMaxX(), 0);
    }
    return hydrogen;
}","/**
     * Position the hydrogen label relative to the element label.
     *
     * @param position relative position where the hydrogen is placed
     * @param element  the outline of the element label
     * @param hydrogen the outline of the hydrogen
     * @return positioned hydrogen label
     */","('positionHydrogenLabel', {'INSTRUCTION': {'covered': 59, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 1}, 'LINE': {'covered': 7, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",151.0,  Position the hydrogen label relative to the element label.,10.0,"['The hydrogen label should be placed relative to the element label.', 'The hydrogen label should be positioned relative to the element label.', 'The hydrogen label needs to be placed relative to the element label.']"
778,jackson-databind,com/fasterxml/jackson/databind/util/ClassUtil.java,/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,primitiveType,911-948,"/**
     * Method that can be used to find primitive type for given class if (but only if)
     * it is either wrapper type or primitive type; returns {@code null} if type is neither.
     *
     * @since 2.7
     */
public static Class<?> primitiveType(Class<?> type){
    if (type.isPrimitive()) {
        return type;
    }
    if (type == Integer.class) {
        return Integer.TYPE;
    }
    if (type == Long.class) {
        return Long.TYPE;
    }
    if (type == Boolean.class) {
        return Boolean.TYPE;
    }
    if (type == Double.class) {
        return Double.TYPE;
    }
    if (type == Float.class) {
        return Float.TYPE;
    }
    if (type == Byte.class) {
        return Byte.TYPE;
    }
    if (type == Short.class) {
        return Short.TYPE;
    }
    if (type == Character.class) {
        return Character.TYPE;
    }
    return null;
}","public static Class<?> primitiveType(Class<?> type){
    if (type.isPrimitive()) {
        return type;
    }
    if (type == Integer.class) {
        return Integer.TYPE;
    }
    if (type == Long.class) {
        return Long.TYPE;
    }
    if (type == Boolean.class) {
        return Boolean.TYPE;
    }
    if (type == Double.class) {
        return Double.TYPE;
    }
    if (type == Float.class) {
        return Float.TYPE;
    }
    if (type == Byte.class) {
        return Byte.TYPE;
    }
    if (type == Short.class) {
        return Short.TYPE;
    }
    if (type == Character.class) {
        return Character.TYPE;
    }
    return null;
}","/**
     * Method that can be used to find primitive type for given class if (but only if)
     * it is either wrapper type or primitive type; returns {@code null} if type is neither.
     *
     * @since 2.7
     */","('primitiveType', {'INSTRUCTION': {'covered': 47, 'missed': 0}, 'BRANCH': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",152.0,  Method that can be used to find primitive type for given class if (but only if)  it is either wrapper type or primitive type; returns {@code null} if type is neither.,38.0,"['If it is either wrapper type or primitive type, the method can be used to find primitive type for given class.', 'If it is either wrapper type or primitive type, the method can be used to find primitive type.', 'If it is either wrapper type or primitive type, the method can be used to find the primitive type for the class.']"
779,cdk,org/openscience/cdk/group/EquitablePartitionRefiner.java,/tool/group/src/main/java/org/openscience/cdk/group/EquitablePartitionRefiner.java,split,153-181,"/**
     * Split the current block using the invariants calculated in getInvariants.
     *
     * @param invariants a map of neighbor counts to elements
     * @param partition the partition that is being refined
     */
private void split(Map<Invariant, SortedSet<Integer>> invariants, Partition partition){
    int nonEmptyInvariants = invariants.keySet().size();
    if (nonEmptyInvariants > 1) {
        List<Invariant> invariantKeys = new ArrayList<Invariant>(invariants.keySet());
        partition.removeCell(currentBlockIndex);
        int k = currentBlockIndex;
        if (splitOrder == SplitOrder.REVERSE) {
            Collections.sort(invariantKeys);
        } else {
            Collections.sort(invariantKeys, Collections.reverseOrder());
        }
        for (Invariant h : invariantKeys) {
            SortedSet<Integer> setH = invariants.get(h);
            partition.insertCell(k, setH);
            blocksToRefine.add(setH);
            k++;
        }
        currentBlockIndex += nonEmptyInvariants - 1;
    }
}","private void split(Map<Invariant, SortedSet<Integer>> invariants, Partition partition){
    int nonEmptyInvariants = invariants.keySet().size();
    if (nonEmptyInvariants > 1) {
        List<Invariant> invariantKeys = new ArrayList<Invariant>(invariants.keySet());
        partition.removeCell(currentBlockIndex);
        int k = currentBlockIndex;
        if (splitOrder == SplitOrder.REVERSE) {
            Collections.sort(invariantKeys);
        } else {
            Collections.sort(invariantKeys, Collections.reverseOrder());
        }
        for (Invariant h : invariantKeys) {
            SortedSet<Integer> setH = invariants.get(h);
            partition.insertCell(k, setH);
            blocksToRefine.add(setH);
            k++;
        }
        currentBlockIndex += nonEmptyInvariants - 1;
    }
}","/**
     * Split the current block using the invariants calculated in getInvariants.
     *
     * @param invariants a map of neighbor counts to elements
     * @param partition the partition that is being refined
     */","('split', {'INSTRUCTION': {'covered': 62, 'missed': 3}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 16, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",152.0,  Split the current block using the invariants calculated in getInvariants.,11.0,"['Use the invariants calculated in getInvariants to split the current block.', 'The invariants calculated in getInvariants are used to split the current block.', 'Use the invariants calculated in getInvariants to split the block.']"
780,cdk,org/openscience/cdk/tools/diff/tree/Point3dDifference.java,/misc/diff/src/main/java/org/openscience/cdk/tools/diff/tree/Point3dDifference.java,construct,39-61,"/**
     * Constructs a new {@link IDifference} object.
     *
     * @param name   a name reflecting the nature of the created {@link IDifference}
     * @param first  the first object to compare
     * @param second the second object to compare
     * @return       an {@link IDifference} reflecting the differences between the first and second object
     */
public static IDifference construct(String name, Point3d first, Point3d second){
    if (first == null && second == null)
        return null;
    Point3dDifference totalDiff = new Point3dDifference(name);
    totalDiff.addChild(DoubleDifference.construct(""x"", first == null ? null : first.x, second == null ? null : second.x));
    totalDiff.addChild(DoubleDifference.construct(""y"", first == null ? null : first.y, second == null ? null : second.y));
    totalDiff.addChild(DoubleDifference.construct(""z"", first == null ? null : first.z, second == null ? null : second.z));
    if (totalDiff.childCount() == 0) {
        return null;
    }
    return totalDiff;
}","public static IDifference construct(String name, Point3d first, Point3d second){
    if (first == null && second == null)
        return null;
    Point3dDifference totalDiff = new Point3dDifference(name);
    totalDiff.addChild(DoubleDifference.construct(""x"", first == null ? null : first.x, second == null ? null : second.x));
    totalDiff.addChild(DoubleDifference.construct(""y"", first == null ? null : first.y, second == null ? null : second.y));
    totalDiff.addChild(DoubleDifference.construct(""z"", first == null ? null : first.z, second == null ? null : second.z));
    if (totalDiff.childCount() == 0) {
        return null;
    }
    return totalDiff;
}","/**
     * Constructs a new {@link IDifference} object.
     *
     * @param name   a name reflecting the nature of the created {@link IDifference}
     * @param first  the first object to compare
     * @param second the second object to compare
     * @return       an {@link IDifference} reflecting the differences between the first and second object
     */","('construct', {'INSTRUCTION': {'covered': 72, 'missed': 0}, 'BRANCH': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",152.0,  Constructs a new {@link IDifference} object.,10.0,"['A new @link IDifference object is created.', 'A new object is created.', 'A new @link IDifference object is constructed.']"
781,cdk,org/openscience/cdk/group/Permutation.java,/tool/group/src/main/java/org/openscience/cdk/group/Permutation.java,toCycleString,225-253,"/**
     * An easily-readable version of the permutation as a product of cycles.
     *
     * @return the cycle form of the permutation as a string
     */
public String toCycleString(){
    int n = this.values.length;
    boolean[] p = new boolean[n];
    Arrays.fill(p, true);
    StringBuilder sb = new StringBuilder();
    int j = 0;
    for (int i = 0; i < n; i++) {
        if (p[i]) {
            sb.append('(');
            sb.append(i);
            p[i] = false;
            j = i;
            while (p[values[j]]) {
                sb.append("", "");
                j = values[j];
                sb.append(j);
                p[j] = false;
            }
            sb.append(')');
        }
    }
    return sb.toString();
}","public String toCycleString(){
    int n = this.values.length;
    boolean[] p = new boolean[n];
    Arrays.fill(p, true);
    StringBuilder sb = new StringBuilder();
    int j = 0;
    for (int i = 0; i < n; i++) {
        if (p[i]) {
            sb.append('(');
            sb.append(i);
            p[i] = false;
            j = i;
            while (p[values[j]]) {
                sb.append("", "");
                j = values[j];
                sb.append(j);
                p[j] = false;
            }
            sb.append(')');
        }
    }
    return sb.toString();
}","/**
     * An easily-readable version of the permutation as a product of cycles.
     *
     * @return the cycle form of the permutation as a string
     */","('toCycleString', {'INSTRUCTION': {'covered': 73, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",153.0,  An easily-readable version of the permutation as a product of cycles.,12.0,"['The permutation is a product of cycles.', 'The permutation is a product of cycles', 'The permutation as a product of cycles is easily readable.']"
782,tablesaw,tech/tablesaw/util/StringUtils.java,/core/src/main/java/tech/tablesaw/util/StringUtils.java,capitalize,301-341,"/**
   * Capitalizes a String changing the first character to title case as per {@link
   * Character#toTitleCase(int)}. No other characters are changed.
   *
   * <p>A {@code null} input String returns {@code null}.
   *
   * <pre>
   * StringUtils.capitalize(null)  = null
   * StringUtils.capitalize("""")    = """"
   * StringUtils.capitalize(""cat"") = ""Cat""
   * StringUtils.capitalize(""cAt"") = ""CAt""
   * StringUtils.capitalize(""'cat'"") = ""'cat'""
   * </pre>
   *
   * @param str the String to capitalize, may be null
   * @return the capitalized String, {@code null} if null String input
   * @since 2.0
   */
public static String capitalize(final String str){
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    final int firstCodepoint = str.codePointAt(0);
    final int newCodePoint = Character.toTitleCase(firstCodepoint);
    if (firstCodepoint == newCodePoint) {
        return str;
    }
    final int[] newCodePoints = new int[strLen];
    int outOffset = 0;
    newCodePoints[outOffset++] = newCodePoint;
    for (int inOffset = Character.charCount(firstCodepoint); inOffset < strLen; ) {
        final int codepoint = str.codePointAt(inOffset);
        newCodePoints[outOffset++] = codepoint;
        inOffset += Character.charCount(codepoint);
    }
    return new String(newCodePoints, 0, outOffset);
}","public static String capitalize(final String str){
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    final int firstCodepoint = str.codePointAt(0);
    final int newCodePoint = Character.toTitleCase(firstCodepoint);
    if (firstCodepoint == newCodePoint) {
        return str;
    }
    final int[] newCodePoints = new int[strLen];
    int outOffset = 0;
    newCodePoints[outOffset++] = newCodePoint;
    for (int inOffset = Character.charCount(firstCodepoint); inOffset < strLen; ) {
        final int codepoint = str.codePointAt(inOffset);
        newCodePoints[outOffset++] = codepoint;
        inOffset += Character.charCount(codepoint);
    }
    return new String(newCodePoints, 0, outOffset);
}","/**
   * Capitalizes a String changing the first character to title case as per {@link
   * Character#toTitleCase(int)}. No other characters are changed.
   *
   * <p>A {@code null} input String returns {@code null}.
   *
   * <pre>
   * StringUtils.capitalize(null)  = null
   * StringUtils.capitalize("""")    = """"
   * StringUtils.capitalize(""cat"") = ""Cat""
   * StringUtils.capitalize(""cAt"") = ""CAt""
   * StringUtils.capitalize(""'cat'"") = ""'cat'""
   * </pre>
   *
   * @param str the String to capitalize, may be null
   * @return the capitalized String, {@code null} if null String input
   * @since 2.0
   */","('capitalize', {'INSTRUCTION': {'covered': 55, 'missed': 4}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 13, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",153.0,  Capitalizes a String changing the first character to title case as per {@link  Character#toTitleCase(int)}.,23.0,"['The capitalizes a string changing the first character to the title case.', 'The capitalizes a string changing the first character to a title case.', 'The capitalizes a string changing the first character to title case.']"
783,cdk,org/openscience/cdk/smiles/CDKToBeam.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/CDKToBeam.java,addExtendedTetrahedralConfiguration,348-366,"/**
     * Add extended tetrahedral stereo configuration to the Beam GraphBuilder.
     *
     * @param et      stereo element specifying tetrahedral configuration
     * @param gb      the current graph builder
     * @param indices atom indices
     */
private static void addExtendedTetrahedralConfiguration(ExtendedTetrahedral et, GraphBuilder gb, Map<IAtom, Integer> indices){
    IAtom[] ligands = et.peripherals();
    int u = indices.get(et.focus());
    int[] vs = new int[] { indices.get(ligands[0]), indices.get(ligands[1]), indices.get(ligands[2]), indices.get(ligands[3]) };
    gb.extendedTetrahedral(u).lookingFrom(vs[0]).neighbors(vs[1], vs[2], vs[3]).winding(et.winding() == CLOCKWISE ? Configuration.CLOCKWISE : Configuration.ANTI_CLOCKWISE).build();
}","private static void addExtendedTetrahedralConfiguration(ExtendedTetrahedral et, GraphBuilder gb, Map<IAtom, Integer> indices){
    IAtom[] ligands = et.peripherals();
    int u = indices.get(et.focus());
    int[] vs = new int[] { indices.get(ligands[0]), indices.get(ligands[1]), indices.get(ligands[2]), indices.get(ligands[3]) };
    gb.extendedTetrahedral(u).lookingFrom(vs[0]).neighbors(vs[1], vs[2], vs[3]).winding(et.winding() == CLOCKWISE ? Configuration.CLOCKWISE : Configuration.ANTI_CLOCKWISE).build();
}","/**
     * Add extended tetrahedral stereo configuration to the Beam GraphBuilder.
     *
     * @param et      stereo element specifying tetrahedral configuration
     * @param gb      the current graph builder
     * @param indices atom indices
     */","('addExtendedTetrahedralConfiguration', {'INSTRUCTION': {'covered': 81, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 7, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",153.0,  Add extended tetrahedral stereo configuration to the Beam GraphBuilder.,10.0,"['The Beam GraphBuilder can be used to add extended stereo configuration.', 'The Beam GraphBuilder can be used to add extended stereo configurations.', 'The Beam GraphBuilder can be used to add extended tetrahedral stereo configuration.']"
784,matsim-libs,org/matsim/core/router/Dijkstra.java,/matsim/src/main/java/org/matsim/core/router/Dijkstra.java,calcLeastCostPath,198-244,"/**
	 * Calculates the cheapest route from Node 'fromNode' to Node 'toNode' at
	 * starting time 'startTime'.
	 *
	 * @param fromNode
	 *            The Node at which the route should start.
	 * @param toNode
	 *            The Node at which the route should end.
	 * @param startTime
	 *            The time at which the route should start.
	 * @see org.matsim.core.router.util.LeastCostPathCalculator#calcLeastCostPath(org.matsim.api.core.v01.network.Node, org.matsim.api.core.v01.network.Node, double, org.matsim.api.core.v01.population.Person, org.matsim.vehicles.Vehicle)
	 */
public Path calcLeastCostPath(final Node fromNode, final Node toNode, final double startTime, final Person person2, final Vehicle vehicle2){
    checkNodeBelongToNetwork(fromNode);
    checkNodeBelongToNetwork(toNode);
    augmentIterationId();
    this.person = person2;
    this.vehicle = vehicle2;
    if (this.pruneDeadEnds) {
        this.deadEndEntryNode = getPreProcessData(toNode).getDeadEndEntryNode();
    }
    RouterPriorityQueue<Node> pendingNodes = (RouterPriorityQueue<Node>) createRouterPriorityQueue();
    initFromNode(fromNode, toNode, startTime, pendingNodes);
    Node foundToNode = searchLogic(fromNode, toNode, pendingNodes);
    if (foundToNode == null)
        return null;
    else {
        DijkstraNodeData outData = getData(foundToNode);
        double arrivalTime = outData.getTime();
        return constructPath(fromNode, foundToNode, startTime, arrivalTime);
    }
}","public Path calcLeastCostPath(final Node fromNode, final Node toNode, final double startTime, final Person person2, final Vehicle vehicle2){
    checkNodeBelongToNetwork(fromNode);
    checkNodeBelongToNetwork(toNode);
    augmentIterationId();
    this.person = person2;
    this.vehicle = vehicle2;
    if (this.pruneDeadEnds) {
        this.deadEndEntryNode = getPreProcessData(toNode).getDeadEndEntryNode();
    }
    RouterPriorityQueue<Node> pendingNodes = (RouterPriorityQueue<Node>) createRouterPriorityQueue();
    initFromNode(fromNode, toNode, startTime, pendingNodes);
    Node foundToNode = searchLogic(fromNode, toNode, pendingNodes);
    if (foundToNode == null)
        return null;
    else {
        DijkstraNodeData outData = getData(foundToNode);
        double arrivalTime = outData.getTime();
        return constructPath(fromNode, foundToNode, startTime, arrivalTime);
    }
}","/**
	 * Calculates the cheapest route from Node 'fromNode' to Node 'toNode' at
	 * starting time 'startTime'.
	 *
	 * @param fromNode
	 *            The Node at which the route should start.
	 * @param toNode
	 *            The Node at which the route should end.
	 * @param startTime
	 *            The time at which the route should start.
	 * @see org.matsim.core.router.util.LeastCostPathCalculator#calcLeastCostPath(org.matsim.api.core.v01.network.Node, org.matsim.api.core.v01.network.Node, double, org.matsim.api.core.v01.population.Person, org.matsim.vehicles.Vehicle)
	 */","('calcLeastCostPath', {'INSTRUCTION': {'covered': 56, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",153.0,  Calculates the cheapest route from Node 'fromNode' to Node 'toNode' at  starting time 'startTime'.,18.0,"['It calculates the cheapest route from the beginning to the end.', 'The cheapest route from the beginning to the end is calculated.', ""The cheapest route from the beginning to the end is 'from the beginning to the end'.""]"
785,cdk,org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAtomTypeMatcher.java,loadPatterns,215-241,"/**
     * Internal - load the SMARTS patterns for each atom type from MMFFSYMB.sma.
     *
     * @param smaIn input stream of MMFFSYMB.sma
     * @return array of patterns
     * @throws IOException
     */
 static AtomTypePattern[] loadPatterns(InputStream smaIn) throws IOException{
    List<AtomTypePattern> matchers = new ArrayList<AtomTypePattern>();
    BufferedReader br = new BufferedReader(new InputStreamReader(smaIn));
    String line = null;
    while ((line = br.readLine()) != null) {
        if (skipLine(line))
            continue;
        String[] cols = line.split("" "");
        String sma = cols[0];
        String symb = cols[1];
        try {
            matchers.add(new AtomTypePattern(SmartsPattern.create(sma).setPrepare(false), symb));
        } catch (IllegalArgumentException ex) {
            throw new IOException(ex);
        }
    }
    return matchers.toArray(new AtomTypePattern[matchers.size()]);
}","static AtomTypePattern[] loadPatterns(InputStream smaIn) throws IOException{
    List<AtomTypePattern> matchers = new ArrayList<AtomTypePattern>();
    BufferedReader br = new BufferedReader(new InputStreamReader(smaIn));
    String line = null;
    while ((line = br.readLine()) != null) {
        if (skipLine(line))
            continue;
        String[] cols = line.split("" "");
        String sma = cols[0];
        String symb = cols[1];
        try {
            matchers.add(new AtomTypePattern(SmartsPattern.create(sma).setPrepare(false), symb));
        } catch (IllegalArgumentException ex) {
            throw new IOException(ex);
        }
    }
    return matchers.toArray(new AtomTypePattern[matchers.size()]);
}","/**
     * Internal - load the SMARTS patterns for each atom type from MMFFSYMB.sma.
     *
     * @param smaIn input stream of MMFFSYMB.sma
     * @return array of patterns
     * @throws IOException
     */","('loadPatterns', {'INSTRUCTION': {'covered': 62, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",154.0,  Internal - load the SMARTS patterns for each atom type from MMFFSYMB.,13.0,"['Load the patterns for each atom type from MMFFSYMB.', 'Load the patterns for the atom types from MMFFSYMB.', 'Load the SMARTS patterns for each atom type from MMFFSYMB.']"
786,dcache,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,addComponent,441-482,"/**
     * Add a new component to our list of children.
     * <p>
     *
     * @param childName the name under which this item should be recorded
     * @param newChild  the StateComponent to be stored.
     */
private void addComponent(String childName, StateComponent newChild){
    StateComponent existingChild = _children.get(childName);
    if (newChild instanceof StateComposite) {
        StateComposite newComposite = (StateComposite) newChild;
        if (existingChild instanceof StateComposite) {
            StateComposite existingComposite = (StateComposite) existingChild;
            for (Map.Entry<String, StateComponent> entry : existingComposite._children.entrySet()) {
                if (!newComposite._children.containsKey(entry.getKey())) {
                    newComposite._children.put(entry.getKey(), entry.getValue());
                }
            }
            newComposite.updateEarliestChildExpiryDate(existingComposite.getEarliestChildExpiryDate());
            newComposite.updateWhenIShouldExpireDate(existingComposite.getExpiryDate());
        }
    }
    _children.put(childName, newChild);
    LOGGER.trace(""Child {} now {}"", childName, newChild);
}","private void addComponent(String childName, StateComponent newChild){
    StateComponent existingChild = _children.get(childName);
    if (newChild instanceof StateComposite) {
        StateComposite newComposite = (StateComposite) newChild;
        if (existingChild instanceof StateComposite) {
            StateComposite existingComposite = (StateComposite) existingChild;
            for (Map.Entry<String, StateComponent> entry : existingComposite._children.entrySet()) {
                if (!newComposite._children.containsKey(entry.getKey())) {
                    newComposite._children.put(entry.getKey(), entry.getValue());
                }
            }
            newComposite.updateEarliestChildExpiryDate(existingComposite.getEarliestChildExpiryDate());
            newComposite.updateWhenIShouldExpireDate(existingComposite.getExpiryDate());
        }
    }
    _children.put(childName, newChild);
    LOGGER.trace(""Child {} now {}"", childName, newChild);
}","/**
     * Add a new component to our list of children.
     * <p>
     *
     * @param childName the name under which this item should be recorded
     * @param newChild  the StateComponent to be stored.
     */","('addComponent', {'INSTRUCTION': {'covered': 67, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",155.0,  Add a new component to our list of children.,10.0,"['There is a new component to our list.', 'We need to add a new component to our list.', 'There is a new component to the list.']"
787,cdk,org/openscience/cdk/hash/SuppressedAtomHashGenerator.java,/tool/hash/src/main/java/org/openscience/cdk/hash/SuppressedAtomHashGenerator.java,next,174-218,"/**
     * Determine the next value of the atom at index <i>v</i>. The value is
     * calculated by combining the current values of adjacent atoms. When a
     * duplicate value is found it can not be directly included and is
     * <i>rotated</i> the number of times it has previously been seen.
     *
     * @param graph      adjacency list representation of connected atoms
     * @param v          the atom to calculate the next value for
     * @param current    the current values
     * @param unique     buffer for working out which adjacent values are unique
     * @param included   buffer for storing the rotated <i>unique</i> value, this
     *                   value is <i>rotated</i> each time the same value is
     *                   found.
     * @param suppressed bit set indicates which atoms are 'suppressed'
     * @return the next value for <i>v</i>
     */
 long next(int[][] graph, int v, long[] current, long[] unique, long[] included, Suppressed suppressed){
    if (suppressed.contains(v))
        return current[v];
    long invariant = distribute(current[v]);
    int nUnique = 0;
    for (int w : graph[v]) {
        if (suppressed.contains(w))
            continue;
        long adjInv = current[w];
        int i = 0;
        while (i < nUnique && unique[i] != adjInv) {
            ++i;
        }
        included[i] = (i == nUnique) ? unique[nUnique++] = adjInv : rotate(included[i]);
        invariant ^= included[i];
    }
    return invariant;
}","long next(int[][] graph, int v, long[] current, long[] unique, long[] included, Suppressed suppressed){
    if (suppressed.contains(v))
        return current[v];
    long invariant = distribute(current[v]);
    int nUnique = 0;
    for (int w : graph[v]) {
        if (suppressed.contains(w))
            continue;
        long adjInv = current[w];
        int i = 0;
        while (i < nUnique && unique[i] != adjInv) {
            ++i;
        }
        included[i] = (i == nUnique) ? unique[nUnique++] = adjInv : rotate(included[i]);
        invariant ^= included[i];
    }
    return invariant;
}","/**
     * Determine the next value of the atom at index <i>v</i>. The value is
     * calculated by combining the current values of adjacent atoms. When a
     * duplicate value is found it can not be directly included and is
     * <i>rotated</i> the number of times it has previously been seen.
     *
     * @param graph      adjacency list representation of connected atoms
     * @param v          the atom to calculate the next value for
     * @param current    the current values
     * @param unique     buffer for working out which adjacent values are unique
     * @param included   buffer for storing the rotated <i>unique</i> value, this
     *                   value is <i>rotated</i> each time the same value is
     *                   found.
     * @param suppressed bit set indicates which atoms are 'suppressed'
     * @return the next value for <i>v</i>
     */","('next', {'INSTRUCTION': {'covered': 82, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",155.0,  Determine the next value of the atom at index <i>v</i>.,17.0,"['Determine the value of the atom at the index.', 'Determine the next value of the atom.', 'The next value of the atom is determined by the index.']"
789,cdk,org/openscience/cdk/group/PermutationGroup.java,/tool/group/src/main/java/org/openscience/cdk/group/PermutationGroup.java,transversal,241-276,"/**
     * Generate a transversal of a subgroup in this group.
     *
     * @param subgroup the subgroup to use for the transversal
     * @return a list of permutations
     */
public List<Permutation> transversal(final PermutationGroup subgroup){
    final long m = this.order() / subgroup.order();
    final List<Permutation> results = new ArrayList<Permutation>();
    Backtracker transversalBacktracker = new Backtracker() {

        private boolean finished = false;

        @Override
        public void applyTo(Permutation p) {
            for (Permutation f : results) {
                Permutation h = f.invert().multiply(p);
                if (subgroup.test(h) == size) {
                    return;
                }
            }
            results.add(p);
            if (results.size() >= m) {
                this.finished = true;
            }
        }

        @Override
        public boolean isFinished() {
            return finished;
        }
    };
    this.apply(transversalBacktracker);
    return results;
}","public List<Permutation> transversal(final PermutationGroup subgroup){
    final long m = this.order() / subgroup.order();
    final List<Permutation> results = new ArrayList<Permutation>();
    Backtracker transversalBacktracker = new Backtracker() {

        private boolean finished = false;

        @Override
        public void applyTo(Permutation p) {
            for (Permutation f : results) {
                Permutation h = f.invert().multiply(p);
                if (subgroup.test(h) == size) {
                    return;
                }
            }
            results.add(p);
            if (results.size() >= m) {
                this.finished = true;
            }
        }

        @Override
        public boolean isFinished() {
            return finished;
        }
    };
    this.apply(transversalBacktracker);
    return results;
}","/**
     * Generate a transversal of a subgroup in this group.
     *
     * @param subgroup the subgroup to use for the transversal
     * @return a list of permutations
     */","('transversal', {'INSTRUCTION': {'covered': 23, 'missed': 0}, 'LINE': {'covered': 5, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",156.0,  Generate a transversal of a subgroup in this group.,10.0,"['A subgroup of this group should be created.', 'This group has a subgroup.', 'A subgroup of this group is created.']"
790,cdk,org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,deltavSulphur,185-217,"/**
     * Evaluates the empirical delt V for some S environments.
     * 
     * The method checks to see whether a S atom is in a -S-S-,
     * -SO-, -SO2- group and returns the empirical values noted
     * in Kier & Hall (1986), page 20.
     *
     * @param atom          The S atom in question
     * @param atomContainer The molecule containing the S
     * @return The empirical delta V if it is present in one of the above
     *         environments, -1 otherwise
     */
protected static double deltavSulphur(IAtom atom, IAtomContainer atomContainer){
    if (atom.getAtomicNumber() != IElement.S)
        return -1;
    List<IAtom> connected = atomContainer.getConnectedAtomsList(atom);
    for (IAtom connectedAtom : connected) {
        if (connectedAtom.getAtomicNumber() == IElement.S && atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.SINGLE)
            return .89;
    }
    int count = 0;
    for (IAtom connectedAtom : connected) {
        if (connectedAtom.getAtomicNumber() == IElement.O && atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.DOUBLE)
            count++;
    }
    if (count == 1)
        return 1.33;
    else if (count == 2)
        return 2.67;
    return -1;
}","protected static double deltavSulphur(IAtom atom, IAtomContainer atomContainer){
    if (atom.getAtomicNumber() != IElement.S)
        return -1;
    List<IAtom> connected = atomContainer.getConnectedAtomsList(atom);
    for (IAtom connectedAtom : connected) {
        if (connectedAtom.getAtomicNumber() == IElement.S && atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.SINGLE)
            return .89;
    }
    int count = 0;
    for (IAtom connectedAtom : connected) {
        if (connectedAtom.getAtomicNumber() == IElement.O && atomContainer.getBond(atom, connectedAtom).getOrder() == IBond.Order.DOUBLE)
            count++;
    }
    if (count == 1)
        return 1.33;
    else if (count == 2)
        return 2.67;
    return -1;
}","/**
     * Evaluates the empirical delt V for some S environments.
     * 
     * The method checks to see whether a S atom is in a -S-S-,
     * -SO-, -SO2- group and returns the empirical values noted
     * in Kier & Hall (1986), page 20.
     *
     * @param atom          The S atom in question
     * @param atomContainer The molecule containing the S
     * @return The empirical delta V if it is present in one of the above
     *         environments, -1 otherwise
     */","('deltavSulphur', {'INSTRUCTION': {'covered': 63, 'missed': 11}, 'BRANCH': {'covered': 13, 'missed': 5}, 'LINE': {'covered': 14, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",156.0,  Evaluates the empirical delt V for some S environments.,10.0,"['Evaluates the empirical delt V.', 'Evaluates the empirical delt V for S environments.', 'Evaluates the empirical delt V for some environments.']"
791,cdk,org/openscience/cdk/group/PermutationGroup.java,/tool/group/src/main/java/org/openscience/cdk/group/PermutationGroup.java,makeSymN,152-182,"/**
     * Make the symmetric group Sym(N) for N. That is, a group of permutations
     * that represents _all_ permutations of size N.
     *
     * @param size the size of the permutation
     * @return a group for all permutations of N
     */
public static PermutationGroup makeSymN(int size){
    List<Permutation> generators = new ArrayList<Permutation>();
    // p1 is (0, 1)
    int[] p1 = new int[size];
    p1[0] = 1;
    p1[1] = 0;
    for (int i = 2; i < size; i++) {
        p1[i] = i;
    }
    // p2 is (1, 2, ...., n, 0)
    int[] p2 = new int[size];
    p2[0] = 1;
    for (int i = 1; i < size - 1; i++) {
        p2[i] = i + 1;
    }
    p2[size - 1] = 0;
    generators.add(new Permutation(p1));
    generators.add(new Permutation(p2));
    return new PermutationGroup(size, generators);
}","public static PermutationGroup makeSymN(int size){
    List<Permutation> generators = new ArrayList<Permutation>();
    // p1 is (0, 1)
    int[] p1 = new int[size];
    p1[0] = 1;
    p1[1] = 0;
    for (int i = 2; i < size; i++) {
        p1[i] = i;
    }
    // p2 is (1, 2, ...., n, 0)
    int[] p2 = new int[size];
    p2[0] = 1;
    for (int i = 1; i < size - 1; i++) {
        p2[i] = i + 1;
    }
    p2[size - 1] = 0;
    generators.add(new Permutation(p1));
    generators.add(new Permutation(p2));
    return new PermutationGroup(size, generators);
}","/**
     * Make the symmetric group Sym(N) for N. That is, a group of permutations
     * that represents _all_ permutations of size N.
     *
     * @param size the size of the permutation
     * @return a group for all permutations of N
     */","('makeSymN', {'INSTRUCTION': {'covered': 74, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",157.0,  Make the symmetric group Sym(N) for N.,11.0,"['Sym(N) is a group for N.', 'Sym(N) is a symmetric group.', 'The symmetric group Sym(N) should be made for N.']"
792,cdk,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,applyMDLValenceModel,566-599,"/**
     * Applies the MDL valence model to atoms using the explicit valence (bond
     * order sum) and charge to determine the correct number of implicit
     * hydrogens. The model is not applied if the explicit valence is less than
     * 0 - this is the case when a query bond was read for an atom.
     *
     * @param atom            the atom to apply the model to
     * @param unpaired        unpaired electron count
     * @param explicitValence the explicit valence (bond order sum)
     */
private void applyMDLValenceModel(IAtom atom, int explicitValence, int unpaired){
    if (atom.getValency() != null) {
        if (atom.getValency() >= explicitValence)
            atom.setImplicitHydrogenCount(atom.getValency() - (explicitValence - unpaired));
        else
            atom.setImplicitHydrogenCount(0);
    } else {
        Integer element = atom.getAtomicNumber();
        if (element == null)
            element = 0;
        Integer charge = atom.getFormalCharge();
        if (charge == null)
            charge = 0;
        int implicitValence = MDLValence.implicitValence(element, charge, explicitValence);
        if (implicitValence < explicitValence) {
            atom.setValency(explicitValence);
            atom.setImplicitHydrogenCount(0);
        } else {
            atom.setValency(implicitValence);
            atom.setImplicitHydrogenCount(implicitValence - explicitValence);
        }
    }
}","private void applyMDLValenceModel(IAtom atom, int explicitValence, int unpaired){
    if (atom.getValency() != null) {
        if (atom.getValency() >= explicitValence)
            atom.setImplicitHydrogenCount(atom.getValency() - (explicitValence - unpaired));
        else
            atom.setImplicitHydrogenCount(0);
    } else {
        Integer element = atom.getAtomicNumber();
        if (element == null)
            element = 0;
        Integer charge = atom.getFormalCharge();
        if (charge == null)
            charge = 0;
        int implicitValence = MDLValence.implicitValence(element, charge, explicitValence);
        if (implicitValence < explicitValence) {
            atom.setValency(explicitValence);
            atom.setImplicitHydrogenCount(0);
        } else {
            atom.setValency(implicitValence);
            atom.setImplicitHydrogenCount(implicitValence - explicitValence);
        }
    }
}","/**
     * Applies the MDL valence model to atoms using the explicit valence (bond
     * order sum) and charge to determine the correct number of implicit
     * hydrogens. The model is not applied if the explicit valence is less than
     * 0 - this is the case when a query bond was read for an atom.
     *
     * @param atom            the atom to apply the model to
     * @param unpaired        unpaired electron count
     * @param explicitValence the explicit valence (bond order sum)
     */","('applyMDLValenceModel', {'INSTRUCTION': {'covered': 61, 'missed': 9}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",158.0,  Applies the MDL valence model to atoms using the explicit valence (bond  order sum) and charge to determine the correct number of implicit  hydrogens.,27.0,"['The correct number of implicit hydrogens can be determined using the explicit valence model and the charge.', 'The correct number of implicit hydrogens can be determined using the explicit valence model and charge.', 'The correct number of implicit hydrogens can be determined using the MDL model.']"
793,openapi-generator,org/openapitools/codegen/DefaultGenerator.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java,toImportsObjects,1234-1257,"/**
     * Using an import map created via {@link #getAllImportsMappings(Set)} to build a list import objects.
     * The import objects have two keys: import and classname which hold the key and value of the initial map entry.
     *
     * @param mappedImports Map of fully qualified import and import
     * @return The set of unique imports
     */
private Set<Map<String, String>> toImportsObjects(Map<String, String> mappedImports){
    Set<Map<String, String>> result = new TreeSet<Map<String, String>>((Comparator<Map<String, String>>) (o1, o2) -> {
        String s1 = o1.get(""classname"");
        String s2 = o2.get(""classname"");
        return s1.compareTo(s2);
    });
    mappedImports.entrySet().forEach(mapping -> {
        Map<String, String> im = new LinkedHashMap<>();
        im.put(""import"", mapping.getKey());
        im.put(""classname"", mapping.getValue());
        result.add(im);
    });
    return result;
}","private Set<Map<String, String>> toImportsObjects(Map<String, String> mappedImports){
    Set<Map<String, String>> result = new TreeSet<Map<String, String>>((Comparator<Map<String, String>>) (o1, o2) -> {
        String s1 = o1.get(""classname"");
        String s2 = o2.get(""classname"");
        return s1.compareTo(s2);
    });
    mappedImports.entrySet().forEach(mapping -> {
        Map<String, String> im = new LinkedHashMap<>();
        im.put(""import"", mapping.getKey());
        im.put(""classname"", mapping.getValue());
        result.add(im);
    });
    return result;
}","/**
     * Using an import map created via {@link #getAllImportsMappings(Set)} to build a list import objects.
     * The import objects have two keys: import and classname which hold the key and value of the initial map entry.
     *
     * @param mappedImports Map of fully qualified import and import
     * @return The set of unique imports
     */","('toImportsObjects', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",158.0,  Using an import map created via {@link #getAllImportsMappings(Set)} to build a list import objects.,22.0,"['To build a list import objects, use an import map created via @link #getAllImportsMappings(Set).', 'To build a list import objects, use an import map created via @link #getAllImportsMappings(Set)', 'To build a list import objects, use an import map created via @link #getAllImportsMappings(Set))']"
794,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,extractFolders,163-197,"/**
     * Extracts each folder path and builds FileFolders, with the qualified name of the form
     * '<externalSourceName>::<path>'. The order is important, meaning the first folder is the one containing the file
     * and the last one the root, and used in creating the folder hierarchy structure al the way to the SoftwareServerCapability
     *
     * @param pathName           file path
     * @param externalSourceName name of SoftwareServerCapability
     * @param methodName         method name
     *
     * @return list of FileFolders
     */
private List<FileFolder> extractFolders(String pathName, String externalSourceName, String methodName) throws InvalidParameterException{
    boolean fileSeparatorReversed = false;
    if (pathName.contains(""\\"")) {
        pathName = pathName.replace(""\\"", ""/"");
        fileSeparatorReversed = true;
    }
    Path path = Paths.get(pathName);
    File parentFile = path.toFile().getParentFile();
    invalidParameterHandler.validateObject(parentFile, ""pathName"", methodName);
    List<FileFolder> folders = new ArrayList<>();
    while (parentFile != null) {
        String parentFilePath = fileSeparatorReversed ? parentFile.getPath().replace(""/"", ""\\"") : parentFile.getPath();
        FileFolder folder = buildFileFolder(parentFilePath, externalSourceName);
        folders.add(folder);
        parentFile = parentFile.getParentFile();
    }
    return folders;
}","private List<FileFolder> extractFolders(String pathName, String externalSourceName, String methodName) throws InvalidParameterException{
    boolean fileSeparatorReversed = false;
    if (pathName.contains(""\\"")) {
        pathName = pathName.replace(""\\"", ""/"");
        fileSeparatorReversed = true;
    }
    Path path = Paths.get(pathName);
    File parentFile = path.toFile().getParentFile();
    invalidParameterHandler.validateObject(parentFile, ""pathName"", methodName);
    List<FileFolder> folders = new ArrayList<>();
    while (parentFile != null) {
        String parentFilePath = fileSeparatorReversed ? parentFile.getPath().replace(""/"", ""\\"") : parentFile.getPath();
        FileFolder folder = buildFileFolder(parentFilePath, externalSourceName);
        folders.add(folder);
        parentFile = parentFile.getParentFile();
    }
    return folders;
}","/**
     * Extracts each folder path and builds FileFolders, with the qualified name of the form
     * '<externalSourceName>::<path>'. The order is important, meaning the first folder is the one containing the file
     * and the last one the root, and used in creating the folder hierarchy structure al the way to the SoftwareServerCapability
     *
     * @param pathName           file path
     * @param externalSourceName name of SoftwareServerCapability
     * @param methodName         method name
     *
     * @return list of FileFolders
     */","('extractFolders', {'INSTRUCTION': {'covered': 47, 'missed': 13}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 13, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",158.0,"  Extracts each folder path and builds FileFolders, with the qualified name of the form  '<externalSourceName>::<path>'.",26.0,"[""The form 'external SourceName>::path>' is used to name the file folder."", ""The form 'external SourceName>::path>' is used to name the file folders."", ""The form 'external SourceName>::path>' is used to create the file folder.""]"
795,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,findEntity,160-195,"/**
     * Find out if the entity is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId         the name of the calling user
     * @param qualifiedName  the qualifiedName name of the entity to be searched
     * @param entityTypeName the type name of the entity
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */
public Optional<EntityDetail> findEntity(String userId, String qualifiedName, String entityTypeName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    final String methodName = ""findEntity"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateName(qualifiedName, CommonMapper.QUALIFIED_NAME_PROPERTY_NAME, methodName);
    qualifiedName = repositoryHelper.getExactMatchRegex(qualifiedName);
    InstanceProperties properties = repositoryHelper.addStringPropertyToInstance(serviceName, null, CommonMapper.QUALIFIED_NAME_PROPERTY_NAME, qualifiedName, methodName);
    TypeDef entityTypeDef = repositoryHelper.getTypeDefByName(userId, entityTypeName);
    Optional<EntityDetail> retrievedEntity = Optional.ofNullable(repositoryHandler.getUniqueEntityByName(userId, qualifiedName, CommonMapper.QUALIFIED_NAME_PROPERTY_NAME, properties, entityTypeDef.getGUID(), entityTypeDef.getName(), methodName));
    log.trace(""Searching for entity with qualifiedName: {}. Result is {}"", qualifiedName, retrievedEntity.map(InstanceHeader::getGUID).orElse(null));
    return retrievedEntity;
}","public Optional<EntityDetail> findEntity(String userId, String qualifiedName, String entityTypeName) throws UserNotAuthorizedException, PropertyServerException, InvalidParameterException{
    final String methodName = ""findEntity"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateName(qualifiedName, CommonMapper.QUALIFIED_NAME_PROPERTY_NAME, methodName);
    qualifiedName = repositoryHelper.getExactMatchRegex(qualifiedName);
    InstanceProperties properties = repositoryHelper.addStringPropertyToInstance(serviceName, null, CommonMapper.QUALIFIED_NAME_PROPERTY_NAME, qualifiedName, methodName);
    TypeDef entityTypeDef = repositoryHelper.getTypeDefByName(userId, entityTypeName);
    Optional<EntityDetail> retrievedEntity = Optional.ofNullable(repositoryHandler.getUniqueEntityByName(userId, qualifiedName, CommonMapper.QUALIFIED_NAME_PROPERTY_NAME, properties, entityTypeDef.getGUID(), entityTypeDef.getName(), methodName));
    log.trace(""Searching for entity with qualifiedName: {}. Result is {}"", qualifiedName, retrievedEntity.map(InstanceHeader::getGUID).orElse(null));
    return retrievedEntity;
}","/**
     * Find out if the entity is already stored in the repository. It uses the fully qualified name to retrieve the entity
     *
     * @param userId         the name of the calling user
     * @param qualifiedName  the qualifiedName name of the entity to be searched
     * @param entityTypeName the type name of the entity
     *
     * @return optional with entity details if found, empty optional if not found
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */","('findEntity', {'INSTRUCTION': {'covered': 59, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",159.0,  Find out if the entity is already stored in the repository.,12.0,"['If the entity is already in the repository, you should know about it.', 'If the entity is already in the repository, you should find it.', 'If the entity is already in the repository, you should find out.']"
797,cdk,org/openscience/cdk/smiles/SmilesParser.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/SmilesParser.java,parseMolCXSMILES,301-327,"/**
     * Parses CXSMILES layer and set attributes for atoms and bonds on the provided molecule.
     *
     * @param title SMILES title field
     * @param mol   molecule
     */
private void parseMolCXSMILES(String title, IAtomContainer mol) throws InvalidSmilesException{
    CxSmilesState cxstate;
    int pos;
    if (title != null && title.startsWith(""|"")) {
        if ((pos = CxSmilesParser.processCx(title, cxstate = new CxSmilesState())) >= 0) {
            mol.setTitle(title.substring(pos));
            final Map<IAtom, IAtomContainer> atomToMol = new HashMap<>(2 * mol.getAtomCount());
            final List<IAtom> atoms = new ArrayList<>(mol.getAtomCount());
            for (IAtom atom : mol.atoms()) {
                atoms.add(atom);
                atomToMol.put(atom, mol);
            }
            assignCxSmilesInfo(mol.getBuilder(), mol, atoms, atomToMol, cxstate);
        }
    }
}","private void parseMolCXSMILES(String title, IAtomContainer mol) throws InvalidSmilesException{
    CxSmilesState cxstate;
    int pos;
    if (title != null && title.startsWith(""|"")) {
        if ((pos = CxSmilesParser.processCx(title, cxstate = new CxSmilesState())) >= 0) {
            mol.setTitle(title.substring(pos));
            final Map<IAtom, IAtomContainer> atomToMol = new HashMap<>(2 * mol.getAtomCount());
            final List<IAtom> atoms = new ArrayList<>(mol.getAtomCount());
            for (IAtom atom : mol.atoms()) {
                atoms.add(atom);
                atomToMol.put(atom, mol);
            }
            assignCxSmilesInfo(mol.getBuilder(), mol, atoms, atomToMol, cxstate);
        }
    }
}","/**
     * Parses CXSMILES layer and set attributes for atoms and bonds on the provided molecule.
     *
     * @param title SMILES title field
     * @param mol   molecule
     */","('parseMolCXSMILES', {'INSTRUCTION': {'covered': 65, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",159.0,  Parses CXSMILES layer and set attributes for atoms and bonds on the provided molecule.,15.0,"['Set attributes for atoms and bonds on the provided molecule.', 'Set attributes for atoms and bonds on the provided molecule by Parses it.', 'Set attributes for atoms and bonds on the provided molecule by Parses the CXSMILES layer.']"
798,acs-aem-commons,com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,/bundle/src/main/java/com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,shouldProcess,122-156,"/**
     * Checks the current URL path against the included and excluded patterns. Exclusions hold priority.
     *
     * @param urlPath Current request path
     * @return if the request should be processed
     */
private boolean shouldProcess(String urlPath){
    // If includes are specified but none are valid we skip all requests.
    if (allInvalidIncludes) {
        LOG.debug(""Include patterns are empty due to invalid regex patterns, not processing any requests"");
        return false;
    }
    // If include and exclude lists are both empty we process all requests.
    if (includePatterns.isEmpty() && excludePatterns.isEmpty()) {
        LOG.debug(""Include and Exclude patterns are empty, processing all requests"");
        return true;
    }
    boolean shouldProcess = false;
    for (Pattern pattern : includePatterns) {
        if (pattern.matcher(urlPath).matches()) {
            LOG.debug(""URL path {} matches INCLUDE pattern {}"", urlPath, pattern.toString());
            shouldProcess = true;
            break;
        }
    }
    for (Pattern pattern : excludePatterns) {
        if (pattern.matcher(urlPath).matches()) {
            LOG.debug(""URL path {} matches EXCLUDE pattern {}"", urlPath, pattern.toString());
            shouldProcess = false;
            break;
        }
    }
    LOG.debug(""URL path {} is processed: {}"", urlPath, shouldProcess);
    return shouldProcess;
}","private boolean shouldProcess(String urlPath){
    // If includes are specified but none are valid we skip all requests.
    if (allInvalidIncludes) {
        LOG.debug(""Include patterns are empty due to invalid regex patterns, not processing any requests"");
        return false;
    }
    // If include and exclude lists are both empty we process all requests.
    if (includePatterns.isEmpty() && excludePatterns.isEmpty()) {
        LOG.debug(""Include and Exclude patterns are empty, processing all requests"");
        return true;
    }
    boolean shouldProcess = false;
    for (Pattern pattern : includePatterns) {
        if (pattern.matcher(urlPath).matches()) {
            LOG.debug(""URL path {} matches INCLUDE pattern {}"", urlPath, pattern.toString());
            shouldProcess = true;
            break;
        }
    }
    for (Pattern pattern : excludePatterns) {
        if (pattern.matcher(urlPath).matches()) {
            LOG.debug(""URL path {} matches EXCLUDE pattern {}"", urlPath, pattern.toString());
            shouldProcess = false;
            break;
        }
    }
    LOG.debug(""URL path {} is processed: {}"", urlPath, shouldProcess);
    return shouldProcess;
}","/**
     * Checks the current URL path against the included and excluded patterns. Exclusions hold priority.
     *
     * @param urlPath Current request path
     * @return if the request should be processed
     */","('shouldProcess', {'INSTRUCTION': {'covered': 81, 'missed': 2}, 'BRANCH': {'covered': 10, 'missed': 4}, 'LINE': {'covered': 19, 'missed': 2}, 'COMPLEXITY': {'covered': 4, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",160.0,  Checks the current URL path against the included and excluded patterns.,12.0,"['The current URL path is checked against the included and excluded patterns.', 'The current URL path is checked against included and excluded patterns.', 'The current URL path is checked against the excluded patterns.']"
802,anserini,io/anserini/index/IndexReaderUtils.java,/src/main/java/io/anserini/index/IndexReaderUtils.java,computeQueryDocumentScoreWithSimilarityAndAnalyzer,691-727,"/**
   * Computes the score of a document with respect to a query given a scoring function and an analyzer.
   *
   * @param reader index reader
   * @param docid docid of the document to score
   * @param q query
   * @param similarity scoring function
   * @param analyzer analyzer to use
   * @return the score of the document with respect to the query
   * @throws IOException if error encountered during query
   */
public static float computeQueryDocumentScoreWithSimilarityAndAnalyzer(IndexReader reader, String docid, String q, Similarity similarity, Analyzer analyzer) throws IOException{
    IndexSearcher searcher = new IndexSearcher(reader);
    searcher.setSimilarity(similarity);
    Query query = new BagOfWordsQueryGenerator().buildQuery(IndexArgs.CONTENTS, analyzer, q);
    Query filterQuery = new ConstantScoreQuery(new TermQuery(new Term(IndexArgs.ID, docid)));
    BooleanQuery.Builder builder = new BooleanQuery.Builder();
    builder.add(filterQuery, BooleanClause.Occur.MUST);
    builder.add(query, BooleanClause.Occur.MUST);
    Query finalQuery = builder.build();
    TopDocs rs = searcher.search(finalQuery, 1);
    return rs.scoreDocs.length == 0 ? 0 : rs.scoreDocs[0].score - 1;
}","public static float computeQueryDocumentScoreWithSimilarityAndAnalyzer(IndexReader reader, String docid, String q, Similarity similarity, Analyzer analyzer) throws IOException{
    IndexSearcher searcher = new IndexSearcher(reader);
    searcher.setSimilarity(similarity);
    Query query = new BagOfWordsQueryGenerator().buildQuery(IndexArgs.CONTENTS, analyzer, q);
    Query filterQuery = new ConstantScoreQuery(new TermQuery(new Term(IndexArgs.ID, docid)));
    BooleanQuery.Builder builder = new BooleanQuery.Builder();
    builder.add(filterQuery, BooleanClause.Occur.MUST);
    builder.add(query, BooleanClause.Occur.MUST);
    Query finalQuery = builder.build();
    TopDocs rs = searcher.search(finalQuery, 1);
    return rs.scoreDocs.length == 0 ? 0 : rs.scoreDocs[0].score - 1;
}","/**
   * Computes the score of a document with respect to a query given a scoring function and an analyzer.
   *
   * @param reader index reader
   * @param docid docid of the document to score
   * @param q query
   * @param similarity scoring function
   * @param analyzer analyzer to use
   * @return the score of the document with respect to the query
   * @throws IOException if error encountered during query
   */","('computeQueryDocumentScoreWithSimilarityAndAnalyzer', {'INSTRUCTION': {'covered': 64, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",161.0,  Computes the score of a document with respect to a query given a scoring function and an analyzer.,19.0,"['The score of a document is computed by using a scoring function and an analyzer.', 'The score of a document is calculated by using a scoring function and an analyzer.', 'The score of a document is computed with respect to a query and a scoring function.']"
803,cdk,org/openscience/cdk/qsar/descriptors/bond/BondSigmaElectronegativityDescriptor.java,/descriptor/qsarbond/src/main/java/org/openscience/cdk/qsar/descriptors/bond/BondSigmaElectronegativityDescriptor.java,calculate,124-154,"/**
     *  The method calculates the sigma electronegativity of a given bond
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *
     *@param  atomContainer                AtomContainer
     *@return return the sigma electronegativity
     */
public DescriptorValue calculate(IBond aBond, IAtomContainer atomContainer){
    IAtomContainer ac;
    IBond bond;
    try {
        ac = (IAtomContainer) atomContainer.clone();
        bond = ac.getBond(atomContainer.indexOf(aBond));
        AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(ac);
    } catch (CDKException e) {
        return getDummyDescriptorValue(e);
    } catch (CloneNotSupportedException e) {
        return getDummyDescriptorValue(e);
    }
    if (maxIterations != -1 && maxIterations != 0)
        electronegativity.setMaxIterations(maxIterations);
    double electroAtom1 = electronegativity.calculateSigmaElectronegativity(ac, bond.getBegin());
    double electroAtom2 = electronegativity.calculateSigmaElectronegativity(ac, bond.getEnd());
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(Math.abs(electroAtom1 - electroAtom2)), NAMES);
}","public DescriptorValue calculate(IBond aBond, IAtomContainer atomContainer){
    IAtomContainer ac;
    IBond bond;
    try {
        ac = (IAtomContainer) atomContainer.clone();
        bond = ac.getBond(atomContainer.indexOf(aBond));
        AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(ac);
    } catch (CDKException e) {
        return getDummyDescriptorValue(e);
    } catch (CloneNotSupportedException e) {
        return getDummyDescriptorValue(e);
    }
    if (maxIterations != -1 && maxIterations != 0)
        electronegativity.setMaxIterations(maxIterations);
    double electroAtom1 = electronegativity.calculateSigmaElectronegativity(ac, bond.getBegin());
    double electroAtom2 = electronegativity.calculateSigmaElectronegativity(ac, bond.getEnd());
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(Math.abs(electroAtom1 - electroAtom2)), NAMES);
}","/**
     *  The method calculates the sigma electronegativity of a given bond
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *
     *@param  atomContainer                AtomContainer
     *@return return the sigma electronegativity
     */","('calculate', {'INSTRUCTION': {'covered': 56, 'missed': 10}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 9, 'missed': 4}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",161.0,  The method calculates the sigma electronegativity of a given bond  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.,23.0,"['The class tools allow the addExplicitHydrogensToSatisfyValency method to be used.', 'The class tools allow the addExplicitHydrogensToSatisfyValency method to be called.', 'The class tools allow the addExplicitHydrogensToSatisfyValency method to be called from the method.']"
804,cdk,org/openscience/cdk/qsar/descriptors/molecular/FractionalCSP3Descriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/FractionalCSP3Descriptor.java,calculate,84-116,"/**
     * Calculates the Fsp<sup>3</sup> descriptor value for the given {@link IAtomContainer}.
     *
     * @param mol An {@link org.openscience.cdk.interfaces.IAtomContainer} for which this descriptor
     *            should be calculated
     * @return An object of {@link org.openscience.cdk.qsar.DescriptorValue} that contains the
     *         calculated Fsp<sup>3</sup> descriptor value
     */
public DescriptorValue calculate(IAtomContainer mol){
    DoubleResult result;
    try {
        int nC = 0;
        int nCSP3 = 0;
        CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.getInstance(mol.getBuilder());
        for (IAtom atom : mol.atoms()) {
            if (atom.getAtomicNumber() == 6) {
                nC++;
                IAtomType matched = matcher.findMatchingAtomType(mol, atom);
                if (matched != null && matched.getHybridization() == IAtomType.Hybridization.SP3) {
                    nCSP3++;
                }
            }
        }
        result = new DoubleResult(nC == 0 ? 0 : (double) nCSP3 / nC);
    } catch (CDKException e) {
        result = new DoubleResult(Double.NaN);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result, getDescriptorNames());
}","public DescriptorValue calculate(IAtomContainer mol){
    DoubleResult result;
    try {
        int nC = 0;
        int nCSP3 = 0;
        CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.getInstance(mol.getBuilder());
        for (IAtom atom : mol.atoms()) {
            if (atom.getAtomicNumber() == 6) {
                nC++;
                IAtomType matched = matcher.findMatchingAtomType(mol, atom);
                if (matched != null && matched.getHybridization() == IAtomType.Hybridization.SP3) {
                    nCSP3++;
                }
            }
        }
        result = new DoubleResult(nC == 0 ? 0 : (double) nCSP3 / nC);
    } catch (CDKException e) {
        result = new DoubleResult(Double.NaN);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result, getDescriptorNames());
}","/**
     * Calculates the Fsp<sup>3</sup> descriptor value for the given {@link IAtomContainer}.
     *
     * @param mol An {@link org.openscience.cdk.interfaces.IAtomContainer} for which this descriptor
     *            should be calculated
     * @return An object of {@link org.openscience.cdk.qsar.DescriptorValue} that contains the
     *         calculated Fsp<sup>3</sup> descriptor value
     */","('calculate', {'INSTRUCTION': {'covered': 65, 'missed': 6}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 14, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",161.0,Calculates the Fsp<sup>3</sup> descriptor value for the given {@link IAtomContainer}.,21.0,"['The Fspsup>3/sup> descriptor value is calculated.', 'The given @link IAtomContainer has a Fspsup>3 value.', 'The given @link IAtomContainer has a Fspsup>3/sup> descriptor value.']"
805,twilio-java,com/twilio/jwt/validation/RequestCanonicalizer.java,/src/main/java/com/twilio/jwt/validation/RequestCanonicalizer.java,replace,168-201,"/**
     * Replaces the special characters in the URLEncoded string with the replacement values defined by the spec.
     *
     * Partially copied from https://github.com/aws/aws-sdk-java: com.amazonaws.util.SdkHttpUtils (2017-05-19)
     *
     * @param string       the string to replace characters in
     * @param replaceSlash whether the encoded '/' should be replaced
     * @return the string after replacements
     */
private static String replace(String string, boolean replaceSlash){
    if (string == null || string.isEmpty()) {
        return string;
    }
    StringBuffer buffer = new StringBuffer(string.length());
    Matcher matcher = TOKEN_REPLACE_PATTERN.matcher(string);
    while (matcher.find()) {
        String replacement = matcher.group(0);
        if (""+"".equals(replacement)) {
            replacement = ""%20"";
        } else if (""*"".equals(replacement)) {
            replacement = ""%2A"";
        } else if (""%7E"".equals(replacement)) {
            replacement = ""~"";
        } else if (replaceSlash && ""%2F"".equals(replacement)) {
            replacement = ""/"";
        }
        matcher.appendReplacement(buffer, replacement);
    }
    matcher.appendTail(buffer);
    return buffer.toString();
}","private static String replace(String string, boolean replaceSlash){
    if (string == null || string.isEmpty()) {
        return string;
    }
    StringBuffer buffer = new StringBuffer(string.length());
    Matcher matcher = TOKEN_REPLACE_PATTERN.matcher(string);
    while (matcher.find()) {
        String replacement = matcher.group(0);
        if (""+"".equals(replacement)) {
            replacement = ""%20"";
        } else if (""*"".equals(replacement)) {
            replacement = ""%2A"";
        } else if (""%7E"".equals(replacement)) {
            replacement = ""~"";
        } else if (replaceSlash && ""%2F"".equals(replacement)) {
            replacement = ""/"";
        }
        matcher.appendReplacement(buffer, replacement);
    }
    matcher.appendTail(buffer);
    return buffer.toString();
}","/**
     * Replaces the special characters in the URLEncoded string with the replacement values defined by the spec.
     *
     * Partially copied from https://github.com/aws/aws-sdk-java: com.amazonaws.util.SdkHttpUtils (2017-05-19)
     *
     * @param string       the string to replace characters in
     * @param replaceSlash whether the encoded '/' should be replaced
     * @return the string after replacements
     */","('replace', {'INSTRUCTION': {'covered': 66, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",161.0,  Replaces the special characters in the URLEncoded string with the replacement values defined by the spec.,17.0,"['The replacement values are defined by the spec.', 'The special characters in the URLEncoded string are replaced with the replacement values defined by the spec.', 'The special characters in the URLEncoded string are replaced with replacement values.']"
806,acs-aem-commons,com/adobe/acs/commons/data/Spreadsheet.java,/bundle/src/main/java/com/adobe/acs/commons/data/Spreadsheet.java,detectTypeFromName,306-347,"/**
     * Look for type hints in the name of a column to extract a usable type.
     * Also look for array hints as well. <br>
     * Possible formats:
     * <ul>
     * <li>column-name - A column named ""column-name"" </li>
     * <li>col@int - An integer column named ""col"" </li>
     * <li>col2@int[] - An integer array colum named ""col2"", assumes standard
     * delimiter (,) </li>
     * <li>col3@string[] or col3@[] - A String array named ""col3"", assumes
     * standard delimiter (,)</li>
     * <li>col4@string[||] - A string array where values are using a custom
     * delimiter (||)</li>
     * </ul>
     *
     * @param name
     * @return
     */
private Optional<Class> detectTypeFromName(String name){
    boolean isArray = false;
    Class detectedClass = Object.class;
    if (name.contains(""@"")) {
        String typeStr = StringUtils.substringAfter(name, ""@"");
        if (typeStr.contains(""["")) {
            typeStr = StringUtils.substringBefore(typeStr, ""["");
        }
        detectedClass = getClassFromName(typeStr);
    }
    if (name.endsWith(""]"")) {
        isArray = true;
        String delimiter = StringUtils.substringBetween(name, ""["", ""]"");
        if (!StringUtils.isEmpty(delimiter)) {
            String colName = convertHeaderName(name);
            delimiters.put(colName, delimiter);
        }
    }
    if (isArray) {
        return getArrayType(Optional.of(detectedClass));
    } else {
        return Optional.of(detectedClass);
    }
}","private Optional<Class> detectTypeFromName(String name){
    boolean isArray = false;
    Class detectedClass = Object.class;
    if (name.contains(""@"")) {
        String typeStr = StringUtils.substringAfter(name, ""@"");
        if (typeStr.contains(""["")) {
            typeStr = StringUtils.substringBefore(typeStr, ""["");
        }
        detectedClass = getClassFromName(typeStr);
    }
    if (name.endsWith(""]"")) {
        isArray = true;
        String delimiter = StringUtils.substringBetween(name, ""["", ""]"");
        if (!StringUtils.isEmpty(delimiter)) {
            String colName = convertHeaderName(name);
            delimiters.put(colName, delimiter);
        }
    }
    if (isArray) {
        return getArrayType(Optional.of(detectedClass));
    } else {
        return Optional.of(detectedClass);
    }
}","/**
     * Look for type hints in the name of a column to extract a usable type.
     * Also look for array hints as well. <br>
     * Possible formats:
     * <ul>
     * <li>column-name - A column named ""column-name"" </li>
     * <li>col@int - An integer column named ""col"" </li>
     * <li>col2@int[] - An integer array colum named ""col2"", assumes standard
     * delimiter (,) </li>
     * <li>col3@string[] or col3@[] - A String array named ""col3"", assumes
     * standard delimiter (,)</li>
     * <li>col4@string[||] - A string array where values are using a custom
     * delimiter (||)</li>
     * </ul>
     *
     * @param name
     * @return
     */","('detectTypeFromName', {'INSTRUCTION': {'covered': 57, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",162.0,  Look for type hints in the name of a column to extract a usable type.,16.0,"['To get a usable type, look for type hints in the name of the column.', 'To get a usable type, look for hints in the name of the column.', 'To get a usable type, look for type hints in the column name.']"
808,cactoos,org/cactoos/scalar/ScalarWithFallback.java,/src/main/java/org/cactoos/scalar/ScalarWithFallback.java,fallback,99-135,"/**
     * Finds the best fallback for the given exception type and apply it to
     * the exception or throw the original error if no fallback found.
     * @param exp The original exception
     * @return Result of the most suitable fallback
     * @throws Exception The original exception if no fallback found
     */
private T fallback(final Throwable exp) throws Exception{
    final Iterator<Map.Entry<Fallback<T>, Integer>> candidates = new Sorted<>(Comparator.comparing(Map.Entry::getValue), new Filtered<>(new org.cactoos.func.Flattened<>(entry -> new Not(new Equals<Integer, Integer>(entry::getValue, new Constant<>(Integer.MIN_VALUE)))), new MapOf<>(fbk -> fbk, fbk -> fbk.support(exp), this.fallbacks).entrySet().iterator()));
    if (candidates.hasNext()) {
        return candidates.next().getKey().apply(exp);
    } else {
        throw new Exception(""No fallback found - throw the original exception"", exp);
    }
}","private T fallback(final Throwable exp) throws Exception{
    final Iterator<Map.Entry<Fallback<T>, Integer>> candidates = new Sorted<>(Comparator.comparing(Map.Entry::getValue), new Filtered<>(new org.cactoos.func.Flattened<>(entry -> new Not(new Equals<Integer, Integer>(entry::getValue, new Constant<>(Integer.MIN_VALUE)))), new MapOf<>(fbk -> fbk, fbk -> fbk.support(exp), this.fallbacks).entrySet().iterator()));
    if (candidates.hasNext()) {
        return candidates.next().getKey().apply(exp);
    } else {
        throw new Exception(""No fallback found - throw the original exception"", exp);
    }
}","/**
     * Finds the best fallback for the given exception type and apply it to
     * the exception or throw the original error if no fallback found.
     * @param exp The original exception
     * @return Result of the most suitable fallback
     * @throws Exception The original exception if no fallback found
     */","('fallback', {'INSTRUCTION': {'covered': 40, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",162.0,  Finds the best fallback for the given exception type and apply it to  the exception or throw the original error if no fallback found.,25.0,"['If no fallback is found, apply it to the exception or throw the original error.', 'If no fallback is found, throw the original error or find the best one.', 'If there is no fallback for the given exception type, throw the original error.']"
810,cdk,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,positionChargeLabel,493-526,"/**
     * Position the charge label on the top right of either the element or hydrogen label. Where the
     * charge is placed depends on the number of hydrogens and their position relative to the
     * element symbol.
     *
     * @param hydrogens number of hydrogen
     * @param position  position of hydrogen
     * @param charge    the charge label outline (to be positioned)
     * @param element   the element label outline
     * @param hydrogen  the hydrogen label outline
     * @return positioned charge label
     */
 TextOutline positionChargeLabel(int hydrogens, HydrogenPosition position, TextOutline charge, TextOutline element, TextOutline hydrogen){
    final Rectangle2D chargeBounds = charge.getBounds();
    Rectangle2D referenceBounds = element.getBounds();
    if (hydrogens > 0 && (position == Left || position == Right))
        referenceBounds = hydrogen.getBounds();
    if (position == Left)
        return charge.translate((referenceBounds.getMinX() - padding) - chargeBounds.getMaxX(), (referenceBounds.getMinY() - (chargeBounds.getHeight() / 2)) - chargeBounds.getMinY());
    else
        return charge.translate((referenceBounds.getMaxX() + padding) - chargeBounds.getMinX(), (referenceBounds.getMinY() - (chargeBounds.getHeight() / 2)) - chargeBounds.getMinY());
}","TextOutline positionChargeLabel(int hydrogens, HydrogenPosition position, TextOutline charge, TextOutline element, TextOutline hydrogen){
    final Rectangle2D chargeBounds = charge.getBounds();
    Rectangle2D referenceBounds = element.getBounds();
    if (hydrogens > 0 && (position == Left || position == Right))
        referenceBounds = hydrogen.getBounds();
    if (position == Left)
        return charge.translate((referenceBounds.getMinX() - padding) - chargeBounds.getMaxX(), (referenceBounds.getMinY() - (chargeBounds.getHeight() / 2)) - chargeBounds.getMinY());
    else
        return charge.translate((referenceBounds.getMaxX() + padding) - chargeBounds.getMinX(), (referenceBounds.getMinY() - (chargeBounds.getHeight() / 2)) - chargeBounds.getMinY());
}","/**
     * Position the charge label on the top right of either the element or hydrogen label. Where the
     * charge is placed depends on the number of hydrogens and their position relative to the
     * element symbol.
     *
     * @param hydrogens number of hydrogen
     * @param position  position of hydrogen
     * @param charge    the charge label outline (to be positioned)
     * @param element   the element label outline
     * @param hydrogen  the hydrogen label outline
     * @return positioned charge label
     */","('positionChargeLabel', {'INSTRUCTION': {'covered': 62, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",162.0,  Position the charge label on the top right of either the element or hydrogen label.,16.0,"['The element or hydrogen label should be placed on the charge label.', 'The charge label should be on the top right of the element.', 'The charge label should be placed on the top right of the element.']"
811,cdk,org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricCumulativeDoubleBondFactory.java,fill2DCoordinates,215-253,"/**
     * Fill the {@literal coordinates} and {@literal elevation} from the given
     * offset index. If there is only one connection then the second entry (from
     * the offset) will use the coordinates of <i>a</i>. The permutation parity
     * is also built and returned.
     *
     * @param container   atom container
     * @param a           the central atom
     * @param connected   bonds connected to the central atom
     * @param coordinates the coordinates array to fill
     * @param elevations  the elevations of the connected atoms
     * @param offset      current location in the offset array
     * @return the permutation parity
     */
private static PermutationParity fill2DCoordinates(IAtomContainer container, IAtom a, List<IBond> connected, Point2d[] coordinates, int[] elevations, int offset){
    int i = 0;
    coordinates[offset + 1] = a.getPoint2d();
    elevations[offset + 1] = 0;
    int[] indices = new int[2];
    for (IBond bond : connected) {
        if (!isDoubleBond(bond)) {
            IAtom other = bond.getOther(a);
            coordinates[i + offset] = other.getPoint2d();
            elevations[i + offset] = elevation(bond, a);
            indices[i] = container.indexOf(other);
            i++;
        }
    }
    if (i == 1) {
        return PermutationParity.IDENTITY;
    } else {
        return new BasicPermutationParity(indices);
    }
}","private static PermutationParity fill2DCoordinates(IAtomContainer container, IAtom a, List<IBond> connected, Point2d[] coordinates, int[] elevations, int offset){
    int i = 0;
    coordinates[offset + 1] = a.getPoint2d();
    elevations[offset + 1] = 0;
    int[] indices = new int[2];
    for (IBond bond : connected) {
        if (!isDoubleBond(bond)) {
            IAtom other = bond.getOther(a);
            coordinates[i + offset] = other.getPoint2d();
            elevations[i + offset] = elevation(bond, a);
            indices[i] = container.indexOf(other);
            i++;
        }
    }
    if (i == 1) {
        return PermutationParity.IDENTITY;
    } else {
        return new BasicPermutationParity(indices);
    }
}","/**
     * Fill the {@literal coordinates} and {@literal elevation} from the given
     * offset index. If there is only one connection then the second entry (from
     * the offset) will use the coordinates of <i>a</i>. The permutation parity
     * is also built and returned.
     *
     * @param container   atom container
     * @param a           the central atom
     * @param connected   bonds connected to the central atom
     * @param coordinates the coordinates array to fill
     * @param elevations  the elevations of the connected atoms
     * @param offset      current location in the offset array
     * @return the permutation parity
     */","('fill2DCoordinates', {'INSTRUCTION': {'covered': 68, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",164.0,  Fill the {@literal coordinates} and {@literal elevation} from the given  offset index.,19.0,"['From the given offset index, fill the @literal coordinates and @literal elevation.', 'From the given offset index, fill in the @literal coordinates and @literal elevation.', 'From the given offset index, fill in the coordinates @literal coordinates and @literal elevation.']"
812,tablesaw,tech/tablesaw/joining/DataFrameJoiner.java,/core/src/main/java/tech/tablesaw/joining/DataFrameJoiner.java,crossProduct,836-873,"/**
   * Creates cross product for the selection of two tables.
   *
   * @param destination the destination table.
   * @param table1 the table on left of join.
   * @param table2 the table on right of join.
   * @param table1Rows the selection of rows in table1.
   * @param table2Rows the selection of rows in table2.
   * @param ignoreColumns a set of column indexes in the result to ignore. They are redundant join
   *     columns.
   */
private void crossProduct(Table destination, Table table1, Table table2, Selection table1Rows, Selection table2Rows, Set<Integer> ignoreColumns, boolean keepTable2JoinKeyColumns){
    for (int c = 0; c < table1.columnCount() + table2.columnCount(); c++) {
        if (!keepTable2JoinKeyColumns && ignoreColumns.contains(c)) {
            continue;
        }
        int table2Index = c - table1.columnCount();
        for (int r1 : table1Rows) {
            for (int r2 : table2Rows) {
                if (c < table1.columnCount()) {
                    Column t1Col = table1.column(c);
                    destination.column(c).append(t1Col, r1);
                } else {
                    Column t2Col = table2.column(table2Index);
                    destination.column(c).append(t2Col, r2);
                }
            }
        }
    }
}","private void crossProduct(Table destination, Table table1, Table table2, Selection table1Rows, Selection table2Rows, Set<Integer> ignoreColumns, boolean keepTable2JoinKeyColumns){
    for (int c = 0; c < table1.columnCount() + table2.columnCount(); c++) {
        if (!keepTable2JoinKeyColumns && ignoreColumns.contains(c)) {
            continue;
        }
        int table2Index = c - table1.columnCount();
        for (int r1 : table1Rows) {
            for (int r2 : table2Rows) {
                if (c < table1.columnCount()) {
                    Column t1Col = table1.column(c);
                    destination.column(c).append(t1Col, r1);
                } else {
                    Column t2Col = table2.column(table2Index);
                    destination.column(c).append(t2Col, r2);
                }
            }
        }
    }
}","/**
   * Creates cross product for the selection of two tables.
   *
   * @param destination the destination table.
   * @param table1 the table on left of join.
   * @param table2 the table on right of join.
   * @param table1Rows the selection of rows in table1.
   * @param table2Rows the selection of rows in table2.
   * @param ignoreColumns a set of column indexes in the result to ignore. They are redundant join
   *     columns.
   */","('crossProduct', {'INSTRUCTION': {'covered': 76, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",164.0,  Creates cross product for the selection of two tables.,10.0,"['Cross product is created for the two tables.', 'Cross product is created for the selection of two tables.', 'Cross product is created for two tables.']"
813,cdk,org/openscience/cdk/fingerprint/model/Bayesian.java,/tool/model/src/main/java/org/openscience/cdk/fingerprint/model/Bayesian.java,predict,265-297,"/**
     * For a given molecule, determines its fingerprints and uses them to calculate a Bayesian prediction. Note that this
     * value is unscaled, and so it only has relative meaning within the confines of the model, i.e. higher is more likely to
     * be active.
     * 
     * @param mol molecular structure which cannot be blank or null
     * @return predictor value
     */
public double predict(IAtomContainer mol) throws CDKException{
    if (mol == null || mol.getAtomCount() == 0)
        throw new CDKException(""Molecule cannot be blank or null."");
    CircularFingerprinter circ = new CircularFingerprinter(classType);
    circ.setPerceiveStereo(optPerceiveStereo);
    circ.calculate(mol);
    final int AND_BITS = folding - 1;
    Set<Integer> hashset = new HashSet<Integer>();
    for (int n = circ.getFPCount() - 1; n >= 0; n--) {
        int code = circ.getFP(n).hashCode;
        if (folding > 0)
            code &= AND_BITS;
        hashset.add(code);
    }
    double val = 0;
    for (int h : hashset) {
        Double c = contribs.get(h);
        if (c != null)
            val += c;
    }
    return val;
}","public double predict(IAtomContainer mol) throws CDKException{
    if (mol == null || mol.getAtomCount() == 0)
        throw new CDKException(""Molecule cannot be blank or null."");
    CircularFingerprinter circ = new CircularFingerprinter(classType);
    circ.setPerceiveStereo(optPerceiveStereo);
    circ.calculate(mol);
    final int AND_BITS = folding - 1;
    Set<Integer> hashset = new HashSet<Integer>();
    for (int n = circ.getFPCount() - 1; n >= 0; n--) {
        int code = circ.getFP(n).hashCode;
        if (folding > 0)
            code &= AND_BITS;
        hashset.add(code);
    }
    double val = 0;
    for (int h : hashset) {
        Double c = contribs.get(h);
        if (c != null)
            val += c;
    }
    return val;
}","/**
     * For a given molecule, determines its fingerprints and uses them to calculate a Bayesian prediction. Note that this
     * value is unscaled, and so it only has relative meaning within the confines of the model, i.e. higher is more likely to
     * be active.
     * 
     * @param mol molecular structure which cannot be blank or null
     * @return predictor value
     */","('predict', {'INSTRUCTION': {'covered': 83, 'missed': 5}, 'BRANCH': {'covered': 8, 'missed': 4}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",165.0,"  For a given molecule, determines its fingerprints and uses them to calculate a Bayesian prediction.",17.0,"[""A molecule's fingerprints are used to calculate a prediction."", ""A molecule's fingerprints are used to calculate a Bayesian prediction."", ""A molecule's fingerprints can be used to calculate a prediction.""]"
815,openapi-generator,org/openapitools/codegen/utils/OneOfImplementorAdditionalData.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/OneOfImplementorAdditionalData.java,addFromInterfaceModel,59-94,"/**
     * Add data from a given CodegenModel that the oneOf implementor should implement. For example:
     *
     * @param cm model that the implementor should implement
     * @param modelsImports imports of the given `cm`
     */
public void addFromInterfaceModel(CodegenModel cm, List<Map<String, String>> modelsImports){
    // Add cm as implemented interface
    additionalInterfaces.add(cm.classname);
    // Add all vars defined on cm
    // a ""oneOf"" model (cm) by default inherits all properties from its ""interfaceModels"",
    // but we only want to add properties defined on cm itself
    List<CodegenProperty> toAdd = new ArrayList<CodegenProperty>(cm.vars);
    // note that we can't just toAdd.removeAll(m.vars) for every interfaceModel,
    // as they might have different value of `hasMore` and thus are not equal
    List<String> omitAdding = new ArrayList<String>();
    if (cm.interfaceModels != null) {
        for (CodegenModel m : cm.interfaceModels) {
            for (CodegenProperty v : m.vars) {
                omitAdding.add(v.baseName);
            }
        }
    }
    for (CodegenProperty v : toAdd) {
        if (!omitAdding.contains(v.baseName)) {
            additionalProps.add(v.clone());
        }
    }
    // Add all imports of cm
    for (Map<String, String> importMap : modelsImports) {
        // we're ok with shallow clone here, because imports are strings only
        additionalImports.add(new HashMap<String, String>(importMap));
    }
}","public void addFromInterfaceModel(CodegenModel cm, List<Map<String, String>> modelsImports){
    // Add cm as implemented interface
    additionalInterfaces.add(cm.classname);
    // Add all vars defined on cm
    // a ""oneOf"" model (cm) by default inherits all properties from its ""interfaceModels"",
    // but we only want to add properties defined on cm itself
    List<CodegenProperty> toAdd = new ArrayList<CodegenProperty>(cm.vars);
    // note that we can't just toAdd.removeAll(m.vars) for every interfaceModel,
    // as they might have different value of `hasMore` and thus are not equal
    List<String> omitAdding = new ArrayList<String>();
    if (cm.interfaceModels != null) {
        for (CodegenModel m : cm.interfaceModels) {
            for (CodegenProperty v : m.vars) {
                omitAdding.add(v.baseName);
            }
        }
    }
    for (CodegenProperty v : toAdd) {
        if (!omitAdding.contains(v.baseName)) {
            additionalProps.add(v.clone());
        }
    }
    // Add all imports of cm
    for (Map<String, String> importMap : modelsImports) {
        // we're ok with shallow clone here, because imports are strings only
        additionalImports.add(new HashMap<String, String>(importMap));
    }
}","/**
     * Add data from a given CodegenModel that the oneOf implementor should implement. For example:
     *
     * @param cm model that the implementor should implement
     * @param modelsImports imports of the given `cm`
     */","('addFromInterfaceModel', {'INSTRUCTION': {'covered': 90, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",165.0,  Add data from a given CodegenModel that the oneOf implementor should implement.,13.0,"['The one of implementors should add data from a given CodegenModel.', 'The one of implementors should add data from the CodegenModel.', 'Data from a given CodegenModel should be added to the one of implementor.']"
817,acs-aem-commons,com/adobe/acs/commons/images/impl/ProgressiveJpeg.java,/bundle/src/main/java/com/adobe/acs/commons/images/impl/ProgressiveJpeg.java,write,43-80,"/**
     * For JPEG images, this method behaves similar to {@link Layer#write(String, double, OutputStream)}. The major
     * difference is that it uses progressive encoding.
     *
     * @param layer   the layer with the image to write to the output stream
     * @param quality JPEG compression quality between 0 and 1
     * @param out     target output stream
     * @throws IOException if anything goes wrong
     */
public static void write(Layer layer, double quality, OutputStream out) throws IOException{
    ImageWriter writer = null;
    ImageOutputStream imageOut = null;
    try {
        ImageWriteParam iwp = new JPEGImageWriteParam(null);
        iwp.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
        iwp.setProgressiveMode(ImageWriteParam.MODE_DEFAULT);
        iwp.setCompressionQuality((float) quality);
        writer = ImageIO.getImageWritersBySuffix(""jpeg"").next();
        imageOut = ImageIO.createImageOutputStream(out);
        writer.setOutput(imageOut);
        BufferedImage image = getRgbImage(layer);
        writer.write(null, new IIOImage(image, null, null), iwp);
    } finally {
        if (writer != null) {
            writer.dispose();
        }
        if (imageOut != null) {
            try {
                imageOut.close();
            } catch (IOException e) {
                // ignore
            }
        }
    }
}","public static void write(Layer layer, double quality, OutputStream out) throws IOException{
    ImageWriter writer = null;
    ImageOutputStream imageOut = null;
    try {
        ImageWriteParam iwp = new JPEGImageWriteParam(null);
        iwp.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
        iwp.setProgressiveMode(ImageWriteParam.MODE_DEFAULT);
        iwp.setCompressionQuality((float) quality);
        writer = ImageIO.getImageWritersBySuffix(""jpeg"").next();
        imageOut = ImageIO.createImageOutputStream(out);
        writer.setOutput(imageOut);
        BufferedImage image = getRgbImage(layer);
        writer.write(null, new IIOImage(image, null, null), iwp);
    } finally {
        if (writer != null) {
            writer.dispose();
        }
        if (imageOut != null) {
            try {
                imageOut.close();
            } catch (IOException e) {
                // ignore
            }
        }
    }
}","/**
     * For JPEG images, this method behaves similar to {@link Layer#write(String, double, OutputStream)}. The major
     * difference is that it uses progressive encoding.
     *
     * @param layer   the layer with the image to write to the output stream
     * @param quality JPEG compression quality between 0 and 1
     * @param out     target output stream
     * @throws IOException if anything goes wrong
     */","('write', {'INSTRUCTION': {'covered': 53, 'missed': 1}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 17, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",165.0,"  For JPEG images, this method behaves similar to {@link Layer#write(String, double, OutputStream)}.",24.0,"['This method behaves similar to @link Layer#write(String, double, OutputStream) for JPEG images.', 'The method behaves similar to @link Layer#write(String, double, OutputStream) for JPEG images.', 'This method behaves similar to @link Layer#write(String, double, OutputStream), for JPEG images.']"
818,cdk,org/openscience/cdk/hash/PerturbedAtomHashGenerator.java,/tool/hash/src/main/java/org/openscience/cdk/hash/PerturbedAtomHashGenerator.java,combine,167-200,"/**
     * Combines the values in an n x m matrix into a single array of size n.
     * This process scans the rows and xors all unique values in the row
     * together. If a duplicate value is found it is rotated using a
     * pseudorandom number generator.
     *
     * @param perturbed n x m, matrix
     * @return the combined values of each row
     */
 long[] combine(long[][] perturbed){
    int n = perturbed.length;
    int m = perturbed[0].length;
    long[] combined = new long[n];
    long[] rotated = new long[m];
    for (int i = 0; i < n; i++) {
        Arrays.sort(perturbed[i]);
        for (int j = 0; j < m; j++) {
            if (j > 0 && perturbed[i][j] == perturbed[i][j - 1]) {
                combined[i] ^= rotated[j] = rotate(rotated[j - 1]);
            } else {
                combined[i] ^= rotated[j] = perturbed[i][j];
            }
        }
    }
    return combined;
}","long[] combine(long[][] perturbed){
    int n = perturbed.length;
    int m = perturbed[0].length;
    long[] combined = new long[n];
    long[] rotated = new long[m];
    for (int i = 0; i < n; i++) {
        Arrays.sort(perturbed[i]);
        for (int j = 0; j < m; j++) {
            if (j > 0 && perturbed[i][j] == perturbed[i][j - 1]) {
                combined[i] ^= rotated[j] = rotate(rotated[j - 1]);
            } else {
                combined[i] ^= rotated[j] = perturbed[i][j];
            }
        }
    }
    return combined;
}","/**
     * Combines the values in an n x m matrix into a single array of size n.
     * This process scans the rows and xors all unique values in the row
     * together. If a duplicate value is found it is rotated using a
     * pseudorandom number generator.
     *
     * @param perturbed n x m, matrix
     * @return the combined values of each row
     */","('combine', {'INSTRUCTION': {'covered': 83, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",165.0,  Combines the values in an n x m matrix into a single array of size n.,17.0,"['The values in an n x m matrix are combined into a single array.', 'The values in an n x m matrix are combined into a single array of size n.', 'The values are combined into a single array of size n.']"
819,cdk,org/openscience/cdk/io/Gaussian98Reader.java,/storage/io/src/main/java/org/openscience/cdk/io/Gaussian98Reader.java,parseLevelOfTheory,463-496,"/**
     * Select the theory and basis set from the first archive line.
     *
     * @param line Description of the Parameter
     * @return Description of the Return Value
     */
private String parseLevelOfTheory(String line){
    StringBuffer summary = new StringBuffer();
    summary.append(line);
    try {
        do {
            line = input.readLine().trim();
            summary.append(line);
        } while (!(line.indexOf('@') >= 0));
    } catch (Exception exc) {
        logger.debug(""syntax problem while parsing summary of g98 section: "");
        logger.debug(exc);
    }
    logger.debug(""parseLoT(): "" + summary.toString());
    StringTokenizer st1 = new StringTokenizer(summary.toString(), ""\\"");
    if (st1.countTokens() < 6) {
        return null;
    }
    for (int i = 0; i < 4; ++i) {
        st1.nextToken();
    }
    return st1.nextToken() + ""/"" + st1.nextToken();
}","private String parseLevelOfTheory(String line){
    StringBuffer summary = new StringBuffer();
    summary.append(line);
    try {
        do {
            line = input.readLine().trim();
            summary.append(line);
        } while (!(line.indexOf('@') >= 0));
    } catch (Exception exc) {
        logger.debug(""syntax problem while parsing summary of g98 section: "");
        logger.debug(exc);
    }
    logger.debug(""parseLoT(): "" + summary.toString());
    StringTokenizer st1 = new StringTokenizer(summary.toString(), ""\\"");
    if (st1.countTokens() < 6) {
        return null;
    }
    for (int i = 0; i < 4; ++i) {
        st1.nextToken();
    }
    return st1.nextToken() + ""/"" + st1.nextToken();
}","/**
     * Select the theory and basis set from the first archive line.
     *
     * @param line Description of the Parameter
     * @return Description of the Return Value
     */","('parseLevelOfTheory', {'INSTRUCTION': {'covered': 67, 'missed': 9}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 4}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",165.0,  Select the theory and basis set from the first archive line.,12.0,"['The basis and theory can be found in the first archive line.', 'The basis and theory are from the first archive line.', 'The basis and theory can be selected from the first archive line.']"
820,cdk,org/openscience/cdk/qsar/descriptors/molecular/HybridizationRatioDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/HybridizationRatioDescriptor.java,calculate,112-139,"/**
     * Calculate sp3/sp2 hybridization ratio in the supplied {@link IAtomContainer}.
     *
     * @param container The AtomContainer for which this descriptor is to be calculated.
     * @return The ratio of sp3 to sp2 carbons
     */
public DescriptorValue calculate(IAtomContainer container){
    try {
        IAtomContainer clone = (IAtomContainer) container.clone();
        AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(clone);
        int nsp2 = 0;
        int nsp3 = 0;
        for (IAtom atom : clone.atoms()) {
            if (atom.getAtomicNumber() != IElement.C)
                continue;
            if (atom.getHybridization() == Hybridization.SP2)
                nsp2++;
            else if (atom.getHybridization() == Hybridization.SP3)
                nsp3++;
        }
        double ratio = nsp3 / (double) (nsp2 + nsp3);
        return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(ratio), getDescriptorNames());
    } catch (CloneNotSupportedException e) {
        return getDummyDescriptorValue(e);
    } catch (CDKException e) {
        return getDummyDescriptorValue(e);
    }
}","public DescriptorValue calculate(IAtomContainer container){
    try {
        IAtomContainer clone = (IAtomContainer) container.clone();
        AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(clone);
        int nsp2 = 0;
        int nsp3 = 0;
        for (IAtom atom : clone.atoms()) {
            if (atom.getAtomicNumber() != IElement.C)
                continue;
            if (atom.getHybridization() == Hybridization.SP2)
                nsp2++;
            else if (atom.getHybridization() == Hybridization.SP3)
                nsp3++;
        }
        double ratio = nsp3 / (double) (nsp2 + nsp3);
        return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(ratio), getDescriptorNames());
    } catch (CloneNotSupportedException e) {
        return getDummyDescriptorValue(e);
    } catch (CDKException e) {
        return getDummyDescriptorValue(e);
    }
}","/**
     * Calculate sp3/sp2 hybridization ratio in the supplied {@link IAtomContainer}.
     *
     * @param container The AtomContainer for which this descriptor is to be calculated.
     * @return The ratio of sp3 to sp2 carbons
     */","('calculate', {'INSTRUCTION': {'covered': 62, 'missed': 10}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 4}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",166.0,Calculate sp3/sp2 hybridization ratio in the supplied {@link IAtomContainer}.,13.0,"['In the supplied IAtomContainer, calculate the sp3/sp2 hybridization ratio.', 'In the supplied IAtomContainer, calculate sp3/sp2 hybridization ratio.', 'The sp3/sp2 hybridization ratio is calculated using the supplied IAtomContainer.']"
821,acs-aem-commons,com/adobe/acs/commons/mcp/impl/processes/DataImporter.java,/bundle/src/main/java/com/adobe/acs/commons/mcp/impl/processes/DataImporter.java,populateMetadataFromRow,364-389,"/**
     * Update the resource with the properties from the row.
     *
     * @param resource Resource object of which the properties are to be modified.
     * @param nodeInfo Map of properties from the row.
     */
private void populateMetadataFromRow(Resource resource, Map<String, Object> nodeInfo) throws RepositoryException{
    LOG.debug(""Start of populateMetadataFromRow"");
    ModifiableValueMap resourceProperties = resource.adaptTo(ModifiableValueMap.class);
    Node node = resource.adaptTo(Node.class);
    for (Map.Entry entry : nodeInfo.entrySet()) {
        String key = (String) entry.getKey();
        Object value = entry.getValue();
        if (key != null && (mergeMode.overwriteProps || !resourceProperties.containsKey(key))) {
            if (node.hasProperty(key) && node.getProperty(key).isMultiple() && mergeMode.appendArrays) {
                appendArray(resourceProperties, entry);
            } else if (value != null) {
                resourceProperties.put(key, value);
            }
        }
    }
    LOG.debug(""End of populateMetadataFromRow"");
}","private void populateMetadataFromRow(Resource resource, Map<String, Object> nodeInfo) throws RepositoryException{
    LOG.debug(""Start of populateMetadataFromRow"");
    ModifiableValueMap resourceProperties = resource.adaptTo(ModifiableValueMap.class);
    Node node = resource.adaptTo(Node.class);
    for (Map.Entry entry : nodeInfo.entrySet()) {
        String key = (String) entry.getKey();
        Object value = entry.getValue();
        if (key != null && (mergeMode.overwriteProps || !resourceProperties.containsKey(key))) {
            if (node.hasProperty(key) && node.getProperty(key).isMultiple() && mergeMode.appendArrays) {
                appendArray(resourceProperties, entry);
            } else if (value != null) {
                resourceProperties.put(key, value);
            }
        }
    }
    LOG.debug(""End of populateMetadataFromRow"");
}","/**
     * Update the resource with the properties from the row.
     *
     * @param resource Resource object of which the properties are to be modified.
     * @param nodeInfo Map of properties from the row.
     */","('populateMetadataFromRow', {'INSTRUCTION': {'covered': 58, 'missed': 13}, 'BRANCH': {'covered': 7, 'missed': 9}, 'LINE': {'covered': 13, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 7}, 'METHOD': {'covered': 1, 'missed': 0}})",166.0,  Update the resource with the properties from the row.,10.0,"['The properties from the row should be updated with the resource.', 'The properties from the row should be updated.', 'The properties from the row are updated with the resource.']"
822,openapi-generator,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,readWithInfo,1608-1638,"/**
     * Parse and return a JsonNode representation of the input OAS document.
     *
     * @param location the URL of the OAS document.
     * @param auths the list of authorization values to access the remote URL.
     *
     * @throws java.lang.Exception if an error occurs while retrieving the OpenAPI document.
     *
     * @return A JsonNode representation of the input OAS document.
     */
public static JsonNode readWithInfo(String location, List<AuthorizationValue> auths) throws Exception{
    String data;
    location = location.replaceAll(""\\\\"", ""/"");
    if (location.toLowerCase(Locale.ROOT).startsWith(""http"")) {
        data = RemoteUrl.urlToString(location, auths);
    } else {
        final String fileScheme = ""file:"";
        Path path;
        if (location.toLowerCase(Locale.ROOT).startsWith(fileScheme)) {
            path = Paths.get(URI.create(location));
        } else {
            path = Paths.get(location);
        }
        if (Files.exists(path)) {
            data = FileUtils.readFileToString(path.toFile(), ""UTF-8"");
        } else {
            data = ClasspathHelper.loadFileFromClasspath(location);
        }
    }
    return getRightMapper(data).readTree(data);
}","public static JsonNode readWithInfo(String location, List<AuthorizationValue> auths) throws Exception{
    String data;
    location = location.replaceAll(""\\\\"", ""/"");
    if (location.toLowerCase(Locale.ROOT).startsWith(""http"")) {
        data = RemoteUrl.urlToString(location, auths);
    } else {
        final String fileScheme = ""file:"";
        Path path;
        if (location.toLowerCase(Locale.ROOT).startsWith(fileScheme)) {
            path = Paths.get(URI.create(location));
        } else {
            path = Paths.get(location);
        }
        if (Files.exists(path)) {
            data = FileUtils.readFileToString(path.toFile(), ""UTF-8"");
        } else {
            data = ClasspathHelper.loadFileFromClasspath(location);
        }
    }
    return getRightMapper(data).readTree(data);
}","/**
     * Parse and return a JsonNode representation of the input OAS document.
     *
     * @param location the URL of the OAS document.
     * @param auths the list of authorization values to access the remote URL.
     *
     * @throws java.lang.Exception if an error occurs while retrieving the OpenAPI document.
     *
     * @return A JsonNode representation of the input OAS document.
     */","('readWithInfo', {'INSTRUCTION': {'covered': 40, 'missed': 13}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 8, 'missed': 3}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",166.0,  Parse and return a JsonNode representation of the input OAS document.,12.0,"['Return a JsonNode representation of the OAS document.', 'Return a representation of the OAS document.', 'Return a JsonNode representation of the OAS document']"
823,cdk,org/openscience/cdk/hash/HashGeneratorMaker.java,/tool/hash/src/main/java/org/openscience/cdk/hash/HashGeneratorMaker.java,atomic,311-349,"/**
     * Given the current configuration create an {@link AtomHashGenerator}.
     *
     * @return instance of the generator
     * @throws IllegalArgumentException no depth or encoders were configured
     */
public AtomHashGenerator atomic(){
    if (depth < 0)
        throw new IllegalArgumentException(""no depth specified, use .depth(int)"");
    List<AtomEncoder> encoders = new ArrayList<AtomEncoder>();
    for (AtomEncoder encoder : encoderSet) {
        encoders.add(encoder);
    }
    encoders.addAll(this.customEncoders);
    boolean suppress = suppression != AtomSuppression.unsuppressed();
    AtomEncoder encoder = new ConjugatedAtomEncoder(encoders);
    SeedGenerator seeds = new SeedGenerator(encoder, suppression);
    AbstractAtomHashGenerator simple = suppress ? new SuppressedAtomHashGenerator(seeds, new Xorshift(), makeStereoEncoderFactory(), suppression, depth) : new BasicAtomHashGenerator(seeds, new Xorshift(), makeStereoEncoderFactory(), depth);
    if (equivSetFinder != null) {
        return new PerturbedAtomHashGenerator(seeds, simple, new Xorshift(), makeStereoEncoderFactory(), equivSetFinder, suppression);
    } else {
        return simple;
    }
}","public AtomHashGenerator atomic(){
    if (depth < 0)
        throw new IllegalArgumentException(""no depth specified, use .depth(int)"");
    List<AtomEncoder> encoders = new ArrayList<AtomEncoder>();
    for (AtomEncoder encoder : encoderSet) {
        encoders.add(encoder);
    }
    encoders.addAll(this.customEncoders);
    boolean suppress = suppression != AtomSuppression.unsuppressed();
    AtomEncoder encoder = new ConjugatedAtomEncoder(encoders);
    SeedGenerator seeds = new SeedGenerator(encoder, suppression);
    AbstractAtomHashGenerator simple = suppress ? new SuppressedAtomHashGenerator(seeds, new Xorshift(), makeStereoEncoderFactory(), suppression, depth) : new BasicAtomHashGenerator(seeds, new Xorshift(), makeStereoEncoderFactory(), depth);
    if (equivSetFinder != null) {
        return new PerturbedAtomHashGenerator(seeds, simple, new Xorshift(), makeStereoEncoderFactory(), equivSetFinder, suppression);
    } else {
        return simple;
    }
}","/**
     * Given the current configuration create an {@link AtomHashGenerator}.
     *
     * @return instance of the generator
     * @throws IllegalArgumentException no depth or encoders were configured
     */","('atomic', {'INSTRUCTION': {'covered': 101, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",167.0,  Given the current configuration create an {@link AtomHashGenerator}.,12.0,"['If the current configuration is used, create an @link AtomHashGenerator.', 'The current configuration would make it possible to create an @link AtomHashGenerator.', 'If the current configuration is used, you can create an @link AtomHashGenerator.']"
824,cdk,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,label,1771-1798,"/**
     * Labels the atom at the specified index with the provide label. If the
     * atom was not already a pseudo atom then the original atom is replaced.
     *
     * @param container structure
     * @param index     atom index to replace
     * @param label     the label for the atom
     * @see IPseudoAtom#setLabel(String)
     */
 static void label(final IAtomContainer container, final int index, final String label){
    final IAtom atom = container.getAtom(index);
    final IPseudoAtom pseudoAtom = atom instanceof IPseudoAtom ? (IPseudoAtom) atom : container.getBuilder().newInstance(IPseudoAtom.class);
    if (atom.equals(pseudoAtom)) {
        pseudoAtom.setLabel(label);
    } else {
        pseudoAtom.setSymbol(label);
        pseudoAtom.setAtomicNumber(atom.getAtomicNumber());
        pseudoAtom.setPoint2d(atom.getPoint2d());
        pseudoAtom.setPoint3d(atom.getPoint3d());
        pseudoAtom.setMassNumber(atom.getMassNumber());
        pseudoAtom.setFormalCharge(atom.getFormalCharge());
        pseudoAtom.setValency(atom.getValency());
        pseudoAtom.setLabel(label);
        AtomContainerManipulator.replaceAtomByAtom(container, atom, pseudoAtom);
    }
}","static void label(final IAtomContainer container, final int index, final String label){
    final IAtom atom = container.getAtom(index);
    final IPseudoAtom pseudoAtom = atom instanceof IPseudoAtom ? (IPseudoAtom) atom : container.getBuilder().newInstance(IPseudoAtom.class);
    if (atom.equals(pseudoAtom)) {
        pseudoAtom.setLabel(label);
    } else {
        pseudoAtom.setSymbol(label);
        pseudoAtom.setAtomicNumber(atom.getAtomicNumber());
        pseudoAtom.setPoint2d(atom.getPoint2d());
        pseudoAtom.setPoint3d(atom.getPoint3d());
        pseudoAtom.setMassNumber(atom.getMassNumber());
        pseudoAtom.setFormalCharge(atom.getFormalCharge());
        pseudoAtom.setValency(atom.getValency());
        pseudoAtom.setLabel(label);
        AtomContainerManipulator.replaceAtomByAtom(container, atom, pseudoAtom);
    }
}","/**
     * Labels the atom at the specified index with the provide label. If the
     * atom was not already a pseudo atom then the original atom is replaced.
     *
     * @param container structure
     * @param index     atom index to replace
     * @param label     the label for the atom
     * @see IPseudoAtom#setLabel(String)
     */","('label', {'INSTRUCTION': {'covered': 62, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",167.0,  Labels the atom at the specified index with the provide label.,12.0,"['The provide label should be used to label the atom at the specified index.', 'The provide label should be used to label the atom.', 'The atom should be labeled with the provide label.']"
825,logstash-logback-encoder,net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,/src/main/java/net/logstash/logback/stacktrace/ShortenedThrowableConverter.java,appendRootCauseFirst,349-380,"/**
     * Appends a throwable and recursively appends its causedby/suppressed throwables
     * in ""reverse"" order (Root cause first).
     */
private void appendRootCauseFirst(StringBuilder builder, String prefix, int indent, IThrowableProxy throwableProxy, Deque<String> stackHashes){
    if (throwableProxy == null || builder.length() > maxLength) {
        return;
    }
    if (throwableProxy.getCause() != null) {
        appendRootCauseFirst(builder, prefix, indent, throwableProxy.getCause(), stackHashes);
        prefix = CoreConstants.WRAPPED_BY;
    }
    String hash = stackHashes == null || stackHashes.isEmpty() ? null : stackHashes.removeLast();
    appendFirstLine(builder, prefix, indent, throwableProxy, hash);
    appendStackTraceElements(builder, indent, throwableProxy);
    IThrowableProxy[] suppressedThrowableProxies = throwableProxy.getSuppressed();
    if (suppressedThrowableProxies != null) {
        for (IThrowableProxy suppressedThrowableProxy : suppressedThrowableProxies) {
            appendRootCauseFirst(builder, CoreConstants.SUPPRESSED, indent + ThrowableProxyUtil.SUPPRESSED_EXCEPTION_INDENT, suppressedThrowableProxy, null);
        }
    }
}","private void appendRootCauseFirst(StringBuilder builder, String prefix, int indent, IThrowableProxy throwableProxy, Deque<String> stackHashes){
    if (throwableProxy == null || builder.length() > maxLength) {
        return;
    }
    if (throwableProxy.getCause() != null) {
        appendRootCauseFirst(builder, prefix, indent, throwableProxy.getCause(), stackHashes);
        prefix = CoreConstants.WRAPPED_BY;
    }
    String hash = stackHashes == null || stackHashes.isEmpty() ? null : stackHashes.removeLast();
    appendFirstLine(builder, prefix, indent, throwableProxy, hash);
    appendStackTraceElements(builder, indent, throwableProxy);
    IThrowableProxy[] suppressedThrowableProxies = throwableProxy.getSuppressed();
    if (suppressedThrowableProxies != null) {
        for (IThrowableProxy suppressedThrowableProxy : suppressedThrowableProxies) {
            appendRootCauseFirst(builder, CoreConstants.SUPPRESSED, indent + ThrowableProxyUtil.SUPPRESSED_EXCEPTION_INDENT, suppressedThrowableProxy, null);
        }
    }
}","/**
     * Appends a throwable and recursively appends its causedby/suppressed throwables
     * in ""reverse"" order (Root cause first).
     */","('appendRootCauseFirst', {'INSTRUCTION': {'covered': 59, 'missed': 16}, 'BRANCH': {'covered': 9, 'missed': 5}, 'LINE': {'covered': 11, 'missed': 2}, 'COMPLEXITY': {'covered': 3, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",167.0,"  Appends a throwable and recursively appends its causedby/suppressed throwables  in ""reverse"" order (Root cause first).",20.0,"['Appends a throwable in reverse order.', 'Appends a throwable and puts it in reverse order.', 'Appends a throwable and puts it in the reverse order.']"
826,weblogic-kubernetes-operator,oracle/kubernetes/operator/helpers/AuthenticationProxy.java,/operator/src/main/java/oracle/kubernetes/operator/helpers/AuthenticationProxy.java,check,20-57,"/**
   * Check if the specified access token can be authenticated.
   *
   * @param principal The user, group or service account.
   * @param token The access token that identifies the user.
   * @param namespace Namespace
   * @return V1TokenReviewStatus containing either info about the authenticated user or an error
   *     explaining why the user couldn't be authenticated
   */
public V1TokenReviewStatus check(String principal, String token, String namespace){
    // Don't expose the token since it's a credential
    LOGGER.entering(principal);
    V1TokenReview result = null;
    try {
        boolean allowed = authorizationProxy.check(principal, AuthorizationProxy.Operation.create, AuthorizationProxy.Resource.TOKENREVIEWS, null, namespace == null ? AuthorizationProxy.Scope.cluster : AuthorizationProxy.Scope.namespace, namespace);
        if (allowed) {
            result = new CallBuilder().createTokenReview(prepareTokenReview(token));
        } else {
            LOGGER.warning(MessageKeys.CANNOT_CREATE_TOKEN_REVIEW);
        }
    } catch (ApiException e) {
        LOGGER.severe(MessageKeys.APIEXCEPTION_FROM_TOKEN_REVIEW, e);
        LOGGER.exiting(null);
        return null;
    }
    LOGGER.fine(""Returned TokenReview"", result);
    V1TokenReviewStatus status = result != null ? result.getStatus() : null;
    LOGGER.exiting(status);
    return status;
}","public V1TokenReviewStatus check(String principal, String token, String namespace){
    // Don't expose the token since it's a credential
    LOGGER.entering(principal);
    V1TokenReview result = null;
    try {
        boolean allowed = authorizationProxy.check(principal, AuthorizationProxy.Operation.create, AuthorizationProxy.Resource.TOKENREVIEWS, null, namespace == null ? AuthorizationProxy.Scope.cluster : AuthorizationProxy.Scope.namespace, namespace);
        if (allowed) {
            result = new CallBuilder().createTokenReview(prepareTokenReview(token));
        } else {
            LOGGER.warning(MessageKeys.CANNOT_CREATE_TOKEN_REVIEW);
        }
    } catch (ApiException e) {
        LOGGER.severe(MessageKeys.APIEXCEPTION_FROM_TOKEN_REVIEW, e);
        LOGGER.exiting(null);
        return null;
    }
    LOGGER.fine(""Returned TokenReview"", result);
    V1TokenReviewStatus status = result != null ? result.getStatus() : null;
    LOGGER.exiting(status);
    return status;
}","/**
   * Check if the specified access token can be authenticated.
   *
   * @param principal The user, group or service account.
   * @param token The access token that identifies the user.
   * @param namespace Namespace
   * @return V1TokenReviewStatus containing either info about the authenticated user or an error
   *     explaining why the user couldn't be authenticated
   */","('check', {'INSTRUCTION': {'covered': 55, 'missed': 14}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 12, 'missed': 5}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",167.0,  Check if the specified access token can be authenticated.,10.0,"['Check if the access token can be used.', 'If the access token can be verified, check it.', 'If the access token can beauthenticated, check it.']"
827,dataverse,edu/harvard/iq/dataverse/ingest/IngestUtil.java,/src/main/java/edu/harvard/iq/dataverse/ingest/IngestUtil.java,generateNewFileName,208-244,"/**
     * Generates a new unique filename by adding -[number] to the base name.
     *
     * @param fileName original filename
     * @return a new unique filename
     */
public static String generateNewFileName(final String fileName){
    String newName;
    String baseName;
    String extension = null;
    int extensionIndex = fileName.lastIndexOf(""."");
    if (extensionIndex != -1) {
        extension = fileName.substring(extensionIndex + 1);
        baseName = fileName.substring(0, extensionIndex);
    } else {
        baseName = fileName;
    }
    if (baseName.matches("".*-[0-9][0-9]*$"")) {
        int dashIndex = baseName.lastIndexOf(""-"");
        String numSuffix = baseName.substring(dashIndex + 1);
        String basePrefix = baseName.substring(0, dashIndex);
        int numSuffixValue = Integer.parseInt(numSuffix);
        numSuffixValue++;
        baseName = basePrefix + ""-"" + numSuffixValue;
    } else {
        baseName = baseName + ""-1"";
    }
    newName = baseName;
    if (extension != null) {
        newName = newName + ""."" + extension;
    }
    return newName;
}","public static String generateNewFileName(final String fileName){
    String newName;
    String baseName;
    String extension = null;
    int extensionIndex = fileName.lastIndexOf(""."");
    if (extensionIndex != -1) {
        extension = fileName.substring(extensionIndex + 1);
        baseName = fileName.substring(0, extensionIndex);
    } else {
        baseName = fileName;
    }
    if (baseName.matches("".*-[0-9][0-9]*$"")) {
        int dashIndex = baseName.lastIndexOf(""-"");
        String numSuffix = baseName.substring(dashIndex + 1);
        String basePrefix = baseName.substring(0, dashIndex);
        int numSuffixValue = Integer.parseInt(numSuffix);
        numSuffixValue++;
        baseName = basePrefix + ""-"" + numSuffixValue;
    } else {
        baseName = baseName + ""-1"";
    }
    newName = baseName;
    if (extension != null) {
        newName = newName + ""."" + extension;
    }
    return newName;
}","/**
     * Generates a new unique filename by adding -[number] to the base name.
     *
     * @param fileName original filename
     * @return a new unique filename
     */","('generateNewFileName', {'INSTRUCTION': {'covered': 62, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 18, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",168.0,  Generates a new unique filename by adding -[number] to the base name.,16.0,"['Adding -[number] to the base name creates a new unique filename.', 'Adding -[number]) to the base name creates a new unique filename.', 'Adding -[number] to the base name will create a new unique filename.']"
828,cdk,org/openscience/cdk/silent/Bond.java,/base/silent/src/main/java/org/openscience/cdk/silent/Bond.java,toString,584-607,"/**
     * Returns a one line string representation of this Container. This method is
     * conform RFC #9.
     *
     * @return The string representation of this Container
     */
public String toString(){
    StringBuffer resultString = new StringBuffer(32);
    resultString.append(""Bond("").append(this.hashCode());
    if (getOrder() != null) {
        resultString.append("", #O:"").append(getOrder());
    }
    resultString.append("", #S:"").append(getStereo());
    if (getAtomCount() > 0) {
        resultString.append("", #A:"").append(getAtomCount());
        for (int i = 0; i < atomCount; i++) {
            resultString.append("", "").append(atoms[i] == null ? ""null"" : atoms[i].toString());
        }
    }
    resultString.append("", "").append(super.toString());
    resultString.append(')');
    return resultString.toString();
}","public String toString(){
    StringBuffer resultString = new StringBuffer(32);
    resultString.append(""Bond("").append(this.hashCode());
    if (getOrder() != null) {
        resultString.append("", #O:"").append(getOrder());
    }
    resultString.append("", #S:"").append(getStereo());
    if (getAtomCount() > 0) {
        resultString.append("", #A:"").append(getAtomCount());
        for (int i = 0; i < atomCount; i++) {
            resultString.append("", "").append(atoms[i] == null ? ""null"" : atoms[i].toString());
        }
    }
    resultString.append("", "").append(super.toString());
    resultString.append(')');
    return resultString.toString();
}","/**
     * Returns a one line string representation of this Container. This method is
     * conform RFC #9.
     *
     * @return The string representation of this Container
     */","('toString', {'INSTRUCTION': {'covered': 76, 'missed': 2}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",168.0,  Returns a one line string representation of this Container.,10.0,"['A one line string representation of this container is returned.', 'A one line string representation of this Container is returned.', 'A one line string representation of the container.']"
829,dcache,org/dcache/util/Bytes.java,/modules/common/src/main/java/org/dcache/util/Bytes.java,putLong,27-51,"/**
     * Puts a big-endian representation of {@code value} into <code>bytes</code> staring from
     * <code>offset</code>.
     *
     * @param bytes
     * @param offset
     * @param value
     * @throws IllegalArgumentException there is no enough room for 8 bytes.
     */
public static void putLong(byte[] bytes, int offset, long value) throws IllegalArgumentException{
    if (bytes.length - offset < 8) {
        throw new IllegalArgumentException(""not enough space to store long"");
    }
    bytes[offset] = (byte) (value >> 56);
    bytes[offset + 1] = (byte) (value >> 48);
    bytes[offset + 2] = (byte) (value >> 40);
    bytes[offset + 3] = (byte) (value >> 32);
    bytes[offset + 4] = (byte) (value >> 24);
    bytes[offset + 5] = (byte) (value >> 16);
    bytes[offset + 6] = (byte) (value >> 8);
    bytes[offset + 7] = (byte) value;
}","public static void putLong(byte[] bytes, int offset, long value) throws IllegalArgumentException{
    if (bytes.length - offset < 8) {
        throw new IllegalArgumentException(""not enough space to store long"");
    }
    bytes[offset] = (byte) (value >> 56);
    bytes[offset + 1] = (byte) (value >> 48);
    bytes[offset + 2] = (byte) (value >> 40);
    bytes[offset + 3] = (byte) (value >> 32);
    bytes[offset + 4] = (byte) (value >> 24);
    bytes[offset + 5] = (byte) (value >> 16);
    bytes[offset + 6] = (byte) (value >> 8);
    bytes[offset + 7] = (byte) value;
}","/**
     * Puts a big-endian representation of {@code value} into <code>bytes</code> staring from
     * <code>offset</code>.
     *
     * @param bytes
     * @param offset
     * @param value
     * @throws IllegalArgumentException there is no enough room for 8 bytes.
     */","('putLong', {'INSTRUCTION': {'covered': 88, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 11, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",168.0,  Puts a big-endian representation of {@code value} into <code>bytes</code> staring from  <code>offset</code>.,28.0,"['Puts a big-endian representation of @code value into code>bytes/code>.', 'Puts a big-endian representation of @code value into code>bytes/code>', 'Puts a big-endian representation of @code value into code>bytes/code> staring from the screen.']"
830,jooby,io/jooby/Cookie.java,/jooby/src/main/java/io/jooby/Cookie.java,encode,481-508,"/**
   * Encode a hash into cookie value, like: <code>k1=v1&amp;...&amp;kn=vn</code>. Also,
   * <code>key</code> and <code>value</code> are encoded using {@link URLEncoder}.
   *
   * @param attributes Map to encode.
   * @return URL encoded from map attributes.
   */
public static String encode(@Nullable Map<String, String> attributes){
    if (attributes == null || attributes.size() == 0) {
        return """";
    }
    try {
        StringBuilder joiner = new StringBuilder();
        String enc = StandardCharsets.UTF_8.name();
        for (Map.Entry<String, String> attribute : attributes.entrySet()) {
            joiner.append(URLEncoder.encode(attribute.getKey(), enc)).append('=').append(URLEncoder.encode(attribute.getValue(), enc)).append('&');
        }
        if (joiner.length() > 0) {
            joiner.setLength(joiner.length() - 1);
        }
        return joiner.toString();
    } catch (UnsupportedEncodingException x) {
        throw SneakyThrows.propagate(x);
    }
}","public static String encode(@Nullable Map<String, String> attributes){
    if (attributes == null || attributes.size() == 0) {
        return """";
    }
    try {
        StringBuilder joiner = new StringBuilder();
        String enc = StandardCharsets.UTF_8.name();
        for (Map.Entry<String, String> attribute : attributes.entrySet()) {
            joiner.append(URLEncoder.encode(attribute.getKey(), enc)).append('=').append(URLEncoder.encode(attribute.getValue(), enc)).append('&');
        }
        if (joiner.length() > 0) {
            joiner.setLength(joiner.length() - 1);
        }
        return joiner.toString();
    } catch (UnsupportedEncodingException x) {
        throw SneakyThrows.propagate(x);
    }
}","/**
   * Encode a hash into cookie value, like: <code>k1=v1&amp;...&amp;kn=vn</code>. Also,
   * <code>key</code> and <code>value</code> are encoded using {@link URLEncoder}.
   *
   * @param attributes Map to encode.
   * @return URL encoded from map attributes.
   */","('encode', {'INSTRUCTION': {'covered': 56, 'missed': 4}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 13, 'missed': 2}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",169.0,"Encode a hash into cookie value, like: <code>k1=v1&amp;.",17.0,"['If you want to make a cookie value, you need to decode a hash into it.', 'If you want to make a cookie value, you need to decode a hash into a cookie value.', 'If you want to make a cookie value, you should use a hash into it.']"
831,cdk,org/openscience/cdk/formula/IsotopePatternManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/IsotopePatternManipulator.java,normalize,17-55,"/**
     * Return the isotope pattern normalized to the highest abundance.
     *
     * @param isotopeP  The IsotopePattern object to normalize
     * @return          The IsotopePattern normalized
     */
public static IsotopePattern normalize(IsotopePattern isotopeP){
    IsotopeContainer isoHighest = null;
    double biggestAbundance = 0;
    /* Extraction of the isoContainer with the highest abundance */
    for (IsotopeContainer isoContainer : isotopeP.getIsotopes()) {
        double abundance = isoContainer.getIntensity();
        if (biggestAbundance < abundance) {
            biggestAbundance = abundance;
            isoHighest = isoContainer;
        }
    }
    /* Normalize */
    IsotopePattern isoNormalized = new IsotopePattern();
    for (IsotopeContainer isoContainer : isotopeP.getIsotopes()) {
        double inten = isoContainer.getIntensity() / isoHighest.getIntensity();
        IsotopeContainer icClone;
        try {
            icClone = (IsotopeContainer) isoContainer.clone();
            icClone.setIntensity(inten);
            if (isoHighest.equals(isoContainer))
                isoNormalized.setMonoIsotope(icClone);
            else
                isoNormalized.addIsotope(icClone);
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }
    isoNormalized.setCharge(isotopeP.getCharge());
    return isoNormalized;
}","public static IsotopePattern normalize(IsotopePattern isotopeP){
    IsotopeContainer isoHighest = null;
    double biggestAbundance = 0;
    /* Extraction of the isoContainer with the highest abundance */
    for (IsotopeContainer isoContainer : isotopeP.getIsotopes()) {
        double abundance = isoContainer.getIntensity();
        if (biggestAbundance < abundance) {
            biggestAbundance = abundance;
            isoHighest = isoContainer;
        }
    }
    /* Normalize */
    IsotopePattern isoNormalized = new IsotopePattern();
    for (IsotopeContainer isoContainer : isotopeP.getIsotopes()) {
        double inten = isoContainer.getIntensity() / isoHighest.getIntensity();
        IsotopeContainer icClone;
        try {
            icClone = (IsotopeContainer) isoContainer.clone();
            icClone.setIntensity(inten);
            if (isoHighest.equals(isoContainer))
                isoNormalized.setMonoIsotope(icClone);
            else
                isoNormalized.addIsotope(icClone);
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }
    isoNormalized.setCharge(isotopeP.getCharge());
    return isoNormalized;
}","/**
     * Return the isotope pattern normalized to the highest abundance.
     *
     * @param isotopeP  The IsotopePattern object to normalize
     * @return          The IsotopePattern normalized
     */","('normalize', {'INSTRUCTION': {'covered': 74, 'missed': 3}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 20, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",169.0,  Return the isotope pattern normalized to the highest abundance.,10.0,"['Return the pattern normalized to the highest amount.', 'Return the pattern normalized to the highest abundance.', 'Return the pattern normalized to the highest amount of isotope.']"
832,cdk,org/openscience/cdk/AtomContainerSet.java,/base/data/src/main/java/org/openscience/cdk/AtomContainerSet.java,sortAtomContainers,408-439,"/**
     * Sort the AtomContainers and multipliers using a provided Comparator.
     * @param comparator defines the sorting method
     */
public void sortAtomContainers(final Comparator<IAtomContainer> comparator){
    Integer[] indexes = new Integer[atomContainerCount];
    for (int i = 0; i < indexes.length; i++) indexes[i] = i;
    Arrays.sort(indexes, new Comparator<Integer>() {

        @Override
        public int compare(Integer o1, Integer o2) {
            return comparator.compare(atomContainers[o1], atomContainers[o2]);
        }
    });
    IAtomContainer[] containersTmp = Arrays.copyOf(atomContainers, indexes.length);
    Double[] multipliersTmp = Arrays.copyOf(multipliers, indexes.length);
    for (int i = 0; i < indexes.length; i++) {
        atomContainers[i] = containersTmp[indexes[i]];
        multipliers[i] = multipliersTmp[indexes[i]];
    }
}","public void sortAtomContainers(final Comparator<IAtomContainer> comparator){
    Integer[] indexes = new Integer[atomContainerCount];
    for (int i = 0; i < indexes.length; i++) indexes[i] = i;
    Arrays.sort(indexes, new Comparator<Integer>() {

        @Override
        public int compare(Integer o1, Integer o2) {
            return comparator.compare(atomContainers[o1], atomContainers[o2]);
        }
    });
    IAtomContainer[] containersTmp = Arrays.copyOf(atomContainers, indexes.length);
    Double[] multipliersTmp = Arrays.copyOf(multipliers, indexes.length);
    for (int i = 0; i < indexes.length; i++) {
        atomContainers[i] = containersTmp[indexes[i]];
        multipliers[i] = multipliersTmp[indexes[i]];
    }
}","/**
     * Sort the AtomContainers and multipliers using a provided Comparator.
     * @param comparator defines the sorting method
     */","('sortAtomContainers', {'INSTRUCTION': {'covered': 67, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",170.0,  Sort the AtomContainers and multipliers using a provided Comparator.,10.0,"['A provided Comparator can be used to sort the AtomContainers and multipliers.', 'A provided Comparator can be used to sort the AtomContainers.', 'A provided Comparator is needed to sort the AtomContainers and multipliers.']"
833,dcache,org/dcache/resilience/data/PoolInfoMap.java,/modules/dcache-resilience/src/main/java/org/dcache/resilience/data/PoolInfoMap.java,resolveStorageUnitIndex,1098-1144,"/**
     * <p>This method is an alternate search for storage unit.
     * It first attempts to match units by interpreting the class names as a regex. If that fails,
     * it tries first the class key, then universal key.</p>
     *
     * @param classKey the storage class of the unit
     * @param unitKey  the full name of the storage unit
     */
private Integer resolveStorageUnitIndex(String classKey, String unitKey) throws NoSuchElementException{
    Integer universalCoverage = null;
    Integer classCoverage = null;
    Integer specific = null;
    read.lock();
    try {
        for (String unit : sunits) {
            if (unit.equals(""*@*"")) {
                universalCoverage = sunits.indexOf(unit);
            } else if (unit.equals(""*@"" + classKey)) {
                classCoverage = sunits.indexOf(unit);
            } else if (useRegex && Pattern.matches(unit, unitKey)) {
                specific = sunits.indexOf(unit);
                break;
            }
        }
    } finally {
        read.unlock();
    }
    if (specific != null) {
        return specific;
    }
    if (classCoverage != null) {
        return classCoverage;
    }
    if (universalCoverage != null) {
        return universalCoverage;
    }
    throw new NoSuchElementException(String.valueOf(unitKey));
}","private Integer resolveStorageUnitIndex(String classKey, String unitKey) throws NoSuchElementException{
    Integer universalCoverage = null;
    Integer classCoverage = null;
    Integer specific = null;
    read.lock();
    try {
        for (String unit : sunits) {
            if (unit.equals(""*@*"")) {
                universalCoverage = sunits.indexOf(unit);
            } else if (unit.equals(""*@"" + classKey)) {
                classCoverage = sunits.indexOf(unit);
            } else if (useRegex && Pattern.matches(unit, unitKey)) {
                specific = sunits.indexOf(unit);
                break;
            }
        }
    } finally {
        read.unlock();
    }
    if (specific != null) {
        return specific;
    }
    if (classCoverage != null) {
        return classCoverage;
    }
    if (universalCoverage != null) {
        return universalCoverage;
    }
    throw new NoSuchElementException(String.valueOf(unitKey));
}","/**
     * <p>This method is an alternate search for storage unit.
     * It first attempts to match units by interpreting the class names as a regex. If that fails,
     * it tries first the class key, then universal key.</p>
     *
     * @param classKey the storage class of the unit
     * @param unitKey  the full name of the storage unit
     */","('resolveStorageUnitIndex', {'INSTRUCTION': {'covered': 64, 'missed': 15}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 18, 'missed': 3}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",171.0,  <p>This method is an alternate search for storage unit.,13.0,"['This method is an alternate search for a storage unit.', 'This method is an alternate search.', 'This method is an alternate search for storage unit.']"
834,cdk,org/openscience/cdk/io/MDLV2000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Writer.java,write,294-326,"/**
     * Writes a {@link IChemObject} to the MDL molfile formated output.
     * It can only output ChemObjects of type {@link IChemFile},
     * {@link IChemObject} and {@link IAtomContainer}.
     *
     * @param object {@link IChemObject} to write
     * @see #accepts(Class)
     */
public void write(IChemObject object) throws CDKException{
    customizeJob();
    try {
        if (object instanceof IChemFile) {
            writeChemFile((IChemFile) object);
            return;
        } else if (object instanceof IChemModel) {
            IChemFile file = object.getBuilder().newInstance(IChemFile.class);
            IChemSequence sequence = object.getBuilder().newInstance(IChemSequence.class);
            sequence.addChemModel((IChemModel) object);
            file.addChemSequence(sequence);
            writeChemFile((IChemFile) file);
            return;
        } else if (object instanceof IAtomContainer) {
            writeMolecule((IAtomContainer) object);
            return;
        }
    } catch (Exception ex) {
        logger.error(ex.getMessage());
        logger.debug(ex);
        throw new CDKException(""Exception while writing MDL file: "" + ex.getMessage(), ex);
    }
    throw new CDKException(""Only supported is writing of IChemFile, "" + ""IChemModel, and IAtomContainer objects."");
}","public void write(IChemObject object) throws CDKException{
    customizeJob();
    try {
        if (object instanceof IChemFile) {
            writeChemFile((IChemFile) object);
            return;
        } else if (object instanceof IChemModel) {
            IChemFile file = object.getBuilder().newInstance(IChemFile.class);
            IChemSequence sequence = object.getBuilder().newInstance(IChemSequence.class);
            sequence.addChemModel((IChemModel) object);
            file.addChemSequence(sequence);
            writeChemFile((IChemFile) file);
            return;
        } else if (object instanceof IAtomContainer) {
            writeMolecule((IAtomContainer) object);
            return;
        }
    } catch (Exception ex) {
        logger.error(ex.getMessage());
        logger.debug(ex);
        throw new CDKException(""Exception while writing MDL file: "" + ex.getMessage(), ex);
    }
    throw new CDKException(""Only supported is writing of IChemFile, "" + ""IChemModel, and IAtomContainer objects."");
}","/**
     * Writes a {@link IChemObject} to the MDL molfile formated output.
     * It can only output ChemObjects of type {@link IChemFile},
     * {@link IChemObject} and {@link IAtomContainer}.
     *
     * @param object {@link IChemObject} to write
     * @see #accepts(Class)
     */","('write', {'INSTRUCTION': {'covered': 65, 'missed': 11}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 16, 'missed': 4}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",172.0,  Writes a {@link IChemObject} to the MDL molfile formated output.,14.0,"['The MDL molfile formated output has a @link IChemObject written on it.', 'The MDL molfile formated output has a @link IChemObject written in it.', 'The MDL molfile formated output is written in a @link IChemObject.']"
835,cdk,org/openscience/cdk/ConformerContainer.java,/base/data/src/main/java/org/openscience/cdk/ConformerContainer.java,indexOf,366-398,"/**
     * Returns the lowest index at which the specific IAtomContainer appears in the list or -1 if is not found.
     * 
     * A given IAtomContainer will occur in the list if the title matches the stored title for
     * the conformers in this container and if the coordinates for each atom in the specified molecule
     * are equal to the coordinates of the corresponding atoms in a conformer.
     *
     * @param o The IAtomContainer whose presence is being tested
     * @return The index where o was found
     */
public int indexOf(Object o){
    IAtomContainer atomContainer = (IAtomContainer) o;
    if (!atomContainer.getTitle().equals(title))
        return -1;
    if (atomContainer.getAtomCount() != this.atomContainer.getAtomCount())
        return -1;
    boolean coordsMatch;
    int index = 0;
    for (Point3d[] coords : coordinates) {
        coordsMatch = true;
        for (int i = 0; i < atomContainer.getAtomCount(); i++) {
            Point3d p = atomContainer.getAtom(i).getPoint3d();
            if (!(p.x == coords[i].x && p.y == coords[i].y && p.z == coords[i].z)) {
                coordsMatch = false;
                break;
            }
        }
        if (coordsMatch)
            return index;
        index++;
    }
    return -1;
}","public int indexOf(Object o){
    IAtomContainer atomContainer = (IAtomContainer) o;
    if (!atomContainer.getTitle().equals(title))
        return -1;
    if (atomContainer.getAtomCount() != this.atomContainer.getAtomCount())
        return -1;
    boolean coordsMatch;
    int index = 0;
    for (Point3d[] coords : coordinates) {
        coordsMatch = true;
        for (int i = 0; i < atomContainer.getAtomCount(); i++) {
            Point3d p = atomContainer.getAtom(i).getPoint3d();
            if (!(p.x == coords[i].x && p.y == coords[i].y && p.z == coords[i].z)) {
                coordsMatch = false;
                break;
            }
        }
        if (coordsMatch)
            return index;
        index++;
    }
    return -1;
}","/**
     * Returns the lowest index at which the specific IAtomContainer appears in the list or -1 if is not found.
     * 
     * A given IAtomContainer will occur in the list if the title matches the stored title for
     * the conformers in this container and if the coordinates for each atom in the specified molecule
     * are equal to the coordinates of the corresponding atoms in a conformer.
     *
     * @param o The IAtomContainer whose presence is being tested
     * @return The index where o was found
     */","('indexOf', {'INSTRUCTION': {'covered': 78, 'missed': 4}, 'BRANCH': {'covered': 12, 'missed': 4}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",172.0,Returns the lowest index at which the specific IAtomContainer appears in the list or -1 if is not found.,20.0,"['If the IAtomContainer is not found, the lowest index will be -1.', ""If the IAtomContainer isn't found, the lowest index will be -1."", ""If the IAtomContainer isn't found, the lowest index will be the one where it appears in the list.""]"
836,glowstone,net/glowstone/entity/GlowHumanEntity.java,/src/main/java/net/glowstone/entity/GlowHumanEntity.java,processArmorChanges,191-217,"/**
     * Process changes to the human enitity's armor, and update the entity's armor attributes
     * accordingly.
     */
private void processArmorChanges(){
    GlowPlayer player = null;
    if (this instanceof GlowPlayer) {
        player = ((GlowPlayer) this);
    }
    boolean armorUpdate = false;
    List<EquipmentMonitor.Entry> armorChanges = getEquipmentMonitor().getArmorChanges();
    if (armorChanges.size() > 0) {
        for (EquipmentMonitor.Entry entry : armorChanges) {
            if (player != null && needsArmorUpdate) {
                player.getSession().send(new EntityEquipmentMessage(0, entry.slot, entry.item));
            }
            armorUpdate = true;
        }
    }
    if (armorUpdate) {
        getAttributeManager().setProperty(AttributeManager.Key.KEY_ARMOR, ArmorConstants.getDefense(getEquipment().getArmorContents()));
        getAttributeManager().setProperty(AttributeManager.Key.KEY_ARMOR_TOUGHNESS, ArmorConstants.getToughness(getEquipment().getArmorContents()));
    }
    needsArmorUpdate = true;
}","private void processArmorChanges(){
    GlowPlayer player = null;
    if (this instanceof GlowPlayer) {
        player = ((GlowPlayer) this);
    }
    boolean armorUpdate = false;
    List<EquipmentMonitor.Entry> armorChanges = getEquipmentMonitor().getArmorChanges();
    if (armorChanges.size() > 0) {
        for (EquipmentMonitor.Entry entry : armorChanges) {
            if (player != null && needsArmorUpdate) {
                player.getSession().send(new EntityEquipmentMessage(0, entry.slot, entry.item));
            }
            armorUpdate = true;
        }
    }
    if (armorUpdate) {
        getAttributeManager().setProperty(AttributeManager.Key.KEY_ARMOR, ArmorConstants.getDefense(getEquipment().getArmorContents()));
        getAttributeManager().setProperty(AttributeManager.Key.KEY_ARMOR_TOUGHNESS, ArmorConstants.getToughness(getEquipment().getArmorContents()));
    }
    needsArmorUpdate = true;
}","/**
     * Process changes to the human enitity's armor, and update the entity's armor attributes
     * accordingly.
     */","('processArmorChanges', {'INSTRUCTION': {'covered': 70, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 4}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",172.0,"  Process changes to the human enitity's armor, and update the entity's armor attributes  accordingly.",18.0,"[""Process changes to the human enitity's armor, and update the entity's armor attributes accordingly."", ""Process changes to the human enitity's armor and armor attributes are updated accordingly."", ""Process changes to the human enitity's armor, and armor attributes are updated accordingly.""]"
837,cdk,org/openscience/cdk/similarity/Tanimoto.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/similarity/Tanimoto.java,method1,185-210,"/**
     * Calculates Tanimoto distance for two count fingerprints using method 1.
     *
     * The feature/count type fingerprints may be of different length.
     * Uses Tanimoto method from {@cdk.cite Steffen09}.
     * 
     * @param fp1 count fingerprint 1
     * @param fp2 count fingerprint 2
     * @return a Tanimoto distance
     */
public static double method1(ICountFingerprint fp1, ICountFingerprint fp2){
    long xy = 0, x = 0, y = 0;
    for (int i = 0; i < fp1.numOfPopulatedbins(); i++) {
        int hash = fp1.getHash(i);
        for (int j = 0; j < fp2.numOfPopulatedbins(); j++) {
            if (hash == fp2.getHash(j)) {
                xy += fp1.getCount(i) * fp2.getCount(j);
            }
        }
        x += fp1.getCount(i) * fp1.getCount(i);
    }
    for (int j = 0; j < fp2.numOfPopulatedbins(); j++) {
        y += fp2.getCount(j) * fp2.getCount(j);
    }
    return ((double) xy / (x + y - xy));
}","public static double method1(ICountFingerprint fp1, ICountFingerprint fp2){
    long xy = 0, x = 0, y = 0;
    for (int i = 0; i < fp1.numOfPopulatedbins(); i++) {
        int hash = fp1.getHash(i);
        for (int j = 0; j < fp2.numOfPopulatedbins(); j++) {
            if (hash == fp2.getHash(j)) {
                xy += fp1.getCount(i) * fp2.getCount(j);
            }
        }
        x += fp1.getCount(i) * fp1.getCount(i);
    }
    for (int j = 0; j < fp2.numOfPopulatedbins(); j++) {
        y += fp2.getCount(j) * fp2.getCount(j);
    }
    return ((double) xy / (x + y - xy));
}","/**
     * Calculates Tanimoto distance for two count fingerprints using method 1.
     *
     * The feature/count type fingerprints may be of different length.
     * Uses Tanimoto method from {@cdk.cite Steffen09}.
     * 
     * @param fp1 count fingerprint 1
     * @param fp2 count fingerprint 2
     * @return a Tanimoto distance
     */","('method1', {'INSTRUCTION': {'covered': 82, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",173.0,Calculates Tanimoto distance for two count fingerprints using method 1.,11.0,"['Tanimoto distance is calculated using method 1.', 'Tanimoto distance is calculated using method 1', 'Method 1 is used to calculate Tanimoto distance.']"
838,seata,io/seata/rm/datasource/exec/BaseTransactionalExecutor.java,/rm-datasource/src/main/java/io/seata/rm/datasource/exec/BaseTransactionalExecutor.java,buildLockKey,289-320,"/**
     * build lockKey
     *
     * @param rowsIncludingPK the records
     * @return the string as local key. the local key example(multi pk): ""t_user:1_a,2_b""
     */
protected String buildLockKey(TableRecords rowsIncludingPK){
    if (rowsIncludingPK.size() == 0) {
        return null;
    }
    StringBuilder sb = new StringBuilder();
    sb.append(rowsIncludingPK.getTableMeta().getTableName());
    sb.append("":"");
    int filedSequence = 0;
    List<Map<String, Field>> pksRows = rowsIncludingPK.pkRows();
    for (Map<String, Field> rowMap : pksRows) {
        int pkSplitIndex = 0;
        for (String pkName : getTableMeta().getPrimaryKeyOnlyName()) {
            if (pkSplitIndex > 0) {
                sb.append(""_"");
            }
            sb.append(rowMap.get(pkName).getValue());
            pkSplitIndex++;
        }
        filedSequence++;
        if (filedSequence < pksRows.size()) {
            sb.append("","");
        }
    }
    return sb.toString();
}","protected String buildLockKey(TableRecords rowsIncludingPK){
    if (rowsIncludingPK.size() == 0) {
        return null;
    }
    StringBuilder sb = new StringBuilder();
    sb.append(rowsIncludingPK.getTableMeta().getTableName());
    sb.append("":"");
    int filedSequence = 0;
    List<Map<String, Field>> pksRows = rowsIncludingPK.pkRows();
    for (Map<String, Field> rowMap : pksRows) {
        int pkSplitIndex = 0;
        for (String pkName : getTableMeta().getPrimaryKeyOnlyName()) {
            if (pkSplitIndex > 0) {
                sb.append(""_"");
            }
            sb.append(rowMap.get(pkName).getValue());
            pkSplitIndex++;
        }
        filedSequence++;
        if (filedSequence < pksRows.size()) {
            sb.append("","");
        }
    }
    return sb.toString();
}","/**
     * build lockKey
     *
     * @param rowsIncludingPK the records
     * @return the string as local key. the local key example(multi pk): ""t_user:1_a,2_b""
     */","('buildLockKey', {'INSTRUCTION': {'covered': 75, 'missed': 2}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 19, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",173.0,  build lockKey   @param rowsIncludingPK the records  @return the string as local key.,15.0,"['The string should be returned as a local key.', 'The string is returned as a local key.', 'The string should be returned as local key.']"
839,cdk,org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,create,58-92,"/**
     * Create a stereo encoder for all potential 2D and 3D double bond stereo
     * configurations.
     *
     * @param container an atom container
     * @param graph     adjacency list representation of the container
     * @return a new encoder for tetrahedral elements
     */
public StereoEncoder create(IAtomContainer container, int[][] graph){
    List<StereoEncoder> encoders = new ArrayList<StereoEncoder>(5);
    for (IBond bond : container.bonds()) {
        // if double bond and not E or Z query bond
        if (DOUBLE.equals(bond.getOrder()) && !E_OR_Z.equals(bond.getStereo())) {
            IAtom left = bond.getBegin();
            IAtom right = bond.getEnd();
            // skip -N=N- double bonds which exhibit inversion
            if (Integer.valueOf(7).equals(left.getAtomicNumber()) && Integer.valueOf(7).equals(right.getAtomicNumber()))
                continue;
            StereoEncoder encoder = newEncoder(container, left, right, right, left, graph);
            if (encoder != null) {
                encoders.add(encoder);
            }
        }
    }
    return encoders.isEmpty() ? StereoEncoder.EMPTY : new MultiStereoEncoder(encoders);
}","public StereoEncoder create(IAtomContainer container, int[][] graph){
    List<StereoEncoder> encoders = new ArrayList<StereoEncoder>(5);
    for (IBond bond : container.bonds()) {
        // if double bond and not E or Z query bond
        if (DOUBLE.equals(bond.getOrder()) && !E_OR_Z.equals(bond.getStereo())) {
            IAtom left = bond.getBegin();
            IAtom right = bond.getEnd();
            // skip -N=N- double bonds which exhibit inversion
            if (Integer.valueOf(7).equals(left.getAtomicNumber()) && Integer.valueOf(7).equals(right.getAtomicNumber()))
                continue;
            StereoEncoder encoder = newEncoder(container, left, right, right, left, graph);
            if (encoder != null) {
                encoders.add(encoder);
            }
        }
    }
    return encoders.isEmpty() ? StereoEncoder.EMPTY : new MultiStereoEncoder(encoders);
}","/**
     * Create a stereo encoder for all potential 2D and 3D double bond stereo
     * configurations.
     *
     * @param container an atom container
     * @param graph     adjacency list representation of the container
     * @return a new encoder for tetrahedral elements
     */","('create', {'INSTRUCTION': {'covered': 63, 'missed': 7}, 'BRANCH': {'covered': 10, 'missed': 4}, 'LINE': {'covered': 11, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",175.0,Create a stereo encoder for all potential 2D and 3D double bond stereo  configurations.,15.0,"['There are potential 2D and 3D double bond stereo configurations.', 'There are 2D and 3D double bond stereo configurations.', 'There are 2D and 3D stereo configurations.']"
840,acs-aem-commons,com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,/bundle/src/main/java/com/adobe/acs/commons/ccvar/filter/ContentVariableJsonFilter.java,replaceInArray,172-194,"/**
     * Iterates through array items and replaces any placeholders found.
     *
     * @param node Array node
     * @param contentVariableReplacements current map of content variables
     */
private void replaceInArray(JsonNode node, Map<String, Object> contentVariableReplacements){
    if (node.get(0) != null && node.get(0).isTextual()) {
        List<String> updated = new LinkedList<>();
        for (JsonNode arrayItem : node) {
            String current = arrayItem.asText();
            updated.add(replaceInString(current, contentVariableReplacements));
        }
        ((ArrayNode) node).removeAll();
        for (int i = 0; i < updated.size(); i++) {
            ((ArrayNode) node).insert(i, updated.get(i));
        }
    } else if (node.get(0) != null && node.get(0).isContainerNode()) {
        for (JsonNode arrayItem : node) {
            replaceInElements(arrayItem, contentVariableReplacements);
        }
    }
}","private void replaceInArray(JsonNode node, Map<String, Object> contentVariableReplacements){
    if (node.get(0) != null && node.get(0).isTextual()) {
        List<String> updated = new LinkedList<>();
        for (JsonNode arrayItem : node) {
            String current = arrayItem.asText();
            updated.add(replaceInString(current, contentVariableReplacements));
        }
        ((ArrayNode) node).removeAll();
        for (int i = 0; i < updated.size(); i++) {
            ((ArrayNode) node).insert(i, updated.get(i));
        }
    } else if (node.get(0) != null && node.get(0).isContainerNode()) {
        for (JsonNode arrayItem : node) {
            replaceInElements(arrayItem, contentVariableReplacements);
        }
    }
}","/**
     * Iterates through array items and replaces any placeholders found.
     *
     * @param node Array node
     * @param contentVariableReplacements current map of content variables
     */","('replaceInArray', {'INSTRUCTION': {'covered': 81, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",175.0,  Iterates through array items and replaces any placeholders found.,10.0,"['Iterates through array items.', 'Iterates through the array items.', 'Iterates through the array items and replaces them with new ones.']"
841,cdk,org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/StandardAtomGenerator.java,chargeAdjunctText,605-636,"/**
     * Create the charge adjunct text for the specified charge and number of unpaired electrons.
     *
     * @param charge   formal charge
     * @param unpaired number of unpaired electrons
     * @return adjunct text
     */
 static String chargeAdjunctText(final int charge, final int unpaired){
    StringBuilder sb = new StringBuilder();
    if (unpaired == 1) {
        if (charge != 0) {
            sb.append('(').append(BULLET).append(')');
        } else {
            sb.append(BULLET);
        }
    } else if (unpaired > 1) {
        if (charge != 0) {
            sb.append('(').append(unpaired).append(BULLET).append(')');
        } else {
            sb.append(unpaired).append(BULLET);
        }
    }
    final char sign = charge < 0 ? MINUS : PLUS;
    final int coefficient = Math.abs(charge);
    if (coefficient > 1)
        sb.append(coefficient);
    if (coefficient > 0)
        sb.append(sign);
    return sb.toString();
}","static String chargeAdjunctText(final int charge, final int unpaired){
    StringBuilder sb = new StringBuilder();
    if (unpaired == 1) {
        if (charge != 0) {
            sb.append('(').append(BULLET).append(')');
        } else {
            sb.append(BULLET);
        }
    } else if (unpaired > 1) {
        if (charge != 0) {
            sb.append('(').append(unpaired).append(BULLET).append(')');
        } else {
            sb.append(unpaired).append(BULLET);
        }
    }
    final char sign = charge < 0 ? MINUS : PLUS;
    final int coefficient = Math.abs(charge);
    if (coefficient > 1)
        sb.append(coefficient);
    if (coefficient > 0)
        sb.append(sign);
    return sb.toString();
}","/**
     * Create the charge adjunct text for the specified charge and number of unpaired electrons.
     *
     * @param charge   formal charge
     * @param unpaired number of unpaired electrons
     * @return adjunct text
     */","('chargeAdjunctText', {'INSTRUCTION': {'covered': 70, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",175.0,  Create the charge adjunct text for the specified charge and number of unpaired electrons.,15.0,"['The specified charge and number of unpaired electrons should be written in the charge adjunct text.', 'The charge and number of unpaired electrons should be written in the charge adjunct text.', 'The charge and number of unpaired electrons should be written in the charge text.']"
842,matsim-libs,org/matsim/core/router/Dijkstra.java,/matsim/src/main/java/org/matsim/core/router/Dijkstra.java,constructPath,321-351,"/**
	 * Constructs the path after the algorithm has been run.
	 *
	 * @param fromNode
	 *            The node where the path starts.
	 * @param toNode
	 *            The node where the path ends.
	 * @param startTime
	 *            The time when the trip starts.
	 */
protected Path constructPath(Node fromNode, Node toNode, double startTime, double arrivalTime){
    List<Node> nodes = new ArrayList<>();
    List<Link> links = new ArrayList<>();
    nodes.add(0, toNode);
    Link tmpLink = getData(toNode).getPrevLink();
    if (tmpLink != null) {
        while (tmpLink.getFromNode() != fromNode) {
            links.add(0, tmpLink);
            nodes.add(0, tmpLink.getFromNode());
            tmpLink = getData(tmpLink.getFromNode()).getPrevLink();
        }
        links.add(0, tmpLink);
        nodes.add(0, tmpLink.getFromNode());
    }
    DijkstraNodeData toNodeData = getData(toNode);
    Path path = new Path(nodes, links, arrivalTime - startTime, toNodeData.getCost());
    return path;
}","protected Path constructPath(Node fromNode, Node toNode, double startTime, double arrivalTime){
    List<Node> nodes = new ArrayList<>();
    List<Link> links = new ArrayList<>();
    nodes.add(0, toNode);
    Link tmpLink = getData(toNode).getPrevLink();
    if (tmpLink != null) {
        while (tmpLink.getFromNode() != fromNode) {
            links.add(0, tmpLink);
            nodes.add(0, tmpLink.getFromNode());
            tmpLink = getData(tmpLink.getFromNode()).getPrevLink();
        }
        links.add(0, tmpLink);
        nodes.add(0, tmpLink.getFromNode());
    }
    DijkstraNodeData toNodeData = getData(toNode);
    Path path = new Path(nodes, links, arrivalTime - startTime, toNodeData.getCost());
    return path;
}","/**
	 * Constructs the path after the algorithm has been run.
	 *
	 * @param fromNode
	 *            The node where the path starts.
	 * @param toNode
	 *            The node where the path ends.
	 * @param startTime
	 *            The time when the trip starts.
	 */","('constructPath', {'INSTRUCTION': {'covered': 65, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",176.0,  Constructs the path after the algorithm has been run.,10.0,"['The path is constructed after the algorithm has been run.', 'The path is created after the algorithm has been run.', 'The path is constructed after the program has been run.']"
843,cdk,org/openscience/cdk/smiles/CDKToBeam.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/CDKToBeam.java,toBeamEdgeLabel,263-298,"/**
     * Convert a CDK {@link IBond} to the Beam edge label type.
     *
     * @param b cdk bond
     * @return the edge label for the Beam edge
     * @throws NullPointerException     the bond order was null and the bond was
     *                                  not-aromatic
     * @throws IllegalArgumentException the bond order could not be converted
     */
private static Bond toBeamEdgeLabel(IBond b, int flavour) throws CDKException{
    if (SmiFlavor.isSet(flavour, SmiFlavor.UseAromaticSymbols) && b.isAromatic()) {
        if (!b.getBegin().isAromatic() || !b.getEnd().isAromatic())
            throw new IllegalStateException(""Aromatic bond connects non-aromatic atomic atoms"");
        return Bond.AROMATIC;
    }
    if (b.getOrder() == null)
        throw new CDKException(""A bond had undefined order, possible query bond?"");
    IBond.Order order = b.getOrder();
    switch(order) {
        case SINGLE:
            return Bond.SINGLE;
        case DOUBLE:
            return Bond.DOUBLE;
        case TRIPLE:
            return Bond.TRIPLE;
        case QUADRUPLE:
            return Bond.QUADRUPLE;
        default:
            if (!SmiFlavor.isSet(flavour, SmiFlavor.UseAromaticSymbols) && b.isAromatic())
                throw new CDKException(""Cannot write Kekul SMILES output due to aromatic bond with unset bond order - molecule should be Kekulized"");
            throw new CDKException(""Unsupported bond order: "" + order);
    }
}","private static Bond toBeamEdgeLabel(IBond b, int flavour) throws CDKException{
    if (SmiFlavor.isSet(flavour, SmiFlavor.UseAromaticSymbols) && b.isAromatic()) {
        if (!b.getBegin().isAromatic() || !b.getEnd().isAromatic())
            throw new IllegalStateException(""Aromatic bond connects non-aromatic atomic atoms"");
        return Bond.AROMATIC;
    }
    if (b.getOrder() == null)
        throw new CDKException(""A bond had undefined order, possible query bond?"");
    IBond.Order order = b.getOrder();
    switch(order) {
        case SINGLE:
            return Bond.SINGLE;
        case DOUBLE:
            return Bond.DOUBLE;
        case TRIPLE:
            return Bond.TRIPLE;
        case QUADRUPLE:
            return Bond.QUADRUPLE;
        default:
            if (!SmiFlavor.isSet(flavour, SmiFlavor.UseAromaticSymbols) && b.isAromatic())
                throw new CDKException(""Cannot write Kekul SMILES output due to aromatic bond with unset bond order - molecule should be Kekulized"");
            throw new CDKException(""Unsupported bond order: "" + order);
    }
}","/**
     * Convert a CDK {@link IBond} to the Beam edge label type.
     *
     * @param b cdk bond
     * @return the edge label for the Beam edge
     * @throws NullPointerException     the bond order was null and the bond was
     *                                  not-aromatic
     * @throws IllegalArgumentException the bond order could not be converted
     */","('toBeamEdgeLabel', {'INSTRUCTION': {'covered': 70, 'missed': 0}, 'BRANCH': {'covered': 17, 'missed': 2}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",176.0,  Convert a CDK {@link IBond} to the Beam edge label type.,15.0,"['The CDK can be converted to the Beam edge label type.', 'The CDK should be converted to the Beam edge label type.', 'The Beam edge label type is a CDK @link IBond conversion.']"
844,cdk,org/openscience/cdk/geometry/cip/LigancyFourChirality.java,/descriptor/cip/src/main/java/org/openscience/cdk/geometry/cip/LigancyFourChirality.java,project,117-149,"/**
     * Recalculates the {@link LigancyFourChirality} based on the new, given atom ordering.
     *
     * @param newOrder new order of atoms
     * @return the chirality following the new atom order
     */
public LigancyFourChirality project(ILigand[] newOrder){
    ITetrahedralChirality.Stereo newStereo = this.stereo;
    ILigand[] newAtoms = new ILigand[4];
    System.arraycopy(this.ligands, 0, newAtoms, 0, 4);
    for (int i = 0; i < 3; i++) {
        if (!newAtoms[i].getLigandAtom().equals(newOrder[i].getLigandAtom())) {
            for (int j = i; j < 4; j++) {
                if (newAtoms[j].getLigandAtom().equals(newOrder[i].getLigandAtom())) {
                    swap(newAtoms, i, j);
                    if (newStereo == Stereo.CLOCKWISE) {
                        newStereo = Stereo.ANTI_CLOCKWISE;
                    } else {
                        newStereo = Stereo.CLOCKWISE;
                    }
                }
            }
        }
    }
    return new LigancyFourChirality(chiralAtom, newAtoms, newStereo);
}","public LigancyFourChirality project(ILigand[] newOrder){
    ITetrahedralChirality.Stereo newStereo = this.stereo;
    ILigand[] newAtoms = new ILigand[4];
    System.arraycopy(this.ligands, 0, newAtoms, 0, 4);
    for (int i = 0; i < 3; i++) {
        if (!newAtoms[i].getLigandAtom().equals(newOrder[i].getLigandAtom())) {
            for (int j = i; j < 4; j++) {
                if (newAtoms[j].getLigandAtom().equals(newOrder[i].getLigandAtom())) {
                    swap(newAtoms, i, j);
                    if (newStereo == Stereo.CLOCKWISE) {
                        newStereo = Stereo.ANTI_CLOCKWISE;
                    } else {
                        newStereo = Stereo.CLOCKWISE;
                    }
                }
            }
        }
    }
    return new LigancyFourChirality(chiralAtom, newAtoms, newStereo);
}","/**
     * Recalculates the {@link LigancyFourChirality} based on the new, given atom ordering.
     *
     * @param newOrder new order of atoms
     * @return the chirality following the new atom order
     */","('project', {'INSTRUCTION': {'covered': 68, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 12, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",176.0,"  Recalculates the {@link LigancyFourChirality} based on the new, given atom ordering.",16.0,"['The calculation is based on the new atom ordering.', 'The @link Ligancy FourChirality is calculated based on the new atom ordering.', 'The @link Ligancy FourChirality is calculated using the new atom ordering.']"
845,cdk,org/openscience/cdk/group/EquitablePartitionRefiner.java,/tool/group/src/main/java/org/openscience/cdk/group/EquitablePartitionRefiner.java,refine,89-126,"/**
     * Refines the coarse partition <code>a</code> into a finer one.
     *
     * @param coarser the partition to refine
     * @return a finer partition
     */
public Partition refine(Partition coarser){
    Partition finer = new Partition(coarser);
    blocksToRefine = new LinkedList<Set<Integer>>();
    for (int i = 0; i < finer.size(); i++) {
        blocksToRefine.add(finer.copyBlock(i));
    }
    int numberOfVertices = refinable.getVertexCount();
    while (!blocksToRefine.isEmpty()) {
        Set<Integer> t = blocksToRefine.remove();
        currentBlockIndex = 0;
        while (currentBlockIndex < finer.size() && finer.size() < numberOfVertices) {
            if (!finer.isDiscreteCell(currentBlockIndex)) {
                Map<Invariant, SortedSet<Integer>> invariants = getInvariants(finer, t);
                split(invariants, finer);
            }
            currentBlockIndex++;
        }
        if (finer.size() == numberOfVertices) {
            return finer;
        }
    }
    return finer;
}","public Partition refine(Partition coarser){
    Partition finer = new Partition(coarser);
    blocksToRefine = new LinkedList<Set<Integer>>();
    for (int i = 0; i < finer.size(); i++) {
        blocksToRefine.add(finer.copyBlock(i));
    }
    int numberOfVertices = refinable.getVertexCount();
    while (!blocksToRefine.isEmpty()) {
        Set<Integer> t = blocksToRefine.remove();
        currentBlockIndex = 0;
        while (currentBlockIndex < finer.size() && finer.size() < numberOfVertices) {
            if (!finer.isDiscreteCell(currentBlockIndex)) {
                Map<Invariant, SortedSet<Integer>> invariants = getInvariants(finer, t);
                split(invariants, finer);
            }
            currentBlockIndex++;
        }
        if (finer.size() == numberOfVertices) {
            return finer;
        }
    }
    return finer;
}","/**
     * Refines the coarse partition <code>a</code> into a finer one.
     *
     * @param coarser the partition to refine
     * @return a finer partition
     */","('refine', {'INSTRUCTION': {'covered': 80, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,  Refines the coarse partition <code>a</code> into a finer one.,16.0,"['The coarse partition is refined into a fine one.', 'The partition is refined into a fine one.', 'The coarse partition is refined into a fine partition.']"
846,jackson-databind,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,_readTreeAndClose,4685-4726,"/**
     * Similar to {@link #_readMapAndClose} but specialized for <code>JsonNode</code>
     * reading.
     *
     * @since 2.9
     */
protected JsonNode _readTreeAndClose(JsonParser p0) throws IOException{
    try (JsonParser p = p0) {
        final JavaType valueType = constructType(JsonNode.class);
        DeserializationConfig cfg = getDeserializationConfig();
        cfg.initialize(p);
        JsonToken t = p.currentToken();
        if (t == null) {
            t = p.nextToken();
            if (t == null) {
                return cfg.getNodeFactory().missingNode();
            }
        }
        final JsonNode resultNode;
        final DefaultDeserializationContext ctxt = createDeserializationContext(p, cfg);
        if (t == JsonToken.VALUE_NULL) {
            resultNode = cfg.getNodeFactory().nullNode();
        } else {
            resultNode = (JsonNode) ctxt.readRootValue(p, valueType, _findRootDeserializer(ctxt, valueType), null);
        }
        if (cfg.isEnabled(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)) {
            _verifyNoTrailingTokens(p, ctxt, valueType);
        }
        return resultNode;
    }
}","protected JsonNode _readTreeAndClose(JsonParser p0) throws IOException{
    try (JsonParser p = p0) {
        final JavaType valueType = constructType(JsonNode.class);
        DeserializationConfig cfg = getDeserializationConfig();
        cfg.initialize(p);
        JsonToken t = p.currentToken();
        if (t == null) {
            t = p.nextToken();
            if (t == null) {
                return cfg.getNodeFactory().missingNode();
            }
        }
        final JsonNode resultNode;
        final DefaultDeserializationContext ctxt = createDeserializationContext(p, cfg);
        if (t == JsonToken.VALUE_NULL) {
            resultNode = cfg.getNodeFactory().nullNode();
        } else {
            resultNode = (JsonNode) ctxt.readRootValue(p, valueType, _findRootDeserializer(ctxt, valueType), null);
        }
        if (cfg.isEnabled(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)) {
            _verifyNoTrailingTokens(p, ctxt, valueType);
        }
        return resultNode;
    }
}","/**
     * Similar to {@link #_readMapAndClose} but specialized for <code>JsonNode</code>
     * reading.
     *
     * @since 2.9
     */","('_readTreeAndClose', {'INSTRUCTION': {'covered': 70, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,  Similar to {@link #_readMapAndClose} but specialized for <code>JsonNode</code>  reading.,20.0,"['Similar to @link #_readMapAndClose but specialized for code reading.', 'It is similar to @link #_readMapAndClose but specialized for code reading.', 'It is similar to @link #_readMapAndClose but specialized for code.']"
847,cdk,org/openscience/cdk/renderer/generators/standard/TextOutline.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/TextOutline.java,transformedBounds,135-156,"/**
     * Access the bounds of a shape that have been transformed.
     *
     * @param shape any shape
     * @return the bounds of the shape transformed
     */
private Rectangle2D transformedBounds(Shape shape){
    Rectangle2D rectangle2D = shape.getBounds2D();
    Point2D minPoint = new Point2D.Double(rectangle2D.getMinX(), rectangle2D.getMinY());
    Point2D maxPoint = new Point2D.Double(rectangle2D.getMaxX(), rectangle2D.getMaxY());
    transform.transform(minPoint, minPoint);
    transform.transform(maxPoint, maxPoint);
    double minX = Math.min(minPoint.getX(), maxPoint.getX());
    double maxX = Math.max(minPoint.getX(), maxPoint.getX());
    double minY = Math.min(minPoint.getY(), maxPoint.getY());
    double maxY = Math.max(minPoint.getY(), maxPoint.getY());
    return new Rectangle2D.Double(minX, minY, maxX - minX, maxY - minY);
}","private Rectangle2D transformedBounds(Shape shape){
    Rectangle2D rectangle2D = shape.getBounds2D();
    Point2D minPoint = new Point2D.Double(rectangle2D.getMinX(), rectangle2D.getMinY());
    Point2D maxPoint = new Point2D.Double(rectangle2D.getMaxX(), rectangle2D.getMaxY());
    transform.transform(minPoint, minPoint);
    transform.transform(maxPoint, maxPoint);
    double minX = Math.min(minPoint.getX(), maxPoint.getX());
    double maxX = Math.max(minPoint.getX(), maxPoint.getX());
    double minY = Math.min(minPoint.getY(), maxPoint.getY());
    double maxY = Math.max(minPoint.getY(), maxPoint.getY());
    return new Rectangle2D.Double(minX, minY, maxX - minX, maxY - minY);
}","/**
     * Access the bounds of a shape that have been transformed.
     *
     * @param shape any shape
     * @return the bounds of the shape transformed
     */","('transformedBounds', {'INSTRUCTION': {'covered': 67, 'missed': 0}, 'LINE': {'covered': 10, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,  Access the bounds of a shape that have been transformed.,11.0,"['The bounds of a shape have been changed.', 'The bounds of a shape have changed.', 'Access the bounds of a shape that has changed.']"
848,dcache,org/dcache/pool/classic/StorageClassContainer.java,/modules/dcache/src/main/java/org/dcache/pool/classic/StorageClassContainer.java,addCacheEntry,157-190,"/**
     * adds a CacheEntry to the list of HSM storage requests.
     *
     * @param entry
     */
public synchronized void addCacheEntry(CacheEntry entry) throws CacheException, InterruptedException{
    FileAttributes fileAttributes = entry.getFileAttributes();
    String storageClass = fileAttributes.getStorageClass();
    String hsmName = fileAttributes.getHsm().toLowerCase();
    String composedName = storageClass + ""@"" + hsmName;
    StorageClassInfo classInfo = _storageClasses.get(composedName);
    if (classInfo == null) {
        classInfo = new StorageClassInfo(_storageHandler, hsmName, storageClass);
        StorageClassInfo tmpInfo = _storageClasses.get(""*@"" + hsmName);
        if (tmpInfo != null) {
            classInfo.setExpiration(tmpInfo.getExpiration());
            classInfo.setPending(tmpInfo.getPending());
            classInfo.setMaxSize(tmpInfo.getMaxSize());
            classInfo.setOpen(tmpInfo.isOpen());
        }
        _storageClasses.put(composedName, classInfo);
    }
    classInfo.add(entry);
    _pnfsIds.put(entry.getPnfsId(), classInfo);
}","public synchronized void addCacheEntry(CacheEntry entry) throws CacheException, InterruptedException{
    FileAttributes fileAttributes = entry.getFileAttributes();
    String storageClass = fileAttributes.getStorageClass();
    String hsmName = fileAttributes.getHsm().toLowerCase();
    String composedName = storageClass + ""@"" + hsmName;
    StorageClassInfo classInfo = _storageClasses.get(composedName);
    if (classInfo == null) {
        classInfo = new StorageClassInfo(_storageHandler, hsmName, storageClass);
        StorageClassInfo tmpInfo = _storageClasses.get(""*@"" + hsmName);
        if (tmpInfo != null) {
            classInfo.setExpiration(tmpInfo.getExpiration());
            classInfo.setPending(tmpInfo.getPending());
            classInfo.setMaxSize(tmpInfo.getMaxSize());
            classInfo.setOpen(tmpInfo.isOpen());
        }
        _storageClasses.put(composedName, classInfo);
    }
    classInfo.add(entry);
    _pnfsIds.put(entry.getPnfsId(), classInfo);
}","/**
     * adds a CacheEntry to the list of HSM storage requests.
     *
     * @param entry
     */","('addCacheEntry', {'INSTRUCTION': {'covered': 72, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 2}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,  adds a CacheEntry to the list of HSM storage requests.,11.0,"['A cache entry is added to the list of storage requests.', 'There is a list of storage requests.', 'The list of storage requests has a cache entry added.']"
849,liquibase,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,fixupArgs,814-839,"/**
     * On windows machines, it splits args on '=' signs.  Put it back like it was.
     */
protected String[] fixupArgs(String[] args){
    List<String> fixedArgs = new ArrayList<>();
    for (int i = 0; i < args.length; i++) {
        String arg = args[i];
        if ((arg.startsWith(""--"") || arg.startsWith(""-D"")) && !arg.contains(""="")) {
            String nextArg = null;
            if ((i + 1) < args.length) {
                nextArg = args[i + 1];
            }
            if ((nextArg != null) && !nextArg.startsWith(""--"") && !isCommand(nextArg)) {
                arg = arg + ""="" + nextArg;
                i++;
            }
        }
        arg = arg.replace(""\\,"", "","");
        fixedArgs.add(arg);
    }
    return fixedArgs.toArray(new String[fixedArgs.size()]);
}","protected String[] fixupArgs(String[] args){
    List<String> fixedArgs = new ArrayList<>();
    for (int i = 0; i < args.length; i++) {
        String arg = args[i];
        if ((arg.startsWith(""--"") || arg.startsWith(""-D"")) && !arg.contains(""="")) {
            String nextArg = null;
            if ((i + 1) < args.length) {
                nextArg = args[i + 1];
            }
            if ((nextArg != null) && !nextArg.startsWith(""--"") && !isCommand(nextArg)) {
                arg = arg + ""="" + nextArg;
                i++;
            }
        }
        arg = arg.replace(""\\,"", "","");
        fixedArgs.add(arg);
    }
    return fixedArgs.toArray(new String[fixedArgs.size()]);
}","/**
     * On windows machines, it splits args on '=' signs.  Put it back like it was.
     */","('fixupArgs', {'INSTRUCTION': {'covered': 79, 'missed': 0}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,"  On windows machines, it splits args on '=' signs.",12.0,"['It splits args on windows machines.', 'On windows machines, it splits args on signs.', 'On windows machines, it splits args.']"
850,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,findRelationship,269-309,"/**
     * Find out if the relationship is already stored in the repository.
     * It will search for relationships that have the source firstGUID and target secondGUID
     *
     * @param userId               the name of the calling user
     * @param firstGUID            the unique identifier of the entity at first end
     * @param secondGUID           the unique identifier of the entity at second end
     * @param relationshipTypeName type name for the relationship to create
     * @param firstEntityTypeName  type name for the entity at first end
     *
     * @return The found relationship or an empty Optional
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */
protected Optional<Relationship> findRelationship(String userId, String firstGUID, String secondGUID, String firstEntityTypeName, String relationshipTypeName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    final String methodName = ""findRelationship"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateName(firstGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    invalidParameterHandler.validateName(secondGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    TypeDef relationshipTypeDef = repositoryHelper.getTypeDefByName(userId, relationshipTypeName);
    Relationship relationshipBetweenEntities = repositoryHandler.getRelationshipBetweenEntities(userId, firstGUID, firstEntityTypeName, secondGUID, relationshipTypeDef.getGUID(), relationshipTypeDef.getName(), methodName);
    if (relationshipBetweenEntities == null) {
        return Optional.empty();
    }
    if (firstGUID.equalsIgnoreCase(relationshipBetweenEntities.getEntityOneProxy().getGUID()) && secondGUID.equalsIgnoreCase(relationshipBetweenEntities.getEntityTwoProxy().getGUID())) {
        return Optional.of(relationshipBetweenEntities);
    }
    return Optional.empty();
}","protected Optional<Relationship> findRelationship(String userId, String firstGUID, String secondGUID, String firstEntityTypeName, String relationshipTypeName) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    final String methodName = ""findRelationship"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateName(firstGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    invalidParameterHandler.validateName(secondGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    TypeDef relationshipTypeDef = repositoryHelper.getTypeDefByName(userId, relationshipTypeName);
    Relationship relationshipBetweenEntities = repositoryHandler.getRelationshipBetweenEntities(userId, firstGUID, firstEntityTypeName, secondGUID, relationshipTypeDef.getGUID(), relationshipTypeDef.getName(), methodName);
    if (relationshipBetweenEntities == null) {
        return Optional.empty();
    }
    if (firstGUID.equalsIgnoreCase(relationshipBetweenEntities.getEntityOneProxy().getGUID()) && secondGUID.equalsIgnoreCase(relationshipBetweenEntities.getEntityTwoProxy().getGUID())) {
        return Optional.of(relationshipBetweenEntities);
    }
    return Optional.empty();
}","/**
     * Find out if the relationship is already stored in the repository.
     * It will search for relationships that have the source firstGUID and target secondGUID
     *
     * @param userId               the name of the calling user
     * @param firstGUID            the unique identifier of the entity at first end
     * @param secondGUID           the unique identifier of the entity at second end
     * @param relationshipTypeName type name for the relationship to create
     * @param firstEntityTypeName  type name for the entity at first end
     *
     * @return The found relationship or an empty Optional
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */","('findRelationship', {'INSTRUCTION': {'covered': 57, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",177.0,  Find out if the relationship is already stored in the repository.,12.0,"['If the relationship is already in the repository, you should find it.', 'If the relationship is already in the repository, you should find out.', 'If the relationship is already stored in the repository, you should find out.']"
851,egeria,org/odpi/openmetadata/frameworks/discovery/properties/Annotation.java,/open-metadata-implementation/frameworks/open-discovery-framework/src/main/java/org/odpi/openmetadata/frameworks/discovery/properties/Annotation.java,equals,412-443,"/**
     * Compare the values of the supplied object with those stored in the current object.
     *
     * @param objectToCompare supplied object
     * @return boolean result of comparison
     */
public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
        return false;
    }
    Annotation that = (Annotation) objectToCompare;
    return confidenceLevel == that.confidenceLevel && numAttachedAnnotations == that.numAttachedAnnotations && Objects.equals(annotationType, that.annotationType) && Objects.equals(summary, that.summary) && Objects.equals(expression, that.expression) && Objects.equals(explanation, that.explanation) && Objects.equals(analysisStep, that.analysisStep) && Objects.equals(jsonProperties, that.jsonProperties) && annotationStatus == that.annotationStatus && Objects.equals(reviewDate, that.reviewDate) && Objects.equals(steward, that.steward) && Objects.equals(reviewComment, that.reviewComment) && Objects.equals(additionalProperties, that.additionalProperties);
}","public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
        return false;
    }
    Annotation that = (Annotation) objectToCompare;
    return confidenceLevel == that.confidenceLevel && numAttachedAnnotations == that.numAttachedAnnotations && Objects.equals(annotationType, that.annotationType) && Objects.equals(summary, that.summary) && Objects.equals(expression, that.expression) && Objects.equals(explanation, that.explanation) && Objects.equals(analysisStep, that.analysisStep) && Objects.equals(jsonProperties, that.jsonProperties) && annotationStatus == that.annotationStatus && Objects.equals(reviewDate, that.reviewDate) && Objects.equals(steward, that.steward) && Objects.equals(reviewComment, that.reviewComment) && Objects.equals(additionalProperties, that.additionalProperties);
}","/**
     * Compare the values of the supplied object with those stored in the current object.
     *
     * @param objectToCompare supplied object
     * @return boolean result of comparison
     */","('equals', {'INSTRUCTION': {'covered': 96, 'missed': 0}, 'BRANCH': {'covered': 20, 'missed': 12}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 12}, 'METHOD': {'covered': 1, 'missed': 0}})",178.0,  Compare the values of the supplied object with those stored in the current object.,15.0,"['The values of the supplied object should be compared with those in the current object.', 'The values of the supplied object and the current object should be compared.', 'The values of the supplied object and those stored in the current object are compared.']"
852,cdk,org/openscience/cdk/fingerprint/PubchemFingerprinter.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/PubchemFingerprinter.java,decode,346-375,"/**
     * Returns a fingerprint from a Base64 encoded Pubchem fingerprint.
     *
     * @param enc The Base64 encoded fingerprint
     * @return A BitSet corresponding to the input fingerprint
     */
public static BitSet decode(String enc){
    byte[] fp = base64Decode(enc);
    if (fp.length < 4) {
        throw new IllegalArgumentException(""Input is not a proper PubChem base64 encoded fingerprint"");
    }
    int len = (fp[0] << 24) | (fp[1] << 16) | (fp[2] << 8) | (fp[3] & 0xff);
    if (len != FP_SIZE) {
        throw new IllegalArgumentException(""Input is not a proper PubChem base64 encoded fingerprint"");
    }
    PubchemFingerprinter pc = new PubchemFingerprinter(null);
    for (int i = 0; i < pc.m_bits.length; ++i) {
        pc.m_bits[i] = fp[i + 4];
    }
    BitSet ret = new BitSet(FP_SIZE);
    for (int i = 0; i < FP_SIZE; i++) {
        if (pc.isBitOn(i))
            ret.set(i);
    }
    return ret;
}","public static BitSet decode(String enc){
    byte[] fp = base64Decode(enc);
    if (fp.length < 4) {
        throw new IllegalArgumentException(""Input is not a proper PubChem base64 encoded fingerprint"");
    }
    int len = (fp[0] << 24) | (fp[1] << 16) | (fp[2] << 8) | (fp[3] & 0xff);
    if (len != FP_SIZE) {
        throw new IllegalArgumentException(""Input is not a proper PubChem base64 encoded fingerprint"");
    }
    PubchemFingerprinter pc = new PubchemFingerprinter(null);
    for (int i = 0; i < pc.m_bits.length; ++i) {
        pc.m_bits[i] = fp[i + 4];
    }
    BitSet ret = new BitSet(FP_SIZE);
    for (int i = 0; i < FP_SIZE; i++) {
        if (pc.isBitOn(i))
            ret.set(i);
    }
    return ret;
}","/**
     * Returns a fingerprint from a Base64 encoded Pubchem fingerprint.
     *
     * @param enc The Base64 encoded fingerprint
     * @return A BitSet corresponding to the input fingerprint
     */","('decode', {'INSTRUCTION': {'covered': 83, 'missed': 5}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",178.0,Returns a fingerprint from a Base64 encoded Pubchem fingerprint.,10.0,"['A Base64 encoded Pubchem fingerprints is returned.', 'A Base64 encoded Pub Chem fingerprints is returned.', 'A Base64 encoded Pubchem fingerprint is returned.']"
853,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineFolderHierarchyHandler.java,upsertFolderHierarchy,65-107,"/**
     * Construct the folder structure in which a data file is stored all the way to the SoftwareServerCapability. Care is
     * taken to maintain uniqueness of the relationship NestedFile that is between the file and the first folder.
     *
     * @param fileGuid           data file guid
     * @param pathName           file path
     * @param externalSourceGuid external source guid
     * @param externalSourceName external source name
     * @param userId             user id
     * @param methodName         method name
     *
     * @throws InvalidParameterException  if invalid parameters
     * @throws PropertyServerException    if errors in repository
     * @throws UserNotAuthorizedException if user not authorized
     */
public void upsertFolderHierarchy(String fileGuid, String pathName, String externalSourceGuid, String externalSourceName, String userId, String methodName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
    if (StringUtils.isEmpty(pathName)) {
        return;
    }
    validateParameters(fileGuid, externalSourceGuid, externalSourceName, userId, methodName);
    List<FileFolder> folders = extractFolders(pathName, externalSourceName, methodName);
    String folderGuid = """";
    String previousEntityGuid = fileGuid;
    String relationshipTypeName = NESTED_FILE_TYPE_NAME;
    for (FileFolder folder : folders) {
        if (relationshipTypeName.equals(NESTED_FILE_TYPE_NAME)) {
            deleteExistingNestedFileRelationships(fileGuid, externalSourceGuid, externalSourceName, userId, methodName);
        }
        folderGuid = upsertFolder(externalSourceGuid, externalSourceName, folder, userId, methodName);
        dataEngineCommonHandler.upsertExternalRelationship(userId, folderGuid, previousEntityGuid, relationshipTypeName, FILE_FOLDER_TYPE_NAME, externalSourceName, null);
        previousEntityGuid = folderGuid;
        relationshipTypeName = FOLDER_HIERARCHY_TYPE_NAME;
    }
    dataEngineCommonHandler.upsertExternalRelationship(userId, externalSourceGuid, folderGuid, SERVER_ASSET_USE_TYPE_NAME, SOFTWARE_SERVER_CAPABILITY_TYPE_NAME, externalSourceName, null);
}","public void upsertFolderHierarchy(String fileGuid, String pathName, String externalSourceGuid, String externalSourceName, String userId, String methodName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
    if (StringUtils.isEmpty(pathName)) {
        return;
    }
    validateParameters(fileGuid, externalSourceGuid, externalSourceName, userId, methodName);
    List<FileFolder> folders = extractFolders(pathName, externalSourceName, methodName);
    String folderGuid = """";
    String previousEntityGuid = fileGuid;
    String relationshipTypeName = NESTED_FILE_TYPE_NAME;
    for (FileFolder folder : folders) {
        if (relationshipTypeName.equals(NESTED_FILE_TYPE_NAME)) {
            deleteExistingNestedFileRelationships(fileGuid, externalSourceGuid, externalSourceName, userId, methodName);
        }
        folderGuid = upsertFolder(externalSourceGuid, externalSourceName, folder, userId, methodName);
        dataEngineCommonHandler.upsertExternalRelationship(userId, folderGuid, previousEntityGuid, relationshipTypeName, FILE_FOLDER_TYPE_NAME, externalSourceName, null);
        previousEntityGuid = folderGuid;
        relationshipTypeName = FOLDER_HIERARCHY_TYPE_NAME;
    }
    dataEngineCommonHandler.upsertExternalRelationship(userId, externalSourceGuid, folderGuid, SERVER_ASSET_USE_TYPE_NAME, SOFTWARE_SERVER_CAPABILITY_TYPE_NAME, externalSourceName, null);
}","/**
     * Construct the folder structure in which a data file is stored all the way to the SoftwareServerCapability. Care is
     * taken to maintain uniqueness of the relationship NestedFile that is between the file and the first folder.
     *
     * @param fileGuid           data file guid
     * @param pathName           file path
     * @param externalSourceGuid external source guid
     * @param externalSourceName external source name
     * @param userId             user id
     * @param methodName         method name
     *
     * @throws InvalidParameterException  if invalid parameters
     * @throws PropertyServerException    if errors in repository
     * @throws UserNotAuthorizedException if user not authorized
     */","('upsertFolderHierarchy', {'INSTRUCTION': {'covered': 77, 'missed': 1}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 16, 'missed': 1}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",180.0,  Construct the folder structure in which a data file is stored all the way to the SoftwareServerCapability.,18.0,"['A data file is stored all the way to the SoftwareServerCapability.', 'A data file is stored all the way to the SoftwareServerCapability if the folder structure is constructed correctly.', 'The folder structure in which the data file is stored should be constructed.']"
854,cdk,org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,reverse,270-300,"/**
     * Reverse a list of tokens for display, flipping
     * brackets as needed.
     *
     * @param tokens list of tokens
     */
 static void reverse(List<String> tokens){
    Collections.reverse(tokens);
    Deque<String> numbers = new ArrayDeque<>();
    for (int i = 0; i < tokens.size(); i++) {
        String token = tokens.get(i);
        if (token.equals(""("")) {
            tokens.set(i, "")"");
            String num = numbers.pop();
            if (!num.isEmpty()) {
                tokens.add(i + 1, num);
                i++;
            }
        } else if (token.equals("")"")) {
            tokens.set(i, ""("");
            if (i > 0 && isNumber(tokens.get(i - 1))) {
                numbers.push(tokens.remove(i - 1));
                i--;
            } else {
                numbers.push("""");
            }
        }
    }
}","static void reverse(List<String> tokens){
    Collections.reverse(tokens);
    Deque<String> numbers = new ArrayDeque<>();
    for (int i = 0; i < tokens.size(); i++) {
        String token = tokens.get(i);
        if (token.equals(""("")) {
            tokens.set(i, "")"");
            String num = numbers.pop();
            if (!num.isEmpty()) {
                tokens.add(i + 1, num);
                i++;
            }
        } else if (token.equals("")"")) {
            tokens.set(i, ""("");
            if (i > 0 && isNumber(tokens.get(i - 1))) {
                numbers.push(tokens.remove(i - 1));
                i--;
            } else {
                numbers.push("""");
            }
        }
    }
}","/**
     * Reverse a list of tokens for display, flipping
     * brackets as needed.
     *
     * @param tokens list of tokens
     */","('reverse', {'INSTRUCTION': {'covered': 76, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",184.0,"  Reverse a list of tokens for display, flipping  brackets as needed.",13.0,"['The list of token should be reversed and brackets flipped as needed.', 'The list of token should be reversed and brackets flipped.', 'A list of token should be reversed and brackets flipped.']"
855,egeria,org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,/open-metadata-implementation/access-services/asset-lineage/asset-lineage-server/src/main/java/org/odpi/openmetadata/accessservices/assetlineage/handlers/AssetContextHandler.java,buildSchemaElementContext,67-105,"/**
     * Builds the context for a schema element without the asset context.
     *
     * @param userId       the unique identifier for the user
     * @param entityDetail the entity for which the context is build
     *
     * @return the context of the schema element
     *
     * @throws OCFCheckedExceptionBase checked exception for reporting errors found when using OCF connectors
     */
public Map<String, RelationshipsContext> buildSchemaElementContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
    final String methodName = ""buildSchemaElementContext"";
    handlerHelper.validateAsset(entityDetail, methodName, supportedZones);
    Map<String, RelationshipsContext> context = new HashMap<>();
    final String typeDefName = entityDetail.getType().getTypeDefName();
    Set<GraphContext> columnContext = new HashSet<>();
    switch(typeDefName) {
        case TABULAR_COLUMN:
            if (!isInternalTabularColumn(userId, entityDetail)) {
                columnContext = buildTabularColumnContext(userId, entityDetail);
            }
            break;
        case TABULAR_FILE_COLUMN:
            columnContext = buildTabularColumnContext(userId, entityDetail);
            break;
        case RELATIONAL_COLUMN:
            columnContext = buildRelationalColumnContext(userId, entityDetail);
            break;
        case EVENT_SCHEMA_ATTRIBUTE:
            columnContext = buildEventSchemaAttributeContext(userId, entityDetail);
            break;
        default:
            return context;
    }
    context.put(AssetLineageEventType.COLUMN_CONTEXT_EVENT.getEventTypeName(), new RelationshipsContext(entityDetail.getGUID(), columnContext));
    return context;
}","public Map<String, RelationshipsContext> buildSchemaElementContext(String userId, EntityDetail entityDetail) throws OCFCheckedExceptionBase{
    final String methodName = ""buildSchemaElementContext"";
    handlerHelper.validateAsset(entityDetail, methodName, supportedZones);
    Map<String, RelationshipsContext> context = new HashMap<>();
    final String typeDefName = entityDetail.getType().getTypeDefName();
    Set<GraphContext> columnContext = new HashSet<>();
    switch(typeDefName) {
        case TABULAR_COLUMN:
            if (!isInternalTabularColumn(userId, entityDetail)) {
                columnContext = buildTabularColumnContext(userId, entityDetail);
            }
            break;
        case TABULAR_FILE_COLUMN:
            columnContext = buildTabularColumnContext(userId, entityDetail);
            break;
        case RELATIONAL_COLUMN:
            columnContext = buildRelationalColumnContext(userId, entityDetail);
            break;
        case EVENT_SCHEMA_ATTRIBUTE:
            columnContext = buildEventSchemaAttributeContext(userId, entityDetail);
            break;
        default:
            return context;
    }
    context.put(AssetLineageEventType.COLUMN_CONTEXT_EVENT.getEventTypeName(), new RelationshipsContext(entityDetail.getGUID(), columnContext));
    return context;
}","/**
     * Builds the context for a schema element without the asset context.
     *
     * @param userId       the unique identifier for the user
     * @param entityDetail the entity for which the context is build
     *
     * @return the context of the schema element
     *
     * @throws OCFCheckedExceptionBase checked exception for reporting errors found when using OCF connectors
     */","('buildSchemaElementContext', {'INSTRUCTION': {'covered': 71, 'missed': 2}, 'BRANCH': {'covered': 6, 'missed': 1}, 'LINE': {'covered': 16, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",185.0,  Builds the context for a schema element without the asset context.,12.0,"['The asset context is not built for a schema element.', 'The asset context is not built for the element.', 'The asset context is built for the element.']"
856,cdk,org/openscience/cdk/qsar/descriptors/molecular/FMFDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/FMFDescriptor.java,calculate,58-89,"/**
     * Calculates the FMF descriptor value for the given {@link IAtomContainer}.
     *
     * @param container An {@link org.openscience.cdk.interfaces.IAtomContainer} for which this descriptor
     *                  should be calculated
     * @return An object of {@link org.openscience.cdk.qsar.DescriptorValue} that contains the
     *         calculated FMF descriptor value as well as specification details
     */
public DescriptorValue calculate(IAtomContainer container){
    // don't mod original
    container = clone(container);
    MurckoFragmenter fragmenter = new MurckoFragmenter(true, 3);
    DoubleResult result;
    try {
        fragmenter.generateFragments(container);
        IAtomContainer[] framework = fragmenter.getFrameworksAsContainers();
        IAtomContainer[] ringSystems = fragmenter.getRingSystemsAsContainers();
        if (framework.length == 1) {
            result = new DoubleResult(framework[0].getAtomCount() / (double) container.getAtomCount());
        } else if (framework.length == 0 && ringSystems.length == 1) {
            result = new DoubleResult(ringSystems[0].getAtomCount() / (double) container.getAtomCount());
        } else
            result = new DoubleResult(0.0);
    } catch (CDKException e) {
        result = new DoubleResult(Double.NaN);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result, getDescriptorNames());
}","public DescriptorValue calculate(IAtomContainer container){
    // don't mod original
    container = clone(container);
    MurckoFragmenter fragmenter = new MurckoFragmenter(true, 3);
    DoubleResult result;
    try {
        fragmenter.generateFragments(container);
        IAtomContainer[] framework = fragmenter.getFrameworksAsContainers();
        IAtomContainer[] ringSystems = fragmenter.getRingSystemsAsContainers();
        if (framework.length == 1) {
            result = new DoubleResult(framework[0].getAtomCount() / (double) container.getAtomCount());
        } else if (framework.length == 0 && ringSystems.length == 1) {
            result = new DoubleResult(ringSystems[0].getAtomCount() / (double) container.getAtomCount());
        } else
            result = new DoubleResult(0.0);
    } catch (CDKException e) {
        result = new DoubleResult(Double.NaN);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result, getDescriptorNames());
}","/**
     * Calculates the FMF descriptor value for the given {@link IAtomContainer}.
     *
     * @param container An {@link org.openscience.cdk.interfaces.IAtomContainer} for which this descriptor
     *                  should be calculated
     * @return An object of {@link org.openscience.cdk.qsar.DescriptorValue} that contains the
     *         calculated FMF descriptor value as well as specification details
     */","('calculate', {'INSTRUCTION': {'covered': 62, 'missed': 20}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 12, 'missed': 3}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",186.0,  Calculates the FMF descriptor value for the given {@link IAtomContainer}.,14.0,"['The given @link IAtomContainer is calculated.', 'The given @link IAtomContainer is calculated as the FMF descriptor value.', 'The given @link IAtomContainer is calculated as a FMF descriptor value.']"
857,dcache,org/dcache/util/histograms/TimeseriesHistogram.java,/modules/common/src/main/java/org/dcache/util/histograms/TimeseriesHistogram.java,update,201-255,"/**
     * <p>Find from the timestamp where to insert the data (which bin).
     * If the bin index exceeds the last bin, rotate buffer. If the bin index is less than the first
     * bin, discard the update. The operation type determines how to insert the value.</p>
     *
     * @param value can be null; replace operations will substitute the null for the current value.
     *              Other operations, however, will only rotate the buffer if necessary, but will
     *              ignore the null value.
     */
private void update(Double value, UpdateOperation operation, Long timestamp){
    int binIndex = findTimebinIndex(timestamp);
    if (binIndex < 0) {
        return;
    }
    if (binIndex >= binCount) {
        binIndex = rotateBuffer(binIndex);
    }
    int count = metadata.updateCountForBin(binIndex, timestamp);
    if (value == null) {
        if (operation == UpdateOperation.REPLACE) {
            data.set(binIndex, value);
        }
    } else {
        switch(operation) {
            case REPLACE:
                data.set(binIndex, value);
                break;
            case SUM:
                Double d = data.get(binIndex);
                data.set(binIndex, d == null ? value : d + value);
                break;
            case AVERAGE:
                d = data.get(binIndex);
                data.set(binIndex, d == null ? value : (d + value) / count);
                break;
        }
        metadata.updateStatistics(value, timestamp);
    }
}","private void update(Double value, UpdateOperation operation, Long timestamp){
    int binIndex = findTimebinIndex(timestamp);
    if (binIndex < 0) {
        return;
    }
    if (binIndex >= binCount) {
        binIndex = rotateBuffer(binIndex);
    }
    int count = metadata.updateCountForBin(binIndex, timestamp);
    if (value == null) {
        if (operation == UpdateOperation.REPLACE) {
            data.set(binIndex, value);
        }
    } else {
        switch(operation) {
            case REPLACE:
                data.set(binIndex, value);
                break;
            case SUM:
                Double d = data.get(binIndex);
                data.set(binIndex, d == null ? value : d + value);
                break;
            case AVERAGE:
                d = data.get(binIndex);
                data.set(binIndex, d == null ? value : (d + value) / count);
                break;
        }
        metadata.updateStatistics(value, timestamp);
    }
}","/**
     * <p>Find from the timestamp where to insert the data (which bin).
     * If the bin index exceeds the last bin, rotate buffer. If the bin index is less than the first
     * bin, discard the update. The operation type determines how to insert the value.</p>
     *
     * @param value can be null; replace operations will substitute the null for the current value.
     *              Other operations, however, will only rotate the buffer if necessary, but will
     *              ignore the null value.
     */","('update', {'INSTRUCTION': {'covered': 90, 'missed': 14}, 'BRANCH': {'covered': 10, 'missed': 6}, 'LINE': {'covered': 16, 'missed': 3}, 'COMPLEXITY': {'covered': 5, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",186.0,  <p>Find from the timestamp where to insert the data (which bin).,17.0,"['The data can be found from the timestamp where to insert it.', 'The data can be found from the timestamp where to put it.', 'The data can be found from the timestamp.']"
858,liquibase,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,isChangeLogRequired,594-619,"/**
     * Returns true if the parameter --changeLogFile is requited for a given command
     *
     * @param command the command to test
     * @return true if a ChangeLog is required, false if not.
     */
private static boolean isChangeLogRequired(String command){
    return command.toLowerCase().startsWith(COMMANDS.UPDATE) || (command.toLowerCase().startsWith(COMMANDS.ROLLBACK) && (!command.equalsIgnoreCase(COMMANDS.ROLLBACK_ONE_CHANGE_SET) && !command.equalsIgnoreCase(COMMANDS.ROLLBACK_ONE_UPDATE))) || COMMANDS.REGISTER_CHANGELOG.equalsIgnoreCase(command) || COMMANDS.DEACTIVATE_CHANGELOG.equalsIgnoreCase(command) || COMMANDS.CALCULATE_CHECKSUM.equalsIgnoreCase(command) || COMMANDS.STATUS.equalsIgnoreCase(command) || COMMANDS.VALIDATE.equalsIgnoreCase(command) || COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(command) || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(command) || COMMANDS.CHANGELOG_SYNC_TO_TAG.equalsIgnoreCase(command) || COMMANDS.CHANGELOG_SYNC_TO_TAG_SQL.equalsIgnoreCase(command) || COMMANDS.GENERATE_CHANGELOG.equalsIgnoreCase(command) || COMMANDS.UNEXPECTED_CHANGESETS.equalsIgnoreCase(command) || COMMANDS.DIFF_CHANGELOG.equalsIgnoreCase(command) || COMMANDS.ROLLBACK_ONE_CHANGE_SET.equalsIgnoreCase(command) || COMMANDS.ROLLBACK_ONE_UPDATE.equalsIgnoreCase(command);
}","private static boolean isChangeLogRequired(String command){
    return command.toLowerCase().startsWith(COMMANDS.UPDATE) || (command.toLowerCase().startsWith(COMMANDS.ROLLBACK) && (!command.equalsIgnoreCase(COMMANDS.ROLLBACK_ONE_CHANGE_SET) && !command.equalsIgnoreCase(COMMANDS.ROLLBACK_ONE_UPDATE))) || COMMANDS.REGISTER_CHANGELOG.equalsIgnoreCase(command) || COMMANDS.DEACTIVATE_CHANGELOG.equalsIgnoreCase(command) || COMMANDS.CALCULATE_CHECKSUM.equalsIgnoreCase(command) || COMMANDS.STATUS.equalsIgnoreCase(command) || COMMANDS.VALIDATE.equalsIgnoreCase(command) || COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(command) || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(command) || COMMANDS.CHANGELOG_SYNC_TO_TAG.equalsIgnoreCase(command) || COMMANDS.CHANGELOG_SYNC_TO_TAG_SQL.equalsIgnoreCase(command) || COMMANDS.GENERATE_CHANGELOG.equalsIgnoreCase(command) || COMMANDS.UNEXPECTED_CHANGESETS.equalsIgnoreCase(command) || COMMANDS.DIFF_CHANGELOG.equalsIgnoreCase(command) || COMMANDS.ROLLBACK_ONE_CHANGE_SET.equalsIgnoreCase(command) || COMMANDS.ROLLBACK_ONE_UPDATE.equalsIgnoreCase(command);
}","/**
     * Returns true if the parameter --changeLogFile is requited for a given command
     *
     * @param command the command to test
     * @return true if a ChangeLog is required, false if not.
     */","('isChangeLogRequired', {'INSTRUCTION': {'covered': 70, 'missed': 8}, 'BRANCH': {'covered': 22, 'missed': 14}, 'LINE': {'covered': 17, 'missed': 1}, 'COMPLEXITY': {'covered': 7, 'missed': 12}, 'METHOD': {'covered': 1, 'missed': 0}})",187.0,"  Returns true if the parameter --changeLogFile is requited for a given command   @param command the command to test  @return true if a ChangeLog is required, false if not.",33.0,"['If the changeLogFile is requited for a given command, then returns true if the changeLog is required.', 'If the changeLogFile is requited for a given command, then returns true.', 'If the changeLogFile is requited for a given command, then returns true if the changeLog is needed.']"
859,cdk,org/openscience/cdk/ConformerContainer.java,/base/data/src/main/java/org/openscience/cdk/ConformerContainer.java,lastIndexOf,400-431,"/**
     * Returns the highest index at which the specific IAtomContainer appears in the list or -1 if is not found.
     * 
     * A given IAtomContainer will occur in the list if the title matches the stored title for
     * the conformers in this container and if the coordinates for each atom in the specified molecule
     * are equal to the coordinates of the corresponding atoms in a conformer.
     *
     * @param o The IAtomContainer whose presence is being tested
     * @return The index where o was found
     */
public int lastIndexOf(Object o){
    IAtomContainer atomContainer = (IAtomContainer) o;
    if (!atomContainer.getTitle().equals(title))
        return -1;
    if (atomContainer.getAtomCount() != coordinates.get(0).length)
        return -1;
    boolean coordsMatch;
    for (int j = coordinates.size() - 1; j >= 0; j--) {
        Point3d[] coords = coordinates.get(j);
        coordsMatch = true;
        for (int i = 0; i < atomContainer.getAtomCount(); i++) {
            Point3d p = atomContainer.getAtom(i).getPoint3d();
            if (!(p.x == coords[i].x && p.y == coords[i].y && p.z == coords[i].z)) {
                coordsMatch = false;
                break;
            }
        }
        if (coordsMatch)
            return j;
    }
    return -1;
}","public int lastIndexOf(Object o){
    IAtomContainer atomContainer = (IAtomContainer) o;
    if (!atomContainer.getTitle().equals(title))
        return -1;
    if (atomContainer.getAtomCount() != coordinates.get(0).length)
        return -1;
    boolean coordsMatch;
    for (int j = coordinates.size() - 1; j >= 0; j--) {
        Point3d[] coords = coordinates.get(j);
        coordsMatch = true;
        for (int i = 0; i < atomContainer.getAtomCount(); i++) {
            Point3d p = atomContainer.getAtom(i).getPoint3d();
            if (!(p.x == coords[i].x && p.y == coords[i].y && p.z == coords[i].z)) {
                coordsMatch = false;
                break;
            }
        }
        if (coordsMatch)
            return j;
    }
    return -1;
}","/**
     * Returns the highest index at which the specific IAtomContainer appears in the list or -1 if is not found.
     * 
     * A given IAtomContainer will occur in the list if the title matches the stored title for
     * the conformers in this container and if the coordinates for each atom in the specified molecule
     * are equal to the coordinates of the corresponding atoms in a conformer.
     *
     * @param o The IAtomContainer whose presence is being tested
     * @return The index where o was found
     */","('lastIndexOf', {'INSTRUCTION': {'covered': 80, 'missed': 6}, 'BRANCH': {'covered': 11, 'missed': 5}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",188.0,Returns the highest index at which the specific IAtomContainer appears in the list or -1 if is not found.,20.0,"[""If the IAtomContainer isn't found, the highest index at which it appears is -1."", ""If the IAtomContainer isn't found, the highest index at which it appears in the list is -1."", 'If the IAtomContainer is not found, the highest index at which it appears in the list is -1.']"
860,anserini,io/anserini/collection/DocumentCollection.java,/src/main/java/io/anserini/collection/DocumentCollection.java,iterator,98-145,"/**
   * An iterator over {@code FileSegment} for the {@code DocumentCollection} iterable.
   * A collection is comprised of one or more file segments.
   */
public final Iterator<FileSegment<T>> iterator(){
    List<Path> paths = discover(this.path);
    Iterator<Path> pathsIterator = paths.iterator();
    return new Iterator<>() {

        Path segmentPath;

        FileSegment<T> segment;

        @Override
        public boolean hasNext() {
            if (segment != null) {
                return true;
            }
            if (!pathsIterator.hasNext()) {
                return false;
            } else {
                try {
                    segmentPath = pathsIterator.next();
                    segment = createFileSegment(segmentPath);
                } catch (IOException e) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public FileSegment<T> next() throws NoSuchElementException {
            if (!hasNext()) {
                throw new NoSuchElementException(""No more file segments to read."");
            } else {
                FileSegment<T> seg = segment;
                segment = null;
                return seg;
            }
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    };
}","public final Iterator<FileSegment<T>> iterator(){
    List<Path> paths = discover(this.path);
    Iterator<Path> pathsIterator = paths.iterator();
    return new Iterator<>() {

        Path segmentPath;

        FileSegment<T> segment;

        @Override
        public boolean hasNext() {
            if (segment != null) {
                return true;
            }
            if (!pathsIterator.hasNext()) {
                return false;
            } else {
                try {
                    segmentPath = pathsIterator.next();
                    segment = createFileSegment(segmentPath);
                } catch (IOException e) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public FileSegment<T> next() throws NoSuchElementException {
            if (!hasNext()) {
                throw new NoSuchElementException(""No more file segments to read."");
            } else {
                FileSegment<T> seg = segment;
                segment = null;
                return seg;
            }
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    };
}","/**
   * An iterator over {@code FileSegment} for the {@code DocumentCollection} iterable.
   * A collection is comprised of one or more file segments.
   */","('iterator', {'INSTRUCTION': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",189.0,  An iterator over {@code FileSegment} for the {@code DocumentCollection} iterable.,17.0,"['The iterator is over @code DocumentCollection.', 'An iterator over the @code DocumentCollection', 'An iterator over the @code DocumentCollection.']"
861,cdk,org/openscience/cdk/qsar/descriptors/molecular/BondCountDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/BondCountDescriptor.java,calculate,131-165,"/**
     *  This method calculate the number of bonds of a given type in an atomContainer
     *
     *@param  container  AtomContainer
     *@return            The number of bonds of a certain type.
     */
public DescriptorValue calculate(IAtomContainer container){
    if (order.equals("""")) {
        int bondCount = 0;
        for (IBond bond : container.bonds()) {
            boolean hasHydrogen = false;
            for (int i = 0; i < bond.getAtomCount(); i++) {
                if (bond.getAtom(i).getAtomicNumber() == IElement.H) {
                    hasHydrogen = true;
                    break;
                }
            }
            if (!hasHydrogen)
                bondCount++;
        }
        return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(bondCount), getDescriptorNames(), null);
    }
    int bondCount = 0;
    for (IBond bond : container.bonds()) {
        if (bondMatch(bond.getOrder(), order)) {
            bondCount += 1;
        }
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(bondCount), getDescriptorNames());
}","public DescriptorValue calculate(IAtomContainer container){
    if (order.equals("""")) {
        int bondCount = 0;
        for (IBond bond : container.bonds()) {
            boolean hasHydrogen = false;
            for (int i = 0; i < bond.getAtomCount(); i++) {
                if (bond.getAtom(i).getAtomicNumber() == IElement.H) {
                    hasHydrogen = true;
                    break;
                }
            }
            if (!hasHydrogen)
                bondCount++;
        }
        return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(bondCount), getDescriptorNames(), null);
    }
    int bondCount = 0;
    for (IBond bond : container.bonds()) {
        if (bondMatch(bond.getOrder(), order)) {
            bondCount += 1;
        }
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(bondCount), getDescriptorNames());
}","/**
     *  This method calculate the number of bonds of a given type in an atomContainer
     *
     *@param  container  AtomContainer
     *@return            The number of bonds of a certain type.
     */","('calculate', {'INSTRUCTION': {'covered': 97, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",189.0,  This method calculate the number of bonds of a given type in an atomContainer  @param container AtomContainer @return The number of bonds of a certain type.,29.0,"['The number of bonds of a certain type is calculated using this method.', 'The number of bonds of a certain type is calculated by this method.', 'The number of bonds of a certain type is calculated by using this method.']"
862,jooby,io/jooby/Router.java,/jooby/src/main/java/io/jooby/Router.java,normalizePath,1065-1096,"/**
   * Normalize a path by removing consecutive <code>/</code>(slashes).
   *
   * @param path Path to process.
   * @return Safe path pattern.
   */
 static String normalizePath(@Nullable String path){
    if (path == null || path.length() == 0 || path.equals(""/"")) {
        return ""/"";
    }
    int len = path.length();
    boolean modified = false;
    int p = 0;
    char[] buff = new char[len + 1];
    if (path.charAt(0) != '/') {
        buff[p++] = '/';
        modified = true;
    }
    for (int i = 0; i < path.length(); i++) {
        char ch = path.charAt(i);
        if (ch != '/') {
            buff[p++] = ch;
        } else if (i == 0 || path.charAt(i - 1) != '/') {
            buff[p++] = ch;
        } else {
            modified = true;
        }
    }
    return modified ? new String(buff, 0, p) : path;
}","static String normalizePath(@Nullable String path){
    if (path == null || path.length() == 0 || path.equals(""/"")) {
        return ""/"";
    }
    int len = path.length();
    boolean modified = false;
    int p = 0;
    char[] buff = new char[len + 1];
    if (path.charAt(0) != '/') {
        buff[p++] = '/';
        modified = true;
    }
    for (int i = 0; i < path.length(); i++) {
        char ch = path.charAt(i);
        if (ch != '/') {
            buff[p++] = ch;
        } else if (i == 0 || path.charAt(i - 1) != '/') {
            buff[p++] = ch;
        } else {
            modified = true;
        }
    }
    return modified ? new String(buff, 0, p) : path;
}","/**
   * Normalize a path by removing consecutive <code>/</code>(slashes).
   *
   * @param path Path to process.
   * @return Safe path pattern.
   */","('normalizePath', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",190.0,  Normalize a path by removing consecutive <code>/</code>(slashes).,17.0,"['Remove consecutive code>//code>(slashes) to normalize a path.', 'Remove consecutive code>//code>(slashes).', 'Remove consecutive code>//code>(slashes) from a path.']"
863,acs-aem-commons,com/adobe/acs/commons/ondeploy/scripts/OnDeployScriptBase.java,/bundle/src/main/java/com/adobe/acs/commons/ondeploy/scripts/OnDeployScriptBase.java,searchAndUpdateResourceType,182-213,"/**
     * Searches for the current sling:resourceType under /content and replaces any nodes it finds
     * with the newResourceType.
     *
     * @param oldResourceType The current sling:resourceType.
     * @param newResourceType The new sling:resourceType to be used.
     */
protected final void searchAndUpdateResourceType(String oldResourceType, String newResourceType) throws RepositoryException{
    Map<String, String> map = new HashMap<>();
    map.put(""p.limit"", ""-1"");
    map.put(""path"", ""/content"");
    map.put(""1_property"", SLING_RESOURCE_TYPE);
    map.put(""1_property.value"", oldResourceType);
    logger.info(""Finding all nodes under /content with resource type: {}"", oldResourceType);
    final QueryBuilder queryBuilder = resourceResolver.adaptTo(QueryBuilder.class);
    if (queryBuilder != null) {
        Query query = queryBuilder.createQuery(PredicateGroup.create(map), session);
        QueryUtil.setResourceResolverOn(resourceResolver, query);
        SearchResult result = query.getResult();
        Iterator<Node> nodeItr = result.getNodes();
        if (nodeItr.hasNext()) {
            while (nodeItr.hasNext()) {
                Node node = nodeItr.next();
                updateResourceType(node, newResourceType);
            }
        } else {
            logger.info(""No nodes found with resource type: {}"", oldResourceType);
        }
    }
}","protected final void searchAndUpdateResourceType(String oldResourceType, String newResourceType) throws RepositoryException{
    Map<String, String> map = new HashMap<>();
    map.put(""p.limit"", ""-1"");
    map.put(""path"", ""/content"");
    map.put(""1_property"", SLING_RESOURCE_TYPE);
    map.put(""1_property.value"", oldResourceType);
    logger.info(""Finding all nodes under /content with resource type: {}"", oldResourceType);
    final QueryBuilder queryBuilder = resourceResolver.adaptTo(QueryBuilder.class);
    if (queryBuilder != null) {
        Query query = queryBuilder.createQuery(PredicateGroup.create(map), session);
        QueryUtil.setResourceResolverOn(resourceResolver, query);
        SearchResult result = query.getResult();
        Iterator<Node> nodeItr = result.getNodes();
        if (nodeItr.hasNext()) {
            while (nodeItr.hasNext()) {
                Node node = nodeItr.next();
                updateResourceType(node, newResourceType);
            }
        } else {
            logger.info(""No nodes found with resource type: {}"", oldResourceType);
        }
    }
}","/**
     * Searches for the current sling:resourceType under /content and replaces any nodes it finds
     * with the newResourceType.
     *
     * @param oldResourceType The current sling:resourceType.
     * @param newResourceType The new sling:resourceType to be used.
     */","('searchAndUpdateResourceType', {'INSTRUCTION': {'covered': 75, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",191.0,  Searches for the current sling:resourceType under /content and replaces any nodes it finds  with the newResourceType.,19.0,"['The current sling:resourceType is searched under /content and replaced with the newResourceType.', 'The current sling:resourceType can be searched under /content and replaced with the newResourceType.', 'The current sling:resourceType is searched under /content and replaced by the newResourceType.']"
864,cdk,org/openscience/cdk/formula/IsotopePatternGenerator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/IsotopePatternGenerator.java,cleanAbundance,254-292,"/**
     * Normalize the intensity (relative abundance) of all isotopes in relation
     * of the most abundant isotope.
     *
     * @param isopattern   The IsotopePattern object
     * @param minIntensity The minimum abundance
     * @return             The IsotopePattern cleaned
     */
private IsotopePattern cleanAbundance(IsotopePattern isopattern, double minIntensity){
    double intensity, biggestIntensity = 0.0f;
    for (IsotopeContainer sc : isopattern.getIsotopes()) {
        intensity = sc.getIntensity();
        if (intensity > biggestIntensity)
            biggestIntensity = intensity;
    }
    for (IsotopeContainer sc : isopattern.getIsotopes()) {
        intensity = sc.getIntensity();
        intensity /= biggestIntensity;
        if (intensity < 0)
            intensity = 0;
        sc.setIntensity(intensity);
    }
    IsotopePattern sortedIsoPattern = new IsotopePattern();
    sortedIsoPattern.setMonoIsotope(new IsotopeContainer(isopattern.getIsotopes().get(0)));
    for (int i = 1; i < isopattern.getNumberOfIsotopes(); i++) {
        if (isopattern.getIsotopes().get(i).getIntensity() >= (minIntensity)) {
            IsotopeContainer container = new IsotopeContainer(isopattern.getIsotopes().get(i));
            sortedIsoPattern.addIsotope(container);
        }
    }
    return sortedIsoPattern;
}","private IsotopePattern cleanAbundance(IsotopePattern isopattern, double minIntensity){
    double intensity, biggestIntensity = 0.0f;
    for (IsotopeContainer sc : isopattern.getIsotopes()) {
        intensity = sc.getIntensity();
        if (intensity > biggestIntensity)
            biggestIntensity = intensity;
    }
    for (IsotopeContainer sc : isopattern.getIsotopes()) {
        intensity = sc.getIntensity();
        intensity /= biggestIntensity;
        if (intensity < 0)
            intensity = 0;
        sc.setIntensity(intensity);
    }
    IsotopePattern sortedIsoPattern = new IsotopePattern();
    sortedIsoPattern.setMonoIsotope(new IsotopeContainer(isopattern.getIsotopes().get(0)));
    for (int i = 1; i < isopattern.getNumberOfIsotopes(); i++) {
        if (isopattern.getIsotopes().get(i).getIntensity() >= (minIntensity)) {
            IsotopeContainer container = new IsotopeContainer(isopattern.getIsotopes().get(i));
            sortedIsoPattern.addIsotope(container);
        }
    }
    return sortedIsoPattern;
}","/**
     * Normalize the intensity (relative abundance) of all isotopes in relation
     * of the most abundant isotope.
     *
     * @param isopattern   The IsotopePattern object
     * @param minIntensity The minimum abundance
     * @return             The IsotopePattern cleaned
     */","('cleanAbundance', {'INSTRUCTION': {'covered': 94, 'missed': 2}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",191.0,  Normalize the intensity (relative abundance) of all isotopes in relation  of the most abundant isotope.,18.0,"['Normalize the intensity of all isotopes in relation to the most abundant.', 'Normalize the intensity of all isotopes in relation to the most abundant one.', 'Normalize the intensity of all the isotopes in relation to the most abundant one.']"
865,acs-aem-commons,com/adobe/acs/commons/hc/impl/HealthCheckStatusEmailer.java,/bundle/src/main/java/com/adobe/acs/commons/hc/impl/HealthCheckStatusEmailer.java,resultToPlainText,262-291,"/**
     * Gererates the plain-text email sections for sets of Health Check Execution Results.
     *
     * @param title The section title
     * @param results the  Health Check Execution Results to render as plain text
     * @return the String for this section to be embedded in the e-mail
     */
protected String resultToPlainText(final String title, final List<HealthCheckExecutionResult> results){
    final StringBuilder sb = new StringBuilder();
    sb.append(title);
    sb.append(System.lineSeparator());
    if (results.size() == 0) {
        sb.append(""No "" + StringUtils.lowerCase(title) + "" could be found!"");
        sb.append(System.lineSeparator());
    } else {
        sb.append(StringUtils.repeat(""-"", NUM_DASHES));
        sb.append(System.lineSeparator());
        for (final HealthCheckExecutionResult result : results) {
            sb.append(StringUtils.rightPad(""[ "" + result.getHealthCheckResult().getStatus().name() + "" ]"", HEALTH_CHECK_STATUS_PADDING));
            sb.append(""  "");
            sb.append(result.getHealthCheckMetadata().getTitle());
            sb.append(System.lineSeparator());
        }
    }
    return sb.toString();
}","protected String resultToPlainText(final String title, final List<HealthCheckExecutionResult> results){
    final StringBuilder sb = new StringBuilder();
    sb.append(title);
    sb.append(System.lineSeparator());
    if (results.size() == 0) {
        sb.append(""No "" + StringUtils.lowerCase(title) + "" could be found!"");
        sb.append(System.lineSeparator());
    } else {
        sb.append(StringUtils.repeat(""-"", NUM_DASHES));
        sb.append(System.lineSeparator());
        for (final HealthCheckExecutionResult result : results) {
            sb.append(StringUtils.rightPad(""[ "" + result.getHealthCheckResult().getStatus().name() + "" ]"", HEALTH_CHECK_STATUS_PADDING));
            sb.append(""  "");
            sb.append(result.getHealthCheckMetadata().getTitle());
            sb.append(System.lineSeparator());
        }
    }
    return sb.toString();
}","/**
     * Gererates the plain-text email sections for sets of Health Check Execution Results.
     *
     * @param title The section title
     * @param results the  Health Check Execution Results to render as plain text
     * @return the String for this section to be embedded in the e-mail
     */","('resultToPlainText', {'INSTRUCTION': {'covered': 90, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",191.0,  Gererates the plain-text email sections for sets of Health Check Execution Results.,13.0,"['The plain-text email sections were used for the Health Check Execution Results.', 'The plain-text email sections for the Health Check Execution Results are gererates.', 'The plain-text email sections for the health check execution results are gererates.']"
866,cdk,org/openscience/cdk/fingerprint/StandardSubstructureSets.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/StandardSubstructureSets.java,readSMARTSPattern,46-74,"/**
     * Load a list of SMARTS patterns from the specified file.
     *
     * Each line in the file corresponds to a pattern with the following structure:
     * PATTERN_DESCRIPTION: SMARTS_PATTERN, <i>e.g., Thioketone: [#6][CX3](=[SX1])[#6]</i>
     *
     * Empty lines and lines starting with a ""#"" are skipped.
     *
     * @param filename list of the SMARTS pattern to be loaded
     * @return list of strings containing the loaded SMARTS pattern
     * @throws Exception if there is an error parsing SMILES patterns
     */
private static String[] readSMARTSPattern(String filename) throws Exception{
    InputStream ins = StandardSubstructureSets.class.getClassLoader().getResourceAsStream(filename);
    BufferedReader reader = new BufferedReader(new InputStreamReader(ins));
    List<String> tmp = new ArrayList<String>();
    String line;
    while ((line = reader.readLine()) != null) {
        if (line.startsWith(""#"") || line.trim().length() == 0)
            continue;
        String[] toks = line.split("":"");
        StringBuffer s = new StringBuffer();
        for (int i = 1; i < toks.length - 1; i++) s.append(toks[i] + "":"");
        s.append(toks[toks.length - 1]);
        tmp.add(s.toString().trim());
    }
    return tmp.toArray(new String[] {});
}","private static String[] readSMARTSPattern(String filename) throws Exception{
    InputStream ins = StandardSubstructureSets.class.getClassLoader().getResourceAsStream(filename);
    BufferedReader reader = new BufferedReader(new InputStreamReader(ins));
    List<String> tmp = new ArrayList<String>();
    String line;
    while ((line = reader.readLine()) != null) {
        if (line.startsWith(""#"") || line.trim().length() == 0)
            continue;
        String[] toks = line.split("":"");
        StringBuffer s = new StringBuffer();
        for (int i = 1; i < toks.length - 1; i++) s.append(toks[i] + "":"");
        s.append(toks[toks.length - 1]);
        tmp.add(s.toString().trim());
    }
    return tmp.toArray(new String[] {});
}","/**
     * Load a list of SMARTS patterns from the specified file.
     *
     * Each line in the file corresponds to a pattern with the following structure:
     * PATTERN_DESCRIPTION: SMARTS_PATTERN, <i>e.g., Thioketone: [#6][CX3](=[SX1])[#6]</i>
     *
     * Empty lines and lines starting with a ""#"" are skipped.
     *
     * @param filename list of the SMARTS pattern to be loaded
     * @return list of strings containing the loaded SMARTS pattern
     * @throws Exception if there is an error parsing SMILES patterns
     */","('readSMARTSPattern', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 13, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",191.0,  Load a list of SMARTS patterns from the specified file.,11.0,"['The specified file should have a list of SMARTS patterns.', 'A list of SMARTS patterns can be loaded.', 'A list of SMARTS patterns can be loaded from the file.']"
867,cdk,org/openscience/cdk/qsar/descriptors/molecular/LargestChainDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/LargestChainDescriptor.java,calculate,149-184,"/**
     * Calculate the count of atoms of the largest chain in the supplied {@link IAtomContainer}.
     *
     * @param atomContainer The {@link IAtomContainer} for which this descriptor is to be calculated
     * @return the number of atoms in the largest chain of this AtomContainer
     * @see #setParameters
     */
public DescriptorValue calculate(IAtomContainer atomContainer){
    if (checkRingSystem)
        Cycles.markRingAtomsAndBonds(atomContainer);
    final Set<IAtom> included = new HashSet<>();
    for (IAtom atom : atomContainer.atoms()) {
        if (!atom.isInRing() && atom.getAtomicNumber() != 1)
            included.add(atom);
    }
    IAtomContainer subset = subsetMol(atomContainer, included);
    AllPairsShortestPaths apsp = new AllPairsShortestPaths(subset);
    int max = 0;
    int numAtoms = subset.getAtomCount();
    for (int i = 0; i < numAtoms; i++) {
        for (int j = i + 1; j < numAtoms; j++) {
            int len = apsp.from(i).pathTo(j).length;
            if (len > max)
                max = len;
        }
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(max), getDescriptorNames());
}","public DescriptorValue calculate(IAtomContainer atomContainer){
    if (checkRingSystem)
        Cycles.markRingAtomsAndBonds(atomContainer);
    final Set<IAtom> included = new HashSet<>();
    for (IAtom atom : atomContainer.atoms()) {
        if (!atom.isInRing() && atom.getAtomicNumber() != 1)
            included.add(atom);
    }
    IAtomContainer subset = subsetMol(atomContainer, included);
    AllPairsShortestPaths apsp = new AllPairsShortestPaths(subset);
    int max = 0;
    int numAtoms = subset.getAtomCount();
    for (int i = 0; i < numAtoms; i++) {
        for (int j = i + 1; j < numAtoms; j++) {
            int len = apsp.from(i).pathTo(j).length;
            if (len > max)
                max = len;
        }
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(max), getDescriptorNames());
}","/**
     * Calculate the count of atoms of the largest chain in the supplied {@link IAtomContainer}.
     *
     * @param atomContainer The {@link IAtomContainer} for which this descriptor is to be calculated
     * @return the number of atoms in the largest chain of this AtomContainer
     * @see #setParameters
     */","('calculate', {'INSTRUCTION': {'covered': 92, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",192.0,  Calculate the count of atoms of the largest chain in the supplied {@link IAtomContainer}.,18.0,"['The supplied IAtomContainer has a count of atoms of the largest chain.', 'The supplied IAtomContainer has a count of the largest chain of atoms.', 'The supplied IAtomContainer has a count of the largest chain.']"
868,cdk,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,addIsotopeDist,1581-1619,"/**
     * Helper method for adding isotope distributions to a MF. The method adds
     * a distribution of isotopes by splitting the set of isotopes in two,
     * the one under consideration (specified by 'idx') and the remaining to be
     * considered ('&gt;idx'). The inflection point is calculate as 'k'
     * &le 'count' isotopes added. If there are remaining isotopes the method
     * calls it's self with 'idx+1' and 'count := k'.
     *
     * @param mf       the molecular formula to update
     * @param isotopes the isotopes, sorted most abundance to least
     * @param idx      which isotope we're currently considering
     * @param count    the number of isotopes remaining to select from
     * @return the distribution is unique (or not)
     */
private static boolean addIsotopeDist(IMolecularFormula mf, IIsotope[] isotopes, int idx, int count){
    if (count == 0)
        return true;
    double frac = 100d;
    for (int i = 0; i < idx; i++) frac -= isotopes[i].getNaturalAbundance();
    double p = isotopes[idx].getNaturalAbundance() / frac;
    if (p >= 1.0) {
        mf.addIsotope(isotopes[idx], count);
        return true;
    }
    double kMin = (count + 1) * (1 - p) - 1;
    double kMax = (count + 1) * (1 - p);
    if ((int) Math.ceil(kMin) == (int) Math.floor(kMax)) {
        int k = (int) kMax;
        mf.addIsotope(isotopes[idx], count - k);
        return addIsotopeDist(mf, isotopes, idx + 1, k);
    }
    return false;
}","private static boolean addIsotopeDist(IMolecularFormula mf, IIsotope[] isotopes, int idx, int count){
    if (count == 0)
        return true;
    double frac = 100d;
    for (int i = 0; i < idx; i++) frac -= isotopes[i].getNaturalAbundance();
    double p = isotopes[idx].getNaturalAbundance() / frac;
    if (p >= 1.0) {
        mf.addIsotope(isotopes[idx], count);
        return true;
    }
    double kMin = (count + 1) * (1 - p) - 1;
    double kMax = (count + 1) * (1 - p);
    if ((int) Math.ceil(kMin) == (int) Math.floor(kMax)) {
        int k = (int) kMax;
        mf.addIsotope(isotopes[idx], count - k);
        return addIsotopeDist(mf, isotopes, idx + 1, k);
    }
    return false;
}","/**
     * Helper method for adding isotope distributions to a MF. The method adds
     * a distribution of isotopes by splitting the set of isotopes in two,
     * the one under consideration (specified by 'idx') and the remaining to be
     * considered ('&gt;idx'). The inflection point is calculate as 'k'
     * &le 'count' isotopes added. If there are remaining isotopes the method
     * calls it's self with 'idx+1' and 'count := k'.
     *
     * @param mf       the molecular formula to update
     * @param isotopes the isotopes, sorted most abundance to least
     * @param idx      which isotope we're currently considering
     * @param count    the number of isotopes remaining to select from
     * @return the distribution is unique (or not)
     */","('addIsotopeDist', {'INSTRUCTION': {'covered': 89, 'missed': 2}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 15, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",192.0,  Helper method for adding isotope distributions to a MF.,10.0,"['Adding isotope to a distribution is a method of adding.', 'Adding isotope to distributions is a method of adding.', 'Adding isotope to a distribution is a method of adding it.']"
869,cdk,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,returnOrdered,538-573,"/**
     * Return all molecular formulas but ordered according the tolerance difference between masses.
     *
     * @param  mass        The mass to analyze
     * @param  formulaSet  The IMolecularFormulaSet to order
     * @return             The IMolecularFormulaSet ordered
     */
private IMolecularFormulaSet returnOrdered(double mass, IMolecularFormulaSet formulaSet){
    IMolecularFormulaSet solutions_new = null;
    if (formulaSet.size() != 0) {
        double valueMin = 100;
        int i_final = 0;
        solutions_new = formulaSet.getBuilder().newInstance(IMolecularFormulaSet.class);
        List<Integer> listI = new ArrayList<Integer>();
        for (int j = 0; j < formulaSet.size(); j++) {
            for (int i = 0; i < formulaSet.size(); i++) {
                if (listI.contains(i))
                    continue;
                double value = MolecularFormulaManipulator.getTotalExactMass(formulaSet.getMolecularFormula(i));
                double diff = Math.abs(mass - Math.abs(value));
                if (valueMin > diff) {
                    valueMin = diff;
                    i_final = i;
                }
            }
            valueMin = 100;
            solutions_new.addMolecularFormula(formulaSet.getMolecularFormula(i_final));
            listI.add(i_final);
        }
    }
    return solutions_new;
}","private IMolecularFormulaSet returnOrdered(double mass, IMolecularFormulaSet formulaSet){
    IMolecularFormulaSet solutions_new = null;
    if (formulaSet.size() != 0) {
        double valueMin = 100;
        int i_final = 0;
        solutions_new = formulaSet.getBuilder().newInstance(IMolecularFormulaSet.class);
        List<Integer> listI = new ArrayList<Integer>();
        for (int j = 0; j < formulaSet.size(); j++) {
            for (int i = 0; i < formulaSet.size(); i++) {
                if (listI.contains(i))
                    continue;
                double value = MolecularFormulaManipulator.getTotalExactMass(formulaSet.getMolecularFormula(i));
                double diff = Math.abs(mass - Math.abs(value));
                if (valueMin > diff) {
                    valueMin = diff;
                    i_final = i;
                }
            }
            valueMin = 100;
            solutions_new.addMolecularFormula(formulaSet.getMolecularFormula(i_final));
            listI.add(i_final);
        }
    }
    return solutions_new;
}","/**
     * Return all molecular formulas but ordered according the tolerance difference between masses.
     *
     * @param  mass        The mass to analyze
     * @param  formulaSet  The IMolecularFormulaSet to order
     * @return             The IMolecularFormulaSet ordered
     */","('returnOrdered', {'INSTRUCTION': {'covered': 76, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",193.0,  Return all molecular formulas but ordered according the tolerance difference between masses.,13.0,"['Return all formulas, but order them according to the tolerance difference.', 'Return all the formulas, but order them according to the tolerance difference.', 'Return all the formulas, but order them according to the tolerance difference between the mass.']"
870,cdk,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,assign,78-111,"/**
     * Given the assigned preliminary MMFF atom types (symbs[]) update these to the aromatic types.
     * To begin, all the 5 and 6 member aromatic cycles are discovered. The symbolic types of five
     * and six member cycles are then update with {@link #updateAromaticTypesInFiveMemberRing(int[],
     * String[])} and {@link #updateAromaticTypesInSixMemberRing(int[], String[])}.
     *
     * @param container structure representation
     * @param symbs     vector of symbolic types for the whole structure
     * @param bonds     edge to bond map lookup
     * @param graph     adjacency list graph representation of structure
     * @param mmffArom  set of bonds that are aromatic
     */
 void assign(IAtomContainer container, String[] symbs, EdgeToBondMap bonds, int[][] graph, Set<IBond> mmffArom){
    int[] contribution = new int[graph.length];
    int[] doubleBonds = new int[graph.length];
    Arrays.fill(doubleBonds, -1);
    setupContributionAndDoubleBonds(container, bonds, graph, contribution, doubleBonds);
    int[][] cycles = findAromaticRings(cyclesOfSizeFiveOrSix(container, graph), contribution, doubleBonds);
    for (int[] cycle : cycles) {
        int len = cycle.length - 1;
        if (len == 6) {
            updateAromaticTypesInSixMemberRing(cycle, symbs);
        }
        if (len == 5 && normaliseCycle(cycle, contribution)) {
            updateAromaticTypesInFiveMemberRing(cycle, symbs);
        }
        // mark aromatic bonds
        for (int i = 1; i < cycle.length; i++) mmffArom.add(bonds.get(cycle[i], cycle[i - 1]));
    }
}","void assign(IAtomContainer container, String[] symbs, EdgeToBondMap bonds, int[][] graph, Set<IBond> mmffArom){
    int[] contribution = new int[graph.length];
    int[] doubleBonds = new int[graph.length];
    Arrays.fill(doubleBonds, -1);
    setupContributionAndDoubleBonds(container, bonds, graph, contribution, doubleBonds);
    int[][] cycles = findAromaticRings(cyclesOfSizeFiveOrSix(container, graph), contribution, doubleBonds);
    for (int[] cycle : cycles) {
        int len = cycle.length - 1;
        if (len == 6) {
            updateAromaticTypesInSixMemberRing(cycle, symbs);
        }
        if (len == 5 && normaliseCycle(cycle, contribution)) {
            updateAromaticTypesInFiveMemberRing(cycle, symbs);
        }
        // mark aromatic bonds
        for (int i = 1; i < cycle.length; i++) mmffArom.add(bonds.get(cycle[i], cycle[i - 1]));
    }
}","/**
     * Given the assigned preliminary MMFF atom types (symbs[]) update these to the aromatic types.
     * To begin, all the 5 and 6 member aromatic cycles are discovered. The symbolic types of five
     * and six member cycles are then update with {@link #updateAromaticTypesInFiveMemberRing(int[],
     * String[])} and {@link #updateAromaticTypesInSixMemberRing(int[], String[])}.
     *
     * @param container structure representation
     * @param symbs     vector of symbolic types for the whole structure
     * @param bonds     edge to bond map lookup
     * @param graph     adjacency list graph representation of structure
     * @param mmffArom  set of bonds that are aromatic
     */","('assign', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",194.0,  Given the assigned preliminary MMFF atom types (symbs[]) update these to the aromatic types.,19.0,"['Update the MMFF atom types to the aromatic ones.', 'Update the MMFF atom types to aromatic ones.', 'Update the MMFF atom types to the aromatic types.']"
871,cucumber-reporting,net/masterthought/cucumber/reducers/ReportFeatureWithRetestMerger.java,/src/main/java/net/masterthought/cucumber/reducers/ReportFeatureWithRetestMerger.java,updateElements,40-74,"/**
     * Updates feature's elements with items from the @elements list if an Id of the item coincides
     * with an Id of any element from the @feature object. If there is no element in the @feature object
     * then the item is appended to the end of the elements' list of the @feature.
     *
     * @param feature  - target object of Feature class.
     * @param elements - list of elements which need to be inserted to the @feature with replacing
     *                   or adding to the end.
     */
 void updateElements(Feature feature, Element[] elements){
    for (int i = 0; i < elements.length; i++) {
        Element current = elements[i];
        if (current.isScenario()) {
            checkArgument(current.getStartTime() != null, ERROR);
            int indexOfPreviousResult = find(feature.getElements(), current);
            boolean hasBackground = isBackground(i - 1, elements);
            if (indexOfPreviousResult < 0) {
                feature.addElements(hasBackground ? new Element[] { elements[i - 1], current } : new Element[] { current });
            } else {
                if (replaceIfExists(feature.getElements()[indexOfPreviousResult], current)) {
                    feature.getElements()[indexOfPreviousResult] = current;
                    if (hasBackground && isBackground(indexOfPreviousResult - 1, feature.getElements())) {
                        feature.getElements()[indexOfPreviousResult - 1] = elements[i - 1];
                    }
                }
            }
        }
    }
}","void updateElements(Feature feature, Element[] elements){
    for (int i = 0; i < elements.length; i++) {
        Element current = elements[i];
        if (current.isScenario()) {
            checkArgument(current.getStartTime() != null, ERROR);
            int indexOfPreviousResult = find(feature.getElements(), current);
            boolean hasBackground = isBackground(i - 1, elements);
            if (indexOfPreviousResult < 0) {
                feature.addElements(hasBackground ? new Element[] { elements[i - 1], current } : new Element[] { current });
            } else {
                if (replaceIfExists(feature.getElements()[indexOfPreviousResult], current)) {
                    feature.getElements()[indexOfPreviousResult] = current;
                    if (hasBackground && isBackground(indexOfPreviousResult - 1, feature.getElements())) {
                        feature.getElements()[indexOfPreviousResult - 1] = elements[i - 1];
                    }
                }
            }
        }
    }
}","/**
     * Updates feature's elements with items from the @elements list if an Id of the item coincides
     * with an Id of any element from the @feature object. If there is no element in the @feature object
     * then the item is appended to the end of the elements' list of the @feature.
     *
     * @param feature  - target object of Feature class.
     * @param elements - list of elements which need to be inserted to the @feature with replacing
     *                   or adding to the end.
     */","('updateElements', {'INSTRUCTION': {'covered': 74, 'missed': 25}, 'BRANCH': {'covered': 11, 'missed': 5}, 'LINE': {'covered': 14, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",195.0,  Updates feature's elements with items from the @elements list if an Id of the item coincides  with an Id of any element from the @feature object.,30.0,"[""If an Id of an item coincides with an Id of an element from the feature object, the feature's elements will be updated."", ""If an Id of an item coincides with an Id of an element from the feature object, the feature's elements are updated."", ""If an Id of an item coincides with an Id of an element from the feature object, the feature's elements will be updated with items from the elements list.""]"
872,cdk,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,breakExtractor,1398-1441,"/**
     * The parenthesis convention is used to show a quantity by which a formula is multiplied.
     * For example: (C12H20O11)2 really means that a C24H40O22 unit.
     *
     * @param formula Formula to correct
     * @return        Formula with the correction
     */
private static String breakExtractor(String formula){
    boolean finalBreak = false;
    int innerMostBracket = formula.lastIndexOf(""("");
    if (innerMostBracket < 0)
        return formula;
    String finalformula = formula.substring(0, innerMostBracket);
    String multipliedformula = """";
    String formulaEnd = """";
    String multiple = """";
    for (int f = innerMostBracket + 1; f < formula.length(); f++) {
        char thisChar = formula.charAt(f);
        if (finalBreak) {
            if (isDigit(thisChar)) {
                multiple += thisChar;
            } else {
                formulaEnd = formula.substring(f, formula.length());
                break;
            }
        } else {
            if (thisChar == ')') {
                finalBreak = true;
            } else
                multipliedformula += thisChar;
        }
    }
    finalformula += muliplier(multipliedformula, multiple.isEmpty() ? 1 : Integer.valueOf(multiple)) + formulaEnd;
    if (finalformula.contains(""(""))
        return breakExtractor(finalformula);
    else
        return finalformula;
}","private static String breakExtractor(String formula){
    boolean finalBreak = false;
    int innerMostBracket = formula.lastIndexOf(""("");
    if (innerMostBracket < 0)
        return formula;
    String finalformula = formula.substring(0, innerMostBracket);
    String multipliedformula = """";
    String formulaEnd = """";
    String multiple = """";
    for (int f = innerMostBracket + 1; f < formula.length(); f++) {
        char thisChar = formula.charAt(f);
        if (finalBreak) {
            if (isDigit(thisChar)) {
                multiple += thisChar;
            } else {
                formulaEnd = formula.substring(f, formula.length());
                break;
            }
        } else {
            if (thisChar == ')') {
                finalBreak = true;
            } else
                multipliedformula += thisChar;
        }
    }
    finalformula += muliplier(multipliedformula, multiple.isEmpty() ? 1 : Integer.valueOf(multiple)) + formulaEnd;
    if (finalformula.contains(""(""))
        return breakExtractor(finalformula);
    else
        return finalformula;
}","/**
     * The parenthesis convention is used to show a quantity by which a formula is multiplied.
     * For example: (C12H20O11)2 really means that a C24H40O22 unit.
     *
     * @param formula Formula to correct
     * @return        Formula with the correction
     */","('breakExtractor', {'INSTRUCTION': {'covered': 99, 'missed': 2}, 'BRANCH': {'covered': 13, 'missed': 1}, 'LINE': {'covered': 21, 'missed': 1}, 'COMPLEXITY': {'covered': 7, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",195.0,  The parenthesis convention is used to show a quantity by which a formula is multiplied.,16.0,"['The quantity is shown by using the parenthesis convention.', 'The quantity is shown by the parenthesis convention.', 'The quantity shown by the parenthesis convention is the formula.']"
874,dcache,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,buildRemovalTransition,687-736,"/**
     * Ostensibly, we iterate over all children to find Mortal children that should be removed.  In
     * practise, cached knowledge of Mortal child expiry Dates means this iterates over only those
     * StateComponents that contain children that have actually expired.
     *
     * @param ourPath
     * @param transition
     * @param forced
     */
public void buildRemovalTransition(StatePath ourPath, StateTransition transition, boolean forced){
    LOGGER.trace(""entering buildRemovalTransition: path={}"", ourPath);
    Date now = new Date();
    for (Map.Entry<String, StateComponent> entry : _children.entrySet()) {
        StateComponent childValue = entry.getValue();
        String childName = entry.getKey();
        boolean shouldRemoveThisChild = forced;
        boolean shouldItr = forced;
        if (childValue.hasExpired()) {
            LOGGER.trace(""registering {} (in path {}) for removal."", childName, ourPath);
            shouldRemoveThisChild = shouldItr = true;
        }
        Date childExp = childValue.getEarliestChildExpiryDate();
        if (childExp != null && !now.before(childExp)) {
            shouldItr = true;
        }
        if (shouldItr || shouldRemoveThisChild) {
            StateChangeSet changeSet = transition.getOrCreateChangeSet(ourPath);
            if (shouldRemoveThisChild) {
                changeSet.recordRemovedChild(childName);
            }
            if (shouldItr) {
                changeSet.recordChildItr(childName);
                childValue.buildRemovalTransition(buildChildPath(ourPath, childName), transition, shouldRemoveThisChild);
            }
        }
    }
}","public void buildRemovalTransition(StatePath ourPath, StateTransition transition, boolean forced){
    LOGGER.trace(""entering buildRemovalTransition: path={}"", ourPath);
    Date now = new Date();
    for (Map.Entry<String, StateComponent> entry : _children.entrySet()) {
        StateComponent childValue = entry.getValue();
        String childName = entry.getKey();
        boolean shouldRemoveThisChild = forced;
        boolean shouldItr = forced;
        if (childValue.hasExpired()) {
            LOGGER.trace(""registering {} (in path {}) for removal."", childName, ourPath);
            shouldRemoveThisChild = shouldItr = true;
        }
        Date childExp = childValue.getEarliestChildExpiryDate();
        if (childExp != null && !now.before(childExp)) {
            shouldItr = true;
        }
        if (shouldItr || shouldRemoveThisChild) {
            StateChangeSet changeSet = transition.getOrCreateChangeSet(ourPath);
            if (shouldRemoveThisChild) {
                changeSet.recordRemovedChild(childName);
            }
            if (shouldItr) {
                changeSet.recordChildItr(childName);
                childValue.buildRemovalTransition(buildChildPath(ourPath, childName), transition, shouldRemoveThisChild);
            }
        }
    }
}","/**
     * Ostensibly, we iterate over all children to find Mortal children that should be removed.  In
     * practise, cached knowledge of Mortal child expiry Dates means this iterates over only those
     * StateComponents that contain children that have actually expired.
     *
     * @param ourPath
     * @param transition
     * @param forced
     */","('buildRemovalTransition', {'INSTRUCTION': {'covered': 83, 'missed': 0}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 22, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",196.0,"  Ostensibly, we iterate over all children to find Mortal children that should be removed.",16.0,"['We have to find children that should be removed.', 'We look over all children to find children that should be removed.', 'We look over all children to find children that should be taken away.']"
875,acs-aem-commons,com/adobe/acs/commons/replication/dispatcher/impl/DispatcherFlushRulesImpl.java,/bundle/src/main/java/com/adobe/acs/commons/replication/dispatcher/impl/DispatcherFlushRulesImpl.java,accepts,208-243,"/**
     * Checks if this service should react to or ignore this replication action.
     *
     * @param replicationAction The replication action that is initiating this flush request
     * @param replicationOptions The replication options that is initiating this flush request
     * @return true is this service should attempt to flush associated resources for this replication request
     */
private boolean accepts(final ReplicationAction replicationAction, final ReplicationOptions replicationOptions){
    if (replicationAction == null || replicationOptions == null) {
        log.debug(""Replication Action or Options are null. Skipping this replication."");
        return false;
    }
    final String path = replicationAction.getPath();
    if (replicationOptions.getFilter() instanceof DispatcherFlushRulesFilter) {
        log.debug(""Ignore applying dispatcher flush rules for [ {} ], as it originated from this "" + ""Service."", path);
        return false;
    } else if ((this.hierarchicalFlushRules == null || this.hierarchicalFlushRules.size() < 1) && (this.resourceOnlyFlushRules == null || this.resourceOnlyFlushRules.size() < 1)) {
        log.warn(""Ignored due no configured flush rules."");
        return false;
    } else if (StringUtils.isBlank(path)) {
        log.debug(""Replication Action path is blank. Skipping this replication."");
        return false;
    } else if (!ReplicationActionType.ACTIVATE.equals(replicationAction.getType()) && !ReplicationActionType.DEACTIVATE.equals(replicationAction.getType()) && !ReplicationActionType.DELETE.equals(replicationAction.getType())) {
        return false;
    }
    return true;
}","private boolean accepts(final ReplicationAction replicationAction, final ReplicationOptions replicationOptions){
    if (replicationAction == null || replicationOptions == null) {
        log.debug(""Replication Action or Options are null. Skipping this replication."");
        return false;
    }
    final String path = replicationAction.getPath();
    if (replicationOptions.getFilter() instanceof DispatcherFlushRulesFilter) {
        log.debug(""Ignore applying dispatcher flush rules for [ {} ], as it originated from this "" + ""Service."", path);
        return false;
    } else if ((this.hierarchicalFlushRules == null || this.hierarchicalFlushRules.size() < 1) && (this.resourceOnlyFlushRules == null || this.resourceOnlyFlushRules.size() < 1)) {
        log.warn(""Ignored due no configured flush rules."");
        return false;
    } else if (StringUtils.isBlank(path)) {
        log.debug(""Replication Action path is blank. Skipping this replication."");
        return false;
    } else if (!ReplicationActionType.ACTIVATE.equals(replicationAction.getType()) && !ReplicationActionType.DEACTIVATE.equals(replicationAction.getType()) && !ReplicationActionType.DELETE.equals(replicationAction.getType())) {
        return false;
    }
    return true;
}","/**
     * Checks if this service should react to or ignore this replication action.
     *
     * @param replicationAction The replication action that is initiating this flush request
     * @param replicationOptions The replication options that is initiating this flush request
     * @return true is this service should attempt to flush associated resources for this replication request
     */","('accepts', {'INSTRUCTION': {'covered': 64, 'missed': 6}, 'BRANCH': {'covered': 17, 'missed': 5}, 'LINE': {'covered': 17, 'missed': 2}, 'COMPLEXITY': {'covered': 7, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",198.0,  Checks if this service should react to or ignore this replication action.,13.0,"['This service is checked to see if it should respond to this action or not.', 'This service is checked to see if it should respond or not.', 'This service is checked to see if it should respond or ignore the action.']"
876,cdk,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,mapInputMoleculeToInchiMolgraph,315-342,"/**
     * Atom-atom mapping of the input molecule to the bare container constructed from the InChI connection table.
     * This makes it possible to map the positions of the mobile hydrogens in the InChI back to the input molecule.
     * @param inchiMolGraph molecule (bare) as defined in InChI
     * @param mol user input molecule
     * @throws CDKException
     */
private void mapInputMoleculeToInchiMolgraph(IAtomContainer inchiMolGraph, IAtomContainer mol) throws CDKException{
    Iterator<Map<IAtom, IAtom>> iter = org.openscience.cdk.isomorphism.VentoFoggia.findIdentical(inchiMolGraph, AtomMatcher.forElement(), BondMatcher.forAny()).matchAll(mol).limit(1).toAtomMap().iterator();
    if (iter.hasNext()) {
        for (Map.Entry<IAtom, IAtom> e : iter.next().entrySet()) {
            IAtom src = e.getKey();
            IAtom dst = e.getValue();
            String position = src.getID();
            dst.setID(position);
            LOGGER.debug(""Mapped InChI "", src.getSymbol(), "" "", src.getID(), "" to "", dst.getSymbol(), "" "" + dst.getID());
        }
    } else {
        throw new IllegalArgumentException(CANSMI.create(inchiMolGraph) + "" "" + CANSMI.create(mol));
    }
}","private void mapInputMoleculeToInchiMolgraph(IAtomContainer inchiMolGraph, IAtomContainer mol) throws CDKException{
    Iterator<Map<IAtom, IAtom>> iter = org.openscience.cdk.isomorphism.VentoFoggia.findIdentical(inchiMolGraph, AtomMatcher.forElement(), BondMatcher.forAny()).matchAll(mol).limit(1).toAtomMap().iterator();
    if (iter.hasNext()) {
        for (Map.Entry<IAtom, IAtom> e : iter.next().entrySet()) {
            IAtom src = e.getKey();
            IAtom dst = e.getValue();
            String position = src.getID();
            dst.setID(position);
            LOGGER.debug(""Mapped InChI "", src.getSymbol(), "" "", src.getID(), "" to "", dst.getSymbol(), "" "" + dst.getID());
        }
    } else {
        throw new IllegalArgumentException(CANSMI.create(inchiMolGraph) + "" "" + CANSMI.create(mol));
    }
}","/**
     * Atom-atom mapping of the input molecule to the bare container constructed from the InChI connection table.
     * This makes it possible to map the positions of the mobile hydrogens in the InChI back to the input molecule.
     * @param inchiMolGraph molecule (bare) as defined in InChI
     * @param mol user input molecule
     * @throws CDKException
     */","('mapInputMoleculeToInchiMolgraph', {'INSTRUCTION': {'covered': 84, 'missed': 18}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",199.0,  Atom-atom mapping of the input molecule to the bare container constructed from the InChI connection table.,17.0,"['The input molecule is mapped to the bare container from the InChI connection table.', 'The input molecule is mapped to a bare container from the InChI connection table.', 'The input molecule is mapped to the bare container constructed from the InChI connection table.']"
877,dcache,dmg/util/command/AcCommandScanner.java,/modules/cells/src/main/java/dmg/util/command/AcCommandScanner.java,scanFields,30-71,"/**
     * Scan for help fields: fh_(= full help) or hh_(= help hint).
     */
private static void scanFields(Object obj, Map<List<String>, AcCommandExecutor> commands){
    for (Field field : obj.getClass().getFields()) {
        Iterator<String> i = Splitter.on('_').split(field.getName()).iterator();
        FieldType helpMode;
        String helpType = i.next();
        switch(helpType) {
            case ""hh"":
                helpMode = FieldType.HELP_HINT;
                break;
            case ""fh"":
                helpMode = FieldType.FULL_HELP;
                break;
            case ""acl"":
                helpMode = FieldType.ACL;
                break;
            default:
                continue;
        }
        if (!i.hasNext()) {
            continue;
        }
        List<String> name = Lists.newArrayList(i);
        AcCommandExecutor command = getCommandExecutor(obj, commands, name);
        switch(helpMode) {
            case FULL_HELP:
                command.setFullHelpField(field);
                break;
            case HELP_HINT:
                command.setHelpHintField(field);
                break;
            case ACL:
                command.setAclField(field);
                break;
        }
    }
}","private static void scanFields(Object obj, Map<List<String>, AcCommandExecutor> commands){
    for (Field field : obj.getClass().getFields()) {
        Iterator<String> i = Splitter.on('_').split(field.getName()).iterator();
        FieldType helpMode;
        String helpType = i.next();
        switch(helpType) {
            case ""hh"":
                helpMode = FieldType.HELP_HINT;
                break;
            case ""fh"":
                helpMode = FieldType.FULL_HELP;
                break;
            case ""acl"":
                helpMode = FieldType.ACL;
                break;
            default:
                continue;
        }
        if (!i.hasNext()) {
            continue;
        }
        List<String> name = Lists.newArrayList(i);
        AcCommandExecutor command = getCommandExecutor(obj, commands, name);
        switch(helpMode) {
            case FULL_HELP:
                command.setFullHelpField(field);
                break;
            case HELP_HINT:
                command.setHelpHintField(field);
                break;
            case ACL:
                command.setAclField(field);
                break;
        }
    }
}","/**
     * Scan for help fields: fh_(= full help) or hh_(= help hint).
     */","('scanFields', {'INSTRUCTION': {'covered': 74, 'missed': 2}, 'BRANCH': {'covered': 9, 'missed': 3}, 'LINE': {'covered': 21, 'missed': 2}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",199.0,  Scan for help fields: fh_(= full help) or hh_(= help hint).,19.0,"['Scan for help fields with the help hint in mind.', 'Scan for help fields with the help hint in the subject line.', 'Scan for help fields with the help hint in the title.']"
878,cdk,org/openscience/cdk/group/PermutationGroup.java,/tool/group/src/main/java/org/openscience/cdk/group/PermutationGroup.java,changeBase,326-357,"/**
     * Change the base of the group to the new base <code>newBase</code>.
     *
     * @param newBase the new base for the group
     */
public void changeBase(Permutation newBase){
    PermutationGroup h = new PermutationGroup(newBase);
    int firstDiffIndex = base.firstIndexOfDifference(newBase);
    for (int j = firstDiffIndex; j < size; j++) {
        for (int a = 0; a < size; a++) {
            Permutation g = permutations[j][a];
            if (g != null) {
                h.enter(g);
            }
        }
    }
    for (int j = 0; j < firstDiffIndex; j++) {
        for (int a = 0; a < size; a++) {
            Permutation g = permutations[j][a];
            if (g != null) {
                int hj = h.base.get(j);
                int x = g.get(hj);
                h.permutations[j][x] = new Permutation(g);
            }
        }
    }
    this.base = new Permutation(h.base);
    this.permutations = h.permutations.clone();
}","public void changeBase(Permutation newBase){
    PermutationGroup h = new PermutationGroup(newBase);
    int firstDiffIndex = base.firstIndexOfDifference(newBase);
    for (int j = firstDiffIndex; j < size; j++) {
        for (int a = 0; a < size; a++) {
            Permutation g = permutations[j][a];
            if (g != null) {
                h.enter(g);
            }
        }
    }
    for (int j = 0; j < firstDiffIndex; j++) {
        for (int a = 0; a < size; a++) {
            Permutation g = permutations[j][a];
            if (g != null) {
                int hj = h.base.get(j);
                int x = g.get(hj);
                h.permutations[j][x] = new Permutation(g);
            }
        }
    }
    this.base = new Permutation(h.base);
    this.permutations = h.permutations.clone();
}","/**
     * Change the base of the group to the new base <code>newBase</code>.
     *
     * @param newBase the new base for the group
     */","('changeBase', {'INSTRUCTION': {'covered': 95, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",199.0,  Change the base of the group to the new base <code>newBase</code>.,18.0,"['The base of the group should be changed to the new base.', 'The base of the group should be changed to the new one.', 'Change the base of the group to a new base.']"
879,cdk,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,muliplier,1471-1505,"/**
     * This method multiply all the element over a value.
     *
     * @param formula Formula to correct
     * @param factor  Factor to multiply
     * @return        Formula with the correction
     */
private static String muliplier(String formula, int factor){
    String finalformula = """";
    String recentElementSymbol = """";
    String recentElementCountString = ""0"";
    for (int f = 0; f < formula.length(); f++) {
        char thisChar = formula.charAt(f);
        if (f < formula.length()) {
            if (thisChar >= 'A' && thisChar <= 'Z') {
                recentElementSymbol = String.valueOf(thisChar);
                recentElementCountString = ""0"";
            }
            if (thisChar >= 'a' && thisChar <= 'z') {
                recentElementSymbol += thisChar;
            }
            if (thisChar >= '0' && thisChar <= '9') {
                recentElementCountString += thisChar;
            }
        }
        if (f == formula.length() - 1 || (formula.charAt(f + 1) >= 'A' && formula.charAt(f + 1) <= 'Z')) {
            Integer recentElementCount = Integer.valueOf(recentElementCountString);
            if (recentElementCount == 0)
                finalformula += recentElementSymbol + factor;
            else
                finalformula += recentElementSymbol + recentElementCount * factor;
        }
    }
    return finalformula;
}","private static String muliplier(String formula, int factor){
    String finalformula = """";
    String recentElementSymbol = """";
    String recentElementCountString = ""0"";
    for (int f = 0; f < formula.length(); f++) {
        char thisChar = formula.charAt(f);
        if (f < formula.length()) {
            if (thisChar >= 'A' && thisChar <= 'Z') {
                recentElementSymbol = String.valueOf(thisChar);
                recentElementCountString = ""0"";
            }
            if (thisChar >= 'a' && thisChar <= 'z') {
                recentElementSymbol += thisChar;
            }
            if (thisChar >= '0' && thisChar <= '9') {
                recentElementCountString += thisChar;
            }
        }
        if (f == formula.length() - 1 || (formula.charAt(f + 1) >= 'A' && formula.charAt(f + 1) <= 'Z')) {
            Integer recentElementCount = Integer.valueOf(recentElementCountString);
            if (recentElementCount == 0)
                finalformula += recentElementSymbol + factor;
            else
                finalformula += recentElementSymbol + recentElementCount * factor;
        }
    }
    return finalformula;
}","/**
     * This method multiply all the element over a value.
     *
     * @param formula Formula to correct
     * @param factor  Factor to multiply
     * @return        Formula with the correction
     */","('muliplier', {'INSTRUCTION': {'covered': 117, 'missed': 0}, 'BRANCH': {'covered': 21, 'missed': 3}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",199.0,  This method multiply all the element over a value.,10.0,"['The method is used to add all the elements over a value.', 'The method is used to divide the element over a value.', 'The method is used to add all the elements together.']"
880,cdk,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,readNonStructuralData,2226-2290,"/**
     * Read non-structural data from input and store as properties the provided
     * 'container'. Non-structural data appears in a structure data file (SDF)
     * after an Molfile and before the record deliminator ('$$$$'). The data
     * consists of one or more Data Header and Data blocks, an example is seen
     * below.
     *
     * <pre>{@code
     * > 29 <DENSITY>
     * 0.9132 - 20.0
     *
     * > 29 <BOILING.POINT>
     * 63.0 (737 MM)
     * 79.0 (42 MM)
     *
     * > 29 <ALTERNATE.NAMES>
     * SYLVAN
     *
     * > 29 <DATE>
     * 09-23-1980
     *
     * > 29 <CRC.NUMBER>
     * F-0213
     *
     * }</pre>
     *
     *
     * @param input     input source
     * @param container the container
     * @throws IOException an error occur whilst reading the input
     */
 static void readNonStructuralData(final BufferedReader input, final IAtomContainer container) throws IOException{
    String line, header = null;
    boolean wrap = false;
    final StringBuilder data = new StringBuilder(80);
    while (!endOfRecord(line = input.readLine())) {
        final String newHeader = dataHeader(line);
        if (newHeader != null) {
            if (header != null)
                container.setProperty(header, data.toString());
            header = newHeader;
            wrap = false;
            data.setLength(0);
        } else {
            if (data.length() > 0 || !line.equals("" ""))
                line = line.trim();
            if (line.isEmpty())
                continue;
            if (!wrap && data.length() > 0)
                data.append('\n');
            data.append(line);
            wrap = line.length() == 80;
        }
    }
    if (header != null)
        container.setProperty(header, data.toString());
}","static void readNonStructuralData(final BufferedReader input, final IAtomContainer container) throws IOException{
    String line, header = null;
    boolean wrap = false;
    final StringBuilder data = new StringBuilder(80);
    while (!endOfRecord(line = input.readLine())) {
        final String newHeader = dataHeader(line);
        if (newHeader != null) {
            if (header != null)
                container.setProperty(header, data.toString());
            header = newHeader;
            wrap = false;
            data.setLength(0);
        } else {
            if (data.length() > 0 || !line.equals("" ""))
                line = line.trim();
            if (line.isEmpty())
                continue;
            if (!wrap && data.length() > 0)
                data.append('\n');
            data.append(line);
            wrap = line.length() == 80;
        }
    }
    if (header != null)
        container.setProperty(header, data.toString());
}","/**
     * Read non-structural data from input and store as properties the provided
     * 'container'. Non-structural data appears in a structure data file (SDF)
     * after an Molfile and before the record deliminator ('$$$$'). The data
     * consists of one or more Data Header and Data blocks, an example is seen
     * below.
     *
     * <pre>{@code
     * > 29 <DENSITY>
     * 0.9132 - 20.0
     *
     * > 29 <BOILING.POINT>
     * 63.0 (737 MM)
     * 79.0 (42 MM)
     *
     * > 29 <ALTERNATE.NAMES>
     * SYLVAN
     *
     * > 29 <DATE>
     * 09-23-1980
     *
     * > 29 <CRC.NUMBER>
     * F-0213
     *
     * }</pre>
     *
     *
     * @param input     input source
     * @param container the container
     * @throws IOException an error occur whilst reading the input
     */","('readNonStructuralData', {'INSTRUCTION': {'covered': 79, 'missed': 0}, 'BRANCH': {'covered': 20, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 11, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",200.0,  Read non-structural data from input and store as properties the provided  'container'.,14.0,"['Read non-structural data from input and store it in a container.', 'Read non-structural data from the input and store it.', 'Read non-structural data from the input and store it as a container.']"
881,cdk,org/openscience/cdk/qsar/descriptors/molecular/LongestAliphaticChainDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/LongestAliphaticChainDescriptor.java,calculate,166-209,"/**
     * Calculate the count of atoms of the longest aliphatic chain in the supplied {@link IAtomContainer}.
     * <p>
     * The method require one parameter:
     * if checkRingSyste is true the CDKConstant.ISINRING will be set
     *
     * @param mol The {@link IAtomContainer} for which this descriptor is to be calculated
     * @return the number of atoms in the longest aliphatic chain of this AtomContainer
     * @see #setParameters
     */
public DescriptorValue calculate(IAtomContainer mol){
    if (checkRingSystem)
        Cycles.markRingAtomsAndBonds(mol);
    IAtomContainer aliphaticParts = mol.getBuilder().newAtomContainer();
    for (IAtom atom : mol.atoms()) {
        if (isAcyclicCarbon(atom))
            aliphaticParts.addAtom(atom);
    }
    for (IBond bond : mol.bonds()) {
        if (isAcyclicCarbon(bond.getBegin()) && isAcyclicCarbon(bond.getEnd()))
            aliphaticParts.addBond(bond);
    }
    int longest = 0;
    final int[][] adjlist = GraphUtil.toAdjList(aliphaticParts);
    for (int i = 0; i < adjlist.length; i++) {
        if (adjlist[i].length != 1)
            continue;
        int length = getMaxDepth(adjlist, i, -1);
        if (length > longest)
            longest = length;
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(longest), getDescriptorNames());
}","public DescriptorValue calculate(IAtomContainer mol){
    if (checkRingSystem)
        Cycles.markRingAtomsAndBonds(mol);
    IAtomContainer aliphaticParts = mol.getBuilder().newAtomContainer();
    for (IAtom atom : mol.atoms()) {
        if (isAcyclicCarbon(atom))
            aliphaticParts.addAtom(atom);
    }
    for (IBond bond : mol.bonds()) {
        if (isAcyclicCarbon(bond.getBegin()) && isAcyclicCarbon(bond.getEnd()))
            aliphaticParts.addBond(bond);
    }
    int longest = 0;
    final int[][] adjlist = GraphUtil.toAdjList(aliphaticParts);
    for (int i = 0; i < adjlist.length; i++) {
        if (adjlist[i].length != 1)
            continue;
        int length = getMaxDepth(adjlist, i, -1);
        if (length > longest)
            longest = length;
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(longest), getDescriptorNames());
}","/**
     * Calculate the count of atoms of the longest aliphatic chain in the supplied {@link IAtomContainer}.
     * <p>
     * The method require one parameter:
     * if checkRingSyste is true the CDKConstant.ISINRING will be set
     *
     * @param mol The {@link IAtomContainer} for which this descriptor is to be calculated
     * @return the number of atoms in the longest aliphatic chain of this AtomContainer
     * @see #setParameters
     */","('calculate', {'INSTRUCTION': {'covered': 97, 'missed': 0}, 'BRANCH': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",201.0,  Calculate the count of atoms of the longest aliphatic chain in the supplied {@link IAtomContainer}.,19.0,"['The supplied IAtomContainer has a count of atoms of the longest aliphatic chain.', 'The supplied IAtomContainer has the count of atoms of the longest aliphatic chain.', 'The supplied IAtomContainer has a count of the longest aliphatic chain.']"
882,cdk,org/openscience/cdk/fragment/FragmentUtils.java,/tool/fragment/src/main/java/org/openscience/cdk/fragment/FragmentUtils.java,splitMolecule,44-93,"/**
     * Non destructively split a molecule into two parts at the specified bond.
     *
     * Note that if a ring bond is specified, the resultant list will contain
     * teh opened ring twice.
     *
     * @param atomContainer The molecule to split
     * @param bond The bond to split at
     * @return A list containing the two parts of the molecule
     */
protected static List<IAtomContainer> splitMolecule(IAtomContainer atomContainer, IBond bond){
    List<IAtomContainer> ret = new ArrayList<IAtomContainer>();
    for (IAtom atom : bond.atoms()) {
        // later on we'll want to make sure that the fragment doesn't contain
        // the bond joining the current atom and the atom that is on the other side
        IAtom excludedAtom;
        if (atom.equals(bond.getBegin()))
            excludedAtom = bond.getEnd();
        else
            excludedAtom = bond.getBegin();
        List<IBond> part = new ArrayList<IBond>();
        part.add(bond);
        part = traverse(atomContainer, atom, part);
        // at this point we have a partion which contains the bond we
        // split. This partition should actually 2 partitions:
        // - one with the splitting bond
        // - one without the splitting bond
        // note that this will lead to repeated fragments when we  do this
        // with adjacent bonds, so when we gather all the fragments we need
        // to check for repeats
        IAtomContainer partContainer;
        partContainer = makeAtomContainer(atom, part, excludedAtom);
        // by checking for more than 2 atoms, we exclude single bond fragments
        // also if a fragment has the same number of atoms as the parent molecule,
        // it is the parent molecule, so we exclude it.
        if (partContainer.getAtomCount() > 2 && partContainer.getAtomCount() != atomContainer.getAtomCount())
            ret.add(partContainer);
        part.remove(0);
        partContainer = makeAtomContainer(atom, part, excludedAtom);
        if (partContainer.getAtomCount() > 2 && partContainer.getAtomCount() != atomContainer.getAtomCount())
            ret.add(partContainer);
    }
    return ret;
}","protected static List<IAtomContainer> splitMolecule(IAtomContainer atomContainer, IBond bond){
    List<IAtomContainer> ret = new ArrayList<IAtomContainer>();
    for (IAtom atom : bond.atoms()) {
        // later on we'll want to make sure that the fragment doesn't contain
        // the bond joining the current atom and the atom that is on the other side
        IAtom excludedAtom;
        if (atom.equals(bond.getBegin()))
            excludedAtom = bond.getEnd();
        else
            excludedAtom = bond.getBegin();
        List<IBond> part = new ArrayList<IBond>();
        part.add(bond);
        part = traverse(atomContainer, atom, part);
        // at this point we have a partion which contains the bond we
        // split. This partition should actually 2 partitions:
        // - one with the splitting bond
        // - one without the splitting bond
        // note that this will lead to repeated fragments when we  do this
        // with adjacent bonds, so when we gather all the fragments we need
        // to check for repeats
        IAtomContainer partContainer;
        partContainer = makeAtomContainer(atom, part, excludedAtom);
        // by checking for more than 2 atoms, we exclude single bond fragments
        // also if a fragment has the same number of atoms as the parent molecule,
        // it is the parent molecule, so we exclude it.
        if (partContainer.getAtomCount() > 2 && partContainer.getAtomCount() != atomContainer.getAtomCount())
            ret.add(partContainer);
        part.remove(0);
        partContainer = makeAtomContainer(atom, part, excludedAtom);
        if (partContainer.getAtomCount() > 2 && partContainer.getAtomCount() != atomContainer.getAtomCount())
            ret.add(partContainer);
    }
    return ret;
}","/**
     * Non destructively split a molecule into two parts at the specified bond.
     *
     * Note that if a ring bond is specified, the resultant list will contain
     * teh opened ring twice.
     *
     * @param atomContainer The molecule to split
     * @param bond The bond to split at
     * @return A list containing the two parts of the molecule
     */","('splitMolecule', {'INSTRUCTION': {'covered': 83, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",201.0,  Non destructively split a molecule into two parts at the specified bond.,13.0,"['A molecule can be split into two parts.', 'A molecule is split into two parts.', 'The molecule was split into two parts.']"
883,logstash-logback-encoder,net/logstash/logback/appender/destination/DestinationParser.java,/src/main/java/net/logstash/logback/appender/destination/DestinationParser.java,parse,39-94,"/**
     * Constructs {@link InetSocketAddress}es by parsing the given {@link String} value.
     * <p>
     * The string is a comma separated list of destinations in the form of hostName[:portNumber].
     * <p>
     *
     * For example, ""host1.domain.com,host2.domain.com:5560""
     * <p>
     *
     * If portNumber is not provided, then the given defaultPort will be used.
     * 
     * @param destinations comma-separated list of destinations in the form of {@code hostName[:portNumber]}
     * @param defaultPort the port number to use when a destination does not specify one explicitly
     * @return ordered list of {@link InetSocketAddress} instances
     */
public static List<InetSocketAddress> parse(String destinations, int defaultPort){
    /*
         * Multiple destinations can be specified on one single line, separated by comma
         */
    String[] destinationStrings = (destinations == null ? """" : destinations.trim()).split(""\\s*,\\s*"");
    List<InetSocketAddress> destinationList = new ArrayList<>(destinationStrings.length);
    for (String entry : destinationStrings) {
        /*
             * For #134, check to ensure properties are defined when destinations
             * are set using properties.
             */
        if (entry.contains(CoreConstants.UNDEFINED_PROPERTY_SUFFIX)) {
            throw new IllegalArgumentException(""Invalid destination '"" + entry + ""': unparseable value (expected format 'host[:port]')."");
        }
        Matcher matcher = DESTINATION_PATTERN.matcher(entry);
        if (!matcher.matches()) {
            throw new IllegalArgumentException(""Invalid destination '"" + entry + ""': unparseable value (expected format 'host[:port]')."");
        }
        String host = matcher.group(HOSTNAME_GROUP);
        String portString = matcher.group(PORT_GROUP);
        int port;
        try {
            port = (portString != null) ? Integer.parseInt(portString) : defaultPort;
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException(""Invalid destination '"" + entry + ""': unparseable port (was '"" + portString + ""')."");
        }
        destinationList.add(InetSocketAddress.createUnresolved(host, port));
    }
    return destinationList;
}","public static List<InetSocketAddress> parse(String destinations, int defaultPort){
    /*
         * Multiple destinations can be specified on one single line, separated by comma
         */
    String[] destinationStrings = (destinations == null ? """" : destinations.trim()).split(""\\s*,\\s*"");
    List<InetSocketAddress> destinationList = new ArrayList<>(destinationStrings.length);
    for (String entry : destinationStrings) {
        /*
             * For #134, check to ensure properties are defined when destinations
             * are set using properties.
             */
        if (entry.contains(CoreConstants.UNDEFINED_PROPERTY_SUFFIX)) {
            throw new IllegalArgumentException(""Invalid destination '"" + entry + ""': unparseable value (expected format 'host[:port]')."");
        }
        Matcher matcher = DESTINATION_PATTERN.matcher(entry);
        if (!matcher.matches()) {
            throw new IllegalArgumentException(""Invalid destination '"" + entry + ""': unparseable value (expected format 'host[:port]')."");
        }
        String host = matcher.group(HOSTNAME_GROUP);
        String portString = matcher.group(PORT_GROUP);
        int port;
        try {
            port = (portString != null) ? Integer.parseInt(portString) : defaultPort;
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException(""Invalid destination '"" + entry + ""': unparseable port (was '"" + portString + ""')."");
        }
        destinationList.add(InetSocketAddress.createUnresolved(host, port));
    }
    return destinationList;
}","/**
     * Constructs {@link InetSocketAddress}es by parsing the given {@link String} value.
     * <p>
     * The string is a comma separated list of destinations in the form of hostName[:portNumber].
     * <p>
     *
     * For example, ""host1.domain.com,host2.domain.com:5560""
     * <p>
     *
     * If portNumber is not provided, then the given defaultPort will be used.
     * 
     * @param destinations comma-separated list of destinations in the form of {@code hostName[:portNumber]}
     * @param defaultPort the port number to use when a destination does not specify one explicitly
     * @return ordered list of {@link InetSocketAddress} instances
     */","('parse', {'INSTRUCTION': {'covered': 111, 'missed': 2}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",203.0,  Constructs {@link InetSocketAddress}es by parsing the given {@link String} value.,18.0,"['The given @link String value is used to construct @link InetSocketAddresses.', 'The given @link String value is used to construct the @link InetSocketAddresses.', 'The given @link String value is used to create @link InetSocketAddresses.']"
886,acs-aem-commons,com/adobe/acs/commons/redirects/filter/RedirectFilter.java,/bundle/src/main/java/com/adobe/acs/commons/redirects/filter/RedirectFilter.java,doesRequestMatch,486-528,"/**
     * Check whether redirection for the given request is allowed.
     * <ol>
     * <li>On author redirects are disabled in EDIT, PREVIEW and DESIGN WCM Modes.
     * To test on author you need to disable WCM mode and append &wcmmode=disabled
     * to the query string</li>
     * <li>Redirects are supported only for GET and HEAD methods</li>
     * This can be changed in the OSGi configuration</li>
     * <li>If configured, redirects are allowed only for the specified extensions,
     * e.g. only *.html requests will be redirected. Same path with .json extension
     * will <i>not</i> be redirected. This feature is disabled by default.</li>
     * </ol>
     *
     * @param request the request to check
     * @return whether redirection for the given is allowed
     */
private boolean doesRequestMatch(SlingHttpServletRequest request){
    WCMMode wcmMode = WCMMode.fromRequest(request);
    if (wcmMode != null && wcmMode != WCMMode.DISABLED) {
        log.trace(""Request in author mode: {}, no redirection."", wcmMode);
        return false;
    }
    String method = request.getMethod();
    if (!getMethods().contains(method)) {
        log.trace(""Request method [{}] does not match any of {}."", method, methods);
        return false;
    }
    String ext = request.getRequestPathInfo().getExtension();
    if (ext != null && !getExtensions().isEmpty() && !getExtensions().contains(ext)) {
        log.trace(""Request extension [{}] does not match any of {}."", ext, exts);
        return false;
    }
    String resourcePath = request.getRequestPathInfo().getResourcePath();
    boolean matches = getPaths().isEmpty() || getPaths().stream().anyMatch(p -> resourcePath.startsWith(p + ""/""));
    if (!matches) {
        log.trace(""Request path [{}] not within any of {}."", resourcePath, paths);
        return false;
    }
    return true;
}","private boolean doesRequestMatch(SlingHttpServletRequest request){
    WCMMode wcmMode = WCMMode.fromRequest(request);
    if (wcmMode != null && wcmMode != WCMMode.DISABLED) {
        log.trace(""Request in author mode: {}, no redirection."", wcmMode);
        return false;
    }
    String method = request.getMethod();
    if (!getMethods().contains(method)) {
        log.trace(""Request method [{}] does not match any of {}."", method, methods);
        return false;
    }
    String ext = request.getRequestPathInfo().getExtension();
    if (ext != null && !getExtensions().isEmpty() && !getExtensions().contains(ext)) {
        log.trace(""Request extension [{}] does not match any of {}."", ext, exts);
        return false;
    }
    String resourcePath = request.getRequestPathInfo().getResourcePath();
    boolean matches = getPaths().isEmpty() || getPaths().stream().anyMatch(p -> resourcePath.startsWith(p + ""/""));
    if (!matches) {
        log.trace(""Request path [{}] not within any of {}."", resourcePath, paths);
        return false;
    }
    return true;
}","/**
     * Check whether redirection for the given request is allowed.
     * <ol>
     * <li>On author redirects are disabled in EDIT, PREVIEW and DESIGN WCM Modes.
     * To test on author you need to disable WCM mode and append &wcmmode=disabled
     * to the query string</li>
     * <li>Redirects are supported only for GET and HEAD methods</li>
     * This can be changed in the OSGi configuration</li>
     * <li>If configured, redirects are allowed only for the specified extensions,
     * e.g. only *.html requests will be redirected. Same path with .json extension
     * will <i>not</i> be redirected. This feature is disabled by default.</li>
     * </ol>
     *
     * @param request the request to check
     * @return whether redirection for the given is allowed
     */","('doesRequestMatch', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 15, 'missed': 3}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",206.0,  Check whether redirection for the given request is allowed.,10.0,"['Redirection for the given request is allowed if you check.', 'Redirection for the given request is allowed if you check that.', 'If the given request is allowed to be diverted, check.']"
888,matsim-libs,org/matsim/core/config/groups/PlanCalcScoreConfigGroup.java,/matsim/src/main/java/org/matsim/core/config/groups/PlanCalcScoreConfigGroup.java,checkConsistency,1510-1561,"/**
		 * Checks whether all the settings make sense or if there are some
		 * problems with the parameters currently set. Currently, this checks
		 * that for at least one activity type opening AND closing times are
		 * defined.
		 */
public void checkConsistency(Config config){
    super.checkConsistency(config);
    boolean hasOpeningAndClosingTime = false;
    boolean hasOpeningTimeAndLatePenalty = false;
    for (ActivityParams actType : this.getActivityParams()) {
        if (actType.isScoringThisActivityAtAll()) {
            if (actType.getOpeningTime().isDefined() && actType.getClosingTime().isDefined()) {
                hasOpeningAndClosingTime = true;
                if (actType.getOpeningTime().seconds() == 0. && actType.getClosingTime().seconds() > 24. * 3600 - 1) {
                    log.error(""it looks like you have an activity type with opening time set to 0:00 and closing "" + ""time set to 24:00. This is most probably not the same as not setting them at all.  "" + ""In particular, activities which extend past midnight may not accumulate scores."");
                }
            }
            if (actType.getOpeningTime().isDefined() && (getLateArrival_utils_hr() < -0.001)) {
                hasOpeningTimeAndLatePenalty = true;
            }
        }
    }
    if (!hasOpeningAndClosingTime && !hasOpeningTimeAndLatePenalty) {
        log.info(""NO OPENING OR CLOSING TIMES DEFINED!\n\n"" + ""There is no activity type that has an opening *and* closing time (or opening time and late penalty) defined.\n"" + ""This usually means that the activity chains can be shifted by an arbitrary\n"" + ""number of hours without having an effect on the score of the plans, and thus\n"" + ""resulting in wrong results / traffic patterns.\n"" + ""If you are using MATSim without time adaptation, you can ignore this warning.\n\n"");
    }
    if (this.getMarginalUtlOfWaiting_utils_hr() != 0.0) {
        log.warn(""marginal utl of wait set to: "" + this.getMarginalUtlOfWaiting_utils_hr() + "". Setting this different from zero is "" + ""discouraged since there is already the marginal utility of time as a resource. The parameter was also used "" + ""in the past for pt routing; if you did that, consider setting the new "" + ""parameter waitingPt instead."");
    }
}","public void checkConsistency(Config config){
    super.checkConsistency(config);
    boolean hasOpeningAndClosingTime = false;
    boolean hasOpeningTimeAndLatePenalty = false;
    for (ActivityParams actType : this.getActivityParams()) {
        if (actType.isScoringThisActivityAtAll()) {
            if (actType.getOpeningTime().isDefined() && actType.getClosingTime().isDefined()) {
                hasOpeningAndClosingTime = true;
                if (actType.getOpeningTime().seconds() == 0. && actType.getClosingTime().seconds() > 24. * 3600 - 1) {
                    log.error(""it looks like you have an activity type with opening time set to 0:00 and closing "" + ""time set to 24:00. This is most probably not the same as not setting them at all.  "" + ""In particular, activities which extend past midnight may not accumulate scores."");
                }
            }
            if (actType.getOpeningTime().isDefined() && (getLateArrival_utils_hr() < -0.001)) {
                hasOpeningTimeAndLatePenalty = true;
            }
        }
    }
    if (!hasOpeningAndClosingTime && !hasOpeningTimeAndLatePenalty) {
        log.info(""NO OPENING OR CLOSING TIMES DEFINED!\n\n"" + ""There is no activity type that has an opening *and* closing time (or opening time and late penalty) defined.\n"" + ""This usually means that the activity chains can be shifted by an arbitrary\n"" + ""number of hours without having an effect on the score of the plans, and thus\n"" + ""resulting in wrong results / traffic patterns.\n"" + ""If you are using MATSim without time adaptation, you can ignore this warning.\n\n"");
    }
    if (this.getMarginalUtlOfWaiting_utils_hr() != 0.0) {
        log.warn(""marginal utl of wait set to: "" + this.getMarginalUtlOfWaiting_utils_hr() + "". Setting this different from zero is "" + ""discouraged since there is already the marginal utility of time as a resource. The parameter was also used "" + ""in the past for pt routing; if you did that, consider setting the new "" + ""parameter waitingPt instead."");
    }
}","/**
		 * Checks whether all the settings make sense or if there are some
		 * problems with the parameters currently set. Currently, this checks
		 * that for at least one activity type opening AND closing times are
		 * defined.
		 */","('checkConsistency', {'INSTRUCTION': {'covered': 90, 'missed': 12}, 'BRANCH': {'covered': 18, 'missed': 2}, 'LINE': {'covered': 17, 'missed': 2}, 'COMPLEXITY': {'covered': 9, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",207.0,  Checks whether all the settings make sense or if there are some  problems with the parameters currently set.,19.0,"['Checks to see if the settings make sense and if there are any problems with the parameters currently set.', 'Checks to see if the settings make sense and if there are any problems with the parameters.', 'Checks to see if the settings make sense or if there are any problems with the parameters currently set.']"
889,jooby,io/jooby/Cookie.java,/jooby/src/main/java/io/jooby/Cookie.java,create,550-575,"/**
   * Attempt to create/parse a cookie from application configuration object. The namespace given
   * must be present and must defined a <code>name</code> property.
   *
   * The namespace might optionally defined: value, path, domain, secure, httpOnly and maxAge.
   *
   * @param namespace Cookie namespace/prefix.
   * @param conf Configuration object.
   * @return Parsed cookie or empty.
   */
public static Optional<Cookie> create(@Nonnull String namespace, @Nonnull Config conf){
    if (conf.hasPath(namespace)) {
        Cookie cookie = new Cookie(conf.getString(namespace + "".name""));
        value(conf, namespace + "".value"", Config::getString, cookie::setValue);
        value(conf, namespace + "".path"", Config::getString, cookie::setPath);
        value(conf, namespace + "".domain"", Config::getString, cookie::setDomain);
        value(conf, namespace + "".secure"", Config::getBoolean, cookie::setSecure);
        value(conf, namespace + "".httpOnly"", Config::getBoolean, cookie::setHttpOnly);
        value(conf, namespace + "".maxAge"", (c, path) -> c.getDuration(path, TimeUnit.SECONDS), cookie::setMaxAge);
        value(conf, namespace + "".sameSite"", (c, path) -> SameSite.of(c.getString(path)), cookie::setSameSite);
        return Optional.of(cookie);
    }
    return Optional.empty();
}","public static Optional<Cookie> create(@Nonnull String namespace, @Nonnull Config conf){
    if (conf.hasPath(namespace)) {
        Cookie cookie = new Cookie(conf.getString(namespace + "".name""));
        value(conf, namespace + "".value"", Config::getString, cookie::setValue);
        value(conf, namespace + "".path"", Config::getString, cookie::setPath);
        value(conf, namespace + "".domain"", Config::getString, cookie::setDomain);
        value(conf, namespace + "".secure"", Config::getBoolean, cookie::setSecure);
        value(conf, namespace + "".httpOnly"", Config::getBoolean, cookie::setHttpOnly);
        value(conf, namespace + "".maxAge"", (c, path) -> c.getDuration(path, TimeUnit.SECONDS), cookie::setMaxAge);
        value(conf, namespace + "".sameSite"", (c, path) -> SameSite.of(c.getString(path)), cookie::setSameSite);
        return Optional.of(cookie);
    }
    return Optional.empty();
}","/**
   * Attempt to create/parse a cookie from application configuration object. The namespace given
   * must be present and must defined a <code>name</code> property.
   *
   * The namespace might optionally defined: value, path, domain, secure, httpOnly and maxAge.
   *
   * @param namespace Cookie namespace/prefix.
   * @param conf Configuration object.
   * @return Parsed cookie or empty.
   */","('create', {'INSTRUCTION': {'covered': 133, 'missed': 2}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 12, 'missed': 1}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",208.0,  Attempt to create/parse a cookie from application configuration object.,10.0,"['Attempt to create a cookie from an object.', 'Attempt to create a cookie from the application configuration object.', 'Attempt to create a cookie from the application configuration object']"
890,cdk,org/openscience/cdk/qsar/descriptors/molecular/KierHallSmartsDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/KierHallSmartsDescriptor.java,calculate,378-414,"/**
     * This method calculates occurrences of the Kier &amp; Hall E-state fragments.
     *
     * @param container The molecule for which this descriptor is to be calculated
     * @return Counts of the fragments
     */
public DescriptorValue calculate(IAtomContainer container){
    if (container == null || container.getAtomCount() == 0) {
        return getDummyDescriptorValue(new CDKException(""Container was null or else had no atoms""));
    }
    IAtomContainer atomContainer;
    try {
        atomContainer = (IAtomContainer) container.clone();
        for (IAtom atom : atomContainer.atoms()) {
            if (atom.getImplicitHydrogenCount() == null)
                atom.setImplicitHydrogenCount(0);
        }
        atomContainer = AtomContainerManipulator.removeHydrogens(atomContainer);
    } catch (CloneNotSupportedException e) {
        return getDummyDescriptorValue(new CDKException(""Error during clone""));
    }
    int[] counts = new int[SMARTS.length];
    SmartsPattern.prepare(atomContainer);
    for (int i = 0; i < SMARTS.length; i++) {
        counts[i] = SMARTS[i].matchAll(atomContainer).countUnique();
    }
    IntegerArrayResult result = new IntegerArrayResult();
    for (Integer i : counts) result.add(i);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result, getDescriptorNames());
}","public DescriptorValue calculate(IAtomContainer container){
    if (container == null || container.getAtomCount() == 0) {
        return getDummyDescriptorValue(new CDKException(""Container was null or else had no atoms""));
    }
    IAtomContainer atomContainer;
    try {
        atomContainer = (IAtomContainer) container.clone();
        for (IAtom atom : atomContainer.atoms()) {
            if (atom.getImplicitHydrogenCount() == null)
                atom.setImplicitHydrogenCount(0);
        }
        atomContainer = AtomContainerManipulator.removeHydrogens(atomContainer);
    } catch (CloneNotSupportedException e) {
        return getDummyDescriptorValue(new CDKException(""Error during clone""));
    }
    int[] counts = new int[SMARTS.length];
    SmartsPattern.prepare(atomContainer);
    for (int i = 0; i < SMARTS.length; i++) {
        counts[i] = SMARTS[i].matchAll(atomContainer).countUnique();
    }
    IntegerArrayResult result = new IntegerArrayResult();
    for (Integer i : counts) result.add(i);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result, getDescriptorNames());
}","/**
     * This method calculates occurrences of the Kier &amp; Hall E-state fragments.
     *
     * @param container The molecule for which this descriptor is to be calculated
     * @return Counts of the fragments
     */","('calculate', {'INSTRUCTION': {'covered': 92, 'missed': 15}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 17, 'missed': 3}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",210.0,  This method calculates occurrences of the Kier &amp; Hall E-state fragments.,14.0,"['The method calculates occurrences of the Hall E-state fragments.', 'The method calculates the occurrences of the Hall E-state fragments.', 'There are occurrences of the Hall E-state fragments.']"
891,jackson-databind,com/fasterxml/jackson/databind/util/ArrayBuilders.java,/src/main/java/com/fasterxml/jackson/databind/util/ArrayBuilders.java,insertInListNoDup,198-238,"/**
     * Helper method for constructing a new array that contains specified
     * element followed by contents of the given array but never contains
     * duplicates.
     * If element already existed, one of two things happens: if the element
     * was already the first one in array, array is returned as is; but
     * if not, a new copy is created in which element has moved as the head.
     */
public static T[] insertInListNoDup(T[] array, T element){
    final int len = array.length;
    for (int ix = 0; ix < len; ++ix) {
        if (array[ix] == element) {
            if (ix == 0) {
                return array;
            }
            T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len);
            System.arraycopy(array, 0, result, 1, ix);
            result[0] = element;
            ++ix;
            int left = len - ix;
            if (left > 0) {
                System.arraycopy(array, ix, result, ix, left);
            }
            return result;
        }
    }
    T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len + 1);
    if (len > 0) {
        System.arraycopy(array, 0, result, 1, len);
    }
    result[0] = element;
    return result;
}","public static T[] insertInListNoDup(T[] array, T element){
    final int len = array.length;
    for (int ix = 0; ix < len; ++ix) {
        if (array[ix] == element) {
            if (ix == 0) {
                return array;
            }
            T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len);
            System.arraycopy(array, 0, result, 1, ix);
            result[0] = element;
            ++ix;
            int left = len - ix;
            if (left > 0) {
                System.arraycopy(array, ix, result, ix, left);
            }
            return result;
        }
    }
    T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len + 1);
    if (len > 0) {
        System.arraycopy(array, 0, result, 1, len);
    }
    result[0] = element;
    return result;
}","/**
     * Helper method for constructing a new array that contains specified
     * element followed by contents of the given array but never contains
     * duplicates.
     * If element already existed, one of two things happens: if the element
     * was already the first one in array, array is returned as is; but
     * if not, a new copy is created in which element has moved as the head.
     */","('insertInListNoDup', {'INSTRUCTION': {'covered': 74, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",210.0,  Helper method for constructing a new array that contains specified  element followed by contents of the given array but never contains  duplicates.,23.0,"['The method for constructing a new array that contains specified element followed by the contents of the given array is called a helpers method.', 'The method for constructing a new array that contains specified element followed by contents of the given array but never contains duplicate elements is called the helpers method.', 'The method for constructing a new array that contains specified element followed by the contents of the given array but never contains duplicate elements is called the helpers method.']"
892,cdk,org/openscience/cdk/smarts/SmartsFragmentExtractor.java,/tool/smarts/src/main/java/org/openscience/cdk/smarts/SmartsFragmentExtractor.java,generate,189-235,"/**
     * Generate a SMARTS for the substructure formed of the provided
     * atoms.
     *
     * @param atomIdxs atom indexes
     * @return SMARTS, null if an empty array is passed
     */
public String generate(int[] atomIdxs){
    if (atomIdxs == null)
        throw new NullPointerException(""No atom indexes provided"");
    if (atomIdxs.length == 0)
        return null;
    if (atomIdxs.length == 1 && mode == MODE_EXACT)
        return aexpr[atomIdxs[0]];
    Arrays.fill(rbnds, 0);
    Arrays.fill(avisit, 0);
    for (int atmIdx : atomIdxs) avisit[atmIdx] = -1;
    numVisit = 1;
    for (int atomIdx : atomIdxs) {
        if (avisit[atomIdx] < 0)
            markRings(atomIdx, -1);
    }
    numVisit = 1;
    for (int atmIdx : atomIdxs) avisit[atmIdx] = -1;
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < atomIdxs.length; i++) {
        if (avisit[atomIdxs[i]] < 0) {
            if (i > 0)
                sb.append('.');
            encodeExpr(atomIdxs[i], -1, sb);
        }
    }
    return sb.toString();
}","public String generate(int[] atomIdxs){
    if (atomIdxs == null)
        throw new NullPointerException(""No atom indexes provided"");
    if (atomIdxs.length == 0)
        return null;
    if (atomIdxs.length == 1 && mode == MODE_EXACT)
        return aexpr[atomIdxs[0]];
    Arrays.fill(rbnds, 0);
    Arrays.fill(avisit, 0);
    for (int atmIdx : atomIdxs) avisit[atmIdx] = -1;
    numVisit = 1;
    for (int atomIdx : atomIdxs) {
        if (avisit[atomIdx] < 0)
            markRings(atomIdx, -1);
    }
    numVisit = 1;
    for (int atmIdx : atomIdxs) avisit[atmIdx] = -1;
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < atomIdxs.length; i++) {
        if (avisit[atomIdxs[i]] < 0) {
            if (i > 0)
                sb.append('.');
            encodeExpr(atomIdxs[i], -1, sb);
        }
    }
    return sb.toString();
}","/**
     * Generate a SMARTS for the substructure formed of the provided
     * atoms.
     *
     * @param atomIdxs atom indexes
     * @return SMARTS, null if an empty array is passed
     */","('generate', {'INSTRUCTION': {'covered': 132, 'missed': 11}, 'BRANCH': {'covered': 19, 'missed': 3}, 'LINE': {'covered': 21, 'missed': 2}, 'COMPLEXITY': {'covered': 9, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",211.0,  Generate a SMARTS for the substructure formed of the provided  atoms.,12.0,"['The provided atoms have a substructure.', 'The provided atoms form a substructure.', 'The provided atoms formed a substructure.']"
893,cdk,org/openscience/cdk/renderer/generators/standard/ConvexHull.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/ConvexHull.java,grahamScan,163-193,"/**
     * The Graham Scan algorithm determines the points belonging to the convex hull in O(n lg n).
     *
     * @param points set of points
     * @return points in the convex hull
     * @see <a href=""http://en.wikipedia.org/wiki/Graham_scan"">Graham scan, Wikipedia</a>
     */
 static List<Point2D> grahamScan(final List<Point2D> points){
    if (points.size() <= 3)
        return new ArrayList<Point2D>(points);
    Collections.sort(points, new CompareYThenX());
    Collections.sort(points, new PolarComparator(points.get(0)));
    Deque<Point2D> hull = new ArrayDeque<Point2D>();
    hull.push(points.get(0));
    hull.push(points.get(1));
    hull.push(points.get(2));
    for (int i = 3; i < points.size(); i++) {
        Point2D top = hull.pop();
        while (!hull.isEmpty() && !isLeftTurn(hull.peek(), top, points.get(i))) {
            top = hull.pop();
        }
        hull.push(top);
        hull.push(points.get(i));
    }
    return new ArrayList<Point2D>(hull);
}","static List<Point2D> grahamScan(final List<Point2D> points){
    if (points.size() <= 3)
        return new ArrayList<Point2D>(points);
    Collections.sort(points, new CompareYThenX());
    Collections.sort(points, new PolarComparator(points.get(0)));
    Deque<Point2D> hull = new ArrayDeque<Point2D>();
    hull.push(points.get(0));
    hull.push(points.get(1));
    hull.push(points.get(2));
    for (int i = 3; i < points.size(); i++) {
        Point2D top = hull.pop();
        while (!hull.isEmpty() && !isLeftTurn(hull.peek(), top, points.get(i))) {
            top = hull.pop();
        }
        hull.push(top);
        hull.push(points.get(i));
    }
    return new ArrayList<Point2D>(hull);
}","/**
     * The Graham Scan algorithm determines the points belonging to the convex hull in O(n lg n).
     *
     * @param points set of points
     * @return points in the convex hull
     * @see <a href=""http://en.wikipedia.org/wiki/Graham_scan"">Graham scan, Wikipedia</a>
     */","('grahamScan', {'INSTRUCTION': {'covered': 89, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",212.0,  The Graham Scan algorithm determines the points belonging to the convex hull in O(n lg n).,20.0,"['The points belonging to the hull are determined by the Graham Scan algorithm.', 'The points belonging to the hull are determined by the Graham Scan.', 'The points belonging to the convex hull are determined by the Graham Scan algorithm.']"
894,cdk,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,generateOrderE,438-458,"/**
     * generate the order of the Elements according probability occurrence.,
     * beginning the C, H, O, N, Si, P, S, F, Cl, Br, I, Sn, B, Pb, Tl, Ba, In, Pd,
     * Pt, Os, Ag, Zr, Se, Zn, Cu, Ni, Co, Fe, Cr, Ti, Ca, K, Al, Mg, Na, Ce,
     * Hg, Au, Ir, Re, W, Ta, Hf, Lu, Yb, Tm, Er, Ho, Dy, Tb, Gd, Eu, Sm, Pm,
     * Nd, Pr, La, Cs, Xe, Te, Sb, Cd, Rh, Ru, Tc, Mo, Nb, Y, Sr, Rb, Kr, As,
     * Ge, Ga, Mn, V, Sc, Ar, Ne, Be, Li, Tl, Pb, Bi, Po, At, Rn, Fr, Ra, Ac,
     * Th, Pa, U, Np, Pu.
     *
     * @return  Array with the elements ordered.
     *
     */
private String[] generateOrderE(){
    String[] listElements = new String[] { ""C"", ""H"", ""O"", ""N"", ""Si"", ""P"", ""S"", ""F"", ""Cl"", ""Br"", ""I"", ""Sn"", ""B"", ""Pb"", ""Tl"", ""Ba"", ""In"", ""Pd"", ""Pt"", ""Os"", ""Ag"", ""Zr"", ""Se"", ""Zn"", ""Cu"", ""Ni"", ""Co"", ""Fe"", ""Cr"", ""Ti"", ""Ca"", ""K"", ""Al"", ""Mg"", ""Na"", ""Ce"", ""Hg"", ""Au"", ""Ir"", ""Re"", ""W"", ""Ta"", ""Hf"", ""Lu"", ""Yb"", ""Tm"", ""Er"", ""Ho"", ""Dy"", ""Tb"", ""Gd"", ""Eu"", ""Sm"", ""Pm"", ""Nd"", ""Pr"", ""La"", ""Cs"", ""Xe"", ""Te"", ""Sb"", ""Cd"", ""Rh"", ""Ru"", ""Tc"", ""Mo"", ""Nb"", ""Y"", ""Sr"", ""Rb"", ""Kr"", ""As"", ""Ge"", ""Ga"", ""Mn"", ""V"", ""Sc"", ""Ar"", ""Ne"", ""Be"", ""Li"", ""Tl"", ""Pb"", ""Bi"", ""Po"", ""At"", ""Rn"", ""Fr"", ""Ra"", ""Ac"", ""Th"", ""Pa"", ""U"", ""Np"", ""Pu"" };
    return listElements;
}","private String[] generateOrderE(){
    String[] listElements = new String[] { ""C"", ""H"", ""O"", ""N"", ""Si"", ""P"", ""S"", ""F"", ""Cl"", ""Br"", ""I"", ""Sn"", ""B"", ""Pb"", ""Tl"", ""Ba"", ""In"", ""Pd"", ""Pt"", ""Os"", ""Ag"", ""Zr"", ""Se"", ""Zn"", ""Cu"", ""Ni"", ""Co"", ""Fe"", ""Cr"", ""Ti"", ""Ca"", ""K"", ""Al"", ""Mg"", ""Na"", ""Ce"", ""Hg"", ""Au"", ""Ir"", ""Re"", ""W"", ""Ta"", ""Hf"", ""Lu"", ""Yb"", ""Tm"", ""Er"", ""Ho"", ""Dy"", ""Tb"", ""Gd"", ""Eu"", ""Sm"", ""Pm"", ""Nd"", ""Pr"", ""La"", ""Cs"", ""Xe"", ""Te"", ""Sb"", ""Cd"", ""Rh"", ""Ru"", ""Tc"", ""Mo"", ""Nb"", ""Y"", ""Sr"", ""Rb"", ""Kr"", ""As"", ""Ge"", ""Ga"", ""Mn"", ""V"", ""Sc"", ""Ar"", ""Ne"", ""Be"", ""Li"", ""Tl"", ""Pb"", ""Bi"", ""Po"", ""At"", ""Rn"", ""Fr"", ""Ra"", ""Ac"", ""Th"", ""Pa"", ""U"", ""Np"", ""Pu"" };
    return listElements;
}","/**
     * generate the order of the Elements according probability occurrence.,
     * beginning the C, H, O, N, Si, P, S, F, Cl, Br, I, Sn, B, Pb, Tl, Ba, In, Pd,
     * Pt, Os, Ag, Zr, Se, Zn, Cu, Ni, Co, Fe, Cr, Ti, Ca, K, Al, Mg, Na, Ce,
     * Hg, Au, Ir, Re, W, Ta, Hf, Lu, Yb, Tm, Er, Ho, Dy, Tb, Gd, Eu, Sm, Pm,
     * Nd, Pr, La, Cs, Xe, Te, Sb, Cd, Rh, Ru, Tc, Mo, Nb, Y, Sr, Rb, Kr, As,
     * Ge, Ga, Mn, V, Sc, Ar, Ne, Be, Li, Tl, Pb, Bi, Po, At, Rn, Fr, Ra, Ac,
     * Th, Pa, U, Np, Pu.
     *
     * @return  Array with the elements ordered.
     *
     */","('generateOrderE', {'INSTRUCTION': {'covered': 385, 'missed': 0}, 'LINE': {'covered': 2, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",213.0,  generate the order of the Elements according probability occurrence.,10.0,"['The order of the Elements can be generated.', 'The order of the Elements is determined by the probability occurrence.', 'The order of the Elements should be generated according to probability occurrence.']"
895,cdk,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,indexElements,351-383,"/**
     * Index the stereo elements of the {@code container} into the the {@code
     * elements} and {@code types} arrays. The {@code map} is used for looking
     * up the index of atoms.
     *
     * @param map       index of atoms
     * @param elements  array to fill with stereo elements
     * @param types     type of stereo element indexed
     * @param container the container to index the elements of
     * @return indices of atoms involved in stereo configurations
     */
private static int[] indexElements(Map<IAtom, Integer> map, IStereoElement[] elements, Type[] types, IAtomContainer container){
    int[] indices = new int[container.getAtomCount()];
    int nElements = 0;
    for (IStereoElement element : container.stereoElements()) {
        if (element instanceof ITetrahedralChirality) {
            ITetrahedralChirality tc = (ITetrahedralChirality) element;
            int idx = map.get(tc.getChiralAtom());
            elements[idx] = element;
            types[idx] = Type.Tetrahedral;
            indices[nElements++] = idx;
        } else if (element instanceof IDoubleBondStereochemistry) {
            IDoubleBondStereochemistry dbs = (IDoubleBondStereochemistry) element;
            int idx1 = map.get(dbs.getStereoBond().getBegin());
            int idx2 = map.get(dbs.getStereoBond().getEnd());
            elements[idx2] = elements[idx1] = element;
            types[idx1] = types[idx2] = Type.Geometric;
            indices[nElements++] = idx1;
        }
    }
    return Arrays.copyOf(indices, nElements);
}","private static int[] indexElements(Map<IAtom, Integer> map, IStereoElement[] elements, Type[] types, IAtomContainer container){
    int[] indices = new int[container.getAtomCount()];
    int nElements = 0;
    for (IStereoElement element : container.stereoElements()) {
        if (element instanceof ITetrahedralChirality) {
            ITetrahedralChirality tc = (ITetrahedralChirality) element;
            int idx = map.get(tc.getChiralAtom());
            elements[idx] = element;
            types[idx] = Type.Tetrahedral;
            indices[nElements++] = idx;
        } else if (element instanceof IDoubleBondStereochemistry) {
            IDoubleBondStereochemistry dbs = (IDoubleBondStereochemistry) element;
            int idx1 = map.get(dbs.getStereoBond().getBegin());
            int idx2 = map.get(dbs.getStereoBond().getEnd());
            elements[idx2] = elements[idx1] = element;
            types[idx1] = types[idx2] = Type.Geometric;
            indices[nElements++] = idx1;
        }
    }
    return Arrays.copyOf(indices, nElements);
}","/**
     * Index the stereo elements of the {@code container} into the the {@code
     * elements} and {@code types} arrays. The {@code map} is used for looking
     * up the index of atoms.
     *
     * @param map       index of atoms
     * @param elements  array to fill with stereo elements
     * @param types     type of stereo element indexed
     * @param container the container to index the elements of
     * @return indices of atoms involved in stereo configurations
     */","('indexElements', {'INSTRUCTION': {'covered': 92, 'missed': 0}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",214.0,  Index the stereo elements of the {@code container} into the the {@code  elements} and {@code types} arrays.,27.0,"['The stereo elements of the @code container should be included in the @code elements and @code types array.', 'The stereo elements of the @code container can be found in the @code elements and @code types array.', 'The stereo elements of the @code container should be put into the @code elements and @code types array.']"
896,tablesaw,tech/tablesaw/api/Table.java,/core/src/main/java/tech/tablesaw/api/Table.java,melt,1554-1619,"/**
   * Melt implements the 'tidy' melt operation as described in these papers by Hadley Wickham.
   *
   * <p>Tidy concepts: {@see https://www.jstatsoft.org/article/view/v059i10}
   *
   * <p>Cast function details: {@see https://www.jstatsoft.org/article/view/v021i12}
   *
   * <p>In short, melt turns columns into rows, but in a particular way. Used with the cast method,
   * it can help make data tidy. In a tidy dataset, every variable is a column and every observation
   * a row.
   *
   * <p>This method returns a table that contains all the data in this table, but organized such
   * that there is a set of identifier variables (columns) and a single measured variable (column).
   * For example, given a table with columns:
   *
   * <p>patient_id, gender, age, weight, temperature,
   *
   * <p>it returns a table with the columns:
   *
   * <p>patient_id, variable, value
   *
   * <p>In the new format, the strings age, weight, and temperature have become cells in the
   * measurement table, such that a single row in the source table might look like this in the
   * result table:
   *
   * <p>1234, gender, male 1234, age, 42 1234, weight, 186 1234, temperature, 97.4
   *
   * <p>This kind of structure often makes for a good intermediate format for performing subsequent
   * transformations. It is especially useful when combined with the {@link #cast()} operation
   *
   * @param idVariables A list of column names intended to be used as identifiers. In he example,
   *     only patient_id would be an identifier
   * @param measuredVariables A list of columns intended to be used as measured variables. All
   *     columns must have the same type
   * @param dropMissing drop any row where the value is missing
   */
public Table melt(List<String> idVariables, List<NumericColumn<?>> measuredVariables, Boolean dropMissing){
    Table result = Table.create(name);
    for (String idColName : idVariables) {
        result.addColumns(column(idColName).type().create(idColName));
    }
    result.addColumns(StringColumn.create(MELT_VARIABLE_COLUMN_NAME), DoubleColumn.create(MELT_VALUE_COLUMN_NAME));
    List<String> measureColumnNames = measuredVariables.stream().map(Column::name).collect(Collectors.toList());
    TableSliceGroup slices = splitOn(idVariables.toArray(new String[0]));
    for (TableSlice slice : slices) {
        for (Row row : slice) {
            for (String colName : measureColumnNames) {
                if (!dropMissing || !row.isMissing(colName)) {
                    writeIdVariables(idVariables, result, row);
                    result.stringColumn(MELT_VARIABLE_COLUMN_NAME).append(colName);
                    double value = row.getNumber(colName);
                    result.doubleColumn(MELT_VALUE_COLUMN_NAME).append(value);
                }
            }
        }
    }
    return result;
}","public Table melt(List<String> idVariables, List<NumericColumn<?>> measuredVariables, Boolean dropMissing){
    Table result = Table.create(name);
    for (String idColName : idVariables) {
        result.addColumns(column(idColName).type().create(idColName));
    }
    result.addColumns(StringColumn.create(MELT_VARIABLE_COLUMN_NAME), DoubleColumn.create(MELT_VALUE_COLUMN_NAME));
    List<String> measureColumnNames = measuredVariables.stream().map(Column::name).collect(Collectors.toList());
    TableSliceGroup slices = splitOn(idVariables.toArray(new String[0]));
    for (TableSlice slice : slices) {
        for (Row row : slice) {
            for (String colName : measureColumnNames) {
                if (!dropMissing || !row.isMissing(colName)) {
                    writeIdVariables(idVariables, result, row);
                    result.stringColumn(MELT_VARIABLE_COLUMN_NAME).append(colName);
                    double value = row.getNumber(colName);
                    result.doubleColumn(MELT_VALUE_COLUMN_NAME).append(value);
                }
            }
        }
    }
    return result;
}","/**
   * Melt implements the 'tidy' melt operation as described in these papers by Hadley Wickham.
   *
   * <p>Tidy concepts: {@see https://www.jstatsoft.org/article/view/v059i10}
   *
   * <p>Cast function details: {@see https://www.jstatsoft.org/article/view/v021i12}
   *
   * <p>In short, melt turns columns into rows, but in a particular way. Used with the cast method,
   * it can help make data tidy. In a tidy dataset, every variable is a column and every observation
   * a row.
   *
   * <p>This method returns a table that contains all the data in this table, but organized such
   * that there is a set of identifier variables (columns) and a single measured variable (column).
   * For example, given a table with columns:
   *
   * <p>patient_id, gender, age, weight, temperature,
   *
   * <p>it returns a table with the columns:
   *
   * <p>patient_id, variable, value
   *
   * <p>In the new format, the strings age, weight, and temperature have become cells in the
   * measurement table, such that a single row in the source table might look like this in the
   * result table:
   *
   * <p>1234, gender, male 1234, age, 42 1234, weight, 186 1234, temperature, 97.4
   *
   * <p>This kind of structure often makes for a good intermediate format for performing subsequent
   * transformations. It is especially useful when combined with the {@link #cast()} operation
   *
   * @param idVariables A list of column names intended to be used as identifiers. In he example,
   *     only patient_id would be an identifier
   * @param measuredVariables A list of columns intended to be used as measured variables. All
   *     columns must have the same type
   * @param dropMissing drop any row where the value is missing
   */","('melt', {'INSTRUCTION': {'covered': 123, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 22, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",214.0,  Melt implements the 'tidy' melt operation as described in these papers by Hadley Wickham.,16.0,"[""The 'tidy' melt operation is described in these papers."", ""The 'tidy' melt operation is described in the papers."", ""The 'tidy' melt operation is described in these papers by the author.""]"
897,cdk,org/openscience/cdk/hash/stereo/TetrahedralElementEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/TetrahedralElementEncoderFactory.java,encoder,73-118,"/**
     * Create an encoder for the {@link ITetrahedralChirality} element.
     *
     * @param tc          stereo element from an atom container
     * @param atomToIndex map of atoms to indices
     * @return a new geometry encoder
     */
private static GeometryEncoder encoder(ITetrahedralChirality tc, Map<IAtom, Integer> atomToIndex){
    IAtom[] ligands = tc.getLigands();
    int centre = atomToIndex.get(tc.getChiralAtom());
    int[] indices = new int[4];
    int offset = -1;
    for (int i = 0; i < ligands.length; i++) {
        indices[i] = atomToIndex.get(ligands[i]);
        if (indices[i] == centre)
            offset = i;
    }
    int parity = tc.getStereo() == CLOCKWISE ? -1 : 1;
    if (offset >= 0) {
        for (int i = offset; i < indices.length - 1; i++) {
            indices[i] = indices[i + 1];
        }
        if (Integer.lowestOneBit(3 - offset) == 0x1)
            parity *= -1;
        indices = Arrays.copyOf(indices, indices.length - 1);
    }
    return new GeometryEncoder(centre, new BasicPermutationParity(indices), GeometricParity.valueOf(parity));
}","private static GeometryEncoder encoder(ITetrahedralChirality tc, Map<IAtom, Integer> atomToIndex){
    IAtom[] ligands = tc.getLigands();
    int centre = atomToIndex.get(tc.getChiralAtom());
    int[] indices = new int[4];
    int offset = -1;
    for (int i = 0; i < ligands.length; i++) {
        indices[i] = atomToIndex.get(ligands[i]);
        if (indices[i] == centre)
            offset = i;
    }
    int parity = tc.getStereo() == CLOCKWISE ? -1 : 1;
    if (offset >= 0) {
        for (int i = offset; i < indices.length - 1; i++) {
            indices[i] = indices[i + 1];
        }
        if (Integer.lowestOneBit(3 - offset) == 0x1)
            parity *= -1;
        indices = Arrays.copyOf(indices, indices.length - 1);
    }
    return new GeometryEncoder(centre, new BasicPermutationParity(indices), GeometricParity.valueOf(parity));
}","/**
     * Create an encoder for the {@link ITetrahedralChirality} element.
     *
     * @param tc          stereo element from an atom container
     * @param atomToIndex map of atoms to indices
     * @return a new geometry encoder
     */","('encoder', {'INSTRUCTION': {'covered': 96, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",215.0,  Create an encoder for the {@link ITetrahedralChirality} element.,12.0,"['The @link ITetrahedralChirality element requires an Encoder.', 'The @link ITetrahedralChirality element has an Encoder.', 'The @link ITetrahedralChirality element has an @link ITetrahedralChirality element.']"
898,cdk,org/openscience/cdk/atomtype/StructGenAtomTypeGuesser.java,/tool/structgen/src/main/java/org/openscience/cdk/atomtype/StructGenAtomTypeGuesser.java,possibleAtomTypes,57-96,"/**
     * Finds the AtomType matching the Atom's element symbol, formal charge and
     * hybridization state.
     *
     * @param  atomContainer  AtomContainer
     * @param  atom            the target atom
     * @exception CDKException Exception thrown if something goes wrong
     * @return                 the matching AtomType
     */
public List<IAtomType> possibleAtomTypes(IAtomContainer atomContainer, IAtom atom) throws CDKException{
    if (factory == null) {
        try {
            factory = AtomTypeFactory.getInstance(""org/openscience/cdk/config/data/structgen_atomtypes.xml"", atom.getBuilder());
        } catch (Exception ex1) {
            logger.error(ex1.getMessage());
            logger.debug(ex1);
            throw new CDKException(""Could not instantiate the AtomType list!"", ex1);
        }
    }
    double bondOrderSum = atomContainer.getBondOrderSum(atom);
    IBond.Order maxBondOrder = atomContainer.getMaximumBondOrder(atom);
    int charge = atom.getFormalCharge();
    int hcount = atom.getImplicitHydrogenCount();
    List<IAtomType> matchingTypes = new ArrayList<IAtomType>();
    IAtomType[] types = factory.getAtomTypes(atom.getSymbol());
    for (IAtomType type : types) {
        logger.debug(""   ... matching atom "", atom, "" vs "", type);
        if (bondOrderSum - charge + hcount <= type.getBondOrderSum() && !BondManipulator.isHigherOrder(maxBondOrder, type.getMaxBondOrder())) {
            matchingTypes.add(type);
        }
    }
    logger.debug(""    No Match"");
    return matchingTypes;
}","public List<IAtomType> possibleAtomTypes(IAtomContainer atomContainer, IAtom atom) throws CDKException{
    if (factory == null) {
        try {
            factory = AtomTypeFactory.getInstance(""org/openscience/cdk/config/data/structgen_atomtypes.xml"", atom.getBuilder());
        } catch (Exception ex1) {
            logger.error(ex1.getMessage());
            logger.debug(ex1);
            throw new CDKException(""Could not instantiate the AtomType list!"", ex1);
        }
    }
    double bondOrderSum = atomContainer.getBondOrderSum(atom);
    IBond.Order maxBondOrder = atomContainer.getMaximumBondOrder(atom);
    int charge = atom.getFormalCharge();
    int hcount = atom.getImplicitHydrogenCount();
    List<IAtomType> matchingTypes = new ArrayList<IAtomType>();
    IAtomType[] types = factory.getAtomTypes(atom.getSymbol());
    for (IAtomType type : types) {
        logger.debug(""   ... matching atom "", atom, "" vs "", type);
        if (bondOrderSum - charge + hcount <= type.getBondOrderSum() && !BondManipulator.isHigherOrder(maxBondOrder, type.getMaxBondOrder())) {
            matchingTypes.add(type);
        }
    }
    logger.debug(""    No Match"");
    return matchingTypes;
}","/**
     * Finds the AtomType matching the Atom's element symbol, formal charge and
     * hybridization state.
     *
     * @param  atomContainer  AtomContainer
     * @param  atom            the target atom
     * @exception CDKException Exception thrown if something goes wrong
     * @return                 the matching AtomType
     */","('possibleAtomTypes', {'INSTRUCTION': {'covered': 92, 'missed': 14}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 17, 'missed': 4}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",216.0,"  Finds the AtomType matching the Atom's element symbol, formal charge and  hybridization state.",16.0,"[""The Atom's element symbol, formal charge and hybridization state are matched by the AtomType."", ""The Atom's element symbol, formal charge and hybridization state are found."", 'The AtomType matches the element symbol, formal charge and hybridization state.']"
899,acs-aem-commons,com/adobe/acs/commons/ondeploy/impl/OnDeployExecutorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/ondeploy/impl/OnDeployExecutorImpl.java,runScript,191-225,"/**
     * Run the {@link OnDeployScript}, if it has not previously been run successfully.
     * @param resourceResolver the resource resolver to use when running
     * @param script the script to run.
     * @return true if the script is executed, false if it has previous been run successfully
     */
protected boolean runScript(ResourceResolver resourceResolver, OnDeployScript script){
    Resource statusResource = getOrCreateStatusTrackingResource(resourceResolver, script.getClass());
    String status = getScriptStatus(statusResource);
    if (status == null || status.equals(SCRIPT_STATUS_FAIL)) {
        trackScriptStart(statusResource);
        try {
            script.execute(resourceResolver);
            logger.info(""On-deploy script completed successfully: {}"", statusResource.getPath());
            trackScriptEnd(statusResource, SCRIPT_STATUS_SUCCESS, """");
            return true;
        } catch (Exception e) {
            String errMsg = ""On-deploy script failed: "" + statusResource.getPath();
            logger.error(errMsg, e);
            resourceResolver.revert();
            trackScriptEnd(statusResource, SCRIPT_STATUS_FAIL, ExceptionUtils.getStackTrace(e.getCause()));
            throw new OnDeployEarlyTerminationException(new RuntimeException(errMsg));
        }
    } else if (!status.equals(SCRIPT_STATUS_SUCCESS)) {
        String errMsg = ""On-deploy script is already running or in an otherwise unknown state: "" + statusResource.getPath() + "" - status: "" + status;
        logger.error(errMsg);
        throw new OnDeployEarlyTerminationException(new RuntimeException(errMsg));
    } else {
        logger.debug(""Skipping on-deploy script, as it is already complete: {}"", statusResource.getPath());
    }
    return false;
}","protected boolean runScript(ResourceResolver resourceResolver, OnDeployScript script){
    Resource statusResource = getOrCreateStatusTrackingResource(resourceResolver, script.getClass());
    String status = getScriptStatus(statusResource);
    if (status == null || status.equals(SCRIPT_STATUS_FAIL)) {
        trackScriptStart(statusResource);
        try {
            script.execute(resourceResolver);
            logger.info(""On-deploy script completed successfully: {}"", statusResource.getPath());
            trackScriptEnd(statusResource, SCRIPT_STATUS_SUCCESS, """");
            return true;
        } catch (Exception e) {
            String errMsg = ""On-deploy script failed: "" + statusResource.getPath();
            logger.error(errMsg, e);
            resourceResolver.revert();
            trackScriptEnd(statusResource, SCRIPT_STATUS_FAIL, ExceptionUtils.getStackTrace(e.getCause()));
            throw new OnDeployEarlyTerminationException(new RuntimeException(errMsg));
        }
    } else if (!status.equals(SCRIPT_STATUS_SUCCESS)) {
        String errMsg = ""On-deploy script is already running or in an otherwise unknown state: "" + statusResource.getPath() + "" - status: "" + status;
        logger.error(errMsg);
        throw new OnDeployEarlyTerminationException(new RuntimeException(errMsg));
    } else {
        logger.debug(""Skipping on-deploy script, as it is already complete: {}"", statusResource.getPath());
    }
    return false;
}","/**
     * Run the {@link OnDeployScript}, if it has not previously been run successfully.
     * @param resourceResolver the resource resolver to use when running
     * @param script the script to run.
     * @return true if the script is executed, false if it has previous been run successfully
     */","('runScript', {'INSTRUCTION': {'covered': 102, 'missed': 0}, 'BRANCH': {'covered': 6, 'missed': 0}, 'LINE': {'covered': 20, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",216.0,"  Run the {@link OnDeployScript}, if it has not previously been run successfully.",17.0,"[""If it hasn't been successfully run before, run the @link OnDeployScript."", ""If it hasn't been successfully run before, run the @link OnDeployscript."", ""If it hasn't been successfully run before, you should run the @link OnDeployscript.""]"
900,cdk,org/openscience/cdk/fingerprint/model/Bayesian.java,/tool/model/src/main/java/org/openscience/cdk/fingerprint/model/Bayesian.java,build,223-263,"/**
     * Performs that Bayesian model generation, using the {molecule:activity} pairs that have been submitted up to this
     * point. Once this method has finished, the object can be used to generate predictions, validation data or to
     * serialise for later use.
     */
public void build() throws CDKException{
    trainingSize = training.size();
    trainingActives = numActive;
    contribs.clear();
    final int sz = training.size();
    final double invSz = 1.0 / sz;
    final double P_AT = numActive * invSz;
    for (Integer hash : inHash.keySet()) {
        final int[] AT = inHash.get(hash);
        final int A = AT[0], T = AT[1];
        final double Pcorr = (A + 1) / (T * P_AT + 1);
        final double P = Math.log(Pcorr);
        contribs.put(hash, P);
    }
    lowThresh = Double.POSITIVE_INFINITY;
    highThresh = Double.NEGATIVE_INFINITY;
    for (int[] fp : training) {
        double val = 0;
        for (int hash : fp) val += contribs.get(hash);
        lowThresh = Math.min(lowThresh, val);
        highThresh = Math.max(highThresh, val);
    }
    range = highThresh - lowThresh;
    invRange = range > 0 ? 1 / range : 0;
}","public void build() throws CDKException{
    trainingSize = training.size();
    trainingActives = numActive;
    contribs.clear();
    final int sz = training.size();
    final double invSz = 1.0 / sz;
    final double P_AT = numActive * invSz;
    for (Integer hash : inHash.keySet()) {
        final int[] AT = inHash.get(hash);
        final int A = AT[0], T = AT[1];
        final double Pcorr = (A + 1) / (T * P_AT + 1);
        final double P = Math.log(Pcorr);
        contribs.put(hash, P);
    }
    lowThresh = Double.POSITIVE_INFINITY;
    highThresh = Double.NEGATIVE_INFINITY;
    for (int[] fp : training) {
        double val = 0;
        for (int hash : fp) val += contribs.get(hash);
        lowThresh = Math.min(lowThresh, val);
        highThresh = Math.max(highThresh, val);
    }
    range = highThresh - lowThresh;
    invRange = range > 0 ? 1 / range : 0;
}","/**
     * Performs that Bayesian model generation, using the {molecule:activity} pairs that have been submitted up to this
     * point. Once this method has finished, the object can be used to generate predictions, validation data or to
     * serialise for later use.
     */","('build', {'INSTRUCTION': {'covered': 154, 'missed': 1}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 25, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",217.0,"  Performs that Bayesian model generation, using the {molecule:activity} pairs that have been submitted up to this  point.",23.0,"['The molecule:activity pairs have been submitted up to this point.', 'The molecule:activity pairs that have been submitted up to this point are used to perform that Bayesian model generation.', 'The molecule:activity pairs that have been submitted up to this point are used to perform that model generation.']"
901,tablesaw,tech/tablesaw/analytic/AnalyticQueryEngine.java,/core/src/main/java/tech/tablesaw/analytic/AnalyticQueryEngine.java,processNumberingFunctions,74-112,"/**
   * Execute all numbering functions for the given slice setting values in the appropriate
   * destination column.
   */
private void processNumberingFunctions(TableSlice slice){
    for (String toColumn : query.getArgumentList().getNumberingFunctions().keySet()) {
        if (rowComparator == null) {
            throw new IllegalArgumentException(""Cannot use Numbering Function without OrderBy"");
        }
        FunctionCall<NumberingFunctions> functionCall = query.getArgumentList().getNumberingFunctions().get(toColumn);
        NumberingFunctions numberingFunctions = functionCall.getFunction();
        NumberingFunction function = numberingFunctions.getImplementation();
        Column<Integer> destinationColumn = (Column<Integer>) destination.column(functionCall.getDestinationColumnName());
        int prevRowNumber = -1;
        for (Row row : slice) {
            if (row.getRowNumber() == 0) {
                function.addNextRow();
            } else {
                if (rowComparator.compare(slice.mappedRowNumber(prevRowNumber), slice.mappedRowNumber(row.getRowNumber())) == 0) {
                    function.addEqualRow();
                } else {
                    function.addNextRow();
                }
            }
            prevRowNumber = row.getRowNumber();
            destinationColumn.set(slice.mappedRowNumber(row.getRowNumber()), function.getValue());
        }
    }
}","private void processNumberingFunctions(TableSlice slice){
    for (String toColumn : query.getArgumentList().getNumberingFunctions().keySet()) {
        if (rowComparator == null) {
            throw new IllegalArgumentException(""Cannot use Numbering Function without OrderBy"");
        }
        FunctionCall<NumberingFunctions> functionCall = query.getArgumentList().getNumberingFunctions().get(toColumn);
        NumberingFunctions numberingFunctions = functionCall.getFunction();
        NumberingFunction function = numberingFunctions.getImplementation();
        Column<Integer> destinationColumn = (Column<Integer>) destination.column(functionCall.getDestinationColumnName());
        int prevRowNumber = -1;
        for (Row row : slice) {
            if (row.getRowNumber() == 0) {
                function.addNextRow();
            } else {
                if (rowComparator.compare(slice.mappedRowNumber(prevRowNumber), slice.mappedRowNumber(row.getRowNumber())) == 0) {
                    function.addEqualRow();
                } else {
                    function.addNextRow();
                }
            }
            prevRowNumber = row.getRowNumber();
            destinationColumn.set(slice.mappedRowNumber(row.getRowNumber()), function.getValue());
        }
    }
}","/**
   * Execute all numbering functions for the given slice setting values in the appropriate
   * destination column.
   */","('processNumberingFunctions', {'INSTRUCTION': {'covered': 88, 'missed': 5}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 21, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",217.0,  Execute all numbering functions for the given slice setting values in the appropriate  destination column.,16.0,"['All numbering functions for the slice setting values should be executed.', 'The numbering functions for the slice setting values should be executed.', 'Numbering functions for the slice setting values should be executed.']"
902,jooby,io/jooby/openapi/OpenAPIGenerator.java,/modules/jooby-openapi/src/main/java/io/jooby/openapi/OpenAPIGenerator.java,export,132-163,"/**
   * Export an {@link OpenAPI} model to the given format.
   *
   * @param openAPI Model.
   * @param format Format.
   * @throws IOException
   * @return Output file.
   */
public Path export(@Nonnull OpenAPI openAPI, @Nonnull Format format) throws IOException{
    Path output;
    if (openAPI instanceof OpenAPIExt) {
        String source = ((OpenAPIExt) openAPI).getSource();
        String[] names = source.split(""\\."");
        output = Stream.of(names).limit(names.length - 1).reduce(outputDir, Path::resolve, Path::resolve);
        String appname = names[names.length - 1];
        if (appname.endsWith(""Kt"")) {
            appname = appname.substring(0, appname.length() - 2);
        }
        output = output.resolve(appname + ""."" + format.extension());
    } else {
        output = outputDir.resolve(""openapi."" + format.extension());
    }
    if (!Files.exists(output.getParent())) {
        Files.createDirectories(output.getParent());
    }
    String content = format.toString(this, openAPI);
    Files.write(output, Collections.singleton(content));
    return output;
}","public Path export(@Nonnull OpenAPI openAPI, @Nonnull Format format) throws IOException{
    Path output;
    if (openAPI instanceof OpenAPIExt) {
        String source = ((OpenAPIExt) openAPI).getSource();
        String[] names = source.split(""\\."");
        output = Stream.of(names).limit(names.length - 1).reduce(outputDir, Path::resolve, Path::resolve);
        String appname = names[names.length - 1];
        if (appname.endsWith(""Kt"")) {
            appname = appname.substring(0, appname.length() - 2);
        }
        output = output.resolve(appname + ""."" + format.extension());
    } else {
        output = outputDir.resolve(""openapi."" + format.extension());
    }
    if (!Files.exists(output.getParent())) {
        Files.createDirectories(output.getParent());
    }
    String content = format.toString(this, openAPI);
    Files.write(output, Collections.singleton(content));
    return output;
}","/**
   * Export an {@link OpenAPI} model to the given format.
   *
   * @param openAPI Model.
   * @param format Format.
   * @throws IOException
   * @return Output file.
   */","('export', {'INSTRUCTION': {'covered': 78, 'missed': 21}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 14, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",217.0,  Export an {@link OpenAPI} model to the given format.,13.0,"['The model should be exported to the given format.', 'The model should be exported to the format given.', 'You can export an @link OpenAPI model.']"
903,cdk,org/openscience/cdk/layout/TemplateHandler.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/TemplateHandler.java,mapTemplates,209-241,"/**
     * Checks if one of the loaded templates is a substructure in the given
     * Molecule. If so, it assigns the coordinates from the template to the
     * respective atoms in the Molecule, and marks the atoms as ISPLACED.
     *
     * @param molecule The molecule to be check for potential templates
     * @return True if there was a possible mapping
     */
public boolean mapTemplates(IAtomContainer molecule) throws CDKException{
    for (Pattern anonPattern : elemPatterns) {
        for (Map<IAtom, IAtom> atoms : anonPattern.matchAll(molecule).toAtomMap()) {
            for (Map.Entry<IAtom, IAtom> e : atoms.entrySet()) {
                e.getValue().setPoint2d(new Point2d(e.getKey().getPoint2d()));
                e.getValue().setFlag(CDKConstants.ISPLACED, true);
            }
            if (!atoms.isEmpty())
                return true;
        }
    }
    for (Pattern anonPattern : anonPatterns) {
        for (Map<IAtom, IAtom> atoms : anonPattern.matchAll(molecule).toAtomMap()) {
            for (Map.Entry<IAtom, IAtom> e : atoms.entrySet()) {
                e.getValue().setPoint2d(new Point2d(e.getKey().getPoint2d()));
                e.getValue().setFlag(CDKConstants.ISPLACED, true);
            }
            if (!atoms.isEmpty())
                return true;
        }
    }
    return false;
}","public boolean mapTemplates(IAtomContainer molecule) throws CDKException{
    for (Pattern anonPattern : elemPatterns) {
        for (Map<IAtom, IAtom> atoms : anonPattern.matchAll(molecule).toAtomMap()) {
            for (Map.Entry<IAtom, IAtom> e : atoms.entrySet()) {
                e.getValue().setPoint2d(new Point2d(e.getKey().getPoint2d()));
                e.getValue().setFlag(CDKConstants.ISPLACED, true);
            }
            if (!atoms.isEmpty())
                return true;
        }
    }
    for (Pattern anonPattern : anonPatterns) {
        for (Map<IAtom, IAtom> atoms : anonPattern.matchAll(molecule).toAtomMap()) {
            for (Map.Entry<IAtom, IAtom> e : atoms.entrySet()) {
                e.getValue().setPoint2d(new Point2d(e.getKey().getPoint2d()));
                e.getValue().setFlag(CDKConstants.ISPLACED, true);
            }
            if (!atoms.isEmpty())
                return true;
        }
    }
    return false;
}","/**
     * Checks if one of the loaded templates is a substructure in the given
     * Molecule. If so, it assigns the coordinates from the template to the
     * respective atoms in the Molecule, and marks the atoms as ISPLACED.
     *
     * @param molecule The molecule to be check for potential templates
     * @return True if there was a possible mapping
     */","('mapTemplates', {'INSTRUCTION': {'covered': 120, 'missed': 2}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 19, 'missed': 2}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",218.0,  Checks if one of the loaded templates is a substructure in the given  Molecule.,15.0,"['If one of the loaded templates is a substructure, the Molecule will be checked.', 'If one of the loaded templates is a substructure in the Molecule, the check is done.', ""If one of the loaded templates is a substructure in the Molecule, it's checked.""]"
904,cdk,org/openscience/cdk/io/Gaussian98Reader.java,/storage/io/src/main/java/org/openscience/cdk/io/Gaussian98Reader.java,readPartialCharges,332-371,"/**
     * Reads partial atomic charges and add the to the given ChemModel.
     *
     * @param model Description of the Parameter
     * @throws CDKException Description of the Exception
     * @throws IOException  Description of the Exception
     */
private void readPartialCharges(IChemModel model) throws CDKException, IOException{
    logger.info(""Reading partial atomic charges"");
    IAtomContainerSet moleculeSet = model.getMoleculeSet();
    IAtomContainer molecule = moleculeSet.getAtomContainer(0);
    String line = input.readLine();
    while (input.ready()) {
        line = input.readLine();
        logger.debug(""Read charge block line: "" + line);
        if ((line == null) || (line.indexOf(""Sum of Mulliken charges"") >= 0)) {
            logger.debug(""End of charge block found"");
            break;
        }
        StringReader sr = new StringReader(line);
        StreamTokenizer tokenizer = new StreamTokenizer(sr);
        if (tokenizer.nextToken() == StreamTokenizer.TT_NUMBER) {
            int atomCounter = (int) tokenizer.nval;
            tokenizer.nextToken();
            double charge;
            if (tokenizer.nextToken() == StreamTokenizer.TT_NUMBER) {
                charge = tokenizer.nval;
                logger.debug(""Found charge for atom "" + atomCounter + "": "" + charge);
            } else {
                throw new CDKException(""Error while reading charge: expected double."");
            }
            IAtom atom = molecule.getAtom(atomCounter - 1);
            atom.setCharge(charge);
        }
    }
}","private void readPartialCharges(IChemModel model) throws CDKException, IOException{
    logger.info(""Reading partial atomic charges"");
    IAtomContainerSet moleculeSet = model.getMoleculeSet();
    IAtomContainer molecule = moleculeSet.getAtomContainer(0);
    String line = input.readLine();
    while (input.ready()) {
        line = input.readLine();
        logger.debug(""Read charge block line: "" + line);
        if ((line == null) || (line.indexOf(""Sum of Mulliken charges"") >= 0)) {
            logger.debug(""End of charge block found"");
            break;
        }
        StringReader sr = new StringReader(line);
        StreamTokenizer tokenizer = new StreamTokenizer(sr);
        if (tokenizer.nextToken() == StreamTokenizer.TT_NUMBER) {
            int atomCounter = (int) tokenizer.nval;
            tokenizer.nextToken();
            double charge;
            if (tokenizer.nextToken() == StreamTokenizer.TT_NUMBER) {
                charge = tokenizer.nval;
                logger.debug(""Found charge for atom "" + atomCounter + "": "" + charge);
            } else {
                throw new CDKException(""Error while reading charge: expected double."");
            }
            IAtom atom = molecule.getAtom(atomCounter - 1);
            atom.setCharge(charge);
        }
    }
}","/**
     * Reads partial atomic charges and add the to the given ChemModel.
     *
     * @param model Description of the Parameter
     * @throws CDKException Description of the Exception
     * @throws IOException  Description of the Exception
     */","('readPartialCharges', {'INSTRUCTION': {'covered': 97, 'missed': 5}, 'BRANCH': {'covered': 6, 'missed': 4}, 'LINE': {'covered': 22, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",218.0,  Reads partial atomic charges and add the to the given ChemModel.,12.0,"['Add partial atomic charges to the ChemModel.', 'Add partial atomic charges to the ChemModel by reading them.', 'Add partial atomic charges to the ChemModel by reading it.']"
905,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineCommonHandler.java,upsertExternalRelationship,221-267,"/**
     * Create or updates an external relationship between two entities. Verifies that the relationship is not present before creating it. If the
     * relationship is present, verifies the instanceProperties for the relationship to be updated.
     *
     * @param userId                 the name of the calling user
     * @param firstGUID              the unique identifier of the entity at first end
     * @param secondGUID             the unique identifier of the entity at second end
     * @param relationshipTypeName   type name for the relationship to create
     * @param firstEntityTypeName    type name for the entity at first end
     * @param externalSourceName     the unique name of the external source
     * @param relationshipProperties the properties for the relationship
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */
protected void upsertExternalRelationship(String userId, String firstGUID, String secondGUID, String relationshipTypeName, String firstEntityTypeName, String externalSourceName, InstanceProperties relationshipProperties) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    final String methodName = ""upsertExternalRelationship"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateGUID(firstGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    invalidParameterHandler.validateGUID(secondGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    String externalSourceGUID = dataEngineRegistrationHandler.getExternalDataEngine(userId, externalSourceName);
    Optional<Relationship> relationship = findRelationship(userId, firstGUID, secondGUID, firstEntityTypeName, relationshipTypeName);
    if (relationship.isEmpty()) {
        TypeDef relationshipTypeDef = repositoryHelper.getTypeDefByName(userId, relationshipTypeName);
        repositoryHandler.createExternalRelationship(userId, relationshipTypeDef.getGUID(), externalSourceGUID, externalSourceName, firstGUID, secondGUID, relationshipProperties, methodName);
    } else {
        Relationship originalRelationship = relationship.get();
        RelationshipDifferences relationshipDifferences = repositoryHelper.getRelationshipDifferences(originalRelationship, buildRelationship(originalRelationship.getGUID(), relationshipProperties), true);
        if (relationshipDifferences.hasInstancePropertiesDifferences()) {
            repositoryHandler.updateRelationshipProperties(userId, externalSourceGUID, externalSourceName, originalRelationship.getGUID(), relationshipProperties, methodName);
        }
    }
}","protected void upsertExternalRelationship(String userId, String firstGUID, String secondGUID, String relationshipTypeName, String firstEntityTypeName, String externalSourceName, InstanceProperties relationshipProperties) throws InvalidParameterException, UserNotAuthorizedException, PropertyServerException{
    final String methodName = ""upsertExternalRelationship"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateGUID(firstGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    invalidParameterHandler.validateGUID(secondGUID, CommonMapper.GUID_PROPERTY_NAME, methodName);
    String externalSourceGUID = dataEngineRegistrationHandler.getExternalDataEngine(userId, externalSourceName);
    Optional<Relationship> relationship = findRelationship(userId, firstGUID, secondGUID, firstEntityTypeName, relationshipTypeName);
    if (relationship.isEmpty()) {
        TypeDef relationshipTypeDef = repositoryHelper.getTypeDefByName(userId, relationshipTypeName);
        repositoryHandler.createExternalRelationship(userId, relationshipTypeDef.getGUID(), externalSourceGUID, externalSourceName, firstGUID, secondGUID, relationshipProperties, methodName);
    } else {
        Relationship originalRelationship = relationship.get();
        RelationshipDifferences relationshipDifferences = repositoryHelper.getRelationshipDifferences(originalRelationship, buildRelationship(originalRelationship.getGUID(), relationshipProperties), true);
        if (relationshipDifferences.hasInstancePropertiesDifferences()) {
            repositoryHandler.updateRelationshipProperties(userId, externalSourceGUID, externalSourceName, originalRelationship.getGUID(), relationshipProperties, methodName);
        }
    }
}","/**
     * Create or updates an external relationship between two entities. Verifies that the relationship is not present before creating it. If the
     * relationship is present, verifies the instanceProperties for the relationship to be updated.
     *
     * @param userId                 the name of the calling user
     * @param firstGUID              the unique identifier of the entity at first end
     * @param secondGUID             the unique identifier of the entity at second end
     * @param relationshipTypeName   type name for the relationship to create
     * @param firstEntityTypeName    type name for the entity at first end
     * @param externalSourceName     the unique name of the external source
     * @param relationshipProperties the properties for the relationship
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */","('upsertExternalRelationship', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",218.0,  Create or updates an external relationship between two entities.,10.0,"['An external relationship between two entities can be created or updated.', 'An external relationship between two entities can be created.', 'An external relationship between two entities is created or updated.']"
906,cdk,org/openscience/cdk/qsar/descriptors/atomic/IPAtomicHOSEDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/IPAtomicHOSEDescriptor.java,calculate,119-160,"/**
     *  This method calculates the ionization potential of an atom.
     *
     *@param  atom          The IAtom to ionize.
     *@param  container         Parameter is the IAtomContainer.
     *@return                   The ionization potential. Not possible the ionization.
     */
public DescriptorValue calculate(IAtom atom, IAtomContainer container){
    double value;
    String originalAtomtypeName = atom.getAtomTypeName();
    Integer originalNeighborCount = atom.getFormalNeighbourCount();
    Integer originalValency = atom.getValency();
    Double originalBondOrderSum = atom.getBondOrderSum();
    Order originalMaxBondOrder = atom.getMaxBondOrder();
    IAtomType.Hybridization originalHybridization = atom.getHybridization();
    if (!isCachedAtomContainer(container)) {
        try {
            AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(container);
            LonePairElectronChecker lpcheck = new LonePairElectronChecker();
            lpcheck.saturate(container);
        } catch (CDKException e) {
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(Double.NaN), NAMES, e);
        }
    }
    value = db.extractIP(container, atom);
    atom.setAtomTypeName(originalAtomtypeName);
    atom.setFormalNeighbourCount(originalNeighborCount);
    atom.setValency(originalValency);
    atom.setHybridization(originalHybridization);
    atom.setMaxBondOrder(originalMaxBondOrder);
    atom.setBondOrderSum(originalBondOrderSum);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(value), NAMES);
}","public DescriptorValue calculate(IAtom atom, IAtomContainer container){
    double value;
    String originalAtomtypeName = atom.getAtomTypeName();
    Integer originalNeighborCount = atom.getFormalNeighbourCount();
    Integer originalValency = atom.getValency();
    Double originalBondOrderSum = atom.getBondOrderSum();
    Order originalMaxBondOrder = atom.getMaxBondOrder();
    IAtomType.Hybridization originalHybridization = atom.getHybridization();
    if (!isCachedAtomContainer(container)) {
        try {
            AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(container);
            LonePairElectronChecker lpcheck = new LonePairElectronChecker();
            lpcheck.saturate(container);
        } catch (CDKException e) {
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(Double.NaN), NAMES, e);
        }
    }
    value = db.extractIP(container, atom);
    atom.setAtomTypeName(originalAtomtypeName);
    atom.setFormalNeighbourCount(originalNeighborCount);
    atom.setValency(originalValency);
    atom.setHybridization(originalHybridization);
    atom.setMaxBondOrder(originalMaxBondOrder);
    atom.setBondOrderSum(originalBondOrderSum);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(value), NAMES);
}","/**
     *  This method calculates the ionization potential of an atom.
     *
     *@param  atom          The IAtom to ionize.
     *@param  container         Parameter is the IAtomContainer.
     *@return                   The ionization potential. Not possible the ionization.
     */","('calculate', {'INSTRUCTION': {'covered': 71, 'missed': 17}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 19, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",220.0,  This method calculates the ionization potential of an atom.,10.0,"['The method calculates the potential of an atom.', 'The method calculates the potential of the atom.', 'The method is used to calculate the potential of an atom.']"
907,matsim-libs,org/matsim/contrib/minibus/genericUtils/TerminusStopFinder.java,/contribs/minibus/src/main/java/org/matsim/contrib/minibus/genericUtils/TerminusStopFinder.java,findSecondTerminusStop,31-75,"/**
	 * Find the 2nd terminus stop (1st terminus is at index 0 per definition).
	 * 
	 * Returns stop index instead of the stop, in order to cater for stops which are
	 * served multiple times
	 * 
	 * @param stops
	 * @return index of the stop which is half way on the route from start stop over
	 *         all stops back to the start stop
	 *         
	 * @author gleich
	 * 
	 */
public static final int findSecondTerminusStop(ArrayList<TransitStopFacility> stops){
    double totalDistance = 0;
    Map<Integer, Double> distFromStart2StopIndex = new HashMap<>();
    TransitStopFacility previousStop = stops.get(0);
    for (int i = 0; i < stops.size(); i++) {
        TransitStopFacility currentStop = stops.get(i);
        totalDistance = totalDistance + CoordUtils.calcEuclideanDistance(previousStop.getCoord(), currentStop.getCoord());
        distFromStart2StopIndex.put(i, totalDistance);
        previousStop = currentStop;
    }
    // add leg from last to first stop
    totalDistance = totalDistance + CoordUtils.calcEuclideanDistance(previousStop.getCoord(), stops.get(0).getCoord());
    // first terminus is first stop in stops, other terminus is stop half way on the
    // circular route beginning at the first stop
    for (int i = 1; i < stops.size(); i++) {
        if (distFromStart2StopIndex.get(i) >= totalDistance / 2) {
            if (Math.abs(totalDistance / 2 - distFromStart2StopIndex.get(i - 1)) > Math.abs(totalDistance / 2 - distFromStart2StopIndex.get(i))) {
                // -> if both Math.abs() are equal the previous stop (i-1) is returned
                return i;
            } else {
                return i - 1;
            }
        }
    }
    return 0;
}","public static final int findSecondTerminusStop(ArrayList<TransitStopFacility> stops){
    double totalDistance = 0;
    Map<Integer, Double> distFromStart2StopIndex = new HashMap<>();
    TransitStopFacility previousStop = stops.get(0);
    for (int i = 0; i < stops.size(); i++) {
        TransitStopFacility currentStop = stops.get(i);
        totalDistance = totalDistance + CoordUtils.calcEuclideanDistance(previousStop.getCoord(), currentStop.getCoord());
        distFromStart2StopIndex.put(i, totalDistance);
        previousStop = currentStop;
    }
    // add leg from last to first stop
    totalDistance = totalDistance + CoordUtils.calcEuclideanDistance(previousStop.getCoord(), stops.get(0).getCoord());
    // first terminus is first stop in stops, other terminus is stop half way on the
    // circular route beginning at the first stop
    for (int i = 1; i < stops.size(); i++) {
        if (distFromStart2StopIndex.get(i) >= totalDistance / 2) {
            if (Math.abs(totalDistance / 2 - distFromStart2StopIndex.get(i - 1)) > Math.abs(totalDistance / 2 - distFromStart2StopIndex.get(i))) {
                // -> if both Math.abs() are equal the previous stop (i-1) is returned
                return i;
            } else {
                return i - 1;
            }
        }
    }
    return 0;
}","/**
	 * Find the 2nd terminus stop (1st terminus is at index 0 per definition).
	 * 
	 * Returns stop index instead of the stop, in order to cater for stops which are
	 * served multiple times
	 * 
	 * @param stops
	 * @return index of the stop which is half way on the route from start stop over
	 *         all stops back to the start stop
	 *         
	 * @author gleich
	 * 
	 */","('findSecondTerminusStop', {'INSTRUCTION': {'covered': 103, 'missed': 2}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",221.0,Find the 2nd terminus stop (1st terminus is at index 0 per definition).,16.0,"['The 2nd stop is at index 0 per definition.', 'The second stop is at index 0 per definition.', 'The 2nd stop is at an index.']"
908,cdk,org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricTetrahedralEncoderFactory.java,create,54-113,"/**
     * Create a stereo encoder for all potential 2D and 3D tetrahedral
     * elements.
     *
     * @param container an atom container
     * @param graph     adjacency list representation of the container
     * @return a new encoder for tetrahedral elements
     */
public StereoEncoder create(IAtomContainer container, int[][] graph){
    // XXX: this code isn't pretty, the current IAtomContainer
    // implementations are  slow for the queries (i.e. looking at connected
    // atoms/bonds) we need to ask to decide if something is a potential
    // tetrahedral centre. We can help out a little with the adjacency list
    // (int[][]) but this doesn't help with the bonds.
    int n = container.getAtomCount();
    List<StereoEncoder> encoders = new ArrayList<StereoEncoder>();
    Map<IAtom, Integer> elevation = new HashMap<IAtom, Integer>(10);
    ATOMS: for (int i = 0; i < n; i++) {
        int degree = graph[i].length;
        // ignore those which don't have 3 or 4 neighbors
        if (degree < 3 || degree > 4)
            continue;
        IAtom atom = container.getAtom(i);
        // only create encoders for SP3 hybridized atom. atom typing is
        // currently wrong for some atoms, in sulfoxide for example the atom
        // type sets SP2... but there we don't to fuss about with that here
        if (!sp3(atom))
            continue;
        // avoid nitrogen-inversion
        if (Integer.valueOf(7).equals(atom.getAtomicNumber()) && degree == 3)
            continue;
        // TODO: we could be more strict with our selection, InChI uses C,
        // Si, Ge, P, As, B, Sn, N, P, S, Se but has preconditions for
        // certain cases. An atom or ion N, P, As, S or Se is not stereogenic
        // if it has a terminal H or two terminal neighbors -XHm, -XHn (n+m>0)
        // where X is O, S, Se, Te, or N
        // XXX: likely bottle neck
        List<IBond> bonds = container.getConnectedBondsList(atom);
        // try to create geometric parity
        GeometricParity geometric = geometric(elevation, bonds, i, graph[i], container);
        if (geometric != null) {
            // add a new encoder if a geometric parity
            encoders.add(new GeometryEncoder(i, new BasicPermutationParity(graph[i]), geometric));
        }
    }
    // no encoders, replace with the empty encoder
    return encoders.isEmpty() ? StereoEncoder.EMPTY : new MultiStereoEncoder(encoders);
}","public StereoEncoder create(IAtomContainer container, int[][] graph){
    // XXX: this code isn't pretty, the current IAtomContainer
    // implementations are  slow for the queries (i.e. looking at connected
    // atoms/bonds) we need to ask to decide if something is a potential
    // tetrahedral centre. We can help out a little with the adjacency list
    // (int[][]) but this doesn't help with the bonds.
    int n = container.getAtomCount();
    List<StereoEncoder> encoders = new ArrayList<StereoEncoder>();
    Map<IAtom, Integer> elevation = new HashMap<IAtom, Integer>(10);
    ATOMS: for (int i = 0; i < n; i++) {
        int degree = graph[i].length;
        // ignore those which don't have 3 or 4 neighbors
        if (degree < 3 || degree > 4)
            continue;
        IAtom atom = container.getAtom(i);
        // only create encoders for SP3 hybridized atom. atom typing is
        // currently wrong for some atoms, in sulfoxide for example the atom
        // type sets SP2... but there we don't to fuss about with that here
        if (!sp3(atom))
            continue;
        // avoid nitrogen-inversion
        if (Integer.valueOf(7).equals(atom.getAtomicNumber()) && degree == 3)
            continue;
        // TODO: we could be more strict with our selection, InChI uses C,
        // Si, Ge, P, As, B, Sn, N, P, S, Se but has preconditions for
        // certain cases. An atom or ion N, P, As, S or Se is not stereogenic
        // if it has a terminal H or two terminal neighbors -XHm, -XHn (n+m>0)
        // where X is O, S, Se, Te, or N
        // XXX: likely bottle neck
        List<IBond> bonds = container.getConnectedBondsList(atom);
        // try to create geometric parity
        GeometricParity geometric = geometric(elevation, bonds, i, graph[i], container);
        if (geometric != null) {
            // add a new encoder if a geometric parity
            encoders.add(new GeometryEncoder(i, new BasicPermutationParity(graph[i]), geometric));
        }
    }
    // no encoders, replace with the empty encoder
    return encoders.isEmpty() ? StereoEncoder.EMPTY : new MultiStereoEncoder(encoders);
}","/**
     * Create a stereo encoder for all potential 2D and 3D tetrahedral
     * elements.
     *
     * @param container an atom container
     * @param graph     adjacency list representation of the container
     * @return a new encoder for tetrahedral elements
     */","('create', {'INSTRUCTION': {'covered': 83, 'missed': 5}, 'BRANCH': {'covered': 12, 'missed': 4}, 'LINE': {'covered': 14, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",221.0,Create a stereo encoder for all potential 2D and 3D tetrahedral  elements.,13.0,"['All potential 2D and 3D elements can be created with a stereo Encoder.', 'All potential 2D and 3D elements can be created with a stereo encoder.', 'All potential 2D and 3D elements can be created by creating a stereo Encoder.']"
910,acs-aem-commons,com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,/bundle/src/main/java/com/adobe/acs/commons/oak/impl/EnsureOakIndexJobHandler.java,needsUpdate,487-522,"/**
     * Determines if the ensure definition is the same as the the same-named oak:index definition.
     *
     * @param ensureDefinition the ensure index definition
     * @param oakIndex         the oak index definition
     * @return true if the ensure definition and the oak index definition are different
     * @throws IOException
     * @throws RepositoryException
     */
 boolean needsUpdate(@Nonnull Resource ensureDefinition, @Nonnull Resource oakIndex) throws IOException, RepositoryException{
    final Session session = ensureDefinition.getResourceResolver().adaptTo(Session.class);
    final ChecksumGenerator checksumGenerator = this.ensureOakIndex.getChecksumGenerator();
    final CustomChecksumGeneratorOptions ensureDefinitionOptions = new CustomChecksumGeneratorOptions();
    ensureDefinitionOptions.addIncludedNodeTypes(new String[] { NT_OAK_UNSTRUCTURED });
    ensureDefinitionOptions.addExcludedProperties(this.ignoreProperties);
    ensureDefinitionOptions.addExcludedSubTrees(this.excludeSubTrees);
    ensureDefinitionOptions.addExcludedNodeNames(this.excludeNodeNames);
    final Map<String, String> srcChecksum = checksumGenerator.generateChecksums(session, ensureDefinition.getPath(), ensureDefinitionOptions);
    final CustomChecksumGeneratorOptions oakIndexOptions = new CustomChecksumGeneratorOptions();
    oakIndexOptions.addIncludedNodeTypes(new String[] { NT_OAK_QUERY_INDEX_DEFINITION });
    oakIndexOptions.addExcludedProperties(this.ignoreProperties);
    oakIndexOptions.addExcludedSubTrees(this.excludeSubTrees);
    oakIndexOptions.addExcludedNodeNames(this.excludeNodeNames);
    final Map<String, String> destChecksum = checksumGenerator.generateChecksums(session, oakIndex.getPath(), oakIndexOptions);
    return !StringUtils.equals(srcChecksum.get(ensureDefinition.getPath()), destChecksum.get(oakIndex.getPath()));
}"," boolean needsUpdate(@Nonnull Resource ensureDefinition, @Nonnull Resource oakIndex) throws IOException, RepositoryException{
    final Session session = ensureDefinition.getResourceResolver().adaptTo(Session.class);
    final ChecksumGenerator checksumGenerator = this.ensureOakIndex.getChecksumGenerator();
    final CustomChecksumGeneratorOptions ensureDefinitionOptions = new CustomChecksumGeneratorOptions();
    ensureDefinitionOptions.addIncludedNodeTypes(new String[] { NT_OAK_UNSTRUCTURED });
    ensureDefinitionOptions.addExcludedProperties(this.ignoreProperties);
    ensureDefinitionOptions.addExcludedSubTrees(this.excludeSubTrees);
    ensureDefinitionOptions.addExcludedNodeNames(this.excludeNodeNames);
    final Map<String, String> srcChecksum = checksumGenerator.generateChecksums(session, ensureDefinition.getPath(), ensureDefinitionOptions);
    final CustomChecksumGeneratorOptions oakIndexOptions = new CustomChecksumGeneratorOptions();
    oakIndexOptions.addIncludedNodeTypes(new String[] { NT_OAK_QUERY_INDEX_DEFINITION });
    oakIndexOptions.addExcludedProperties(this.ignoreProperties);
    oakIndexOptions.addExcludedSubTrees(this.excludeSubTrees);
    oakIndexOptions.addExcludedNodeNames(this.excludeNodeNames);
    final Map<String, String> destChecksum = checksumGenerator.generateChecksums(session, oakIndex.getPath(), oakIndexOptions);
    return !StringUtils.equals(srcChecksum.get(ensureDefinition.getPath()), destChecksum.get(oakIndex.getPath()));
}","/**
     * Determines if the ensure definition is the same as the the same-named oak:index definition.
     *
     * @param ensureDefinition the ensure index definition
     * @param oakIndex         the oak index definition
     * @return true if the ensure definition and the oak index definition are different
     * @throws IOException
     * @throws RepositoryException
     */","('needsUpdate', {'INSTRUCTION': {'covered': 88, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",223.0,  Determines if the ensure definition is the same as the the same-named oak:index definition.,17.0,"['The ensure definition is the same as the oak: index definition.', ""If the ensure definition is the same as the oak: index definition, it's determined."", ""If the ensure definition is the same as the oak: index definition, then it's a problem.""]"
911,egeria,org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaTypeHandler.java,/open-metadata-implementation/access-services/data-engine/data-engine-server/src/main/java/org/odpi/openmetadata/accessservices/dataengine/server/handlers/DataEngineSchemaTypeHandler.java,upsertSchemaType,79-127,"/**
     * Create the schema type entity, with the corresponding schema attributes and relationships if it doesn't exist or
     * updates the existing one.
     *
     * @param userId             the name of the calling user
     * @param schemaType         the schema type values
     * @param externalSourceName the unique name of the external source
     *
     * @return unique identifier of the schema type in the repository
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */
public String upsertSchemaType(String userId, SchemaType schemaType, String externalSourceName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
    final String methodName = ""upsertSchemaType"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateName(schemaType.getQualifiedName(), QUALIFIED_NAME_PROPERTY_NAME, methodName);
    invalidParameterHandler.validateName(schemaType.getDisplayName(), DISPLAY_NAME_PROPERTY_NAME, methodName);
    Optional<EntityDetail> originalSchemaTypeEntity = findSchemaTypeEntity(userId, schemaType.getQualifiedName());
    SchemaTypeBuilder schemaTypeBuilder = getSchemaTypeBuilder(schemaType);
    String externalSourceGUID = dataEngineRegistrationHandler.getExternalDataEngine(userId, externalSourceName);
    String schemaTypeGUID;
    if (originalSchemaTypeEntity.isEmpty()) {
        schemaTypeGUID = schemaTypeHandler.addSchemaType(userId, externalSourceGUID, externalSourceName, schemaTypeBuilder, methodName);
    } else {
        schemaTypeGUID = originalSchemaTypeEntity.get().getGUID();
        EntityDetail updatedSchemaTypeEntity = buildSchemaTypeEntityDetail(schemaTypeGUID, schemaType);
        EntityDetailDifferences entityDetailDifferences = repositoryHelper.getEntityDetailDifferences(originalSchemaTypeEntity.get(), updatedSchemaTypeEntity, true);
        if (entityDetailDifferences.hasInstancePropertiesDifferences()) {
            schemaTypeHandler.updateSchemaType(userId, externalSourceGUID, externalSourceName, schemaTypeGUID, SCHEMA_TYPE_GUID_PARAMETER_NAME, schemaTypeBuilder);
        }
    }
    dataEngineSchemaAttributeHandler.upsertSchemaAttributes(userId, schemaType.getAttributeList(), externalSourceName, externalSourceGUID, schemaTypeGUID);
    return schemaTypeGUID;
}","public String upsertSchemaType(String userId, SchemaType schemaType, String externalSourceName) throws InvalidParameterException, PropertyServerException, UserNotAuthorizedException{
    final String methodName = ""upsertSchemaType"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateName(schemaType.getQualifiedName(), QUALIFIED_NAME_PROPERTY_NAME, methodName);
    invalidParameterHandler.validateName(schemaType.getDisplayName(), DISPLAY_NAME_PROPERTY_NAME, methodName);
    Optional<EntityDetail> originalSchemaTypeEntity = findSchemaTypeEntity(userId, schemaType.getQualifiedName());
    SchemaTypeBuilder schemaTypeBuilder = getSchemaTypeBuilder(schemaType);
    String externalSourceGUID = dataEngineRegistrationHandler.getExternalDataEngine(userId, externalSourceName);
    String schemaTypeGUID;
    if (originalSchemaTypeEntity.isEmpty()) {
        schemaTypeGUID = schemaTypeHandler.addSchemaType(userId, externalSourceGUID, externalSourceName, schemaTypeBuilder, methodName);
    } else {
        schemaTypeGUID = originalSchemaTypeEntity.get().getGUID();
        EntityDetail updatedSchemaTypeEntity = buildSchemaTypeEntityDetail(schemaTypeGUID, schemaType);
        EntityDetailDifferences entityDetailDifferences = repositoryHelper.getEntityDetailDifferences(originalSchemaTypeEntity.get(), updatedSchemaTypeEntity, true);
        if (entityDetailDifferences.hasInstancePropertiesDifferences()) {
            schemaTypeHandler.updateSchemaType(userId, externalSourceGUID, externalSourceName, schemaTypeGUID, SCHEMA_TYPE_GUID_PARAMETER_NAME, schemaTypeBuilder);
        }
    }
    dataEngineSchemaAttributeHandler.upsertSchemaAttributes(userId, schemaType.getAttributeList(), externalSourceName, externalSourceGUID, schemaTypeGUID);
    return schemaTypeGUID;
}","/**
     * Create the schema type entity, with the corresponding schema attributes and relationships if it doesn't exist or
     * updates the existing one.
     *
     * @param userId             the name of the calling user
     * @param schemaType         the schema type values
     * @param externalSourceName the unique name of the external source
     *
     * @return unique identifier of the schema type in the repository
     *
     * @throws InvalidParameterException  the bean properties are invalid
     * @throws UserNotAuthorizedException user not authorized to issue this request
     * @throws PropertyServerException    problem accessing the property server
     */","('upsertSchemaType', {'INSTRUCTION': {'covered': 92, 'missed': 0}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",225.0,"  Create the schema type entity, with the corresponding schema attributes and relationships if it doesn't exist or  updates the existing one.",24.0,"[""If the existing entity doesn't exist or is not updated, create a new entity with the corresponding attributes and relationships."", ""If the existing entity doesn't exist or is not updated, create a new entity with the same attributes and relationships."", ""If the existing entity doesn't exist or is not updated, you can create a new entity with the corresponding attributes and relationships.""]"
912,jooby,io/jooby/Cookie.java,/jooby/src/main/java/io/jooby/Cookie.java,decode,510-548,"/**
   * Decode a cookie value using, like: <code>k=v</code>, multiple <code>k=v</code> pair are
   * separated by <code>&amp;</code>. Also, <code>k</code> and <code>v</code> are decoded using
   * {@link URLDecoder}.
   *
   * @param value URL encoded value.
   * @return Decoded as map.
   */
public static Map<String, String> decode(@Nullable String value){
    if (value == null || value.length() == 0) {
        return Collections.emptyMap();
    }
    try {
        Map<String, String> attributes = new HashMap<>();
        String enc = StandardCharsets.UTF_8.name();
        int start = 0;
        int len = value.length();
        do {
            int end = value.indexOf('&', start + 1);
            if (end < 0) {
                end = len;
            }
            int eq = value.indexOf('=', start);
            if (eq > 0 && eq < len - 1) {
                attributes.put(URLDecoder.decode(value.substring(start, eq), enc), URLDecoder.decode(value.substring(eq + 1, end), enc));
            }
            start = end + 1;
        } while (start < len);
        return attributes.isEmpty() ? Collections.emptyMap() : Collections.unmodifiableMap(attributes);
    } catch (UnsupportedEncodingException x) {
        throw SneakyThrows.propagate(x);
    }
}","public static Map<String, String> decode(@Nullable String value){
    if (value == null || value.length() == 0) {
        return Collections.emptyMap();
    }
    try {
        Map<String, String> attributes = new HashMap<>();
        String enc = StandardCharsets.UTF_8.name();
        int start = 0;
        int len = value.length();
        do {
            int end = value.indexOf('&', start + 1);
            if (end < 0) {
                end = len;
            }
            int eq = value.indexOf('=', start);
            if (eq > 0 && eq < len - 1) {
                attributes.put(URLDecoder.decode(value.substring(start, eq), enc), URLDecoder.decode(value.substring(eq + 1, end), enc));
            }
            start = end + 1;
        } while (start < len);
        return attributes.isEmpty() ? Collections.emptyMap() : Collections.unmodifiableMap(attributes);
    } catch (UnsupportedEncodingException x) {
        throw SneakyThrows.propagate(x);
    }
}","/**
   * Decode a cookie value using, like: <code>k=v</code>, multiple <code>k=v</code> pair are
   * separated by <code>&amp;</code>. Also, <code>k</code> and <code>v</code> are decoded using
   * {@link URLDecoder}.
   *
   * @param value URL encoded value.
   * @return Decoded as map.
   */","('decode', {'INSTRUCTION': {'covered': 74, 'missed': 4}, 'BRANCH': {'covered': 13, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 2}, 'COMPLEXITY': {'covered': 7, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",225.0,"  Decode a cookie value using, like: <code>k=v</code>, multiple <code>k=v</code> pair are  separated by <code>&amp;</code>.",38.0,"['Multiple code>k/code> pair are separated by a cookie value.', 'Multiple code>k/code> pair are separated by code>&amp;/code>.', 'Multiple code>k/code> pair are separated by the cookie value.']"
913,matsim-libs,org/matsim/contrib/analysis/spatial/SpatialInterpolation.java,/contribs/analysis/src/main/java/org/matsim/contrib/analysis/spatial/SpatialInterpolation.java,calculateWeightFromLine,8-39,"/**
     * This uses a gaussian distance weighting to calculate the impact of link based emissions onto the centroid of a
     * grid cell. The level of emission is assumed to be linear over the link. The calculation is described in Argawal's
     * PhD thesis https://depositonce.tu-berlin.de/handle/11303/6266 in Appendix A.2
     *
     * @param from         Link from coordinate
     * @param to           Link to coordinate
     * @param cellCentroid centroid of the impacted cell
     * @return weight factor by which the emission value should be multiplied to calculate the impact of the cell
     */
public static double calculateWeightFromLine(final Coordinate from, final Coordinate to, final Coordinate cellCentroid, final double smoothingRadius){
    if (smoothingRadius <= 0)
        throw new IllegalArgumentException(""smoothing radius must be greater 0"");
    double a = from.distance(cellCentroid) * from.distance(cellCentroid);
    double b = (to.x - from.x) * (from.x - cellCentroid.x) + (to.y - from.y) * (from.y - cellCentroid.y);
    double linkLength = from.distance(to);
    double c = (smoothingRadius * Math.sqrt(Math.PI) / (linkLength * 2)) * Math.exp(-(a - (b * b / (linkLength * linkLength))) / (smoothingRadius * smoothingRadius));
    double upperLimit = linkLength + b / linkLength;
    double lowerLimit = b / linkLength;
    double integrationUpperLimit = Erf.erf(upperLimit / smoothingRadius);
    double integrationLowerLimit = Erf.erf(lowerLimit / smoothingRadius);
    double weight = c * (integrationUpperLimit - integrationLowerLimit);
    if (weight < 0)
        throw new RuntimeException(""Weight may not be negative! Value: "" + weight);
    return weight;
}","public static double calculateWeightFromLine(final Coordinate from, final Coordinate to, final Coordinate cellCentroid, final double smoothingRadius){
    if (smoothingRadius <= 0)
        throw new IllegalArgumentException(""smoothing radius must be greater 0"");
    double a = from.distance(cellCentroid) * from.distance(cellCentroid);
    double b = (to.x - from.x) * (from.x - cellCentroid.x) + (to.y - from.y) * (from.y - cellCentroid.y);
    double linkLength = from.distance(to);
    double c = (smoothingRadius * Math.sqrt(Math.PI) / (linkLength * 2)) * Math.exp(-(a - (b * b / (linkLength * linkLength))) / (smoothingRadius * smoothingRadius));
    double upperLimit = linkLength + b / linkLength;
    double lowerLimit = b / linkLength;
    double integrationUpperLimit = Erf.erf(upperLimit / smoothingRadius);
    double integrationLowerLimit = Erf.erf(lowerLimit / smoothingRadius);
    double weight = c * (integrationUpperLimit - integrationLowerLimit);
    if (weight < 0)
        throw new RuntimeException(""Weight may not be negative! Value: "" + weight);
    return weight;
}","/**
     * This uses a gaussian distance weighting to calculate the impact of link based emissions onto the centroid of a
     * grid cell. The level of emission is assumed to be linear over the link. The calculation is described in Argawal's
     * PhD thesis https://depositonce.tu-berlin.de/handle/11303/6266 in Appendix A.2
     *
     * @param from         Link from coordinate
     * @param to           Link to coordinate
     * @param cellCentroid centroid of the impacted cell
     * @return weight factor by which the emission value should be multiplied to calculate the impact of the cell
     */","('calculateWeightFromLine', {'INSTRUCTION': {'covered': 102, 'missed': 6}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",225.0,  This uses a gaussian distance weighting to calculate the impact of link based emissions onto the centroid of a  grid cell.,22.0,"['The impact of link based emissions onto the centroid of a grid cell is calculated using a gaussian distance weighting.', 'The impact of link based emissions onto the centroid of a grid cell is calculated using a gaussian distance weight.', 'The impact of link based emissions onto the centroid of a grid cell is calculated using a gaussian distance weighted.']"
914,cdk,org/openscience/cdk/qsar/descriptors/molecular/LargestPiSystemDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/LargestPiSystemDescriptor.java,breadthFirstSearch,224-266,"/**
     * Performs a breadthFirstSearch in an AtomContainer starting with a
     * particular sphere, which usually consists of one start atom, and searches
     * for a pi system.
     *
     * @param container The AtomContainer to
     *                  be searched
     * @param sphere    A sphere of atoms to
     *                  start the search with
     * @param path      An array list which stores the atoms belonging to the pi system
     * @throws org.openscience.cdk.exception.CDKException
     *          Description of the
     *          Exception
     */
private void breadthFirstSearch(IAtomContainer container, List<IAtom> sphere, List<IAtom> path) throws CDKException{
    IAtom nextAtom;
    List<IAtom> newSphere = new ArrayList<IAtom>();
    for (IAtom atom : sphere) {
        List bonds = container.getConnectedBondsList(atom);
        for (Object bond : bonds) {
            nextAtom = ((IBond) bond).getOther(atom);
            if ((container.getMaximumBondOrder(nextAtom) != IBond.Order.SINGLE || Math.abs(nextAtom.getFormalCharge()) >= 1 || nextAtom.getFlag(CDKConstants.ISAROMATIC) || nextAtom.getAtomicNumber() == IElement.N || nextAtom.getAtomicNumber() == IElement.O) & !nextAtom.getFlag(CDKConstants.VISITED)) {
                path.add(nextAtom);
                nextAtom.setFlag(CDKConstants.VISITED, true);
                if (container.getConnectedBondsCount(nextAtom) > 1) {
                    newSphere.add(nextAtom);
                }
            } else {
                nextAtom.setFlag(CDKConstants.VISITED, true);
            }
        }
    }
    if (newSphere.size() > 0) {
        breadthFirstSearch(container, newSphere, path);
    }
}","private void breadthFirstSearch(IAtomContainer container, List<IAtom> sphere, List<IAtom> path) throws CDKException{
    IAtom nextAtom;
    List<IAtom> newSphere = new ArrayList<IAtom>();
    for (IAtom atom : sphere) {
        List bonds = container.getConnectedBondsList(atom);
        for (Object bond : bonds) {
            nextAtom = ((IBond) bond).getOther(atom);
            if ((container.getMaximumBondOrder(nextAtom) != IBond.Order.SINGLE || Math.abs(nextAtom.getFormalCharge()) >= 1 || nextAtom.getFlag(CDKConstants.ISAROMATIC) || nextAtom.getAtomicNumber() == IElement.N || nextAtom.getAtomicNumber() == IElement.O) & !nextAtom.getFlag(CDKConstants.VISITED)) {
                path.add(nextAtom);
                nextAtom.setFlag(CDKConstants.VISITED, true);
                if (container.getConnectedBondsCount(nextAtom) > 1) {
                    newSphere.add(nextAtom);
                }
            } else {
                nextAtom.setFlag(CDKConstants.VISITED, true);
            }
        }
    }
    if (newSphere.size() > 0) {
        breadthFirstSearch(container, newSphere, path);
    }
}","/**
     * Performs a breadthFirstSearch in an AtomContainer starting with a
     * particular sphere, which usually consists of one start atom, and searches
     * for a pi system.
     *
     * @param container The AtomContainer to
     *                  be searched
     * @param sphere    A sphere of atoms to
     *                  start the search with
     * @param path      An array list which stores the atoms belonging to the pi system
     * @throws org.openscience.cdk.exception.CDKException
     *          Description of the
     *          Exception
     */","('breadthFirstSearch', {'INSTRUCTION': {'covered': 102, 'missed': 0}, 'BRANCH': {'covered': 21, 'missed': 1}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 11, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",226.0,"  Performs a breadthFirstSearch in an AtomContainer starting with a  particular sphere, which usually consists of one start atom, and searches  for a pi system.",27.0,"['A search for a pi system is performed in an atom container starting with a particular sphere and usually consisting of one start atom.', 'A search for a pi system is performed in an atom container starting with a particular sphere.', 'A search for a pi system is performed in an atom container starting with a particular sphere, which usually consists of one start atom.']"
916,cdk,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,combineHydrogenPositions,590-622,"/**
     * Makes combinations recursively of all possible mobile Hydrogen positions.
     * @param taken positions taken by hydrogen
     * @param combinations combinations made so far
     * @param skeleton container to work on
     * @param totalMobHydrCount
     * @param mobHydrAttachPositions
     */
private void combineHydrogenPositions(List<Integer> taken, List<List<Integer>> combinations, IAtomContainer skeleton, int totalMobHydrCount, List<Integer> mobHydrAttachPositions){
    if (taken.size() != totalMobHydrCount) {
        for (int i = 0; i < mobHydrAttachPositions.size(); i++) {
            int pos = mobHydrAttachPositions.get(i);
            IAtom atom = findAtomByPosition(skeleton, pos);
            int conn = getConnectivity(atom, skeleton);
            int hCnt = 0;
            for (int t : taken) if (t == pos)
                hCnt++;
            if (atom.getValency() - atom.getFormalCharge() > (hCnt + conn)) {
                taken.add(pos);
                combineHydrogenPositions(taken, combinations, skeleton, totalMobHydrCount, mobHydrAttachPositions);
                taken.remove(taken.size() - 1);
            }
        }
    } else {
        List<Integer> addList = new ArrayList<Integer>(taken.size());
        addList.addAll(taken);
        Collections.sort(addList);
        if (!combinations.contains(addList)) {
            combinations.add(addList);
        }
    }
}","private void combineHydrogenPositions(List<Integer> taken, List<List<Integer>> combinations, IAtomContainer skeleton, int totalMobHydrCount, List<Integer> mobHydrAttachPositions){
    if (taken.size() != totalMobHydrCount) {
        for (int i = 0; i < mobHydrAttachPositions.size(); i++) {
            int pos = mobHydrAttachPositions.get(i);
            IAtom atom = findAtomByPosition(skeleton, pos);
            int conn = getConnectivity(atom, skeleton);
            int hCnt = 0;
            for (int t : taken) if (t == pos)
                hCnt++;
            if (atom.getValency() - atom.getFormalCharge() > (hCnt + conn)) {
                taken.add(pos);
                combineHydrogenPositions(taken, combinations, skeleton, totalMobHydrCount, mobHydrAttachPositions);
                taken.remove(taken.size() - 1);
            }
        }
    } else {
        List<Integer> addList = new ArrayList<Integer>(taken.size());
        addList.addAll(taken);
        Collections.sort(addList);
        if (!combinations.contains(addList)) {
            combinations.add(addList);
        }
    }
}","/**
     * Makes combinations recursively of all possible mobile Hydrogen positions.
     * @param taken positions taken by hydrogen
     * @param combinations combinations made so far
     * @param skeleton container to work on
     * @param totalMobHydrCount
     * @param mobHydrAttachPositions
     */","('combineHydrogenPositions', {'INSTRUCTION': {'covered': 98, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",226.0,  Makes combinations recursively of all possible mobile Hydrogen positions.,10.0,"['All possible mobile Hydrogen positions are combined.', 'All possible mobile Hydrogen positions are made combinations.', 'All possible mobile Hydrogen positions are combinations.']"
917,cdk,org/openscience/cdk/normalize/SMSDNormalizer.java,/legacy/src/main/java/org/openscience/cdk/normalize/SMSDNormalizer.java,aromatizeMolecule,118-178,"/**
     * This function finds rings and uses aromaticity detection code to
     * aromatize the molecule.
     * @param mol input molecule
     */
public static void aromatizeMolecule(IAtomContainer mol){
    IRingSet ringSet = null;
    try {
        AllRingsFinder arf = new AllRingsFinder();
        ringSet = arf.findAllRings(mol);
    } catch (Exception e) {
        e.printStackTrace();
    }
    try {
        SMSDNormalizer.percieveAtomTypesAndConfigureAtoms(mol);
        Aromaticity.cdkLegacy().apply(mol);
        RingSetManipulator.markAromaticRings(ringSet);
    } catch (Exception e) {
        e.printStackTrace();
    }
    for (int i = 0; i <= mol.getAtomCount() - 1; i++) {
        mol.getAtom(i).setFlag(CDKConstants.ISAROMATIC, false);
        jloop: for (int j = 0; j <= ringSet.getAtomContainerCount() - 1; j++) {
            IRing ring = (IRing) ringSet.getAtomContainer(j);
            if (!ring.getFlag(CDKConstants.ISAROMATIC)) {
                continue jloop;
            }
            boolean haveatom = ring.contains(mol.getAtom(i));
            if (haveatom && ring.getAtomCount() == 6) {
                mol.getAtom(i).setFlag(CDKConstants.ISAROMATIC, true);
            }
        }
    }
}","public static void aromatizeMolecule(IAtomContainer mol){
    IRingSet ringSet = null;
    try {
        AllRingsFinder arf = new AllRingsFinder();
        ringSet = arf.findAllRings(mol);
    } catch (Exception e) {
        e.printStackTrace();
    }
    try {
        SMSDNormalizer.percieveAtomTypesAndConfigureAtoms(mol);
        Aromaticity.cdkLegacy().apply(mol);
        RingSetManipulator.markAromaticRings(ringSet);
    } catch (Exception e) {
        e.printStackTrace();
    }
    for (int i = 0; i <= mol.getAtomCount() - 1; i++) {
        mol.getAtom(i).setFlag(CDKConstants.ISAROMATIC, false);
        jloop: for (int j = 0; j <= ringSet.getAtomContainerCount() - 1; j++) {
            IRing ring = (IRing) ringSet.getAtomContainer(j);
            if (!ring.getFlag(CDKConstants.ISAROMATIC)) {
                continue jloop;
            }
            boolean haveatom = ring.contains(mol.getAtom(i));
            if (haveatom && ring.getAtomCount() == 6) {
                mol.getAtom(i).setFlag(CDKConstants.ISAROMATIC, true);
            }
        }
    }
}","/**
     * This function finds rings and uses aromaticity detection code to
     * aromatize the molecule.
     * @param mol input molecule
     */","('aromatizeMolecule', {'INSTRUCTION': {'covered': 74, 'missed': 7}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 5}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",226.0,  This function finds rings and uses aromaticity detection code to  aromatize the molecule.,14.0,"['The function uses aromaticity detection code to smell the molecule.', 'The function finds rings and uses aromaticity detection code to aromatize the molecule.', 'The function uses aromaticity detection code to find rings.']"
918,tablesaw,tech/tablesaw/api/CategoricalColumn.java,/core/src/main/java/tech/tablesaw/api/CategoricalColumn.java,countByCategory,37-70,"/**
   * Returns a count of the number of elements in each category (i.e., the number of repetitions of
   * each value) TODO: This needs to be well tested, especially for IntColumn
   */
 Table countByCategory(){
    final Table t = new Table(""Column: "" + name());
    final CategoricalColumn<?> categories = (CategoricalColumn<?>) type().create(""Category"");
    final IntColumn counts = IntColumn.create(""Count"");
    final Object2IntMap<String> valueToCount = new Object2IntOpenHashMap<>();
    for (int i = 0; i < size(); i++) {
        if (!isMissing(i)) {
            final String next = getString(i);
            if (valueToCount.containsKey(next)) {
                valueToCount.put(next, valueToCount.getInt(next) + 1);
            } else {
                valueToCount.put(next, 1);
            }
        }
    }
    for (Map.Entry<String, Integer> entry : valueToCount.object2IntEntrySet()) {
        categories.appendCell(entry.getKey());
        counts.append(entry.getValue());
    }
    if (countMissing() > 0) {
        categories.appendMissing();
        counts.append(countMissing());
    }
    t.addColumns(categories);
    t.addColumns(counts);
    return t;
}","Table countByCategory(){
    final Table t = new Table(""Column: "" + name());
    final CategoricalColumn<?> categories = (CategoricalColumn<?>) type().create(""Category"");
    final IntColumn counts = IntColumn.create(""Count"");
    final Object2IntMap<String> valueToCount = new Object2IntOpenHashMap<>();
    for (int i = 0; i < size(); i++) {
        if (!isMissing(i)) {
            final String next = getString(i);
            if (valueToCount.containsKey(next)) {
                valueToCount.put(next, valueToCount.getInt(next) + 1);
            } else {
                valueToCount.put(next, 1);
            }
        }
    }
    for (Map.Entry<String, Integer> entry : valueToCount.object2IntEntrySet()) {
        categories.appendCell(entry.getKey());
        counts.append(entry.getValue());
    }
    if (countMissing() > 0) {
        categories.appendMissing();
        counts.append(countMissing());
    }
    t.addColumns(categories);
    t.addColumns(counts);
    return t;
}","/**
   * Returns a count of the number of elements in each category (i.e., the number of repetitions of
   * each value) TODO: This needs to be well tested, especially for IntColumn
   */","('countByCategory', {'INSTRUCTION': {'covered': 108, 'missed': 10}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 19, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",227.0,  Returns a count of the number of elements in each category (i.,14.0,"['The number of elements in each category is returned.', 'A count of elements in each category is returned.', 'A count of the number of elements in each category is returned.']"
919,dcache,org/dcache/resilience/data/FileFilter.java,/modules/dcache-resilience/src/main/java/org/dcache/resilience/data/FileFilter.java,matches,125-172,"/**
     * <p>Filter components are treated as parts of an AND statement.</p>
     */
public boolean matches(FileOperation operation, PoolInfoMap map){
    if (state != null && !state.contains(operation.getStateName())) {
        return false;
    }
    if (pnfsids != null && !pnfsids.contains(operation.getPnfsId().toString())) {
        return false;
    }
    if (retentionPolicy != null && !retentionPolicy.equals(operation.getRetentionPolicyName())) {
        return false;
    }
    if (storageUnit != null && !storageUnit.equals(map.getUnit(operation.getStorageUnit()))) {
        return false;
    }
    if (opCount != null && operation.getOpCount() != opCount) {
        return false;
    }
    Long lastUpdate = operation.getLastUpdate();
    if (lastUpdateBefore != null && lastUpdateBefore <= lastUpdate) {
        return false;
    }
    if (lastUpdateAfter != null && lastUpdateAfter >= lastUpdate) {
        return false;
    }
    if (!matchesPool(parent, operation.getParent(), map)) {
        return false;
    }
    if (!matchesPool(source, operation.getSource(), map)) {
        return false;
    }
    return matchesPool(target, operation.getTarget(), map);
}","public boolean matches(FileOperation operation, PoolInfoMap map){
    if (state != null && !state.contains(operation.getStateName())) {
        return false;
    }
    if (pnfsids != null && !pnfsids.contains(operation.getPnfsId().toString())) {
        return false;
    }
    if (retentionPolicy != null && !retentionPolicy.equals(operation.getRetentionPolicyName())) {
        return false;
    }
    if (storageUnit != null && !storageUnit.equals(map.getUnit(operation.getStorageUnit()))) {
        return false;
    }
    if (opCount != null && operation.getOpCount() != opCount) {
        return false;
    }
    Long lastUpdate = operation.getLastUpdate();
    if (lastUpdateBefore != null && lastUpdateBefore <= lastUpdate) {
        return false;
    }
    if (lastUpdateAfter != null && lastUpdateAfter >= lastUpdate) {
        return false;
    }
    if (!matchesPool(parent, operation.getParent(), map)) {
        return false;
    }
    if (!matchesPool(source, operation.getSource(), map)) {
        return false;
    }
    return matchesPool(target, operation.getTarget(), map);
}","/**
     * <p>Filter components are treated as parts of an AND statement.</p>
     */","('matches', {'INSTRUCTION': {'covered': 102, 'missed': 12}, 'BRANCH': {'covered': 27, 'missed': 5}, 'LINE': {'covered': 20, 'missed': 3}, 'COMPLEXITY': {'covered': 13, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",227.0,  <p>Filter components are treated as parts of an AND statement.,14.0,"['The components of an AND statement are treated as filters.', 'Filters are treated as part of an AND statement.', 'The components of the AND statement are treated as filters.']"
920,liquibase,liquibase/change/AbstractSQLChange.java,/liquibase-core/src/main/java/liquibase/change/AbstractSQLChange.java,generateStatements,216-256,"/**
     * Generates one or more SqlStatements depending on how the SQL should be parsed.
     * If split statements is set to true then the SQL is split and each command is made into a separate SqlStatement.
     * <p></p>
     * If stripping comments is true then any comments are removed before the splitting is executed.
     * The set SQL is passed through the {@link java.sql.Connection#nativeSQL} method if a connection is available.
     */
public SqlStatement[] generateStatements(Database database){
    List<SqlStatement> returnStatements = new ArrayList<>();
    String sql = StringUtil.trimToNull(getSql());
    if (sql == null) {
        return new SqlStatement[0];
    }
    String processedSQL = normalizeLineEndings(sql);
    if (this instanceof RawSQLChange && ((RawSQLChange) this).isRerunnable()) {
        returnStatements.add(new RawSqlStatement(processedSQL, getEndDelimiter()));
        return returnStatements.toArray(new SqlStatement[returnStatements.size()]);
    }
    for (String statement : StringUtil.processMultiLineSQL(processedSQL, isStripComments(), isSplitStatements(), getEndDelimiter())) {
        if (database instanceof MSSQLDatabase) {
            statement = statement.replaceAll(""\\n"", ""\r\n"");
        }
        String escapedStatement = statement;
        try {
            if (database.getConnection() != null) {
                escapedStatement = database.getConnection().nativeSQL(statement);
            }
        } catch (DatabaseException e) {
            escapedStatement = statement;
        }
        returnStatements.add(new RawSqlStatement(escapedStatement, getEndDelimiter()));
    }
    return returnStatements.toArray(new SqlStatement[returnStatements.size()]);
}","public SqlStatement[] generateStatements(Database database){
    List<SqlStatement> returnStatements = new ArrayList<>();
    String sql = StringUtil.trimToNull(getSql());
    if (sql == null) {
        return new SqlStatement[0];
    }
    String processedSQL = normalizeLineEndings(sql);
    if (this instanceof RawSQLChange && ((RawSQLChange) this).isRerunnable()) {
        returnStatements.add(new RawSqlStatement(processedSQL, getEndDelimiter()));
        return returnStatements.toArray(new SqlStatement[returnStatements.size()]);
    }
    for (String statement : StringUtil.processMultiLineSQL(processedSQL, isStripComments(), isSplitStatements(), getEndDelimiter())) {
        if (database instanceof MSSQLDatabase) {
            statement = statement.replaceAll(""\\n"", ""\r\n"");
        }
        String escapedStatement = statement;
        try {
            if (database.getConnection() != null) {
                escapedStatement = database.getConnection().nativeSQL(statement);
            }
        } catch (DatabaseException e) {
            escapedStatement = statement;
        }
        returnStatements.add(new RawSqlStatement(escapedStatement, getEndDelimiter()));
    }
    return returnStatements.toArray(new SqlStatement[returnStatements.size()]);
}","/**
     * Generates one or more SqlStatements depending on how the SQL should be parsed.
     * If split statements is set to true then the SQL is split and each command is made into a separate SqlStatement.
     * <p></p>
     * If stripping comments is true then any comments are removed before the splitting is executed.
     * The set SQL is passed through the {@link java.sql.Connection#nativeSQL} method if a connection is available.
     */","('generateStatements', {'INSTRUCTION': {'covered': 84, 'missed': 19}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 15, 'missed': 4}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",229.0,  Generates one or more SqlStatements depending on how the SQL should be parsed.,14.0,"['Generates one or more SqlStatements.', 'Generates one or more SqlStatements depending on how the SQL should be interpreted.', 'Generates one or more SqlStatements depending on how the SQL should be read.']"
921,anserini,io/anserini/ann/ApproximateNearestNeighborEval.java,/src/main/java/io/anserini/ann/ApproximateNearestNeighborEval.java,nearestVector,216-251,"/**
   * Calculate the nearest <i>N</i> words for a given input word.
   *
   * @param vectors vectors, keyed by word
   * @param word    the input word
   * @param topN    the number of similar word vectors to output
   * @return the {@code topN} similar words of the input word
   */
private static Set<String> nearestVector(Map<String, List<float[]>> vectors, String word, int topN){
    Set<String> intermediate = new TreeSet<>();
    List<float[]> inputs = vectors.get(word);
    String separateToken = ""__"";
    for (Map.Entry<String, List<float[]>> entry : vectors.entrySet()) {
        for (float[] value : entry.getValue()) {
            for (float[] input : inputs) {
                float sim = 0;
                for (int i = 0; i < value.length; i++) {
                    sim += value[i] * input[i];
                }
                // store the words, sorted by decreasing distance using natural order (in the $dist__$word format)
                intermediate.add((1 - sim) + separateToken + entry.getKey());
            }
        }
    }
    Set<String> result = new HashSet<>();
    int i = 0;
    for (String w : intermediate) {
        if (i == topN) {
            break;
        }
        // only add actual word String (not the distance) to the result collection
        result.add(w.substring(w.indexOf(separateToken) + 2));
        i++;
    }
    return result;
}","private static Set<String> nearestVector(Map<String, List<float[]>> vectors, String word, int topN){
    Set<String> intermediate = new TreeSet<>();
    List<float[]> inputs = vectors.get(word);
    String separateToken = ""__"";
    for (Map.Entry<String, List<float[]>> entry : vectors.entrySet()) {
        for (float[] value : entry.getValue()) {
            for (float[] input : inputs) {
                float sim = 0;
                for (int i = 0; i < value.length; i++) {
                    sim += value[i] * input[i];
                }
                // store the words, sorted by decreasing distance using natural order (in the $dist__$word format)
                intermediate.add((1 - sim) + separateToken + entry.getKey());
            }
        }
    }
    Set<String> result = new HashSet<>();
    int i = 0;
    for (String w : intermediate) {
        if (i == topN) {
            break;
        }
        // only add actual word String (not the distance) to the result collection
        result.add(w.substring(w.indexOf(separateToken) + 2));
        i++;
    }
    return result;
}","/**
   * Calculate the nearest <i>N</i> words for a given input word.
   *
   * @param vectors vectors, keyed by word
   * @param word    the input word
   * @param topN    the number of similar word vectors to output
   * @return the {@code topN} similar words of the input word
   */","('nearestVector', {'INSTRUCTION': {'covered': 111, 'missed': 1}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 21, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",229.0,  Calculate the nearest <i>N</i> words for a given input word.,17.0,"['The nearest words for the input word are calculated.', 'The nearest words for a given input word are calculated.', 'The nearest words for a given word are calculated.']"
922,egeria,org/odpi/openmetadata/commonservices/ocf/metadatamanagement/rest/AssetResponse.java,/open-metadata-implementation/common-services/ocf-metadata-management/ocf-metadata-api/src/main/java/org/odpi/openmetadata/commonservices/ocf/metadatamanagement/rest/AssetResponse.java,equals,505-543,"/**
     * Return comparison result based on the content of the properties.
     *
     * @param objectToCompare test object
     * @return result of comparison
     */
public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
        return false;
    }
    if (!super.equals(objectToCompare)) {
        return false;
    }
    AssetResponse that = (AssetResponse) objectToCompare;
    return getCertificationCount() == that.getCertificationCount() && getCommentCount() == that.getCommentCount() && getConnectionCount() == that.getConnectionCount() && getExternalIdentifierCount() == that.getExternalIdentifierCount() && getExternalReferencesCount() == that.getExternalReferencesCount() && getInformalTagCount() == that.getInformalTagCount() && getLicenseCount() == that.getLicenseCount() && getLikeCount() == that.getLikeCount() && getKnownLocationsCount() == that.getKnownLocationsCount() && getNoteLogsCount() == that.getNoteLogsCount() && getRatingsCount() == that.getRatingsCount() && getRelatedAssetCount() == that.getRelatedAssetCount() && getRelatedMediaReferenceCount() == that.getRelatedMediaReferenceCount() && getSchemaType() == that.getSchemaType() && getLastAttachment() == that.getLastAttachment() && Objects.equals(getAsset(), that.getAsset());
}","public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
        return false;
    }
    if (!super.equals(objectToCompare)) {
        return false;
    }
    AssetResponse that = (AssetResponse) objectToCompare;
    return getCertificationCount() == that.getCertificationCount() && getCommentCount() == that.getCommentCount() && getConnectionCount() == that.getConnectionCount() && getExternalIdentifierCount() == that.getExternalIdentifierCount() && getExternalReferencesCount() == that.getExternalReferencesCount() && getInformalTagCount() == that.getInformalTagCount() && getLicenseCount() == that.getLicenseCount() && getLikeCount() == that.getLikeCount() && getKnownLocationsCount() == that.getKnownLocationsCount() && getNoteLogsCount() == that.getNoteLogsCount() && getRatingsCount() == that.getRatingsCount() && getRelatedAssetCount() == that.getRelatedAssetCount() && getRelatedMediaReferenceCount() == that.getRelatedMediaReferenceCount() && getSchemaType() == that.getSchemaType() && getLastAttachment() == that.getLastAttachment() && Objects.equals(getAsset(), that.getAsset());
}","/**
     * Return comparison result based on the content of the properties.
     *
     * @param objectToCompare test object
     * @return result of comparison
     */","('equals', {'INSTRUCTION': {'covered': 107, 'missed': 1}, 'BRANCH': {'covered': 24, 'missed': 16}, 'LINE': {'covered': 23, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 16}, 'METHOD': {'covered': 1, 'missed': 0}})",230.0,  Return comparison result based on the content of the properties.,11.0,"['The result is based on the content of the properties.', 'The result is based on the properties.', 'The return result is based on the properties.']"
923,acs-aem-commons,com/adobe/acs/commons/replication/status/impl/JcrPackageReplicationStatusEventHandler.java,/bundle/src/main/java/com/adobe/acs/commons/replication/status/impl/JcrPackageReplicationStatusEventHandler.java,accept,397-445,"/**
     * Checks if the ReplicationStatusManager should make the provides resource w replication status.
     *
     * @param resource the return
     * @return true is the resource is markable resource
     * @throws RepositoryException
     */
private boolean accept(final Resource resource) throws RepositoryException{
    if (resource == null || ResourceUtil.isNonExistingResource(resource)) {
        return false;
    }
    for (final Map.Entry<String, Pattern> nodeTypeAndPathRestriction : this.pathRestrictionByNodeType.entrySet()) {
        final String[] hierarchyNodeTypes = StringUtils.split(nodeTypeAndPathRestriction.getKey(), ""/"");
        boolean match = true;
        Resource walkingResource = resource;
        for (int i = (hierarchyNodeTypes.length - 1); i >= 0; i--) {
            if (walkingResource == null) {
                match = false;
                break;
            } else {
                final Node node = walkingResource.adaptTo(Node.class);
                if (node == null || !node.isNodeType(hierarchyNodeTypes[i])) {
                    match = false;
                    break;
                }
                walkingResource = walkingResource.getParent();
            }
        }
        if (match) {
            Pattern pathRestriction = nodeTypeAndPathRestriction.getValue();
            if (pathRestriction != null && !pathRestriction.matcher(resource.getPath()).matches()) {
                log.debug(""Path restriction '{}' prevents the resource at '{}' from getting its replication status updated!"", pathRestriction, resource.getPath());
                return false;
            }
            return true;
        }
    }
    return false;
}","private boolean accept(final Resource resource) throws RepositoryException{
    if (resource == null || ResourceUtil.isNonExistingResource(resource)) {
        return false;
    }
    for (final Map.Entry<String, Pattern> nodeTypeAndPathRestriction : this.pathRestrictionByNodeType.entrySet()) {
        final String[] hierarchyNodeTypes = StringUtils.split(nodeTypeAndPathRestriction.getKey(), ""/"");
        boolean match = true;
        Resource walkingResource = resource;
        for (int i = (hierarchyNodeTypes.length - 1); i >= 0; i--) {
            if (walkingResource == null) {
                match = false;
                break;
            } else {
                final Node node = walkingResource.adaptTo(Node.class);
                if (node == null || !node.isNodeType(hierarchyNodeTypes[i])) {
                    match = false;
                    break;
                }
                walkingResource = walkingResource.getParent();
            }
        }
        if (match) {
            Pattern pathRestriction = nodeTypeAndPathRestriction.getValue();
            if (pathRestriction != null && !pathRestriction.matcher(resource.getPath()).matches()) {
                log.debug(""Path restriction '{}' prevents the resource at '{}' from getting its replication status updated!"", pathRestriction, resource.getPath());
                return false;
            }
            return true;
        }
    }
    return false;
}","/**
     * Checks if the ReplicationStatusManager should make the provides resource w replication status.
     *
     * @param resource the return
     * @return true is the resource is markable resource
     * @throws RepositoryException
     */","('accept', {'INSTRUCTION': {'covered': 74, 'missed': 15}, 'BRANCH': {'covered': 14, 'missed': 6}, 'LINE': {'covered': 17, 'missed': 6}, 'COMPLEXITY': {'covered': 5, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",230.0,  Checks if the ReplicationStatusManager should make the provides resource w replication status.,13.0,"['If the ReplicationStatusManager should make the provides resource.', 'If the ReplicationStatusManager should make the provided resource.', 'If the ReplicationStatusManager should make the provides resource with replication status.']"
924,activiti,org/activiti/engine/impl/persistence/entity/ExecutionEntityManagerImpl.java,/activiti-core/activiti-engine/src/main/java/org/activiti/engine/impl/persistence/entity/ExecutionEntityManagerImpl.java,processExecutionTree,133-180,"/**
   * Processes a collection of {@link ExecutionEntity} instances, which form on execution tree.
   * All the executions share the same rootProcessInstanceId (which is provided).
   * The return value will be the root {@link ExecutionEntity} instance, with all child {@link ExecutionEntity}
   * instances populated and set using the {@link ExecutionEntity} instances from the provided collections
   */
protected ExecutionEntity processExecutionTree(String rootProcessInstanceId, List<ExecutionEntity> executions){
    ExecutionEntity rootExecution = null;
    // Collect executions
    Map<String, ExecutionEntity> executionMap = new HashMap<String, ExecutionEntity>(executions.size());
    for (ExecutionEntity executionEntity : executions) {
        if (executionEntity.getId().equals(rootProcessInstanceId)) {
            rootExecution = executionEntity;
        }
        executionMap.put(executionEntity.getId(), executionEntity);
    }
    // Set relationships
    for (ExecutionEntity executionEntity : executions) {
        // Root process instance relationship
        if (executionEntity.getRootProcessInstanceId() != null) {
            executionEntity.setRootProcessInstance(executionMap.get(executionEntity.getRootProcessInstanceId()));
        }
        // Process instance relationship
        if (executionEntity.getProcessInstanceId() != null) {
            executionEntity.setProcessInstance(executionMap.get(executionEntity.getProcessInstanceId()));
        }
        // Parent - child relationship
        if (executionEntity.getParentId() != null) {
            ExecutionEntity parentExecutionEntity = executionMap.get(executionEntity.getParentId());
            executionEntity.setParent(parentExecutionEntity);
            parentExecutionEntity.addChildExecution(executionEntity);
        }
        // Super - sub execution relationship
        if (executionEntity.getSuperExecution() != null) {
            ExecutionEntity superExecutionEntity = executionMap.get(executionEntity.getSuperExecutionId());
            executionEntity.setSuperExecution(superExecutionEntity);
            superExecutionEntity.setSubProcessInstance(executionEntity);
        }
    }
    return rootExecution;
}","protected ExecutionEntity processExecutionTree(String rootProcessInstanceId, List<ExecutionEntity> executions){
    ExecutionEntity rootExecution = null;
    // Collect executions
    Map<String, ExecutionEntity> executionMap = new HashMap<String, ExecutionEntity>(executions.size());
    for (ExecutionEntity executionEntity : executions) {
        if (executionEntity.getId().equals(rootProcessInstanceId)) {
            rootExecution = executionEntity;
        }
        executionMap.put(executionEntity.getId(), executionEntity);
    }
    // Set relationships
    for (ExecutionEntity executionEntity : executions) {
        // Root process instance relationship
        if (executionEntity.getRootProcessInstanceId() != null) {
            executionEntity.setRootProcessInstance(executionMap.get(executionEntity.getRootProcessInstanceId()));
        }
        // Process instance relationship
        if (executionEntity.getProcessInstanceId() != null) {
            executionEntity.setProcessInstance(executionMap.get(executionEntity.getProcessInstanceId()));
        }
        // Parent - child relationship
        if (executionEntity.getParentId() != null) {
            ExecutionEntity parentExecutionEntity = executionMap.get(executionEntity.getParentId());
            executionEntity.setParent(parentExecutionEntity);
            parentExecutionEntity.addChildExecution(executionEntity);
        }
        // Super - sub execution relationship
        if (executionEntity.getSuperExecution() != null) {
            ExecutionEntity superExecutionEntity = executionMap.get(executionEntity.getSuperExecutionId());
            executionEntity.setSuperExecution(superExecutionEntity);
            superExecutionEntity.setSubProcessInstance(executionEntity);
        }
    }
    return rootExecution;
}","/**
   * Processes a collection of {@link ExecutionEntity} instances, which form on execution tree.
   * All the executions share the same rootProcessInstanceId (which is provided).
   * The return value will be the root {@link ExecutionEntity} instance, with all child {@link ExecutionEntity}
   * instances populated and set using the {@link ExecutionEntity} instances from the provided collections
   */","('processExecutionTree', {'INSTRUCTION': {'covered': 95, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 2}, 'LINE': {'covered': 22, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",232.0,"  Processes a collection of {@link ExecutionEntity} instances, which form on execution tree.",17.0,"['A collection of @link ExecutionEntity instances form on an execution tree.', 'A collection of @link ExecutionEntity instances form on the execution tree.', 'A collection of instances form on the execution tree.']"
925,jackson-databind,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,_convert,4347-4395,"/**
     * Actual conversion implementation: instead of using existing read
     * and write methods, much of code is inlined. Reason for this is
     * that we must avoid root value wrapping/unwrapping both for efficiency and
     * for correctness. If root value wrapping/unwrapping is actually desired,
     * caller must use explicit <code>writeValue</code> and
     * <code>readValue</code> methods.
     */
protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException{
    final SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);
    final DefaultSerializerProvider context = _serializerProvider(config);
    TokenBuffer buf = context.bufferForValueConversion(this);
    if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
        buf = buf.forceUseOfBigDecimal(true);
    }
    try {
        context.serializeValue(buf, fromValue);
        final JsonParser p = buf.asParser();
        Object result;
        final DeserializationConfig deserConfig = getDeserializationConfig();
        JsonToken t = _initForReading(p, toValueType);
        if (t == JsonToken.VALUE_NULL) {
            DeserializationContext ctxt = createDeserializationContext(p, deserConfig);
            result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);
        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
            result = null;
        } else {
            DeserializationContext ctxt = createDeserializationContext(p, deserConfig);
            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);
            result = deser.deserialize(p, ctxt);
        }
        p.close();
        return result;
    } catch (IOException e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}","protected Object _convert(Object fromValue, JavaType toValueType) throws IllegalArgumentException{
    final SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);
    final DefaultSerializerProvider context = _serializerProvider(config);
    TokenBuffer buf = context.bufferForValueConversion(this);
    if (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
        buf = buf.forceUseOfBigDecimal(true);
    }
    try {
        context.serializeValue(buf, fromValue);
        final JsonParser p = buf.asParser();
        Object result;
        final DeserializationConfig deserConfig = getDeserializationConfig();
        JsonToken t = _initForReading(p, toValueType);
        if (t == JsonToken.VALUE_NULL) {
            DeserializationContext ctxt = createDeserializationContext(p, deserConfig);
            result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);
        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
            result = null;
        } else {
            DeserializationContext ctxt = createDeserializationContext(p, deserConfig);
            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);
            result = deser.deserialize(p, ctxt);
        }
        p.close();
        return result;
    } catch (IOException e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    }
}","/**
     * Actual conversion implementation: instead of using existing read
     * and write methods, much of code is inlined. Reason for this is
     * that we must avoid root value wrapping/unwrapping both for efficiency and
     * for correctness. If root value wrapping/unwrapping is actually desired,
     * caller must use explicit <code>writeValue</code> and
     * <code>readValue</code> methods.
     */","('_convert', {'INSTRUCTION': {'covered': 81, 'missed': 7}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 19, 'missed': 2}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",232.0,"  Actual conversion implementation: instead of using existing read  and write methods, much of code is inlined.",19.0,"['Much of the code is inlined, instead of using existing read and write methods.', 'A lot of code is inlined instead of using existing read and write methods.', 'Much of the code is inlined.']"
926,acs-aem-commons,com/adobe/acs/commons/remoteassets/impl/RemoteAssetsNodeSyncImpl.java,/bundle/src/main/java/com/adobe/acs/commons/remoteassets/impl/RemoteAssetsNodeSyncImpl.java,createOrUpdateNodesForJsonObject,208-242,"/**
     * Handler for when a JSON element is an Object, representing a resource.
     *
     * @param key String
     * @param parentResource Resource
     * @throws IOException exception
     * @throws RepositoryException exception
     */
private void createOrUpdateNodesForJsonObject(final ResourceResolver remoteAssetsResolver, final String key, final Resource parentResource) throws IOException, RepositoryException{
    if (PROTECTED_NODES.contains(key)) {
        return;
    }
    String objectPath = String.format(""%s/%s"", parentResource.getPath(), key);
    JsonObject jsonObjectWithChildren = getJsonFromUri(objectPath);
    String resourcePrimaryType = jsonObjectWithChildren.getAsJsonPrimitive(JcrConstants.JCR_PRIMARYTYPE).getAsString();
    Resource resource = getOrCreateNode(remoteAssetsResolver, objectPath, resourcePrimaryType);
    createOrUpdateNodes(remoteAssetsResolver, jsonObjectWithChildren, resource);
    ValueMap resourceProperties = resource.adaptTo(ModifiableValueMap.class);
    if (DamConstants.NT_DAM_ASSET.equals(parentResource.getValueMap().get(JcrConstants.JCR_PRIMARYTYPE, String.class)) && DamConstants.NT_DAM_ASSETCONTENT.equals(resourceProperties.get(JcrConstants.JCR_PRIMARYTYPE, String.class))) {
        resourceProperties.put(RemoteAssets.IS_REMOTE_ASSET, true);
        LOG.trace(""Property '{}' added for resource '{}'."", RemoteAssets.IS_REMOTE_ASSET, resource.getPath());
        this.saveRefreshCount++;
        if (this.saveRefreshCount == this.remoteAssetsConfig.getSaveInterval()) {
            this.saveRefreshCount = 0;
            remoteAssetsResolver.commit();
            remoteAssetsResolver.refresh();
            LOG.info(""Executed incremental save of node sync."");
        }
    }
}","private void createOrUpdateNodesForJsonObject(final ResourceResolver remoteAssetsResolver, final String key, final Resource parentResource) throws IOException, RepositoryException{
    if (PROTECTED_NODES.contains(key)) {
        return;
    }
    String objectPath = String.format(""%s/%s"", parentResource.getPath(), key);
    JsonObject jsonObjectWithChildren = getJsonFromUri(objectPath);
    String resourcePrimaryType = jsonObjectWithChildren.getAsJsonPrimitive(JcrConstants.JCR_PRIMARYTYPE).getAsString();
    Resource resource = getOrCreateNode(remoteAssetsResolver, objectPath, resourcePrimaryType);
    createOrUpdateNodes(remoteAssetsResolver, jsonObjectWithChildren, resource);
    ValueMap resourceProperties = resource.adaptTo(ModifiableValueMap.class);
    if (DamConstants.NT_DAM_ASSET.equals(parentResource.getValueMap().get(JcrConstants.JCR_PRIMARYTYPE, String.class)) && DamConstants.NT_DAM_ASSETCONTENT.equals(resourceProperties.get(JcrConstants.JCR_PRIMARYTYPE, String.class))) {
        resourceProperties.put(RemoteAssets.IS_REMOTE_ASSET, true);
        LOG.trace(""Property '{}' added for resource '{}'."", RemoteAssets.IS_REMOTE_ASSET, resource.getPath());
        this.saveRefreshCount++;
        if (this.saveRefreshCount == this.remoteAssetsConfig.getSaveInterval()) {
            this.saveRefreshCount = 0;
            remoteAssetsResolver.commit();
            remoteAssetsResolver.refresh();
            LOG.info(""Executed incremental save of node sync."");
        }
    }
}","/**
     * Handler for when a JSON element is an Object, representing a resource.
     *
     * @param key String
     * @param parentResource Resource
     * @throws IOException exception
     * @throws RepositoryException exception
     */","('createOrUpdateNodesForJsonObject', {'INSTRUCTION': {'covered': 95, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",232.0,"  Handler for when a JSON element is an Object, representing a resource.",14.0,"['A resource is represented by an object.', 'When a resource is represented by an object, the handler is needed.', 'When a resource is represented by an object, the handler is used.']"
929,cdk,org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRGraph.java,solution,322-375,"/**
     * Checks if a potential solution is a real one
     * (not included in a previous solution)
     *  and add this solution to the solution list
     * in case of success.
     *
     * @param  traversed  new potential solution
     */
private void solution(BitSet traversed) throws CDKException{
    boolean included = false;
    BitSet projG1 = projectG1(traversed);
    BitSet projG2 = projectG2(traversed);
    if (isContainedIn(getSourceBitSet(), projG1) && isContainedIn(getTargetBitSet(), projG2)) {
        for (Iterator<BitSet> i = getSolutionList().listIterator(); i.hasNext() && !included; ) {
            BitSet sol = i.next();
            checkTimeOut();
            if (!sol.equals(traversed)) {
                if (isFindAllMap() && (projG1.equals(projectG1(sol)) || projG2.equals(projectG2(sol)))) {
                } else if (isContainedIn(projG1, projectG1(sol)) || isContainedIn(projG2, projectG2(sol))) {
                    included = true;
                } else if (isContainedIn(projectG1(sol), projG1) || isContainedIn(projectG2(sol), projG2)) {
                    i.remove();
                }
            } else {
                included = true;
            }
        }
        if (included == false) {
            getSolutionList().add(traversed);
        }
        if (!isFindAllStructure()) {
            setStop(true);
        }
    }
}","private void solution(BitSet traversed) throws CDKException{
    boolean included = false;
    BitSet projG1 = projectG1(traversed);
    BitSet projG2 = projectG2(traversed);
    if (isContainedIn(getSourceBitSet(), projG1) && isContainedIn(getTargetBitSet(), projG2)) {
        for (Iterator<BitSet> i = getSolutionList().listIterator(); i.hasNext() && !included; ) {
            BitSet sol = i.next();
            checkTimeOut();
            if (!sol.equals(traversed)) {
                if (isFindAllMap() && (projG1.equals(projectG1(sol)) || projG2.equals(projectG2(sol)))) {
                } else if (isContainedIn(projG1, projectG1(sol)) || isContainedIn(projG2, projectG2(sol))) {
                    included = true;
                } else if (isContainedIn(projectG1(sol), projG1) || isContainedIn(projectG2(sol), projG2)) {
                    i.remove();
                }
            } else {
                included = true;
            }
        }
        if (included == false) {
            getSolutionList().add(traversed);
        }
        if (!isFindAllStructure()) {
            setStop(true);
        }
    }
}","/**
     * Checks if a potential solution is a real one
     * (not included in a previous solution)
     *  and add this solution to the solution list
     * in case of success.
     *
     * @param  traversed  new potential solution
     */","('solution', {'INSTRUCTION': {'covered': 107, 'missed': 2}, 'BRANCH': {'covered': 27, 'missed': 1}, 'LINE': {'covered': 19, 'missed': 1}, 'COMPLEXITY': {'covered': 14, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",235.0,  Checks if a potential solution is a real one  (not included in a previous solution)  and add this solution to the solution list  in case of success.,30.0,"['If a potential solution is not included in a previous solution, it is checked to see if it is a real solution.', 'If a potential solution is not included in a previous solution, it should be added to the solution list in case of success.', 'If a potential solution is not included in a previous solution, it is checked to see if it is a real one.']"
930,cdk,org/openscience/cdk/qsar/descriptors/atomic/EffectiveAtomPolarizabilityDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/EffectiveAtomPolarizabilityDescriptor.java,calculate,104-141,"/**
     *  The method calculates the Effective Atom Polarizability of a given atom
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *
     *@param  atom              The IAtom for which the DescriptorValue is requested
     *@param  ac                AtomContainer
     *@return                   return the effective polarizability
     */
public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
    double polarizability;
    try {
        String originalAtomtypeName = atom.getAtomTypeName();
        Integer originalNeighborCount = atom.getFormalNeighbourCount();
        Integer originalHCount = atom.getImplicitHydrogenCount();
        Integer originalValency = atom.getValency();
        IAtomType.Hybridization originalHybridization = atom.getHybridization();
        boolean originalFlag = atom.getFlag(CDKConstants.VISITED);
        Double originalBondOrderSum = atom.getBondOrderSum();
        Order originalMaxBondOrder = atom.getMaxBondOrder();
        polarizability = pol.calculateGHEffectiveAtomPolarizability(ac, atom, 100, true);
        atom.setAtomTypeName(originalAtomtypeName);
        atom.setFormalNeighbourCount(originalNeighborCount);
        atom.setValency(originalValency);
        atom.setImplicitHydrogenCount(originalHCount);
        atom.setFlag(CDKConstants.VISITED, originalFlag);
        atom.setHybridization(originalHybridization);
        atom.setMaxBondOrder(originalMaxBondOrder);
        atom.setBondOrderSum(originalBondOrderSum);
        return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(polarizability), getDescriptorNames());
    } catch (Exception ex1) {
        return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(Double.NaN), getDescriptorNames(), ex1);
    }
}","public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
    double polarizability;
    try {
        String originalAtomtypeName = atom.getAtomTypeName();
        Integer originalNeighborCount = atom.getFormalNeighbourCount();
        Integer originalHCount = atom.getImplicitHydrogenCount();
        Integer originalValency = atom.getValency();
        IAtomType.Hybridization originalHybridization = atom.getHybridization();
        boolean originalFlag = atom.getFlag(CDKConstants.VISITED);
        Double originalBondOrderSum = atom.getBondOrderSum();
        Order originalMaxBondOrder = atom.getMaxBondOrder();
        polarizability = pol.calculateGHEffectiveAtomPolarizability(ac, atom, 100, true);
        atom.setAtomTypeName(originalAtomtypeName);
        atom.setFormalNeighbourCount(originalNeighborCount);
        atom.setValency(originalValency);
        atom.setImplicitHydrogenCount(originalHCount);
        atom.setFlag(CDKConstants.VISITED, originalFlag);
        atom.setHybridization(originalHybridization);
        atom.setMaxBondOrder(originalMaxBondOrder);
        atom.setBondOrderSum(originalBondOrderSum);
        return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(polarizability), getDescriptorNames());
    } catch (Exception ex1) {
        return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(Double.NaN), getDescriptorNames(), ex1);
    }
}","/**
     *  The method calculates the Effective Atom Polarizability of a given atom
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *
     *@param  atom              The IAtom for which the DescriptorValue is requested
     *@param  ac                AtomContainer
     *@return                   return the effective polarizability
     */","('calculate', {'INSTRUCTION': {'covered': 74, 'missed': 18}, 'LINE': {'covered': 19, 'missed': 3}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",235.0,  The method calculates the Effective Atom Polarizability of a given atom  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.,24.0,"['The class tools allow the addExplicitHydrogensToSatisfyValency method to be called from the method.', 'It is necessary to call the addExplicitHydrogensToSatisfyValency method from the class tools.', 'The class tools allow the addExplicitHydrogensToSatisfyValency method to be used.']"
931,cdk,org/openscience/cdk/qsar/descriptors/bond/BondPartialSigmaChargeDescriptor.java,/descriptor/qsarbond/src/main/java/org/openscience/cdk/qsar/descriptors/bond/BondPartialSigmaChargeDescriptor.java,calculate,124-154,"/**
     *  The method calculates the bond-sigma Partial charge of a given bond
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *
     *@param  ac                AtomContainer
     *@return return the sigma electronegativity
     */
public DescriptorValue calculate(IBond bond, IAtomContainer ac){
    Double originalCharge1 = bond.getBegin().getCharge();
    Double originalCharge2 = bond.getEnd().getCharge();
    if (!isCachedAtomContainer(ac)) {
        IAtomContainer mol = ac.getBuilder().newInstance(IAtomContainer.class, ac);
        if (maxIterations != 0)
            peoe.setMaxGasteigerIters(maxIterations);
        try {
            peoe.assignGasteigerMarsiliSigmaPartialCharges(mol, true);
            for (Iterator<IBond> it = ac.bonds().iterator(); it.hasNext(); ) {
                IBond bondi = it.next();
                double result = Math.abs(bondi.getBegin().getCharge() - bondi.getEnd().getCharge());
                cacheDescriptorValue(bondi, ac, new DoubleResult(result));
            }
        } catch (Exception ex1) {
            return getDummyDescriptorValue(ex1);
        }
    }
    bond.getBegin().setCharge(originalCharge1);
    bond.getEnd().setCharge(originalCharge2);
    return getCachedDescriptorValue(bond) != null ? new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), getCachedDescriptorValue(bond), NAMES) : null;
}","public DescriptorValue calculate(IBond bond, IAtomContainer ac){
    Double originalCharge1 = bond.getBegin().getCharge();
    Double originalCharge2 = bond.getEnd().getCharge();
    if (!isCachedAtomContainer(ac)) {
        IAtomContainer mol = ac.getBuilder().newInstance(IAtomContainer.class, ac);
        if (maxIterations != 0)
            peoe.setMaxGasteigerIters(maxIterations);
        try {
            peoe.assignGasteigerMarsiliSigmaPartialCharges(mol, true);
            for (Iterator<IBond> it = ac.bonds().iterator(); it.hasNext(); ) {
                IBond bondi = it.next();
                double result = Math.abs(bondi.getBegin().getCharge() - bondi.getEnd().getCharge());
                cacheDescriptorValue(bondi, ac, new DoubleResult(result));
            }
        } catch (Exception ex1) {
            return getDummyDescriptorValue(ex1);
        }
    }
    bond.getBegin().setCharge(originalCharge1);
    bond.getEnd().setCharge(originalCharge2);
    return getCachedDescriptorValue(bond) != null ? new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), getCachedDescriptorValue(bond), NAMES) : null;
}","/**
     *  The method calculates the bond-sigma Partial charge of a given bond
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *
     *@param  ac                AtomContainer
     *@return return the sigma electronegativity
     */","('calculate', {'INSTRUCTION': {'covered': 92, 'missed': 12}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 16, 'missed': 2}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",236.0,  The method calculates the bond-sigma Partial charge of a given bond  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.,24.0,"['The addExplicitHydrogensToSatisfyValency method needs to be called from the class tools.', 'The addExplicitHydrogensToSatisfyValency method is needed from the class tools to calculate the partial charge of a bond.', 'The addExplicitHydrogensToSatisfyValency method is needed from the class tools to calculate the partial charge of a given bond.']"
932,matsim-libs,org/matsim/core/router/Dijkstra.java,/matsim/src/main/java/org/matsim/core/router/Dijkstra.java,addToPendingNodes,430-476,"/**
	 * Adds some parameters to the given Node then adds it to the set of pending
	 * nodes.
	 *
	 * @param l
	 *            The link from which we came to this Node.
	 * @param n
	 *            The Node to add to the pending nodes.
	 * @param pendingNodes
	 *            The set of pending nodes.
	 * @param currTime
	 *            The time at which we started to traverse l.
	 * @param currCost
	 *            The cost at the time we started to traverse l.
	 * @param toNode
	 *            The target Node of the route.
	 * @return true if the node was added to the pending nodes, false otherwise
	 * 		(e.g. when the same node already has an earlier visiting time).
	 */
protected boolean addToPendingNodes(final Link l, final Node n, final RouterPriorityQueue<Node> pendingNodes, final double currTime, final double currCost, final Node toNode){
    final double travelTime = this.timeFunction.getLinkTravelTime(l, currTime, this.person, this.vehicle);
    final double travelCost = this.costFunction.getLinkTravelDisutility(l, currTime, this.person, this.vehicle);
    final DijkstraNodeData data = getData(n);
    if (!data.isVisited(getIterationId())) {
        visitNode(n, data, pendingNodes, currTime + travelTime, currCost + travelCost, l);
        return true;
    }
    final double nCost = data.getCost();
    final double totalCost = currCost + travelCost;
    if (totalCost < nCost) {
        revisitNode(n, data, pendingNodes, currTime + travelTime, totalCost, l);
        return true;
    } else if (totalCost == nCost) {
        Link prevLink = data.getPrevLink();
        if (prevLink != null && prevLink.getId().compareTo(l.getId()) > 0) {
            revisitNode(n, data, pendingNodes, currTime + travelTime, totalCost, l);
            return true;
        }
    }
    return false;
}","protected boolean addToPendingNodes(final Link l, final Node n, final RouterPriorityQueue<Node> pendingNodes, final double currTime, final double currCost, final Node toNode){
    final double travelTime = this.timeFunction.getLinkTravelTime(l, currTime, this.person, this.vehicle);
    final double travelCost = this.costFunction.getLinkTravelDisutility(l, currTime, this.person, this.vehicle);
    final DijkstraNodeData data = getData(n);
    if (!data.isVisited(getIterationId())) {
        visitNode(n, data, pendingNodes, currTime + travelTime, currCost + travelCost, l);
        return true;
    }
    final double nCost = data.getCost();
    final double totalCost = currCost + travelCost;
    if (totalCost < nCost) {
        revisitNode(n, data, pendingNodes, currTime + travelTime, totalCost, l);
        return true;
    } else if (totalCost == nCost) {
        Link prevLink = data.getPrevLink();
        if (prevLink != null && prevLink.getId().compareTo(l.getId()) > 0) {
            revisitNode(n, data, pendingNodes, currTime + travelTime, totalCost, l);
            return true;
        }
    }
    return false;
}","/**
	 * Adds some parameters to the given Node then adds it to the set of pending
	 * nodes.
	 *
	 * @param l
	 *            The link from which we came to this Node.
	 * @param n
	 *            The Node to add to the pending nodes.
	 * @param pendingNodes
	 *            The set of pending nodes.
	 * @param currTime
	 *            The time at which we started to traverse l.
	 * @param currCost
	 *            The cost at the time we started to traverse l.
	 * @param toNode
	 *            The target Node of the route.
	 * @return true if the node was added to the pending nodes, false otherwise
	 * 		(e.g. when the same node already has an earlier visiting time).
	 */","('addToPendingNodes', {'INSTRUCTION': {'covered': 95, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 17, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",236.0,  Adds some parameters to the given Node then adds it to the set of pending  nodes.,17.0,"['Adds parameters to the given Node and adds them to the pending nodes.', 'Adds some parameters to the given Node and then adds it to the pending nodes.', 'Adds some parameters to the given Node and then adds it to the set of pending nodes.']"
933,cdk,org/openscience/cdk/silent/Atom.java,/base/silent/src/main/java/org/openscience/cdk/silent/Atom.java,toString,489-523,"/**
     * Returns a one line string representation of this Atom.
     * Methods is conform RFC #9.
     *
     * @return  The string representation of this Atom
     */
public String toString(){
    StringBuffer stringContent = new StringBuffer(64);
    stringContent.append(""Atom("").append(hashCode());
    if (getSymbol() != null) {
        stringContent.append("", S:"").append(getSymbol());
    }
    if (getImplicitHydrogenCount() != null) {
        stringContent.append("", H:"").append(getImplicitHydrogenCount());
    }
    if (getStereoParity() != null) {
        stringContent.append("", SP:"").append(getStereoParity());
    }
    if (getPoint2d() != null) {
        stringContent.append("", 2D:["").append(getPoint2d()).append(']');
    }
    if (getPoint3d() != null) {
        stringContent.append("", 3D:["").append(getPoint3d()).append(']');
    }
    if (getFractionalPoint3d() != null) {
        stringContent.append("", F3D:["").append(getFractionalPoint3d());
    }
    if (getCharge() != null) {
        stringContent.append("", C:"").append(getCharge());
    }
    stringContent.append("", "").append(super.toString());
    stringContent.append(')');
    return stringContent.toString();
}","public String toString(){
    StringBuffer stringContent = new StringBuffer(64);
    stringContent.append(""Atom("").append(hashCode());
    if (getSymbol() != null) {
        stringContent.append("", S:"").append(getSymbol());
    }
    if (getImplicitHydrogenCount() != null) {
        stringContent.append("", H:"").append(getImplicitHydrogenCount());
    }
    if (getStereoParity() != null) {
        stringContent.append("", SP:"").append(getStereoParity());
    }
    if (getPoint2d() != null) {
        stringContent.append("", 2D:["").append(getPoint2d()).append(']');
    }
    if (getPoint3d() != null) {
        stringContent.append("", 3D:["").append(getPoint3d()).append(']');
    }
    if (getFractionalPoint3d() != null) {
        stringContent.append("", F3D:["").append(getFractionalPoint3d());
    }
    if (getCharge() != null) {
        stringContent.append("", C:"").append(getCharge());
    }
    stringContent.append("", "").append(super.toString());
    stringContent.append(')');
    return stringContent.toString();
}","/**
     * Returns a one line string representation of this Atom.
     * Methods is conform RFC #9.
     *
     * @return  The string representation of this Atom
     */","('toString', {'INSTRUCTION': {'covered': 75, 'missed': 25}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 16, 'missed': 3}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",238.0,  Returns a one line string representation of this Atom.,10.0,"['A one line string representation of this atom is returned.', 'A one line string is returned.', 'A one line string representation of the atom.']"
934,egeria,org/odpi/openmetadata/repositoryservices/connectors/stores/metadatacollectionstore/properties/typedefs/TypeDefPatch.java,/open-metadata-implementation/repository-services/repository-services-apis/src/main/java/org/odpi/openmetadata/repositoryservices/connectors/stores/metadatacollectionstore/properties/typedefs/TypeDefPatch.java,equals,615-652,"/**
     * Validate that an object is equal depending on their stored values.
     *
     * @param objectToCompare object
     * @return boolean result
     */
public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
        return false;
    }
    TypeDefPatch that = (TypeDefPatch) objectToCompare;
    return applyToVersion == that.applyToVersion && updateToVersion == that.updateToVersion && Objects.equals(typeDefGUID, that.typeDefGUID) && Objects.equals(typeDefName, that.typeDefName) && typeDefStatus == that.typeDefStatus && Objects.equals(newVersionName, that.newVersionName) && Objects.equals(updatedBy, that.updatedBy) && Objects.equals(updateTime, that.updateTime) && Objects.equals(description, that.description) && Objects.equals(descriptionGUID, that.descriptionGUID) && Objects.equals(superType, that.superType) && Objects.equals(propertyDefinitions, that.propertyDefinitions) && Objects.equals(typeDefOptions, that.typeDefOptions) && Objects.equals(externalStandardMappings, that.externalStandardMappings) && Objects.equals(validInstanceStatusList, that.validInstanceStatusList) && initialStatus == that.initialStatus && Objects.equals(validEntityDefs, that.validEntityDefs) && Objects.equals(endDef1, that.endDef1) && Objects.equals(endDef2, that.endDef2);
}","public boolean equals(Object objectToCompare){
    if (this == objectToCompare) {
        return true;
    }
    if (objectToCompare == null || getClass() != objectToCompare.getClass()) {
        return false;
    }
    TypeDefPatch that = (TypeDefPatch) objectToCompare;
    return applyToVersion == that.applyToVersion && updateToVersion == that.updateToVersion && Objects.equals(typeDefGUID, that.typeDefGUID) && Objects.equals(typeDefName, that.typeDefName) && typeDefStatus == that.typeDefStatus && Objects.equals(newVersionName, that.newVersionName) && Objects.equals(updatedBy, that.updatedBy) && Objects.equals(updateTime, that.updateTime) && Objects.equals(description, that.description) && Objects.equals(descriptionGUID, that.descriptionGUID) && Objects.equals(superType, that.superType) && Objects.equals(propertyDefinitions, that.propertyDefinitions) && Objects.equals(typeDefOptions, that.typeDefOptions) && Objects.equals(externalStandardMappings, that.externalStandardMappings) && Objects.equals(validInstanceStatusList, that.validInstanceStatusList) && initialStatus == that.initialStatus && Objects.equals(validEntityDefs, that.validEntityDefs) && Objects.equals(endDef1, that.endDef1) && Objects.equals(endDef2, that.endDef2);
}","/**
     * Validate that an object is equal depending on their stored values.
     *
     * @param objectToCompare object
     * @return boolean result
     */","('equals', {'INSTRUCTION': {'covered': 133, 'missed': 0}, 'BRANCH': {'covered': 27, 'missed': 17}, 'LINE': {'covered': 21, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 17}, 'METHOD': {'covered': 1, 'missed': 0}})",239.0,  Validate that an object is equal depending on their stored values.,12.0,"['Determine that an object is the same depending on their stored values.', 'Determine that an object is equal.', 'Determine that an object is the same as it is stored.']"
935,acs-aem-commons,com/adobe/acs/commons/util/TypeUtil.java,/bundle/src/main/java/com/adobe/acs/commons/util/TypeUtil.java,toObjectType,120-166,"/**
     * Converts a limited set of String representations to their corresponding Objects
     * <p/>
     * Supports
     * * Double
     * * Long
     * * Integer
     * * Boolean (true/false)
     * * Dates in string format of ISODateTimeFormat
     * <p/>
     * Else, null is returned.
     *
     * @param data  the String representation of the data
     * @param klass the target class type of the provided data
     * @param <T>   the target class type of the provided data
     * @return the derived object representing the data as specified by the klass
     */
public static T toObjectType(String data, Class<T> klass){
    if (Double.class.equals(klass)) {
        try {
            return klass.cast(Double.parseDouble(data));
        } catch (NumberFormatException ex) {
            return null;
        }
    } else if (Long.class.equals(klass)) {
        try {
            return klass.cast(Long.parseLong(data));
        } catch (NumberFormatException ex) {
            return null;
        }
    } else if (Integer.class.equals(klass)) {
        try {
            return klass.cast(Long.parseLong(data));
        } catch (NumberFormatException ex) {
            return null;
        }
    } else if (StringUtils.equalsIgnoreCase(""true"", data)) {
        return klass.cast(Boolean.TRUE);
    } else if (StringUtils.equalsIgnoreCase(""false"", data)) {
        return klass.cast(Boolean.FALSE);
    } else if (JSON_DATE.matcher(data).matches()) {
        long epochSeconds = OffsetDateTime.parse(data).toInstant().toEpochMilli();
        return klass.cast(new Date(epochSeconds));
    } else {
        return klass.cast(data);
    }
}","public static T toObjectType(String data, Class<T> klass){
    if (Double.class.equals(klass)) {
        try {
            return klass.cast(Double.parseDouble(data));
        } catch (NumberFormatException ex) {
            return null;
        }
    } else if (Long.class.equals(klass)) {
        try {
            return klass.cast(Long.parseLong(data));
        } catch (NumberFormatException ex) {
            return null;
        }
    } else if (Integer.class.equals(klass)) {
        try {
            return klass.cast(Long.parseLong(data));
        } catch (NumberFormatException ex) {
            return null;
        }
    } else if (StringUtils.equalsIgnoreCase(""true"", data)) {
        return klass.cast(Boolean.TRUE);
    } else if (StringUtils.equalsIgnoreCase(""false"", data)) {
        return klass.cast(Boolean.FALSE);
    } else if (JSON_DATE.matcher(data).matches()) {
        long epochSeconds = OffsetDateTime.parse(data).toInstant().toEpochMilli();
        return klass.cast(new Date(epochSeconds));
    } else {
        return klass.cast(data);
    }
}","/**
     * Converts a limited set of String representations to their corresponding Objects
     * <p/>
     * Supports
     * * Double
     * * Long
     * * Integer
     * * Boolean (true/false)
     * * Dates in string format of ISODateTimeFormat
     * <p/>
     * Else, null is returned.
     *
     * @param data  the String representation of the data
     * @param klass the target class type of the provided data
     * @param <T>   the target class type of the provided data
     * @return the derived object representing the data as specified by the klass
     */","('toObjectType', {'INSTRUCTION': {'covered': 61, 'missed': 15}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 13, 'missed': 7}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",240.0,"  Converts a limited set of String representations to their corresponding Objects  <p/>  Supports   Double   Long   Integer   Boolean (true/false)   Dates in string format of ISODateTimeFormat  <p/>  Else, null is returned.",37.0,"['null is returned if the Double Long Integer Boolean is true or false.', 'null is returned if the double long string is converted to the corresponding object.', 'null is returned if the double long string is converted to the corresponding objects.']"
936,matsim-libs,org/matsim/core/replanning/selectors/ExpBetaPlanChanger.java,/matsim/src/main/java/org/matsim/core/replanning/selectors/ExpBetaPlanChanger.java,selectPlan,44-104,"/**
	 * Changes to another plan with a probability proportional to exp( Delta scores ).
	 * Need to think through if this goes to Nash Equilibrium or to SUE !!!
	 */
public T selectPlan(final HasPlansAndId<T, I> person){
    // current plan and random plan:
    T currentPlan = person.getSelectedPlan();
    T otherPlan = new RandomPlanSelector<T, I>().selectPlan(person);
    if (currentPlan == null) {
        // this case should only happen when the agent has no plans at all
        return null;
    }
    if ((currentPlan.getScore() == null) || (otherPlan.getScore() == null)) {
        /* With the previous behavior, Double.NaN was returned if no score was available.
			 * This resulted in weight=NaN below as well, and then ultimately in returning
			 * the currentPlan---what we're doing right now as well.
			 */
        if (currentPlan.getScore() != null && otherPlan.getScore() == null) {
            if (scoreWrnFlag) {
                log.error(""yyyyyy not switching to other plan although it needs to be explored.  "" + ""Possibly a serious bug; ask kai if you encounter this.  kai, sep'10"");
                scoreWrnFlag = false;
            }
        }
        return currentPlan;
    }
    // defending against NaN (which should not happen, but happens):
    if (currentPlan.getScore().isNaN()) {
        return otherPlan;
    }
    if (otherPlan.getScore().isNaN()) {
        return currentPlan;
    }
    double currentScore = currentPlan.getScore().doubleValue();
    double otherScore = otherPlan.getScore().doubleValue();
    if (betaWrnFlag) {
        log.warn(""Would make sense to revise this once more.  See comments in code.  kai, nov08"");
        /**
         * Gunnar says, rightly I think, that what is below hits the ""0.01*weight > 1"" threshold fairly quickly.
         *   An alternative might be to divide by exp(0.5*beta*oS)+exp(0.5*beta*cS), or the max of these two numbers.  But:
         *   (1) someone would need to go through the theory to make sure that we remain within what we have said before
         *       (convergence to logit and proba of jump between equal options = 0.01
         *   (2) someone would need to test if the ""traffic"" results are similar
         */
        betaWrnFlag = false;
    }
    double weight = Math.exp(0.5 * this.beta * (otherScore - currentScore));
    // (so far, this is >1 if otherScore>currentScore, and <=1 otherwise)
    // (beta is the slope (strength) of the operation: large beta means strong reaction)
    if (MatsimRandom.getRandom().nextDouble() < 0.01 * weight) {
        // as of now, 0.01 is hardcoded (proba to change when both
        // scores are the same)
        return otherPlan;
    }
    return currentPlan;
}","public T selectPlan(final HasPlansAndId<T, I> person){
    // current plan and random plan:
    T currentPlan = person.getSelectedPlan();
    T otherPlan = new RandomPlanSelector<T, I>().selectPlan(person);
    if (currentPlan == null) {
        // this case should only happen when the agent has no plans at all
        return null;
    }
    if ((currentPlan.getScore() == null) || (otherPlan.getScore() == null)) {
        /* With the previous behavior, Double.NaN was returned if no score was available.
			 * This resulted in weight=NaN below as well, and then ultimately in returning
			 * the currentPlan---what we're doing right now as well.
			 */
        if (currentPlan.getScore() != null && otherPlan.getScore() == null) {
            if (scoreWrnFlag) {
                log.error(""yyyyyy not switching to other plan although it needs to be explored.  "" + ""Possibly a serious bug; ask kai if you encounter this.  kai, sep'10"");
                scoreWrnFlag = false;
            }
        }
        return currentPlan;
    }
    // defending against NaN (which should not happen, but happens):
    if (currentPlan.getScore().isNaN()) {
        return otherPlan;
    }
    if (otherPlan.getScore().isNaN()) {
        return currentPlan;
    }
    double currentScore = currentPlan.getScore().doubleValue();
    double otherScore = otherPlan.getScore().doubleValue();
    if (betaWrnFlag) {
        log.warn(""Would make sense to revise this once more.  See comments in code.  kai, nov08"");
        /**
         * Gunnar says, rightly I think, that what is below hits the ""0.01*weight > 1"" threshold fairly quickly.
         *   An alternative might be to divide by exp(0.5*beta*oS)+exp(0.5*beta*cS), or the max of these two numbers.  But:
         *   (1) someone would need to go through the theory to make sure that we remain within what we have said before
         *       (convergence to logit and proba of jump between equal options = 0.01
         *   (2) someone would need to test if the ""traffic"" results are similar
         */
        betaWrnFlag = false;
    }
    double weight = Math.exp(0.5 * this.beta * (otherScore - currentScore));
    // (so far, this is >1 if otherScore>currentScore, and <=1 otherwise)
    // (beta is the slope (strength) of the operation: large beta means strong reaction)
    if (MatsimRandom.getRandom().nextDouble() < 0.01 * weight) {
        // as of now, 0.01 is hardcoded (proba to change when both
        // scores are the same)
        return otherPlan;
    }
    return currentPlan;
}","/**
	 * Changes to another plan with a probability proportional to exp( Delta scores ).
	 * Need to think through if this goes to Nash Equilibrium or to SUE !!!
	 */","('selectPlan', {'INSTRUCTION': {'covered': 78, 'missed': 4}, 'BRANCH': {'covered': 16, 'missed': 4}, 'LINE': {'covered': 21, 'missed': 2}, 'COMPLEXITY': {'covered': 7, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",240.0,  Changes to another plan with a probability proportional to exp( Delta scores ).,15.0,"['Changes to another plan that has a probability proportional to exp.', 'Changes to another plan with a probability that is proportional to exp.', 'Changes to another plan with a probability that is related to exp.']"
937,weblogic-kubernetes-operator,oracle/kubernetes/operator/wlsconfig/WlsServerConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsServerConfig.java,create,71-111,"/**
   * Creates a WLSServerConfig object using an ""servers"" or ""serverTemplates"" item parsed from JSON
   * result from WLS REST call.
   *
   * @param serverConfigMap A Map containing the parsed ""servers"" or ""serverTemplates"" element for a
   *     WLS server or WLS server template.
   * @return A new WlsServerConfig object using the provided configuration from the configuration
   *     map
   */
 static WlsServerConfig create(Map<String, Object> serverConfigMap){
    // parse the configured network access points or channels
    Map networkAccessPointsMap = (Map<String, Object>) serverConfigMap.get(""networkAccessPoints"");
    List<NetworkAccessPoint> networkAccessPoints = new ArrayList<>();
    if (networkAccessPointsMap != null) {
        List<Map<String, Object>> networkAccessPointItems = (List<Map<String, Object>>) networkAccessPointsMap.get(""items"");
        if (networkAccessPointItems != null && networkAccessPointItems.size() > 0) {
            for (Map<String, Object> networkAccessPointConfigMap : networkAccessPointItems) {
                NetworkAccessPoint networkAccessPoint = new NetworkAccessPoint(networkAccessPointConfigMap);
                networkAccessPoints.add(networkAccessPoint);
            }
        }
    }
    // parse the SSL configuration
    Map<String, Object> sslMap = (Map<String, Object>) serverConfigMap.get(""SSL"");
    Integer sslListenPort = (sslMap == null) ? null : (Integer) sslMap.get(""listenPort"");
    boolean sslPortEnabled = sslMap != null && sslMap.get(""listenPort"") != null;
    // parse the administration port
    return new WlsServerConfig((String) serverConfigMap.get(""name""), (String) serverConfigMap.get(""listenAddress""), getMachineNameFromJsonMap(serverConfigMap), (Integer) serverConfigMap.get(""listenPort""), sslListenPort, (Integer) serverConfigMap.get(""adminPort""), networkAccessPoints);
}","static WlsServerConfig create(Map<String, Object> serverConfigMap){
    // parse the configured network access points or channels
    Map networkAccessPointsMap = (Map<String, Object>) serverConfigMap.get(""networkAccessPoints"");
    List<NetworkAccessPoint> networkAccessPoints = new ArrayList<>();
    if (networkAccessPointsMap != null) {
        List<Map<String, Object>> networkAccessPointItems = (List<Map<String, Object>>) networkAccessPointsMap.get(""items"");
        if (networkAccessPointItems != null && networkAccessPointItems.size() > 0) {
            for (Map<String, Object> networkAccessPointConfigMap : networkAccessPointItems) {
                NetworkAccessPoint networkAccessPoint = new NetworkAccessPoint(networkAccessPointConfigMap);
                networkAccessPoints.add(networkAccessPoint);
            }
        }
    }
    // parse the SSL configuration
    Map<String, Object> sslMap = (Map<String, Object>) serverConfigMap.get(""SSL"");
    Integer sslListenPort = (sslMap == null) ? null : (Integer) sslMap.get(""listenPort"");
    boolean sslPortEnabled = sslMap != null && sslMap.get(""listenPort"") != null;
    // parse the administration port
    return new WlsServerConfig((String) serverConfigMap.get(""name""), (String) serverConfigMap.get(""listenAddress""), getMachineNameFromJsonMap(serverConfigMap), (Integer) serverConfigMap.get(""listenPort""), sslListenPort, (Integer) serverConfigMap.get(""adminPort""), networkAccessPoints);
}","/**
   * Creates a WLSServerConfig object using an ""servers"" or ""serverTemplates"" item parsed from JSON
   * result from WLS REST call.
   *
   * @param serverConfigMap A Map containing the parsed ""servers"" or ""serverTemplates"" element for a
   *     WLS server or WLS server template.
   * @return A new WlsServerConfig object using the provided configuration from the configuration
   *     map
   */","('create', {'INSTRUCTION': {'covered': 89, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 2}, 'LINE': {'covered': 19, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",242.0,"  Creates a WLSServerConfig object using an ""servers"" or ""serverTemplates"" item parsed from JSON  result from WLS REST call.",23.0,"['The object is created using the ""servers"" or ""serverTemplates"" item from the WLS REST call.', 'The object is created using the ""servers"" or ""serverTemplates"" item from the WLS call.', 'The object is created by using the ""servers"" or ""serverTemplates"" item from the WLS REST call.']"
938,dcache,diskCacheV111/namespace/EventNotifier.java,/modules/dcache/src/main/java/diskCacheV111/namespace/EventNotifier.java,fromZkData,143-173,"/**
     * Convert a binary representation back into an event receiver's list of desired events.
     *
     * @param data the binary data
     * @return a Map between the target and its set of desired event types.
     * @throws IllegalArgumentException if the data is badly formatted.
     */
public static Map<PnfsId, EnumSet<EventType>> fromZkData(byte[] data){
    checkArgument(data.length > 1, ""Too little data"");
    checkArgument(data[0] == 0, ""Wrong format"");
    Map<PnfsId, EnumSet<EventType>> deserialised = new HashMap<>();
    int index = 1;
    while (index < data.length) {
        checkArgument(data.length - index >= 3, ""Too little data for bitmask"");
        short bitmask = (short) (data[index++] << 8 | data[index++] & 0xFF);
        EnumSet<EventType> eventTypes = Arrays.stream(EventType.values()).filter(t -> (bitmask & 1 << t.ordinal()) != 0).collect(Collectors.toCollection(() -> EnumSet.noneOf(EventType.class)));
        byte length = data[index++];
        checkArgument(data.length - index >= length, ""Too little data for PNFSID"");
        PnfsId id = new PnfsId(BaseEncoding.base16().encode(data, index, length));
        index += length;
        deserialised.put(id, eventTypes);
        LOGGER.debug(""Adding id={} bitmask={} types={}"", id, bitmask, eventTypes);
    }
    return deserialised;
}","public static Map<PnfsId, EnumSet<EventType>> fromZkData(byte[] data){
    checkArgument(data.length > 1, ""Too little data"");
    checkArgument(data[0] == 0, ""Wrong format"");
    Map<PnfsId, EnumSet<EventType>> deserialised = new HashMap<>();
    int index = 1;
    while (index < data.length) {
        checkArgument(data.length - index >= 3, ""Too little data for bitmask"");
        short bitmask = (short) (data[index++] << 8 | data[index++] & 0xFF);
        EnumSet<EventType> eventTypes = Arrays.stream(EventType.values()).filter(t -> (bitmask & 1 << t.ordinal()) != 0).collect(Collectors.toCollection(() -> EnumSet.noneOf(EventType.class)));
        byte length = data[index++];
        checkArgument(data.length - index >= length, ""Too little data for PNFSID"");
        PnfsId id = new PnfsId(BaseEncoding.base16().encode(data, index, length));
        index += length;
        deserialised.put(id, eventTypes);
        LOGGER.debug(""Adding id={} bitmask={} types={}"", id, bitmask, eventTypes);
    }
    return deserialised;
}","/**
     * Convert a binary representation back into an event receiver's list of desired events.
     *
     * @param data the binary data
     * @return a Map between the target and its set of desired event types.
     * @throws IllegalArgumentException if the data is badly formatted.
     */","('fromZkData', {'INSTRUCTION': {'covered': 115, 'missed': 4}, 'BRANCH': {'covered': 6, 'missed': 4}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",242.0,  Convert a binary representation back into an event receiver's list of desired events.,15.0,"['An event receiver wants a list of desired events.', 'An event receiver will want a list of desired events.', 'An event receiver wants a list of events.']"
939,tablesaw,tech/tablesaw/util/StringUtils.java,/core/src/main/java/tech/tablesaw/util/StringUtils.java,repeat,200-254,"/**
   * Repeat a String {@code repeat} times to form a new String.
   *
   * <pre>
   * StringUtils.repeat(null, 2) = null
   * StringUtils.repeat("""", 0)   = """"
   * StringUtils.repeat("""", 2)   = """"
   * StringUtils.repeat(""a"", 3)  = ""aaa""
   * StringUtils.repeat(""ab"", 2) = ""abab""
   * StringUtils.repeat(""a"", -2) = """"
   * </pre>
   *
   * @param str the String to repeat, may be null
   * @param repeat number of times to repeat str, negative treated as zero
   * @return a new String consisting of the original String repeated, {@code null} if null String
   *     input
   */
public static String repeat(final String str, final int repeat){
    if (str == null) {
        return null;
    }
    if (repeat <= 0) {
        return EMPTY;
    }
    final int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
        return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
        return repeat(str.charAt(0), repeat);
    }
    final int outputLength = inputLength * repeat;
    switch(inputLength) {
        case 1:
            return repeat(str.charAt(0), repeat);
        case 2:
            final char ch0 = str.charAt(0);
            final char ch1 = str.charAt(1);
            final char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            final StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(str);
            }
            return buf.toString();
    }
}","public static String repeat(final String str, final int repeat){
    if (str == null) {
        return null;
    }
    if (repeat <= 0) {
        return EMPTY;
    }
    final int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
        return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
        return repeat(str.charAt(0), repeat);
    }
    final int outputLength = inputLength * repeat;
    switch(inputLength) {
        case 1:
            return repeat(str.charAt(0), repeat);
        case 2:
            final char ch0 = str.charAt(0);
            final char ch1 = str.charAt(1);
            final char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            final StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(str);
            }
            return buf.toString();
    }
}","/**
   * Repeat a String {@code repeat} times to form a new String.
   *
   * <pre>
   * StringUtils.repeat(null, 2) = null
   * StringUtils.repeat("""", 0)   = """"
   * StringUtils.repeat("""", 2)   = """"
   * StringUtils.repeat(""a"", 3)  = ""aaa""
   * StringUtils.repeat(""ab"", 2) = ""abab""
   * StringUtils.repeat(""a"", -2) = """"
   * </pre>
   *
   * @param str the String to repeat, may be null
   * @param repeat number of times to repeat str, negative treated as zero
   * @return a new String consisting of the original String repeated, {@code null} if null String
   *     input
   */","('repeat', {'INSTRUCTION': {'covered': 22, 'missed': 2}, 'BRANCH': {'covered': 3, 'missed': 1}, 'LINE': {'covered': 5, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",242.0,  Repeat a String {@code repeat} times to form a new String.,15.0,"['A new String can be formed by repeating a String @code repeat times.', 'A new String can be formed by repeating a string @code repeat times.', 'A new string can be formed by repeating a string @code repeat times.']"
940,cdk,org/openscience/cdk/isomorphism/VFState.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/VFState.java,feasible,86-160,"/**
     * Check the feasibility of the candidate pair {n, m}. A candidate pair is
     * syntactically feasible iff all k-look-ahead rules hold. These look ahead
     * rules check adjacency relation of the mapping. If an edge is mapped in g1
     * it should also be mapped in g2 and vise-versa (0-look-ahead). If an edge
     * in g1 is unmapped but the edge is adjacent to an another mapped vertex
     * (terminal) then the number of such edges should be equal in g1 compared
     * to g2 (1-look-ahead). If the edge is unmapped and non-terminal then the
     * number of such edges should be equal in g1 compared to g2 (2-look-ahead).
     * 
     *
     * @param n a candidate vertex from g1
     * @param m a candidate vertex from g2
     * @return the mapping is feasible
     */
 boolean feasible(int n, int m){
    // verify atom semantic feasibility
    if (!atomMatcher.matches(container1.getAtom(n), container2.getAtom(m)))
        return false;
    // unmapped terminal vertices n and m are adjacent to
    int nTerminal1 = 0, nTerminal2 = 0;
    // unmapped non-terminal (remaining) vertices n and m are adjacent to
    int nRemain1 = 0, nRemain2 = 0;
    // 0-look-ahead: check each adjacent edge for being mapped, and count
    // terminal or remaining
    for (int n_prime : g1[n]) {
        int m_prime = m1[n_prime];
        // v is already mapped, there should be an edge {m, w} in g2.
        if (m_prime != UNMAPPED) {
            IBond bond2 = bonds2.get(m, m_prime);
            // the bond is not present in the target
            if (bond2 == null)
                return false;
            // verify bond semantic feasibility
            if (!bondMatcher.matches(bonds1.get(n, n_prime), bond2))
                return false;
        } else {
            if (t1[n_prime] > 0)
                nTerminal1++;
            else
                nRemain1++;
        }
    }
    // 0-look-ahead: check each adjacent edge for being mapped, and count
    // terminal or remaining
    for (int m_prime : g2[m]) {
        int n_prime = m2[m_prime];
        if (n_prime != UNMAPPED) {
            IBond bond1 = bonds1.get(n, n_prime);
            // the bond is not present in the query
            if (bond1 == null)
                return false;
            // verify bond semantic feasibility
            if (!bondMatcher.matches(bond1, bonds2.get(m, m_prime)))
                return false;
        } else {
            if (t2[m_prime] > 0)
                nTerminal2++;
            else
                nRemain2++;
        }
    }
    // 1-look-ahead : the mapping {n, m} is feasible iff the number of
    // terminal vertices (t1) adjacent to n is equal to the
    // number of terminal vertices (t2) adjacent to m.
    // 
    // 2-look-ahead: the mapping {n, m} is feasible iff the number of
    // vertices adjacent to n that are neither in m1 or t1 is equal to
    // the number of the number of vertices adjacent to m that are neither
    // in m2 or t2.
    return nTerminal1 == nTerminal2 && nRemain1 == nRemain2;
}","boolean feasible(int n, int m){
    // verify atom semantic feasibility
    if (!atomMatcher.matches(container1.getAtom(n), container2.getAtom(m)))
        return false;
    // unmapped terminal vertices n and m are adjacent to
    int nTerminal1 = 0, nTerminal2 = 0;
    // unmapped non-terminal (remaining) vertices n and m are adjacent to
    int nRemain1 = 0, nRemain2 = 0;
    // 0-look-ahead: check each adjacent edge for being mapped, and count
    // terminal or remaining
    for (int n_prime : g1[n]) {
        int m_prime = m1[n_prime];
        // v is already mapped, there should be an edge {m, w} in g2.
        if (m_prime != UNMAPPED) {
            IBond bond2 = bonds2.get(m, m_prime);
            // the bond is not present in the target
            if (bond2 == null)
                return false;
            // verify bond semantic feasibility
            if (!bondMatcher.matches(bonds1.get(n, n_prime), bond2))
                return false;
        } else {
            if (t1[n_prime] > 0)
                nTerminal1++;
            else
                nRemain1++;
        }
    }
    // 0-look-ahead: check each adjacent edge for being mapped, and count
    // terminal or remaining
    for (int m_prime : g2[m]) {
        int n_prime = m2[m_prime];
        if (n_prime != UNMAPPED) {
            IBond bond1 = bonds1.get(n, n_prime);
            // the bond is not present in the query
            if (bond1 == null)
                return false;
            // verify bond semantic feasibility
            if (!bondMatcher.matches(bond1, bonds2.get(m, m_prime)))
                return false;
        } else {
            if (t2[m_prime] > 0)
                nTerminal2++;
            else
                nRemain2++;
        }
    }
    // 1-look-ahead : the mapping {n, m} is feasible iff the number of
    // terminal vertices (t1) adjacent to n is equal to the
    // number of terminal vertices (t2) adjacent to m.
    // 
    // 2-look-ahead: the mapping {n, m} is feasible iff the number of
    // vertices adjacent to n that are neither in m1 or t1 is equal to
    // the number of the number of vertices adjacent to m that are neither
    // in m2 or t2.
    return nTerminal1 == nTerminal2 && nRemain1 == nRemain2;
}","/**
     * Check the feasibility of the candidate pair {n, m}. A candidate pair is
     * syntactically feasible iff all k-look-ahead rules hold. These look ahead
     * rules check adjacency relation of the mapping. If an edge is mapped in g1
     * it should also be mapped in g2 and vise-versa (0-look-ahead). If an edge
     * in g1 is unmapped but the edge is adjacent to an another mapped vertex
     * (terminal) then the number of such edges should be equal in g1 compared
     * to g2 (1-look-ahead). If the edge is unmapped and non-terminal then the
     * number of such edges should be equal in g1 compared to g2 (2-look-ahead).
     * 
     *
     * @param n a candidate vertex from g1
     * @param m a candidate vertex from g2
     * @return the mapping is feasible
     */","('feasible', {'INSTRUCTION': {'covered': 144, 'missed': 4}, 'BRANCH': {'covered': 24, 'missed': 2}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 12, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",243.0,"  Check the feasibility of the candidate pair {n, m}.",13.0,"['The feasibility of the candidate pair is checked.', 'The feasibility of the candidate pair should be checked.', 'Check the feasibility of the candidate pair.']"
943,cdk,org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,/tool/formula/src/main/java/org/openscience/cdk/tools/manipulator/MolecularFormulaManipulator.java,generateOrderEle,1183-1214,"/**
     * Returns the Elements ordered according to (approximate) probability of occurrence.
     *
     * <p>This begins with the ""elements of life"" C, H, O, N, (Si, P, S, F, Cl),
     * then continues with the ""common"" chemical synthesis ingredients, closing off
     * with the tail-end of the periodic table in atom-number order and finally
     * the generic R-group.
     *
     * @return  fixed-order array
     *
     */
public static String[] generateOrderEle(){
    return new String[] { ""C"", ""H"", ""O"", ""N"", ""Si"", ""P"", ""S"", ""F"", ""Cl"", ""Br"", ""I"", ""Sn"", ""B"", ""Pb"", ""Tl"", ""Ba"", ""In"", ""Pd"", ""Pt"", ""Os"", ""Ag"", ""Zr"", ""Se"", ""Zn"", ""Cu"", ""Ni"", ""Co"", ""Fe"", ""Cr"", ""Ti"", ""Ca"", ""K"", ""Al"", ""Mg"", ""Na"", ""Ce"", ""Hg"", ""Au"", ""Ir"", ""Re"", ""W"", ""Ta"", ""Hf"", ""Lu"", ""Yb"", ""Tm"", ""Er"", ""Ho"", ""Dy"", ""Tb"", ""Gd"", ""Eu"", ""Sm"", ""Pm"", ""Nd"", ""Pr"", ""La"", ""Cs"", ""Xe"", ""Te"", ""Sb"", ""Cd"", ""Rh"", ""Ru"", ""Tc"", ""Mo"", ""Nb"", ""Y"", ""Sr"", ""Rb"", ""Kr"", ""As"", ""Ge"", ""Ga"", ""Mn"", ""V"", ""Sc"", ""Ar"", ""Ne"", ""He"", ""Be"", ""Li"", ""Bi"", ""Po"", ""At"", ""Rn"", ""Fr"", ""Ra"", ""Ac"", ""Th"", ""Pa"", ""U"", ""Np"", ""Pu"", ""Am"", ""Cm"", ""Bk"", ""Cf"", ""Es"", ""Fm"", ""Md"", ""No"", ""Lr"", ""Rf"", ""Db"", ""Sg"", ""Bh"", ""Hs"", ""Mt"", ""Ds"", ""Rg"", ""Cn"", ""R"" };
}","public static String[] generateOrderEle(){
    return new String[] { ""C"", ""H"", ""O"", ""N"", ""Si"", ""P"", ""S"", ""F"", ""Cl"", ""Br"", ""I"", ""Sn"", ""B"", ""Pb"", ""Tl"", ""Ba"", ""In"", ""Pd"", ""Pt"", ""Os"", ""Ag"", ""Zr"", ""Se"", ""Zn"", ""Cu"", ""Ni"", ""Co"", ""Fe"", ""Cr"", ""Ti"", ""Ca"", ""K"", ""Al"", ""Mg"", ""Na"", ""Ce"", ""Hg"", ""Au"", ""Ir"", ""Re"", ""W"", ""Ta"", ""Hf"", ""Lu"", ""Yb"", ""Tm"", ""Er"", ""Ho"", ""Dy"", ""Tb"", ""Gd"", ""Eu"", ""Sm"", ""Pm"", ""Nd"", ""Pr"", ""La"", ""Cs"", ""Xe"", ""Te"", ""Sb"", ""Cd"", ""Rh"", ""Ru"", ""Tc"", ""Mo"", ""Nb"", ""Y"", ""Sr"", ""Rb"", ""Kr"", ""As"", ""Ge"", ""Ga"", ""Mn"", ""V"", ""Sc"", ""Ar"", ""Ne"", ""He"", ""Be"", ""Li"", ""Bi"", ""Po"", ""At"", ""Rn"", ""Fr"", ""Ra"", ""Ac"", ""Th"", ""Pa"", ""U"", ""Np"", ""Pu"", ""Am"", ""Cm"", ""Bk"", ""Cf"", ""Es"", ""Fm"", ""Md"", ""No"", ""Lr"", ""Rf"", ""Db"", ""Sg"", ""Bh"", ""Hs"", ""Mt"", ""Ds"", ""Rg"", ""Cn"", ""R"" };
}","/**
     * Returns the Elements ordered according to (approximate) probability of occurrence.
     *
     * <p>This begins with the ""elements of life"" C, H, O, N, (Si, P, S, F, Cl),
     * then continues with the ""common"" chemical synthesis ingredients, closing off
     * with the tail-end of the periodic table in atom-number order and finally
     * the generic R-group.
     *
     * @return  fixed-order array
     *
     */","('generateOrderEle', {'INSTRUCTION': {'covered': 455, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",243.0,  Returns the Elements ordered according to (approximate) probability of occurrence.,13.0,"['The Elements are ordered according to the probability of occurrence.', 'The elements are ordered according to the probability of occurrence.', 'The Elements are ordered by the probability of occurrence.']"
944,dataverse,edu/harvard/iq/dataverse/util/FileUtil.java,/src/main/java/edu/harvard/iq/dataverse/util/FileUtil.java,isDownloadPopupRequired,1467-1508,"/**
     * @todo Consider returning not only the boolean but the human readable
     * reason why the popup is required, which could be used in the GUI to
     * elaborate on the text ""This file cannot be downloaded publicly.""
     */
public static boolean isDownloadPopupRequired(DatasetVersion datasetVersion){
    if (datasetVersion == null) {
        logger.fine(""Download popup required because datasetVersion is null."");
        return false;
    }
    if (!datasetVersion.isReleased()) {
        logger.fine(""Download popup required because datasetVersion has not been released."");
        return false;
    }
    if (datasetVersion.getTermsOfUseAndAccess() != null) {
        if (!TermsOfUseAndAccess.License.CC0.equals(datasetVersion.getTermsOfUseAndAccess().getLicense()) && !(datasetVersion.getTermsOfUseAndAccess().getTermsOfUse() == null || datasetVersion.getTermsOfUseAndAccess().getTermsOfUse().equals(""""))) {
            logger.fine(""Download popup required because of license or terms of use."");
            return true;
        }
        if (!(datasetVersion.getTermsOfUseAndAccess().getTermsOfAccess() == null) && !datasetVersion.getTermsOfUseAndAccess().getTermsOfAccess().equals("""")) {
            logger.fine(""Download popup required because of terms of access."");
            return true;
        }
    }
    if (datasetVersion.getDataset() != null && datasetVersion.getDataset().getGuestbook() != null && datasetVersion.getDataset().getGuestbook().isEnabled() && datasetVersion.getDataset().getGuestbook().getDataverse() != null) {
        logger.fine(""Download popup required because of guestbook."");
        return true;
    }
    logger.fine(""Download popup is not required."");
    return false;
}","public static boolean isDownloadPopupRequired(DatasetVersion datasetVersion){
    if (datasetVersion == null) {
        logger.fine(""Download popup required because datasetVersion is null."");
        return false;
    }
    if (!datasetVersion.isReleased()) {
        logger.fine(""Download popup required because datasetVersion has not been released."");
        return false;
    }
    if (datasetVersion.getTermsOfUseAndAccess() != null) {
        if (!TermsOfUseAndAccess.License.CC0.equals(datasetVersion.getTermsOfUseAndAccess().getLicense()) && !(datasetVersion.getTermsOfUseAndAccess().getTermsOfUse() == null || datasetVersion.getTermsOfUseAndAccess().getTermsOfUse().equals(""""))) {
            logger.fine(""Download popup required because of license or terms of use."");
            return true;
        }
        if (!(datasetVersion.getTermsOfUseAndAccess().getTermsOfAccess() == null) && !datasetVersion.getTermsOfUseAndAccess().getTermsOfAccess().equals("""")) {
            logger.fine(""Download popup required because of terms of access."");
            return true;
        }
    }
    if (datasetVersion.getDataset() != null && datasetVersion.getDataset().getGuestbook() != null && datasetVersion.getDataset().getGuestbook().isEnabled() && datasetVersion.getDataset().getGuestbook().getDataverse() != null) {
        logger.fine(""Download popup required because of guestbook."");
        return true;
    }
    logger.fine(""Download popup is not required."");
    return false;
}","/**
     * @todo Consider returning not only the boolean but the human readable
     * reason why the popup is required, which could be used in the GUI to
     * elaborate on the text ""This file cannot be downloaded publicly.""
     */","('isDownloadPopupRequired', {'INSTRUCTION': {'covered': 81, 'missed': 0}, 'BRANCH': {'covered': 20, 'missed': 4}, 'LINE': {'covered': 20, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",244.0,"  @todo Consider returning not only the boolean but the human readable  reason why the popup is required, which could be used in the GUI to  elaborate on the text ""This file cannot be downloaded publicly.",40.0,"['The human readable reason why the popup is required could be used in the GUI to elaborate on the text.', 'The human readable reason why the popup is required, which could be used in the GUI to elaborate on the text, should be returned.', 'The human readable reason why the popup is required, which could be used in the GUI to elaborate on the text, could be returned.']"
945,cdk,org/openscience/cdk/qsar/descriptors/atomic/ProtonTotalPartialChargeDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/ProtonTotalPartialChargeDescriptor.java,calculate,109-160,"/**
     *  The method returns partial charges assigned to an heavy atom and its protons through Gasteiger Marsili
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *
     *@param  atom              The IAtom for which the DescriptorValue is requested
     *@param  ac                AtomContainer
     *@return                   an array of doubles with partial charges of [heavy, proton_1 ... proton_n]
     */
public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
    neighboors = ac.getConnectedAtomsList(atom);
    IAtomContainer clone;
    try {
        clone = (IAtomContainer) ac.clone();
    } catch (CloneNotSupportedException e) {
        return getDummyDescriptorValue(e);
    }
    try {
        peoe = new GasteigerMarsiliPartialCharges();
        peoe.setMaxGasteigerIters(6);
        peoe.assignGasteigerMarsiliSigmaPartialCharges(clone, true);
    } catch (Exception exception) {
        return getDummyDescriptorValue(exception);
    }
    IAtom localAtom = clone.getAtom(ac.indexOf(atom));
    neighboors = clone.getConnectedAtomsList(localAtom);
    DoubleArrayResult protonPartialCharge = new DoubleArrayResult(MAX_PROTON_COUNT);
    assert (neighboors.size() < MAX_PROTON_COUNT);
    protonPartialCharge.add(localAtom.getCharge());
    int hydrogenNeighbors = 0;
    for (IAtom neighboor : neighboors) {
        if (neighboor.getAtomicNumber() == IElement.H) {
            hydrogenNeighbors++;
            protonPartialCharge.add(neighboor.getCharge());
        }
    }
    int remainder = MAX_PROTON_COUNT - (hydrogenNeighbors + 1);
    for (int i = 0; i < remainder; i++) protonPartialCharge.add(Double.NaN);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), protonPartialCharge, getDescriptorNames());
}","public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
    neighboors = ac.getConnectedAtomsList(atom);
    IAtomContainer clone;
    try {
        clone = (IAtomContainer) ac.clone();
    } catch (CloneNotSupportedException e) {
        return getDummyDescriptorValue(e);
    }
    try {
        peoe = new GasteigerMarsiliPartialCharges();
        peoe.setMaxGasteigerIters(6);
        peoe.assignGasteigerMarsiliSigmaPartialCharges(clone, true);
    } catch (Exception exception) {
        return getDummyDescriptorValue(exception);
    }
    IAtom localAtom = clone.getAtom(ac.indexOf(atom));
    neighboors = clone.getConnectedAtomsList(localAtom);
    DoubleArrayResult protonPartialCharge = new DoubleArrayResult(MAX_PROTON_COUNT);
    assert (neighboors.size() < MAX_PROTON_COUNT);
    protonPartialCharge.add(localAtom.getCharge());
    int hydrogenNeighbors = 0;
    for (IAtom neighboor : neighboors) {
        if (neighboor.getAtomicNumber() == IElement.H) {
            hydrogenNeighbors++;
            protonPartialCharge.add(neighboor.getCharge());
        }
    }
    int remainder = MAX_PROTON_COUNT - (hydrogenNeighbors + 1);
    for (int i = 0; i < remainder; i++) protonPartialCharge.add(Double.NaN);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), protonPartialCharge, getDescriptorNames());
}","/**
     *  The method returns partial charges assigned to an heavy atom and its protons through Gasteiger Marsili
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *
     *@param  atom              The IAtom for which the DescriptorValue is requested
     *@param  ac                AtomContainer
     *@return                   an array of doubles with partial charges of [heavy, proton_1 ... proton_n]
     */","('calculate', {'INSTRUCTION': {'covered': 107, 'missed': 14}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 23, 'missed': 4}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",244.0,  The method returns partial charges assigned to an heavy atom and its protons through Gasteiger Marsili  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.,29.0,"['The class tools need to be used to call the addExplicitHydrogensToSatisfyValency method.', 'The class tools need to be used to call the addExplicitHydrogensToSatisfyValency method from the method.', 'The method returns partial charges assigned to an heavy atom and its protons through Gasteiger Marsili.']"
946,cdk,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,queryAdjacencyAndOrder,966-1008,"/**
     *  Determines if 2 bondA1 have 1 atom in common if second is atom query AtomContainer
     *  and wheter the order of the atoms is correct (atoms match).
     *
     * @param  bondA1  first bondA1
     * @param  bond2  second bondA1
     * @param queryBond1 first query bondA1
     * @param queryBond2 second query bondA1
     * @return    the symbol of the common atom or """" if the 2 bonds have no common atom
     */
private static boolean queryAdjacencyAndOrder(IBond bond1, IBond bond2, IBond queryBond1, IBond queryBond2){
    IAtom centralAtom = null;
    IAtom centralQueryAtom = null;
    if (bond1.contains(bond2.getBegin())) {
        centralAtom = bond2.getBegin();
    } else if (bond1.contains(bond2.getEnd())) {
        centralAtom = bond2.getEnd();
    }
    if (queryBond1.contains(queryBond2.getBegin())) {
        centralQueryAtom = queryBond2.getBegin();
    } else if (queryBond1.contains(queryBond2.getEnd())) {
        centralQueryAtom = queryBond2.getEnd();
    }
    if (centralAtom != null && centralQueryAtom != null && ((IQueryAtom) centralQueryAtom).matches(centralAtom)) {
        IQueryAtom queryAtom1 = (IQueryAtom) queryBond1.getOther(centralQueryAtom);
        IQueryAtom queryAtom2 = (IQueryAtom) queryBond2.getOther(centralQueryAtom);
        IAtom atom1 = bond1.getOther(centralAtom);
        IAtom atom2 = bond2.getOther(centralAtom);
        if (queryAtom1.matches(atom1) && queryAtom2.matches(atom2) || queryAtom1.matches(atom2) && queryAtom2.matches(atom1)) {
            return true;
        } else {
            return false;
        }
    } else {
        return centralAtom == null && centralQueryAtom == null;
    }
}","private static boolean queryAdjacencyAndOrder(IBond bond1, IBond bond2, IBond queryBond1, IBond queryBond2){
    IAtom centralAtom = null;
    IAtom centralQueryAtom = null;
    if (bond1.contains(bond2.getBegin())) {
        centralAtom = bond2.getBegin();
    } else if (bond1.contains(bond2.getEnd())) {
        centralAtom = bond2.getEnd();
    }
    if (queryBond1.contains(queryBond2.getBegin())) {
        centralQueryAtom = queryBond2.getBegin();
    } else if (queryBond1.contains(queryBond2.getEnd())) {
        centralQueryAtom = queryBond2.getEnd();
    }
    if (centralAtom != null && centralQueryAtom != null && ((IQueryAtom) centralQueryAtom).matches(centralAtom)) {
        IQueryAtom queryAtom1 = (IQueryAtom) queryBond1.getOther(centralQueryAtom);
        IQueryAtom queryAtom2 = (IQueryAtom) queryBond2.getOther(centralQueryAtom);
        IAtom atom1 = bond1.getOther(centralAtom);
        IAtom atom2 = bond2.getOther(centralAtom);
        if (queryAtom1.matches(atom1) && queryAtom2.matches(atom2) || queryAtom1.matches(atom2) && queryAtom2.matches(atom1)) {
            return true;
        } else {
            return false;
        }
    } else {
        return centralAtom == null && centralQueryAtom == null;
    }
}","/**
     *  Determines if 2 bondA1 have 1 atom in common if second is atom query AtomContainer
     *  and wheter the order of the atoms is correct (atoms match).
     *
     * @param  bondA1  first bondA1
     * @param  bond2  second bondA1
     * @param queryBond1 first query bondA1
     * @param queryBond2 second query bondA1
     * @return    the symbol of the common atom or """" if the 2 bonds have no common atom
     */","('queryAdjacencyAndOrder', {'INSTRUCTION': {'covered': 89, 'missed': 4}, 'BRANCH': {'covered': 21, 'missed': 5}, 'LINE': {'covered': 19, 'missed': 1}, 'COMPLEXITY': {'covered': 10, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",246.0,Determines if 2 bondA1 have 1 atom in common if second is atom query AtomContainer  and wheter the order of the atoms is correct (atoms match).,29.0,"['If the second atom query is correct and the order of the atoms is correct, then the second bondA1 has 1 atom in common.', 'If the second atom query is correct and the order of the atoms is correct, the second bondA1 has 1 atom in common.', 'If the second atom query is correct and the order of the atoms is correct, then the second bondA1 have the same atom.']"
947,cdk,org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,geometric,148-194,"/**
     * Generate a new geometric parity (2D or 3D) for the given molecule and
     * atom indices. This method ensure that 2D and 3D coordinates are available
     * on the specified atoms and returns null if the 2D or 3D coordinates are
     * not fully available.
     *
     * @param mol a molecule
     * @param l   left double bonded atom
     * @param r   right double bonded atom
     * @param l1  first substituent atom of <i>l</i>
     * @param l2  second substituent atom of <i>l</i> or <i>l</i> if there is
     *            none
     * @param r1  first substituent atom of <i>r</i>
     * @param r2  second substituent atom of <i>r</i> or <i>r</i> if there is
     *            none
     * @return geometric parity or null
     */
 static GeometricParity geometric(IAtomContainer mol, int l, int r, int l1, int l2, int r1, int r2){
    Point2d l2d = mol.getAtom(l).getPoint2d();
    Point2d r2d = mol.getAtom(r).getPoint2d();
    Point2d l12d = mol.getAtom(l1).getPoint2d();
    Point2d l22d = mol.getAtom(l2).getPoint2d();
    Point2d r12d = mol.getAtom(r1).getPoint2d();
    Point2d r22d = mol.getAtom(r2).getPoint2d();
    if (l2d != null && r2d != null && l12d != null && l22d != null && r12d != null && r22d != null) {
        return new DoubleBond2DParity(l2d, r2d, l12d, l22d, r12d, r22d);
    }
    Point3d l3d = mol.getAtom(l).getPoint3d();
    Point3d r3d = mol.getAtom(r).getPoint3d();
    Point3d l13d = mol.getAtom(l1).getPoint3d();
    Point3d r13d = mol.getAtom(r1).getPoint3d();
    if (l3d != null && r3d != null && l13d != null && r13d != null)
        return new DoubleBond3DParity(l3d, r3d, l13d, r13d);
    return null;
}","static GeometricParity geometric(IAtomContainer mol, int l, int r, int l1, int l2, int r1, int r2){
    Point2d l2d = mol.getAtom(l).getPoint2d();
    Point2d r2d = mol.getAtom(r).getPoint2d();
    Point2d l12d = mol.getAtom(l1).getPoint2d();
    Point2d l22d = mol.getAtom(l2).getPoint2d();
    Point2d r12d = mol.getAtom(r1).getPoint2d();
    Point2d r22d = mol.getAtom(r2).getPoint2d();
    if (l2d != null && r2d != null && l12d != null && l22d != null && r12d != null && r22d != null) {
        return new DoubleBond2DParity(l2d, r2d, l12d, l22d, r12d, r22d);
    }
    Point3d l3d = mol.getAtom(l).getPoint3d();
    Point3d r3d = mol.getAtom(r).getPoint3d();
    Point3d l13d = mol.getAtom(l1).getPoint3d();
    Point3d r13d = mol.getAtom(r1).getPoint3d();
    if (l3d != null && r3d != null && l13d != null && r13d != null)
        return new DoubleBond3DParity(l3d, r3d, l13d, r13d);
    return null;
}","/**
     * Generate a new geometric parity (2D or 3D) for the given molecule and
     * atom indices. This method ensure that 2D and 3D coordinates are available
     * on the specified atoms and returns null if the 2D or 3D coordinates are
     * not fully available.
     *
     * @param mol a molecule
     * @param l   left double bonded atom
     * @param r   right double bonded atom
     * @param l1  first substituent atom of <i>l</i>
     * @param l2  second substituent atom of <i>l</i> or <i>l</i> if there is
     *            none
     * @param r1  first substituent atom of <i>r</i>
     * @param r2  second substituent atom of <i>r</i> or <i>r</i> if there is
     *            none
     * @return geometric parity or null
     */","('geometric', {'INSTRUCTION': {'covered': 90, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 8}, 'LINE': {'covered': 15, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",246.0,Generate a new geometric parity (2D or 3D) for the given molecule and  atom indices.,18.0,"['A new geometric parity is created for the given molecule and atom indices.', 'A new geometric parity for the given molecule and atom indices can be created.', 'A new geometric parity is created for the given molecule and atom index.']"
948,weblogic-kubernetes-operator,oracle/kubernetes/operator/wlsconfig/WlsDynamicServerConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsDynamicServerConfig.java,create,47-106,"/**
   * Create a dynamic server config using server template and index number of this server.
   *
   * @param name Name of the server
   * @param index index of this server within the cluster, for example, the index of dserver-2 would
   *     be 2
   * @param clusterName name of the WLS cluster that this server belongs to
   * @param domainName name of the WLS domain that this server belongs to
   * @param calculatedListenPorts whether listen ports are calculated according to configuration in
   *     the dynamic cluster
   * @param serverTemplate server template used for servers in the dynamic cluster
   * @return a dynamic server configuration object containing configuration of this dynamic server
   */
 static WlsDynamicServerConfig create(String name, int index, String clusterName, String domainName, boolean calculatedListenPorts, WlsServerConfig serverTemplate){
    Integer listenPort = serverTemplate.getListenPort();
    Integer sslListenPort = serverTemplate.getSslListenPort();
    List<NetworkAccessPoint> networkAccessPoints = new ArrayList<>();
    if (serverTemplate.getNetworkAccessPoints() != null) {
        for (NetworkAccessPoint networkAccessPoint : serverTemplate.getNetworkAccessPoints()) {
            Integer networkAccessPointListenPort = networkAccessPoint.getListenPort();
            if (calculatedListenPorts) {
                networkAccessPointListenPort = networkAccessPointListenPort == null ? (DEFAULT_NAP_LISTEN_PORT_RANGE_BASE + index) : networkAccessPointListenPort + index;
            }
            networkAccessPoints.add(new NetworkAccessPoint(networkAccessPoint.getName(), networkAccessPoint.getProtocol(), networkAccessPointListenPort, networkAccessPoint.getPublicPort()));
        }
    }
    // calculate listen ports if configured to do so
    if (calculatedListenPorts) {
        listenPort = (listenPort == null) ? (DEFAULT_LISTEN_PORT_RANGE_BASE + index) : (listenPort + index);
        sslListenPort = (sslListenPort == null) ? (DEFAULT_SSL_LISTEN_PORT_RANGE_BASE + index) : (sslListenPort + index);
    }
    MacroSubstitutor macroSubstitutor = new MacroSubstitutor(index, name, clusterName, domainName, serverTemplate.getMachineName());
    return new WlsDynamicServerConfig(name, listenPort, macroSubstitutor.substituteMacro(serverTemplate.getListenAddress()), sslListenPort, macroSubstitutor.substituteMacro(serverTemplate.getMachineName()), serverTemplate.getAdminPort(), networkAccessPoints);
}"," static WlsDynamicServerConfig create(String name, int index, String clusterName, String domainName, boolean calculatedListenPorts, WlsServerConfig serverTemplate){
    Integer listenPort = serverTemplate.getListenPort();
    Integer sslListenPort = serverTemplate.getSslListenPort();
    List<NetworkAccessPoint> networkAccessPoints = new ArrayList<>();
    if (serverTemplate.getNetworkAccessPoints() != null) {
        for (NetworkAccessPoint networkAccessPoint : serverTemplate.getNetworkAccessPoints()) {
            Integer networkAccessPointListenPort = networkAccessPoint.getListenPort();
            if (calculatedListenPorts) {
                networkAccessPointListenPort = networkAccessPointListenPort == null ? (DEFAULT_NAP_LISTEN_PORT_RANGE_BASE + index) : networkAccessPointListenPort + index;
            }
            networkAccessPoints.add(new NetworkAccessPoint(networkAccessPoint.getName(), networkAccessPoint.getProtocol(), networkAccessPointListenPort, networkAccessPoint.getPublicPort()));
        }
    }
    // calculate listen ports if configured to do so
    if (calculatedListenPorts) {
        listenPort = (listenPort == null) ? (DEFAULT_LISTEN_PORT_RANGE_BASE + index) : (listenPort + index);
        sslListenPort = (sslListenPort == null) ? (DEFAULT_SSL_LISTEN_PORT_RANGE_BASE + index) : (sslListenPort + index);
    }
    MacroSubstitutor macroSubstitutor = new MacroSubstitutor(index, name, clusterName, domainName, serverTemplate.getMachineName());
    return new WlsDynamicServerConfig(name, listenPort, macroSubstitutor.substituteMacro(serverTemplate.getListenAddress()), sslListenPort, macroSubstitutor.substituteMacro(serverTemplate.getMachineName()), serverTemplate.getAdminPort(), networkAccessPoints);
}","/**
   * Create a dynamic server config using server template and index number of this server.
   *
   * @param name Name of the server
   * @param index index of this server within the cluster, for example, the index of dserver-2 would
   *     be 2
   * @param clusterName name of the WLS cluster that this server belongs to
   * @param domainName name of the WLS domain that this server belongs to
   * @param calculatedListenPorts whether listen ports are calculated according to configuration in
   *     the dynamic cluster
   * @param serverTemplate server template used for servers in the dynamic cluster
   * @return a dynamic server configuration object containing configuration of this dynamic server
   */","('create', {'INSTRUCTION': {'covered': 109, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 26, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",248.0,  Create a dynamic server config using server template and index number of this server.,15.0,"['The server template and index number can be used to create a dynamic server config.', 'The server template and index number can be used to create a dynamic server configuration.', 'The server template and index number are used to create a dynamic server config.']"
949,dcache,org/dcache/services/info/base/StateComposite.java,/modules/dcache-info/src/main/java/org/dcache/services/info/base/StateComposite.java,buildTransition,485-557,"/**
     * Update a StateTransition object so a new StateComponent will be added to dCache's state.  The
     * changes are recorded in StateTransition so they can be applied later.
     *
     * @param ourPath          the StatePath to this StateComposite.
     * @param newComponentPath the StatePath to this StateComponent, relative to this
     *                         StateComposition
     * @param newComponent     the StateComponent to add.
     * @param transition       the StateTransition in which we will record these changes
     */
public void buildTransition(StatePath ourPath, StatePath newComponentPath, StateComponent newComponent, StateTransition transition) throws MetricStatePathException{
    String childName = newComponentPath.getFirstElement();
    StateChangeSet changeSet = transition.getOrCreateChangeSet(ourPath);
    if (this.isMortal() && newComponent.isMortal()) {
        Date newComponentExpiryDate = newComponent.getExpiryDate();
        changeSet.recordNewWhenIShouldExpireDate(newComponentExpiryDate);
    }
    if (newComponent.isImmortal()) {
        changeSet.recordChildIsImmortal();
    }
    changeSet.ensureChildNotRemoved(childName);
    if (newComponentPath.isSimplePath()) {
        if (_children.containsKey(childName)) {
            changeSet.recordUpdatedChild(childName, newComponent);
        } else {
            changeSet.recordNewChild(childName, newComponent);
        }
        if (newComponent instanceof StateComposite) {
            StateComposite newComposite = (StateComposite) newComponent;
            newComposite._metadataRef = getChildMetadata(childName);
        }
        return;
    }
    StateComponent child = _children.get(childName);
    if (child == null) {
        child = changeSet.getNewChildValue(childName);
        if (child == null) {
            child = new StateComposite(getChildMetadata(childName), DEFAULT_LIFETIME);
            changeSet.recordNewChild(childName, child);
        }
    }
    changeSet.recordChildItr(childName);
    child.buildTransition(buildChildPath(ourPath, childName), newComponentPath.childPath(), newComponent, transition);
}","public void buildTransition(StatePath ourPath, StatePath newComponentPath, StateComponent newComponent, StateTransition transition) throws MetricStatePathException{
    String childName = newComponentPath.getFirstElement();
    StateChangeSet changeSet = transition.getOrCreateChangeSet(ourPath);
    if (this.isMortal() && newComponent.isMortal()) {
        Date newComponentExpiryDate = newComponent.getExpiryDate();
        changeSet.recordNewWhenIShouldExpireDate(newComponentExpiryDate);
    }
    if (newComponent.isImmortal()) {
        changeSet.recordChildIsImmortal();
    }
    changeSet.ensureChildNotRemoved(childName);
    if (newComponentPath.isSimplePath()) {
        if (_children.containsKey(childName)) {
            changeSet.recordUpdatedChild(childName, newComponent);
        } else {
            changeSet.recordNewChild(childName, newComponent);
        }
        if (newComponent instanceof StateComposite) {
            StateComposite newComposite = (StateComposite) newComponent;
            newComposite._metadataRef = getChildMetadata(childName);
        }
        return;
    }
    StateComponent child = _children.get(childName);
    if (child == null) {
        child = changeSet.getNewChildValue(childName);
        if (child == null) {
            child = new StateComposite(getChildMetadata(childName), DEFAULT_LIFETIME);
            changeSet.recordNewChild(childName, child);
        }
    }
    changeSet.recordChildItr(childName);
    child.buildTransition(buildChildPath(ourPath, childName), newComponentPath.childPath(), newComponent, transition);
}","/**
     * Update a StateTransition object so a new StateComponent will be added to dCache's state.  The
     * changes are recorded in StateTransition so they can be applied later.
     *
     * @param ourPath          the StatePath to this StateComposite.
     * @param newComponentPath the StatePath to this StateComponent, relative to this
     *                         StateComposition
     * @param newComponent     the StateComponent to add.
     * @param transition       the StateTransition in which we will record these changes
     */","('buildTransition', {'INSTRUCTION': {'covered': 96, 'missed': 0}, 'BRANCH': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 25, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",249.0,  Update a StateTransition object so a new StateComponent will be added to dCache's state.,16.0,"['A new StateComponent will be added if a StateTransition object is updated.', 'A new StateComponent will be added when a StateTransition object is updated.', ""A new StateComponent will be added to dCache's state if a StateTransition object is updated.""]"
950,cdk,org/openscience/cdk/templates/AminoAcids.java,/storage/pdb/src/main/java/org/openscience/cdk/templates/AminoAcids.java,aaBondInfo,60-99,"/**
     * Creates matrix with info about the bonds in the amino acids.
     * 0 = bond id, 1 = atom1 in bond, 2 = atom2 in bond, 3 = bond order.
     * @return info
     */
public static int[][] aaBondInfo(){
    if (aminoAcids == null) {
        createAAs();
    }
    int[][] info = new int[153][4];
    int counter = 0;
    int total = 0;
    for (int aa = 0; aa < aminoAcids.length; aa++) {
        AminoAcid acid = aminoAcids[aa];
        LOGGER.debug(""#bonds for "", acid.getProperty(RESIDUE_NAME).toString(), "" = "" + acid.getBondCount());
        total += acid.getBondCount();
        LOGGER.debug(""total #bonds: "", total);
        Iterator<IBond> bonds = acid.bonds().iterator();
        while (bonds.hasNext()) {
            IBond bond = (IBond) bonds.next();
            info[counter][0] = counter;
            info[counter][1] = acid.indexOf(bond.getBegin());
            info[counter][2] = acid.indexOf(bond.getEnd());
            info[counter][3] = bond.getOrder().numeric();
            counter++;
        }
    }
    if (counter > 153) {
        LOGGER.error(""Error while creating AA info! Bond count is too large: "", counter);
        return null;
    }
    return info;
}","public static int[][] aaBondInfo(){
    if (aminoAcids == null) {
        createAAs();
    }
    int[][] info = new int[153][4];
    int counter = 0;
    int total = 0;
    for (int aa = 0; aa < aminoAcids.length; aa++) {
        AminoAcid acid = aminoAcids[aa];
        LOGGER.debug(""#bonds for "", acid.getProperty(RESIDUE_NAME).toString(), "" = "" + acid.getBondCount());
        total += acid.getBondCount();
        LOGGER.debug(""total #bonds: "", total);
        Iterator<IBond> bonds = acid.bonds().iterator();
        while (bonds.hasNext()) {
            IBond bond = (IBond) bonds.next();
            info[counter][0] = counter;
            info[counter][1] = acid.indexOf(bond.getBegin());
            info[counter][2] = acid.indexOf(bond.getEnd());
            info[counter][3] = bond.getOrder().numeric();
            counter++;
        }
    }
    if (counter > 153) {
        LOGGER.error(""Error while creating AA info! Bond count is too large: "", counter);
        return null;
    }
    return info;
}","/**
     * Creates matrix with info about the bonds in the amino acids.
     * 0 = bond id, 1 = atom1 in bond, 2 = atom2 in bond, 3 = bond order.
     * @return info
     */","('aaBondInfo', {'INSTRUCTION': {'covered': 112, 'missed': 14}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 20, 'missed': 3}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",249.0,  Creates matrix with info about the bonds in the amino acids.,12.0,"['The matrix has information about the bonds in the amino acids.', 'A matrix is created with information about the bonds.', 'A matrix is created with information about the bonds in the acids.']"
951,matsim-libs,org/matsim/core/events/algorithms/EventWriterXML.java,/matsim/src/main/java/org/matsim/core/events/algorithms/EventWriterXML.java,encodeAttributeValue,98-149,"/**
	 * Encodes the given string in such a way that it no longer contains
	 * characters that have a special meaning in xml.
	 * 
	 * @see <a href=""http://www.w3.org/International/questions/qa-escapes#use"">http://www.w3.org/International/questions/qa-escapes#use</a>
	 * @param attributeValue
	 * @return String with some characters replaced by their xml-encoding.
	 */
private String encodeAttributeValue(final String attributeValue){
    if (attributeValue == null) {
        return null;
    }
    int len = attributeValue.length();
    boolean encode = false;
    for (int pos = 0; pos < len; pos++) {
        char ch = attributeValue.charAt(pos);
        if (ch == '<') {
            encode = true;
            break;
        } else if (ch == '>') {
            encode = true;
            break;
        } else if (ch == '\""') {
            encode = true;
            break;
        } else if (ch == '&') {
            encode = true;
            break;
        }
    }
    if (encode) {
        StringBuilder bf = new StringBuilder(attributeValue.length() + 30);
        for (int pos = 0; pos < len; pos++) {
            char ch = attributeValue.charAt(pos);
            if (ch == '<') {
                bf.append(""&lt;"");
            } else if (ch == '>') {
                bf.append(""&gt;"");
            } else if (ch == '\""') {
                bf.append(""&quot;"");
            } else if (ch == '&') {
                bf.append(""&amp;"");
            } else {
                bf.append(ch);
            }
        }
        return bf.toString();
    }
    return attributeValue;
}","private String encodeAttributeValue(final String attributeValue){
    if (attributeValue == null) {
        return null;
    }
    int len = attributeValue.length();
    boolean encode = false;
    for (int pos = 0; pos < len; pos++) {
        char ch = attributeValue.charAt(pos);
        if (ch == '<') {
            encode = true;
            break;
        } else if (ch == '>') {
            encode = true;
            break;
        } else if (ch == '\""') {
            encode = true;
            break;
        } else if (ch == '&') {
            encode = true;
            break;
        }
    }
    if (encode) {
        StringBuilder bf = new StringBuilder(attributeValue.length() + 30);
        for (int pos = 0; pos < len; pos++) {
            char ch = attributeValue.charAt(pos);
            if (ch == '<') {
                bf.append(""&lt;"");
            } else if (ch == '>') {
                bf.append(""&gt;"");
            } else if (ch == '\""') {
                bf.append(""&quot;"");
            } else if (ch == '&') {
                bf.append(""&amp;"");
            } else {
                bf.append(ch);
            }
        }
        return bf.toString();
    }
    return attributeValue;
}","/**
	 * Encodes the given string in such a way that it no longer contains
	 * characters that have a special meaning in xml.
	 * 
	 * @see <a href=""http://www.w3.org/International/questions/qa-escapes#use"">http://www.w3.org/International/questions/qa-escapes#use</a>
	 * @param attributeValue
	 * @return String with some characters replaced by their xml-encoding.
	 */","('encodeAttributeValue', {'INSTRUCTION': {'covered': 98, 'missed': 8}, 'BRANCH': {'covered': 22, 'missed': 2}, 'LINE': {'covered': 30, 'missed': 3}, 'COMPLEXITY': {'covered': 11, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",250.0,  Encodes the given string in such a way that it no longer contains  characters that have a special meaning in xml.,22.0,"['Encodes the string in a way that it no longer contains characters that have a special meaning.', 'Encodes the given string in a way that it no longer contains characters that have a special meaning.', 'Encodes the string in a way that it no longer contains characters with special meaning.']"
952,cdk,org/openscience/cdk/fingerprint/model/Bayesian.java,/tool/model/src/main/java/org/openscience/cdk/fingerprint/model/Bayesian.java,addMolecule,181-221,"/**
     * Appends a new row to the model source data, which consists of a molecule and whether or not it
     * is considered active.
     * 
     * @param mol molecular structure, which must be non-blank
     * @param active whether active or not
     */
public void addMolecule(IAtomContainer mol, boolean active) throws CDKException{
    if (mol == null || mol.getAtomCount() == 0)
        throw new CDKException(""Molecule cannot be blank or null."");
    CircularFingerprinter circ = new CircularFingerprinter(classType);
    circ.setPerceiveStereo(optPerceiveStereo);
    circ.calculate(mol);
    final int AND_BITS = folding - 1;
    Set<Integer> hashset = new TreeSet<Integer>();
    for (int n = circ.getFPCount() - 1; n >= 0; n--) {
        int code = circ.getFP(n).hashCode;
        if (folding > 0)
            code &= AND_BITS;
        hashset.add(code);
    }
    int[] hashes = new int[hashset.size()];
    int p = 0;
    for (Integer h : hashset) hashes[p++] = h;
    if (active)
        numActive++;
    training.add(hashes);
    activity.add(active);
    for (int h : hashes) {
        int[] stash = inHash.get(h);
        if (stash == null)
            stash = new int[] { 0, 0 };
        if (active)
            stash[0]++;
        stash[1]++;
        inHash.put(h, stash);
    }
}","public void addMolecule(IAtomContainer mol, boolean active) throws CDKException{
    if (mol == null || mol.getAtomCount() == 0)
        throw new CDKException(""Molecule cannot be blank or null."");
    CircularFingerprinter circ = new CircularFingerprinter(classType);
    circ.setPerceiveStereo(optPerceiveStereo);
    circ.calculate(mol);
    final int AND_BITS = folding - 1;
    Set<Integer> hashset = new TreeSet<Integer>();
    for (int n = circ.getFPCount() - 1; n >= 0; n--) {
        int code = circ.getFP(n).hashCode;
        if (folding > 0)
            code &= AND_BITS;
        hashset.add(code);
    }
    int[] hashes = new int[hashset.size()];
    int p = 0;
    for (Integer h : hashset) hashes[p++] = h;
    if (active)
        numActive++;
    training.add(hashes);
    activity.add(active);
    for (int h : hashes) {
        int[] stash = inHash.get(h);
        if (stash == null)
            stash = new int[] { 0, 0 };
        if (active)
            stash[0]++;
        stash[1]++;
        inHash.put(h, stash);
    }
}","/**
     * Appends a new row to the model source data, which consists of a molecule and whether or not it
     * is considered active.
     * 
     * @param mol molecular structure, which must be non-blank
     * @param active whether active or not
     */","('addMolecule', {'INSTRUCTION': {'covered': 155, 'missed': 5}, 'BRANCH': {'covered': 16, 'missed': 2}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",251.0,"  Appends a new row to the model source data, which consists of a molecule and whether or not it  is considered active.",24.0,"['A new row is added to the model source data, which contains a molecule and whether or not it is active.', 'A new row is added to the model source data, which consists of a molecule and whether or not it is active.', 'A new row is added to the model source data which contains a molecule and whether or not it is active.']"
953,cdk,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,nodeConstructor,773-818,"/**
     *  Builds  the nodes of the CDKRGraph ( resolution graph ), from
     *  two atom containers (description of the two molecules to compare)
     *
     * @param  graph   the target CDKRGraph
     * @param  ac1   first molecule. Must not be an IQueryAtomContainer.
     * @param  ac2   second molecule. May be an IQueryAtomContainer.
     * @throws org.openscience.cdk.exception.CDKException if it takes too long to identify overlaps
     */
private static void nodeConstructor(CDKRGraph graph, IAtomContainer ac1, IAtomContainer ac2, boolean shouldMatchBonds) throws CDKException{
    if (ac1 instanceof IQueryAtomContainer) {
        throw new CDKException(""The first IAtomContainer must not be an IQueryAtomContainer"");
    }
    graph.clear();
    for (int i = 0; i < ac1.getBondCount(); i++) {
        IBond bondA1 = ac1.getBond(i);
        for (int j = 0; j < ac2.getBondCount(); j++) {
            IBond bondA2 = ac2.getBond(j);
            if (bondA2 instanceof IQueryBond) {
                IQueryBond queryBond = (IQueryBond) bondA2;
                IQueryAtom atom1 = (IQueryAtom) (bondA2.getBegin());
                IQueryAtom atom2 = (IQueryAtom) (bondA2.getEnd());
                if (queryBond.matches(bondA1)) {
                    if (atom1.matches(bondA1.getBegin()) && atom2.matches(bondA1.getEnd()) || atom1.matches(bondA1.getEnd()) && atom2.matches(bondA1.getBegin())) {
                        graph.addNode(new CDKRNode(i, j));
                    }
                }
            } else {
                if (isMatchFeasible(ac1, bondA1, ac2, bondA2, shouldMatchBonds)) {
                    graph.addNode(new CDKRNode(i, j));
                }
            }
        }
    }
}","private static void nodeConstructor(CDKRGraph graph, IAtomContainer ac1, IAtomContainer ac2, boolean shouldMatchBonds) throws CDKException{
    if (ac1 instanceof IQueryAtomContainer) {
        throw new CDKException(""The first IAtomContainer must not be an IQueryAtomContainer"");
    }
    graph.clear();
    for (int i = 0; i < ac1.getBondCount(); i++) {
        IBond bondA1 = ac1.getBond(i);
        for (int j = 0; j < ac2.getBondCount(); j++) {
            IBond bondA2 = ac2.getBond(j);
            if (bondA2 instanceof IQueryBond) {
                IQueryBond queryBond = (IQueryBond) bondA2;
                IQueryAtom atom1 = (IQueryAtom) (bondA2.getBegin());
                IQueryAtom atom2 = (IQueryAtom) (bondA2.getEnd());
                if (queryBond.matches(bondA1)) {
                    if (atom1.matches(bondA1.getBegin()) && atom2.matches(bondA1.getEnd()) || atom1.matches(bondA1.getEnd()) && atom2.matches(bondA1.getBegin())) {
                        graph.addNode(new CDKRNode(i, j));
                    }
                }
            } else {
                if (isMatchFeasible(ac1, bondA1, ac2, bondA2, shouldMatchBonds)) {
                    graph.addNode(new CDKRNode(i, j));
                }
            }
        }
    }
}","/**
     *  Builds  the nodes of the CDKRGraph ( resolution graph ), from
     *  two atom containers (description of the two molecules to compare)
     *
     * @param  graph   the target CDKRGraph
     * @param  ac1   first molecule. Must not be an IQueryAtomContainer.
     * @param  ac2   second molecule. May be an IQueryAtomContainer.
     * @throws org.openscience.cdk.exception.CDKException if it takes too long to identify overlaps
     */","('nodeConstructor', {'INSTRUCTION': {'covered': 90, 'missed': 5}, 'BRANCH': {'covered': 19, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 1}, 'COMPLEXITY': {'covered': 10, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",251.0,"Builds the nodes of the CDKRGraph ( resolution graph ), from  two atom containers (description of the two molecules to compare)   @param graph the target CDKRGraph  @param ac1 first molecule.",36.0,"['The CDKRGraph is built from two atom containers with a description of the two molecule to compare.', 'The CDKRGraph is built from two atom containers with a description of the two molecules to compare.', 'The CDKRGraph is built from two atom containers and the first molecule is the target.']"
954,cdk,org/openscience/cdk/qsar/descriptors/molecular/FractionalPSADescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/FractionalPSADescriptor.java,calculate,104-145,"/**
     * Calculates the topological polar surface area and expresses it as a ratio to molecule size.
     *
     * @param mol The {@link IAtomContainer} whose volume is to be calculated
     * @return descriptor(s) retaining to polar surface area
     */
public DescriptorValue calculate(IAtomContainer mol){
    try {
        mol = mol.clone();
    } catch (CloneNotSupportedException ex) {
    }
    double polar = 0, weight = 0;
    try {
        IChemObjectBuilder builder = mol.getBuilder();
        CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.getInstance(builder);
        for (IAtom atom : mol.atoms()) {
            IAtomType type = matcher.findMatchingAtomType(mol, atom);
            AtomTypeManipulator.configure(atom, type);
        }
        CDKHydrogenAdder adder = CDKHydrogenAdder.getInstance(builder);
        adder.addImplicitHydrogens(mol);
        TPSADescriptor tpsa = new TPSADescriptor();
        DescriptorValue value = tpsa.calculate(mol);
        polar = ((DoubleResult) value.getValue()).doubleValue();
        for (IAtom atom : mol.atoms()) {
            weight += Isotopes.getInstance().getMajorIsotope(atom.getSymbol()).getExactMass();
            Integer hcount = atom.getImplicitHydrogenCount();
            if (hcount != CDKConstants.UNSET)
                weight += hcount * 1.00782504;
        }
    } catch (CDKException | IOException exception) {
        return getDummyDescriptorValue(exception);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(weight == 0 ? 0 : polar / weight), getDescriptorNames());
}","public DescriptorValue calculate(IAtomContainer mol){
    try {
        mol = mol.clone();
    } catch (CloneNotSupportedException ex) {
    }
    double polar = 0, weight = 0;
    try {
        IChemObjectBuilder builder = mol.getBuilder();
        CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.getInstance(builder);
        for (IAtom atom : mol.atoms()) {
            IAtomType type = matcher.findMatchingAtomType(mol, atom);
            AtomTypeManipulator.configure(atom, type);
        }
        CDKHydrogenAdder adder = CDKHydrogenAdder.getInstance(builder);
        adder.addImplicitHydrogens(mol);
        TPSADescriptor tpsa = new TPSADescriptor();
        DescriptorValue value = tpsa.calculate(mol);
        polar = ((DoubleResult) value.getValue()).doubleValue();
        for (IAtom atom : mol.atoms()) {
            weight += Isotopes.getInstance().getMajorIsotope(atom.getSymbol()).getExactMass();
            Integer hcount = atom.getImplicitHydrogenCount();
            if (hcount != CDKConstants.UNSET)
                weight += hcount * 1.00782504;
        }
    } catch (CDKException | IOException exception) {
        return getDummyDescriptorValue(exception);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(weight == 0 ? 0 : polar / weight), getDescriptorNames());
}","/**
     * Calculates the topological polar surface area and expresses it as a ratio to molecule size.
     *
     * @param mol The {@link IAtomContainer} whose volume is to be calculated
     * @return descriptor(s) retaining to polar surface area
     */","('calculate', {'INSTRUCTION': {'covered': 111, 'missed': 8}, 'BRANCH': {'covered': 6, 'missed': 2}, 'LINE': {'covered': 22, 'missed': 3}, 'COMPLEXITY': {'covered': 3, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",251.0,  Calculates the topological polar surface area and expresses it as a ratio to molecule size.,16.0,"['The ratio to molecule size is calculated using the topological polar surface area.', 'The ratio to molecule size is calculated by summing the topological polar surface area.', 'The ratio to molecule size is calculated using the topological polar surface area as a reference.']"
955,matsim-libs,org/matsim/contrib/common/stats/FixedSampleSizeDiscretizer.java,/contribs/common/src/main/java/org/matsim/contrib/common/stats/FixedSampleSizeDiscretizer.java,create,37-92,"/**
	 * Creates a new discretizer with bin borders defined such that each bin
	 * would contain approximately <tt>size</tt> samples from <tt>samples</tt>.
	 * 
	 * Samples are sorted into bins in ascending order. If there are not
	 * sufficient (less than <tt>size</tt>) samples to fill a further bin, the
	 * remaining samples are sorted into the last bin. That is, the last bin is
	 * the only bin that may contain more than <tt>size</tt> samples.
	 * 
	 * @param samples
	 *            an array with samples.
	 * @param size
	 *            the number of samples per bin.
	 * @return a new discretizer.
	 */
public static FixedBordersDiscretizer create(double[] samples, int size){
    TDoubleArrayList borders;
    double min = Double.MAX_VALUE;
    double max = -Double.MAX_VALUE;
    TDoubleIntHashMap hist = new TDoubleIntHashMap(samples.length);
    for (int i = 0; i < samples.length; i++) {
        hist.adjustOrPutValue(samples[i], 1, 1);
        min = Math.min(min, samples[i]);
        max = Math.max(max, samples[i]);
    }
    double[] keys = hist.keys();
    Arrays.sort(keys);
    borders = new TDoubleArrayList(keys.length);
    borders.add(min - 1E-10);
    int binsize = 0;
    int n = 0;
    for (int i = 0; i < keys.length; i++) {
        int nBin = hist.get(keys[i]);
        binsize += nBin;
        n += nBin;
        if (binsize >= size && i > 0) {
            // sufficient samples for the
            // current bin
            if (samples.length - n >= binsize) {
                // sufficient remaining
                // samples to fill the
                // next bin
                borders.add(keys[i]);
                binsize = 0;
            }
        }
    }
    if (binsize > 0)
        borders.add(max);
    return new FixedBordersDiscretizer(borders.toArray());
}","public static FixedBordersDiscretizer create(double[] samples, int size){
    TDoubleArrayList borders;
    double min = Double.MAX_VALUE;
    double max = -Double.MAX_VALUE;
    TDoubleIntHashMap hist = new TDoubleIntHashMap(samples.length);
    for (int i = 0; i < samples.length; i++) {
        hist.adjustOrPutValue(samples[i], 1, 1);
        min = Math.min(min, samples[i]);
        max = Math.max(max, samples[i]);
    }
    double[] keys = hist.keys();
    Arrays.sort(keys);
    borders = new TDoubleArrayList(keys.length);
    borders.add(min - 1E-10);
    int binsize = 0;
    int n = 0;
    for (int i = 0; i < keys.length; i++) {
        int nBin = hist.get(keys[i]);
        binsize += nBin;
        n += nBin;
        if (binsize >= size && i > 0) {
            // sufficient samples for the
            // current bin
            if (samples.length - n >= binsize) {
                // sufficient remaining
                // samples to fill the
                // next bin
                borders.add(keys[i]);
                binsize = 0;
            }
        }
    }
    if (binsize > 0)
        borders.add(max);
    return new FixedBordersDiscretizer(borders.toArray());
}","/**
	 * Creates a new discretizer with bin borders defined such that each bin
	 * would contain approximately <tt>size</tt> samples from <tt>samples</tt>.
	 * 
	 * Samples are sorted into bins in ascending order. If there are not
	 * sufficient (less than <tt>size</tt>) samples to fill a further bin, the
	 * remaining samples are sorted into the last bin. That is, the last bin is
	 * the only bin that may contain more than <tt>size</tt> samples.
	 * 
	 * @param samples
	 *            an array with samples.
	 * @param size
	 *            the number of samples per bin.
	 * @return a new discretizer.
	 */","('create', {'INSTRUCTION': {'covered': 112, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",252.0,  Creates a new discretizer with bin borders defined such that each bin  would contain approximately <tt>size</tt> samples from <tt>samples</tt>.,32.0,"['A new discretizer is created with bin borders that are defined so that each bin has approximately tt>size/tt> samples from tt>samples/tt>.', 'A new discretizer is created with bin borders that are defined so that each bin has approximately tt>size/tt> samples.', 'A new discretizer is created with bin borders that are defined so that each bin has approximately tt>size/tt> samples from tt>Samples/tt>.']"
956,twilio-java,com/twilio/jwt/validation/RequestCanonicalizer.java,/src/main/java/com/twilio/jwt/validation/RequestCanonicalizer.java,create,44-90,"/**
     * Creates a canonical request string out of HTTP request components.
     *
     * @param sortedIncludedHeaders the headers that should be included into canonical request string
     * @return a string representing the canonical request
     */
public String create(List<String> sortedIncludedHeaders){
    // Add the method and uri
    StringBuilder canonicalRequest = new StringBuilder();
    canonicalRequest.append(method).append(NEW_LINE);
    String canonicalUri = CANONICALIZE_PATH.apply(uri);
    canonicalRequest.append(canonicalUri).append(NEW_LINE);
    // Get the query args, replace whitespace and values that should be not encoded, sort and rejoin
    String canonicalQuery = CANONICALIZE_QUERY.apply(queryString);
    canonicalRequest.append(canonicalQuery).append(NEW_LINE);
    // Normalize all the headers
    Header[] normalizedHeaders = NORMALIZE_HEADERS.apply(headers);
    Map<String, List<String>> combinedHeaders = COMBINE_HEADERS.apply(normalizedHeaders);
    // Add the headers that we care about
    for (String header : sortedIncludedHeaders) {
        String lowercase = header.toLowerCase().trim();
        if (combinedHeaders.containsKey(lowercase)) {
            List<String> values = combinedHeaders.get(lowercase);
            Collections.sort(values);
            canonicalRequest.append(lowercase).append("":"").append(String.join("","", values)).append(NEW_LINE);
        }
    }
    canonicalRequest.append(NEW_LINE);
    // Mark the headers that we care about
    canonicalRequest.append(String.join("";"", sortedIncludedHeaders)).append(NEW_LINE);
    // Hash and hex the request payload
    if (requestBody != null && !requestBody.isEmpty()) {
        String hashedPayload = DigestUtils.sha256Hex(requestBody);
        canonicalRequest.append(hashedPayload);
    }
    return canonicalRequest.toString();
}","public String create(List<String> sortedIncludedHeaders){
    // Add the method and uri
    StringBuilder canonicalRequest = new StringBuilder();
    canonicalRequest.append(method).append(NEW_LINE);
    String canonicalUri = CANONICALIZE_PATH.apply(uri);
    canonicalRequest.append(canonicalUri).append(NEW_LINE);
    // Get the query args, replace whitespace and values that should be not encoded, sort and rejoin
    String canonicalQuery = CANONICALIZE_QUERY.apply(queryString);
    canonicalRequest.append(canonicalQuery).append(NEW_LINE);
    // Normalize all the headers
    Header[] normalizedHeaders = NORMALIZE_HEADERS.apply(headers);
    Map<String, List<String>> combinedHeaders = COMBINE_HEADERS.apply(normalizedHeaders);
    // Add the headers that we care about
    for (String header : sortedIncludedHeaders) {
        String lowercase = header.toLowerCase().trim();
        if (combinedHeaders.containsKey(lowercase)) {
            List<String> values = combinedHeaders.get(lowercase);
            Collections.sort(values);
            canonicalRequest.append(lowercase).append("":"").append(String.join("","", values)).append(NEW_LINE);
        }
    }
    canonicalRequest.append(NEW_LINE);
    // Mark the headers that we care about
    canonicalRequest.append(String.join("";"", sortedIncludedHeaders)).append(NEW_LINE);
    // Hash and hex the request payload
    if (requestBody != null && !requestBody.isEmpty()) {
        String hashedPayload = DigestUtils.sha256Hex(requestBody);
        canonicalRequest.append(hashedPayload);
    }
    return canonicalRequest.toString();
}","/**
     * Creates a canonical request string out of HTTP request components.
     *
     * @param sortedIncludedHeaders the headers that should be included into canonical request string
     * @return a string representing the canonical request
     */","('create', {'INSTRUCTION': {'covered': 114, 'missed': 0}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",253.0,  Creates a canonical request string out of HTTP request components.,11.0,"['The string is created from the request components.', 'A string of request components is created.', 'The string is created from the request components of the internet.']"
957,cdk,org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/GeometricDoubleBondEncoderFactory.java,newEncoder,94-146,"/**
     * Create a new encoder for the specified left and right atoms. The parent
     * is the atom which is connected by a double bond to the left and right
     * atom. For simple double bonds the parent of each is the other atom, in
     * cumulenes the parents are not the same.
     *
     * @param container   the molecule
     * @param left        the left atom
     * @param leftParent  the left atoms parent (usually {@literal right})
     * @param right       the right atom
     * @param rightParent the right atoms parent (usually {@literal left})
     * @param graph       adjacency list representation of the molecule
     * @return a stereo encoder (or null)
     */
 static StereoEncoder newEncoder(IAtomContainer container, IAtom left, IAtom leftParent, IAtom right, IAtom rightParent, int[][] graph){
    List<IBond> leftBonds = container.getConnectedBondsList(left);
    List<IBond> rightBonds = container.getConnectedBondsList(right);
    if (accept(left, leftBonds) && accept(right, rightBonds)) {
        int leftIndex = container.indexOf(left);
        int rightIndex = container.indexOf(right);
        int leftParentIndex = container.indexOf(leftParent);
        int rightParentIndex = container.indexOf(rightParent);
        int[] leftNeighbors = moveToBack(graph[leftIndex], leftParentIndex);
        int[] rightNeighbors = moveToBack(graph[rightIndex], rightParentIndex);
        int l1 = leftNeighbors[0];
        int l2 = leftNeighbors[1] == leftParentIndex ? leftIndex : leftNeighbors[1];
        int r1 = rightNeighbors[0];
        int r2 = rightNeighbors[1] == rightParentIndex ? rightIndex : rightNeighbors[1];
        GeometricParity geometric = geometric(container, leftIndex, rightIndex, l1, l2, r1, r2);
        if (geometric != null) {
            return new GeometryEncoder(new int[] { leftIndex, rightIndex }, new CombinedPermutationParity(permutation(leftNeighbors), permutation(rightNeighbors)), geometric);
        }
    }
    return null;
}","static StereoEncoder newEncoder(IAtomContainer container, IAtom left, IAtom leftParent, IAtom right, IAtom rightParent, int[][] graph){
    List<IBond> leftBonds = container.getConnectedBondsList(left);
    List<IBond> rightBonds = container.getConnectedBondsList(right);
    if (accept(left, leftBonds) && accept(right, rightBonds)) {
        int leftIndex = container.indexOf(left);
        int rightIndex = container.indexOf(right);
        int leftParentIndex = container.indexOf(leftParent);
        int rightParentIndex = container.indexOf(rightParent);
        int[] leftNeighbors = moveToBack(graph[leftIndex], leftParentIndex);
        int[] rightNeighbors = moveToBack(graph[rightIndex], rightParentIndex);
        int l1 = leftNeighbors[0];
        int l2 = leftNeighbors[1] == leftParentIndex ? leftIndex : leftNeighbors[1];
        int r1 = rightNeighbors[0];
        int r2 = rightNeighbors[1] == rightParentIndex ? rightIndex : rightNeighbors[1];
        GeometricParity geometric = geometric(container, leftIndex, rightIndex, l1, l2, r1, r2);
        if (geometric != null) {
            return new GeometryEncoder(new int[] { leftIndex, rightIndex }, new CombinedPermutationParity(permutation(leftNeighbors), permutation(rightNeighbors)), geometric);
        }
    }
    return null;
}","/**
     * Create a new encoder for the specified left and right atoms. The parent
     * is the atom which is connected by a double bond to the left and right
     * atom. For simple double bonds the parent of each is the other atom, in
     * cumulenes the parents are not the same.
     *
     * @param container   the molecule
     * @param left        the left atom
     * @param leftParent  the left atoms parent (usually {@literal right})
     * @param right       the right atom
     * @param rightParent the right atoms parent (usually {@literal left})
     * @param graph       adjacency list representation of the molecule
     * @return a stereo encoder (or null)
     */","('newEncoder', {'INSTRUCTION': {'covered': 109, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 18, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",254.0,  Create a new encoder for the specified left and right atoms.,12.0,"['The left and right atoms are specified.', 'The specified left and right atoms should be used.', 'The specified left and right atoms need a new encoder.']"
959,openapi-generator,org/openapitools/codegen/InlineModelResolver.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/InlineModelResolver.java,flattenComposedChildren,348-412,"/**
     * Flattens properties of inline object schemas that belong to a composed schema into a
     * single flat list of properties. This is useful to generate a single or multiple
     * inheritance model.
     *
     * In the example below, codegen may generate a 'Dog' class that extends from the
     * generated 'Animal' class. 'Dog' has additional properties 'name', 'age' and 'breed' that
     * are flattened as a single list of properties.
     *
     * Dog:
     *   allOf:
     *     - $ref: '#/components/schemas/Animal'
     *     - type: object
     *       properties:
     *         name:
     *           type: string
     *         age:
     *           type: string
     *     - type: object
     *       properties:
     *         breed:
     *           type: string
     *
     * @param openAPI the OpenAPI document
     * @param key a unique name ofr the composed schema.
     * @param children the list of nested schemas within a composed schema (allOf, anyOf, oneOf).
     */
private void flattenComposedChildren(OpenAPI openAPI, String key, List<Schema> children){
    if (children == null || children.isEmpty()) {
        return;
    }
    ListIterator<Schema> listIterator = children.listIterator();
    while (listIterator.hasNext()) {
        Schema component = listIterator.next();
        if ((component != null) && (component.get$ref() == null) && ((component.getProperties() != null && !component.getProperties().isEmpty()) || (component.getEnum() != null && !component.getEnum().isEmpty()))) {
            String innerModelName = resolveModelName(component.getTitle(), key);
            Schema innerModel = modelFromProperty(openAPI, component, innerModelName);
            String existing = matchGenerated(innerModel);
            if (existing == null) {
                openAPI.getComponents().addSchemas(innerModelName, innerModel);
                addGenerated(innerModelName, innerModel);
                Schema schema = new Schema().$ref(innerModelName);
                schema.setRequired(component.getRequired());
                listIterator.set(schema);
            } else {
                Schema schema = new Schema().$ref(existing);
                schema.setRequired(component.getRequired());
                listIterator.set(schema);
            }
        }
    }
}","private void flattenComposedChildren(OpenAPI openAPI, String key, List<Schema> children){
    if (children == null || children.isEmpty()) {
        return;
    }
    ListIterator<Schema> listIterator = children.listIterator();
    while (listIterator.hasNext()) {
        Schema component = listIterator.next();
        if ((component != null) && (component.get$ref() == null) && ((component.getProperties() != null && !component.getProperties().isEmpty()) || (component.getEnum() != null && !component.getEnum().isEmpty()))) {
            String innerModelName = resolveModelName(component.getTitle(), key);
            Schema innerModel = modelFromProperty(openAPI, component, innerModelName);
            String existing = matchGenerated(innerModel);
            if (existing == null) {
                openAPI.getComponents().addSchemas(innerModelName, innerModel);
                addGenerated(innerModelName, innerModel);
                Schema schema = new Schema().$ref(innerModelName);
                schema.setRequired(component.getRequired());
                listIterator.set(schema);
            } else {
                Schema schema = new Schema().$ref(existing);
                schema.setRequired(component.getRequired());
                listIterator.set(schema);
            }
        }
    }
}","/**
     * Flattens properties of inline object schemas that belong to a composed schema into a
     * single flat list of properties. This is useful to generate a single or multiple
     * inheritance model.
     *
     * In the example below, codegen may generate a 'Dog' class that extends from the
     * generated 'Animal' class. 'Dog' has additional properties 'name', 'age' and 'breed' that
     * are flattened as a single list of properties.
     *
     * Dog:
     *   allOf:
     *     - $ref: '#/components/schemas/Animal'
     *     - type: object
     *       properties:
     *         name:
     *           type: string
     *         age:
     *           type: string
     *     - type: object
     *       properties:
     *         breed:
     *           type: string
     *
     * @param openAPI the OpenAPI document
     * @param key a unique name ofr the composed schema.
     * @param children the list of nested schemas within a composed schema (allOf, anyOf, oneOf).
     */","('flattenComposedChildren', {'INSTRUCTION': {'covered': 88, 'missed': 4}, 'BRANCH': {'covered': 14, 'missed': 6}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",256.0,  Flattens properties of inline object schemas that belong to a composed schema into a  single flat list of properties.,20.0,"['Flatten the properties of inline object schemas into a single list.', 'Flatten the properties of inline object schemas into a single flat list.', 'Flatten the properties of inline objects in a single list.']"
960,logstash-logback-encoder,net/logstash/logback/appender/AsyncDisruptorAppender.java,/src/main/java/net/logstash/logback/appender/AsyncDisruptorAppender.java,enqueue,534-600,"/**
     * Enqueue an event in the ring buffer, retrying if allowed by the configuration.
     * 
     * @param event the event to add to the ring buffer
     * @return {@code true} if the event is successfully enqueued, {@code false} if the event
     *         could not be added to the ring buffer.
     * @throws ShutdownInProgressException thrown when the appender is shutdown while retrying
     *         to enqueue the event
     * @throws InterruptedException thrown when the logging thread is interrupted while retrying
     */
private boolean enqueue(Event event) throws ShutdownInProgressException, InterruptedException{
    if (this.disruptor.getRingBuffer().tryPublishEvent(this.eventTranslator, event)) {
        return true;
    }
    if (this.appendTimeout.getMilliseconds() == 0) {
        return false;
    }
    long deadline = Long.MAX_VALUE;
    if (this.appendTimeout.getMilliseconds() < 0) {
        lock.lockInterruptibly();
    } else {
        deadline = System.currentTimeMillis() + this.appendTimeout.getMilliseconds();
        if (!lock.tryLock(this.appendTimeout.getMilliseconds(), TimeUnit.MILLISECONDS)) {
            return false;
        }
    }
    long backoff = 1L;
    long backoffLimit = TimeUnit.MILLISECONDS.toNanos(this.appendRetryFrequency.getMilliseconds());
    try {
        do {
            if (!isStarted()) {
                throw new ShutdownInProgressException();
            }
            if (deadline <= System.currentTimeMillis()) {
                return false;
            }
            if (Thread.currentThread().isInterrupted()) {
                throw new InterruptedException();
            }
            LockSupport.parkNanos(backoff);
            backoff = Math.min(backoff * 2, backoffLimit);
        } while (!this.disruptor.getRingBuffer().tryPublishEvent(this.eventTranslator, event));
        return true;
    } finally {
        lock.unlock();
    }
}","private boolean enqueue(Event event) throws ShutdownInProgressException, InterruptedException{
    if (this.disruptor.getRingBuffer().tryPublishEvent(this.eventTranslator, event)) {
        return true;
    }
    if (this.appendTimeout.getMilliseconds() == 0) {
        return false;
    }
    long deadline = Long.MAX_VALUE;
    if (this.appendTimeout.getMilliseconds() < 0) {
        lock.lockInterruptibly();
    } else {
        deadline = System.currentTimeMillis() + this.appendTimeout.getMilliseconds();
        if (!lock.tryLock(this.appendTimeout.getMilliseconds(), TimeUnit.MILLISECONDS)) {
            return false;
        }
    }
    long backoff = 1L;
    long backoffLimit = TimeUnit.MILLISECONDS.toNanos(this.appendRetryFrequency.getMilliseconds());
    try {
        do {
            if (!isStarted()) {
                throw new ShutdownInProgressException();
            }
            if (deadline <= System.currentTimeMillis()) {
                return false;
            }
            if (Thread.currentThread().isInterrupted()) {
                throw new InterruptedException();
            }
            LockSupport.parkNanos(backoff);
            backoff = Math.min(backoff * 2, backoffLimit);
        } while (!this.disruptor.getRingBuffer().tryPublishEvent(this.eventTranslator, event));
        return true;
    } finally {
        lock.unlock();
    }
}","/**
     * Enqueue an event in the ring buffer, retrying if allowed by the configuration.
     * 
     * @param event the event to add to the ring buffer
     * @return {@code true} if the event is successfully enqueued, {@code false} if the event
     *         could not be added to the ring buffer.
     * @throws ShutdownInProgressException thrown when the appender is shutdown while retrying
     *         to enqueue the event
     * @throws InterruptedException thrown when the logging thread is interrupted while retrying
     */","('enqueue', {'INSTRUCTION': {'covered': 93, 'missed': 6}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 21, 'missed': 2}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",257.0,"  Enqueue an event in the ring buffer, retrying if allowed by the configuration.",15.0,"['If allowed by the configuration, you can queue an event in the ring buffer.', 'If allowed by the configuration, you can enqueue an event in the ring buffer.', 'If allowed by the configuration, queue an event in the ring buffer.']"
961,openapi-generator,org/openapitools/codegen/DefaultGenerator.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java,addAuthenticationSwitches,804-844,"/**
     * Add authentication methods to the given map
     * This adds a boolean and a collection for each authentication type to the map.
     * <p>
     * Examples:
     * <p> 
     *   boolean hasOAuthMethods
     * <p>
     *   List&lt;CodegenSecurity&gt; oauthMethods
     *
     * @param bundle the map which the booleans and collections will be added
     */
 void addAuthenticationSwitches(Map<String, Object> bundle){
    Map<String, SecurityScheme> securitySchemeMap = openAPI.getComponents() != null ? openAPI.getComponents().getSecuritySchemes() : null;
    List<CodegenSecurity> authMethods = config.fromSecurity(securitySchemeMap);
    if (authMethods != null && !authMethods.isEmpty()) {
        bundle.put(""authMethods"", authMethods);
        bundle.put(""hasAuthMethods"", true);
        if (ProcessUtils.hasOAuthMethods(authMethods)) {
            bundle.put(""hasOAuthMethods"", true);
            bundle.put(""oauthMethods"", ProcessUtils.getOAuthMethods(authMethods));
        }
        if (ProcessUtils.hasHttpBearerMethods(authMethods)) {
            bundle.put(""hasHttpBearerMethods"", true);
            bundle.put(""httpBearerMethods"", ProcessUtils.getHttpBearerMethods(authMethods));
        }
        if (ProcessUtils.hasHttpSignatureMethods(authMethods)) {
            bundle.put(""hasHttpSignatureMethods"", true);
            bundle.put(""httpSignatureMethods"", ProcessUtils.getHttpSignatureMethods(authMethods));
        }
        if (ProcessUtils.hasHttpBasicMethods(authMethods)) {
            bundle.put(""hasHttpBasicMethods"", true);
            bundle.put(""httpBasicMethods"", ProcessUtils.getHttpBasicMethods(authMethods));
        }
        if (ProcessUtils.hasApiKeyMethods(authMethods)) {
            bundle.put(""hasApiKeyMethods"", true);
            bundle.put(""apiKeyMethods"", ProcessUtils.getApiKeyMethods(authMethods));
        }
    }
}"," void addAuthenticationSwitches(Map<String, Object> bundle){
    Map<String, SecurityScheme> securitySchemeMap = openAPI.getComponents() != null ? openAPI.getComponents().getSecuritySchemes() : null;
    List<CodegenSecurity> authMethods = config.fromSecurity(securitySchemeMap);
    if (authMethods != null && !authMethods.isEmpty()) {
        bundle.put(""authMethods"", authMethods);
        bundle.put(""hasAuthMethods"", true);
        if (ProcessUtils.hasOAuthMethods(authMethods)) {
            bundle.put(""hasOAuthMethods"", true);
            bundle.put(""oauthMethods"", ProcessUtils.getOAuthMethods(authMethods));
        }
        if (ProcessUtils.hasHttpBearerMethods(authMethods)) {
            bundle.put(""hasHttpBearerMethods"", true);
            bundle.put(""httpBearerMethods"", ProcessUtils.getHttpBearerMethods(authMethods));
        }
        if (ProcessUtils.hasHttpSignatureMethods(authMethods)) {
            bundle.put(""hasHttpSignatureMethods"", true);
            bundle.put(""httpSignatureMethods"", ProcessUtils.getHttpSignatureMethods(authMethods));
        }
        if (ProcessUtils.hasHttpBasicMethods(authMethods)) {
            bundle.put(""hasHttpBasicMethods"", true);
            bundle.put(""httpBasicMethods"", ProcessUtils.getHttpBasicMethods(authMethods));
        }
        if (ProcessUtils.hasApiKeyMethods(authMethods)) {
            bundle.put(""hasApiKeyMethods"", true);
            bundle.put(""apiKeyMethods"", ProcessUtils.getApiKeyMethods(authMethods));
        }
    }
}","/**
     * Add authentication methods to the given map
     * This adds a boolean and a collection for each authentication type to the map.
     * <p>
     * Examples:
     * <p> 
     *   boolean hasOAuthMethods
     * <p>
     *   List&lt;CodegenSecurity&gt; oauthMethods
     *
     * @param bundle the map which the booleans and collections will be added
     */","('addAuthenticationSwitches', {'INSTRUCTION': {'covered': 83, 'missed': 25}, 'BRANCH': {'covered': 12, 'missed': 4}, 'LINE': {'covered': 17, 'missed': 4}, 'COMPLEXITY': {'covered': 5, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",257.0,  Add authentication methods to the given map  This adds a boolean and a collection for each authentication type to the map.,22.0,"['This adds a collection and a boolean for each type ofAuthentication to the map.', 'This adds a collection and a boolean to the map.', 'This adds a collection and a boolean to the map for each type ofAuthentication.']"
962,cdk,org/openscience/cdk/qsar/descriptors/atomic/PartialSigmaChargeDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/PartialSigmaChargeDescriptor.java,calculate,120-152,"/**
     *  The method returns apha partial charges assigned to an heavy atom through Gasteiger Marsili
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *  For this method will be only possible if the heavy atom has single bond.
     *
     *@param  atom              The IAtom for which the DescriptorValue is requested
     *@param  ac                AtomContainer
     *@return                   Value of the alpha partial charge
     */
public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
    if (!isCachedAtomContainer(ac)) {
        Double[] org = new Double[ac.getAtomCount()];
        for (int i = 0; i < org.length; i++) org[i] = ac.getAtom(i).getCharge();
        IAtomContainer mol = atom.getBuilder().newInstance(IAtomContainer.class, ac);
        if (maxIterations != 0)
            peoe.setMaxGasteigerIters(maxIterations);
        try {
            peoe.assignGasteigerMarsiliSigmaPartialCharges(mol, true);
            for (int i = 0; i < ac.getAtomCount(); i++) {
                cacheDescriptorValue(ac.getAtom(i), ac, new DoubleResult(mol.getAtom(i).getCharge()));
            }
        } catch (Exception e) {
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(Double.NaN), NAMES, e);
        }
        for (int i = 0; i < org.length; i++) mol.getAtom(i).setCharge(org[i]);
    }
    return getCachedDescriptorValue(atom) != null ? new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), getCachedDescriptorValue(atom), NAMES) : null;
}","public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
    if (!isCachedAtomContainer(ac)) {
        Double[] org = new Double[ac.getAtomCount()];
        for (int i = 0; i < org.length; i++) org[i] = ac.getAtom(i).getCharge();
        IAtomContainer mol = atom.getBuilder().newInstance(IAtomContainer.class, ac);
        if (maxIterations != 0)
            peoe.setMaxGasteigerIters(maxIterations);
        try {
            peoe.assignGasteigerMarsiliSigmaPartialCharges(mol, true);
            for (int i = 0; i < ac.getAtomCount(); i++) {
                cacheDescriptorValue(ac.getAtom(i), ac, new DoubleResult(mol.getAtom(i).getCharge()));
            }
        } catch (Exception e) {
            return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(Double.NaN), NAMES, e);
        }
        for (int i = 0; i < org.length; i++) mol.getAtom(i).setCharge(org[i]);
    }
    return getCachedDescriptorValue(atom) != null ? new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), getCachedDescriptorValue(atom), NAMES) : null;
}","/**
     *  The method returns apha partial charges assigned to an heavy atom through Gasteiger Marsili
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *  For this method will be only possible if the heavy atom has single bond.
     *
     *@param  atom              The IAtom for which the DescriptorValue is requested
     *@param  ac                AtomContainer
     *@return                   Value of the alpha partial charge
     */","('calculate', {'INSTRUCTION': {'covered': 107, 'missed': 18}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 14, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",259.0,  The method returns apha partial charges assigned to an heavy atom through Gasteiger Marsili  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.,27.0,"['The class tools need to be used to call the addExplicitHydrogensToSatisfyValency method.', 'The class tools need to be used to call the addExplicitHydrogensToSatisfyValency method from the method.', 'The method returns partial charges assigned to an heavy atom through Gasteiger Marsili.']"
963,cron-utils,com/cronutils/mapper/CronMapper.java,/src/main/java/com/cronutils/mapper/CronMapper.java,buildMappings,175-217,"/**
     * Builds functions that map the fields from source CronDefinition to target.
     *
     * @param from - source CronDefinition
     * @param to   - target CronDefinition
     */
private void buildMappings(final CronDefinition from, final CronDefinition to){
    final Map<CronFieldName, FieldDefinition> sourceFieldDefinitions = getFieldDefinitions(from);
    final Map<CronFieldName, FieldDefinition> destFieldDefinitions = getFieldDefinitions(to);
    boolean startedDestMapping = false;
    boolean startedSourceMapping = false;
    for (final CronFieldName name : CronFieldName.values()) {
        final FieldDefinition destinationFieldDefinition = destFieldDefinitions.get(name);
        final FieldDefinition sourceFieldDefinition = sourceFieldDefinitions.get(name);
        if (destinationFieldDefinition != null) {
            startedDestMapping = true;
        }
        if (sourceFieldDefinition != null) {
            startedSourceMapping = true;
        }
        if (startedDestMapping && destinationFieldDefinition == null) {
            break;
        }
        if (!startedSourceMapping && destinationFieldDefinition != null) {
            mappings.put(name, returnOnZeroExpression(name));
        }
        if (startedSourceMapping && sourceFieldDefinition == null && destinationFieldDefinition != null) {
            mappings.put(name, returnAlwaysExpression(name));
        }
        if (sourceFieldDefinition == null || destinationFieldDefinition == null) {
            continue;
        }
        if (CronFieldName.DAY_OF_WEEK.equals(name)) {
            mappings.put(name, dayOfWeekMapping((DayOfWeekFieldDefinition) sourceFieldDefinition, (DayOfWeekFieldDefinition) destinationFieldDefinition));
        } else if (CronFieldName.DAY_OF_MONTH.equals(name)) {
            mappings.put(name, dayOfMonthMapping(sourceFieldDefinition, destinationFieldDefinition));
        } else {
            mappings.put(name, returnSameExpression());
        }
    }
}","private void buildMappings(final CronDefinition from, final CronDefinition to){
    final Map<CronFieldName, FieldDefinition> sourceFieldDefinitions = getFieldDefinitions(from);
    final Map<CronFieldName, FieldDefinition> destFieldDefinitions = getFieldDefinitions(to);
    boolean startedDestMapping = false;
    boolean startedSourceMapping = false;
    for (final CronFieldName name : CronFieldName.values()) {
        final FieldDefinition destinationFieldDefinition = destFieldDefinitions.get(name);
        final FieldDefinition sourceFieldDefinition = sourceFieldDefinitions.get(name);
        if (destinationFieldDefinition != null) {
            startedDestMapping = true;
        }
        if (sourceFieldDefinition != null) {
            startedSourceMapping = true;
        }
        if (startedDestMapping && destinationFieldDefinition == null) {
            break;
        }
        if (!startedSourceMapping && destinationFieldDefinition != null) {
            mappings.put(name, returnOnZeroExpression(name));
        }
        if (startedSourceMapping && sourceFieldDefinition == null && destinationFieldDefinition != null) {
            mappings.put(name, returnAlwaysExpression(name));
        }
        if (sourceFieldDefinition == null || destinationFieldDefinition == null) {
            continue;
        }
        if (CronFieldName.DAY_OF_WEEK.equals(name)) {
            mappings.put(name, dayOfWeekMapping((DayOfWeekFieldDefinition) sourceFieldDefinition, (DayOfWeekFieldDefinition) destinationFieldDefinition));
        } else if (CronFieldName.DAY_OF_MONTH.equals(name)) {
            mappings.put(name, dayOfMonthMapping(sourceFieldDefinition, destinationFieldDefinition));
        } else {
            mappings.put(name, returnSameExpression());
        }
    }
}","/**
     * Builds functions that map the fields from source CronDefinition to target.
     *
     * @param from - source CronDefinition
     * @param to   - target CronDefinition
     */","('buildMappings', {'INSTRUCTION': {'covered': 115, 'missed': 0}, 'BRANCH': {'covered': 26, 'missed': 2}, 'LINE': {'covered': 25, 'missed': 0}, 'COMPLEXITY': {'covered': 13, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",262.0,  Builds functions that map the fields from source CronDefinition to target.,12.0,"['The functions map the fields from source to target.', 'Functions that map the fields from source to target were built.', 'Functions that map the fields from source to target are built.']"
964,cdk,org/openscience/cdk/formula/rules/ElementRule.java,/tool/formula/src/main/java/org/openscience/cdk/formula/rules/ElementRule.java,ensureDefaultOccurElements,128-145,"/**
     * Initiate the MolecularFormulaExpand with the maximum and minimum occurrence of the Elements.
     * In this case all elements of the periodic table are loaded.
     */
private void ensureDefaultOccurElements(IChemObjectBuilder builder){
    if (mfRange == null) {
        String[] elements = new String[] { ""C"", ""H"", ""O"", ""N"", ""Si"", ""P"", ""S"", ""F"", ""Cl"", ""Br"", ""I"", ""Sn"", ""B"", ""Pb"", ""Tl"", ""Ba"", ""In"", ""Pd"", ""Pt"", ""Os"", ""Ag"", ""Zr"", ""Se"", ""Zn"", ""Cu"", ""Ni"", ""Co"", ""Fe"", ""Cr"", ""Ti"", ""Ca"", ""K"", ""Al"", ""Mg"", ""Na"", ""Ce"", ""Hg"", ""Au"", ""Ir"", ""Re"", ""W"", ""Ta"", ""Hf"", ""Lu"", ""Yb"", ""Tm"", ""Er"", ""Ho"", ""Dy"", ""Tb"", ""Gd"", ""Eu"", ""Sm"", ""Pm"", ""Nd"", ""Pr"", ""La"", ""Cs"", ""Xe"", ""Te"", ""Sb"", ""Cd"", ""Rh"", ""Ru"", ""Tc"", ""Mo"", ""Nb"", ""Y"", ""Sr"", ""Rb"", ""Kr"", ""As"", ""Ge"", ""Ga"", ""Mn"", ""V"", ""Sc"", ""Ar"", ""Ne"", ""Be"", ""Li"", ""Tl"", ""Pb"", ""Bi"", ""Po"", ""At"", ""Rn"", ""Fr"", ""Ra"", ""Ac"", ""Th"", ""Pa"", ""U"", ""Np"", ""Pu"" };
        mfRange = new MolecularFormulaRange();
        for (int i = 0; i < elements.length; i++) mfRange.addIsotope(builder.newInstance(IIsotope.class, elements[i]), 0, 50);
    }
}","private void ensureDefaultOccurElements(IChemObjectBuilder builder){
    if (mfRange == null) {
        String[] elements = new String[] { ""C"", ""H"", ""O"", ""N"", ""Si"", ""P"", ""S"", ""F"", ""Cl"", ""Br"", ""I"", ""Sn"", ""B"", ""Pb"", ""Tl"", ""Ba"", ""In"", ""Pd"", ""Pt"", ""Os"", ""Ag"", ""Zr"", ""Se"", ""Zn"", ""Cu"", ""Ni"", ""Co"", ""Fe"", ""Cr"", ""Ti"", ""Ca"", ""K"", ""Al"", ""Mg"", ""Na"", ""Ce"", ""Hg"", ""Au"", ""Ir"", ""Re"", ""W"", ""Ta"", ""Hf"", ""Lu"", ""Yb"", ""Tm"", ""Er"", ""Ho"", ""Dy"", ""Tb"", ""Gd"", ""Eu"", ""Sm"", ""Pm"", ""Nd"", ""Pr"", ""La"", ""Cs"", ""Xe"", ""Te"", ""Sb"", ""Cd"", ""Rh"", ""Ru"", ""Tc"", ""Mo"", ""Nb"", ""Y"", ""Sr"", ""Rb"", ""Kr"", ""As"", ""Ge"", ""Ga"", ""Mn"", ""V"", ""Sc"", ""Ar"", ""Ne"", ""Be"", ""Li"", ""Tl"", ""Pb"", ""Bi"", ""Po"", ""At"", ""Rn"", ""Fr"", ""Ra"", ""Ac"", ""Th"", ""Pa"", ""U"", ""Np"", ""Pu"" };
        mfRange = new MolecularFormulaRange();
        for (int i = 0; i < elements.length; i++) mfRange.addIsotope(builder.newInstance(IIsotope.class, elements[i]), 0, 50);
    }
}","/**
     * Initiate the MolecularFormulaExpand with the maximum and minimum occurrence of the Elements.
     * In this case all elements of the periodic table are loaded.
     */","('ensureDefaultOccurElements', {'INSTRUCTION': {'covered': 417, 'missed': 0}, 'BRANCH': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 6, 'missed': 0}, 'COMPLEXITY': {'covered': 3, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",264.0,  Initiate the MolecularFormulaExpand with the maximum and minimum occurrence of the Elements.,13.0,"['The maximum and minimum occurrence of the Elements is what the MolecularFormulaExpand should start with.', 'The maximum and minimum occurrence of the Elements is what the MolecularFormulaExpand should be initiated with.', 'The maximum and minimum occurrence of the Elements is what the MolecularFormulaExpand should be started with.']"
965,glowstone,net/glowstone/util/nbt/CompoundTag.java,/src/main/java/net/glowstone/util/nbt/CompoundTag.java,matches,85-125,"/**
     * Checks to see if this tag is a strict, deep submap of the given CompoundTag.
     *
     * @param other The CompoundTag that should contain our values.
     */
public boolean matches(CompoundTag other){
    for (Entry<String, Tag> entry : value.entrySet()) {
        if (!other.value.containsKey(entry.getKey())) {
            return false;
        }
        Tag value = entry.getValue();
        Tag otherValue = other.value.get(entry.getKey());
        if ((value == null && otherValue != null) || (value != null && otherValue == null)) {
            return false;
        }
        if (value != null) {
            if (value.getClass() != otherValue.getClass()) {
                return false;
            }
            if (value instanceof CompoundTag) {
                if (!((CompoundTag) value).matches((CompoundTag) otherValue)) {
                    return false;
                }
            } else if (value instanceof IntArrayTag) {
                if (!Arrays.equals(((IntArrayTag) value).getValue(), ((IntArrayTag) otherValue).getValue())) {
                    return false;
                }
            } else if (value instanceof ByteArrayTag) {
                if (!Arrays.equals(((ByteArrayTag) value).getValue(), ((ByteArrayTag) otherValue).getValue())) {
                    return false;
                }
            } else if (!value.equals(otherValue)) {
                return false;
            }
        }
    }
    return true;
}","public boolean matches(CompoundTag other){
    for (Entry<String, Tag> entry : value.entrySet()) {
        if (!other.value.containsKey(entry.getKey())) {
            return false;
        }
        Tag value = entry.getValue();
        Tag otherValue = other.value.get(entry.getKey());
        if ((value == null && otherValue != null) || (value != null && otherValue == null)) {
            return false;
        }
        if (value != null) {
            if (value.getClass() != otherValue.getClass()) {
                return false;
            }
            if (value instanceof CompoundTag) {
                if (!((CompoundTag) value).matches((CompoundTag) otherValue)) {
                    return false;
                }
            } else if (value instanceof IntArrayTag) {
                if (!Arrays.equals(((IntArrayTag) value).getValue(), ((IntArrayTag) otherValue).getValue())) {
                    return false;
                }
            } else if (value instanceof ByteArrayTag) {
                if (!Arrays.equals(((ByteArrayTag) value).getValue(), ((ByteArrayTag) otherValue).getValue())) {
                    return false;
                }
            } else if (!value.equals(otherValue)) {
                return false;
            }
        }
    }
    return true;
}","/**
     * Checks to see if this tag is a strict, deep submap of the given CompoundTag.
     *
     * @param other The CompoundTag that should contain our values.
     */","('matches', {'INSTRUCTION': {'covered': 80, 'missed': 16}, 'BRANCH': {'covered': 18, 'missed': 12}, 'LINE': {'covered': 18, 'missed': 7}, 'COMPLEXITY': {'covered': 5, 'missed': 11}, 'METHOD': {'covered': 1, 'missed': 0}})",265.0,"  Checks to see if this tag is a strict, deep submap of the given CompoundTag.",17.0,"['If this tag is a strict, deep submap of the CompoundTag, we need to check it out.', 'If this tag is a strict, deep submap of the CompoundTag, we need to check it.', 'If this tag is a strict, deep submap of the CompoundTag, then we need to check it out.']"
967,soul,org/apache/shenyu/plugin/base/AbstractShenyuPlugin.java,/shenyu-plugin/shenyu-plugin-base/src/main/java/org/apache/shenyu/plugin/base/AbstractShenyuPlugin.java,execute,56-96,"/**
     * Process the Web request and (optionally) delegate to the next
     * {@code ShenyuPlugin} through the given {@link ShenyuPluginChain}.
     *
     * @param exchange the current server exchange
     * @param chain    provides a way to delegate to the next plugin
     * @return {@code Mono<Void>} to indicate when request processing is complete
     */
public Mono<Void> execute(final ServerWebExchange exchange, final ShenyuPluginChain chain){
    String pluginName = named();
    PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName);
    if (pluginData != null && pluginData.getEnabled()) {
        final Collection<SelectorData> selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName);
        if (CollectionUtils.isEmpty(selectors)) {
            return handleSelectorIfNull(pluginName, exchange, chain);
        }
        SelectorData selectorData = matchSelector(exchange, selectors);
        if (Objects.isNull(selectorData)) {
            return handleSelectorIfNull(pluginName, exchange, chain);
        }
        selectorLog(selectorData, pluginName);
        List<RuleData> rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId());
        if (CollectionUtils.isEmpty(rules)) {
            return handleRuleIfNull(pluginName, exchange, chain);
        }
        RuleData rule;
        if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) {
            // get last
            rule = rules.get(rules.size() - 1);
        } else {
            rule = matchRule(exchange, rules);
        }
        if (Objects.isNull(rule)) {
            return handleRuleIfNull(pluginName, exchange, chain);
        }
        ruleLog(rule, pluginName);
        return doExecute(exchange, chain, selectorData, rule);
    }
    return chain.execute(exchange);
}","public Mono<Void> execute(final ServerWebExchange exchange, final ShenyuPluginChain chain){
    String pluginName = named();
    PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName);
    if (pluginData != null && pluginData.getEnabled()) {
        final Collection<SelectorData> selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName);
        if (CollectionUtils.isEmpty(selectors)) {
            return handleSelectorIfNull(pluginName, exchange, chain);
        }
        SelectorData selectorData = matchSelector(exchange, selectors);
        if (Objects.isNull(selectorData)) {
            return handleSelectorIfNull(pluginName, exchange, chain);
        }
        selectorLog(selectorData, pluginName);
        List<RuleData> rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId());
        if (CollectionUtils.isEmpty(rules)) {
            return handleRuleIfNull(pluginName, exchange, chain);
        }
        RuleData rule;
        if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) {
            // get last
            rule = rules.get(rules.size() - 1);
        } else {
            rule = matchRule(exchange, rules);
        }
        if (Objects.isNull(rule)) {
            return handleRuleIfNull(pluginName, exchange, chain);
        }
        ruleLog(rule, pluginName);
        return doExecute(exchange, chain, selectorData, rule);
    }
    return chain.execute(exchange);
}","/**
     * Process the Web request and (optionally) delegate to the next
     * {@code ShenyuPlugin} through the given {@link ShenyuPluginChain}.
     *
     * @param exchange the current server exchange
     * @param chain    provides a way to delegate to the next plugin
     * @return {@code Mono<Void>} to indicate when request processing is complete
     */","('execute', {'INSTRUCTION': {'covered': 80, 'missed': 22}, 'BRANCH': {'covered': 9, 'missed': 5}, 'LINE': {'covered': 17, 'missed': 4}, 'COMPLEXITY': {'covered': 3, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",267.0,  Process the Web request and (optionally) delegate to the next  {@code ShenyuPlugin} through the given {@link ShenyuPluginChain}.,26.0,"['If you want to delegate to the next @code ShenyuPlugin through the given @link ShenyuPluginChain, Process the Web request.', 'If you want to delegate to the next @code ShenyuPlugin through the given @link ShenyuPluginChain, Process the Web request first.', 'You can delegate to the next @code ShenyuPlugin through the given @link ShenyuPluginChain.']"
968,cdk,org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,calculate3DCoordinates3,496-552,"/**
     *  Calculate new point X in a B-A(-D)-C system. It forms a B-A(-D)(-C)-X
     *  system. (3) 3 ligands(B, C, D) of refAtom A (i) 1 points required; if A, B,
     *  C, D coplanar, no points. else vector is resultant of BA, CA, DA
     *
     *@param  aPoint  to which substituents are added
     *@param  bPoint  first ligand of A
     *@param  cPoint  second ligand of A
     *@param  dPoint  third ligand of A
     *@param  length  A-X length
     *@return         Point3d nwanted points (or null if failed (coplanar))
     */
public Point3d calculate3DCoordinates3(Point3d aPoint, Point3d bPoint, Point3d cPoint, Point3d dPoint, double length){
    Vector3d bc = new Vector3d(bPoint);
    bc.sub(cPoint);
    Vector3d dc = new Vector3d(dPoint);
    dc.sub(cPoint);
    Vector3d ca = new Vector3d(cPoint);
    ca.sub(aPoint);
    Vector3d n1 = new Vector3d();
    Vector3d n2 = new Vector3d();
    n1.cross(bc, dc);
    n1.normalize();
    n1.scale(length);
    Vector3d ax = new Vector3d(aPoint);
    ax.add(n1);
    ax.sub(aPoint);
    Vector3d ax2 = new Vector3d(aPoint);
    ax2.add(n2);
    ax2.sub(aPoint);
    Point3d point = new Point3d(aPoint);
    double dotProduct = ca.dot(ax);
    double angle = Math.acos((dotProduct) / (ax.length() * ca.length()));
    if (angle < 1.5) {
        n2.cross(dc, bc);
        n2.normalize();
        n2.scale(length);
        point.add(n2);
    } else {
        point.add(n1);
    }
    bc = null;
    dc = null;
    ca = null;
    n1 = null;
    n2 = null;
    return point;
}","public Point3d calculate3DCoordinates3(Point3d aPoint, Point3d bPoint, Point3d cPoint, Point3d dPoint, double length){
    Vector3d bc = new Vector3d(bPoint);
    bc.sub(cPoint);
    Vector3d dc = new Vector3d(dPoint);
    dc.sub(cPoint);
    Vector3d ca = new Vector3d(cPoint);
    ca.sub(aPoint);
    Vector3d n1 = new Vector3d();
    Vector3d n2 = new Vector3d();
    n1.cross(bc, dc);
    n1.normalize();
    n1.scale(length);
    Vector3d ax = new Vector3d(aPoint);
    ax.add(n1);
    ax.sub(aPoint);
    Vector3d ax2 = new Vector3d(aPoint);
    ax2.add(n2);
    ax2.sub(aPoint);
    Point3d point = new Point3d(aPoint);
    double dotProduct = ca.dot(ax);
    double angle = Math.acos((dotProduct) / (ax.length() * ca.length()));
    if (angle < 1.5) {
        n2.cross(dc, bc);
        n2.normalize();
        n2.scale(length);
        point.add(n2);
    } else {
        point.add(n1);
    }
    bc = null;
    dc = null;
    ca = null;
    n1 = null;
    n2 = null;
    return point;
}","/**
     *  Calculate new point X in a B-A(-D)-C system. It forms a B-A(-D)(-C)-X
     *  system. (3) 3 ligands(B, C, D) of refAtom A (i) 1 points required; if A, B,
     *  C, D coplanar, no points. else vector is resultant of BA, CA, DA
     *
     *@param  aPoint  to which substituents are added
     *@param  bPoint  first ligand of A
     *@param  cPoint  second ligand of A
     *@param  dPoint  third ligand of A
     *@param  length  A-X length
     *@return         Point3d nwanted points (or null if failed (coplanar))
     */","('calculate3DCoordinates3', {'INSTRUCTION': {'covered': 100, 'missed': 13}, 'BRANCH': {'covered': 1, 'missed': 1}, 'LINE': {'covered': 28, 'missed': 4}, 'COMPLEXITY': {'covered': 1, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",268.0,  Calculate new point X in a B-A(-D)-C system.,13.0,"['In a B-A(-D)-C system, calculate the new point X.', 'In a B-A(-D)-C system, calculate the new point.', 'A B-A(-D)-C system is used to calculate new point X.']"
970,acs-aem-commons,com/adobe/acs/commons/users/impl/EnsureAce.java,/bundle/src/main/java/com/adobe/acs/commons/users/impl/EnsureAce.java,findAcls,225-271,"/**
     * Locates by query all the ACLs that the principal participates in.
     *
     * @param resourceResolver     the resource resolver to perform the user management
     * @param principalName        the principal name
     * @param accessControlManager Jackrabbit access control manager
     * @return a list of ACLs that principal participates in.
     */
private List<JackrabbitAccessControlList> findAcls(ResourceResolver resourceResolver, String principalName, JackrabbitAccessControlManager accessControlManager){
    final Set<String> paths = new HashSet<String>();
    final List<JackrabbitAccessControlList> acls = new ArrayList<JackrabbitAccessControlList>();
    final Map<String, String> params = new HashMap<String, String>();
    params.put(""type"", PROP_NT_REP_ACE);
    params.put(""property"", PROP_REP_PRINCIPAL_NAME);
    params.put(""property.value"", principalName);
    params.put(""p.limit"", ""-1"");
    Query query = queryBuilder.createQuery(PredicateGroup.create(params), resourceResolver.adaptTo(Session.class));
    QueryUtil.setResourceResolverOn(resourceResolver, query);
    for (final Hit hit : query.getResult().getHits()) {
        try {
            final Resource aceResource = resourceResolver.getResource(hit.getPath());
            final Resource contentResource = aceResource.getParent().getParent();
            if (!paths.contains(contentResource.getPath())) {
                paths.add(contentResource.getPath());
                for (AccessControlPolicy policy : accessControlManager.getPolicies(contentResource.getPath())) {
                    if (policy instanceof JackrabbitAccessControlList) {
                        acls.add((JackrabbitAccessControlList) policy);
                        break;
                    }
                }
            }
        } catch (RepositoryException e) {
            log.error(""Failed to get resource for query result."", e);
        }
    }
    return acls;
}","private List<JackrabbitAccessControlList> findAcls(ResourceResolver resourceResolver, String principalName, JackrabbitAccessControlManager accessControlManager){
    final Set<String> paths = new HashSet<String>();
    final List<JackrabbitAccessControlList> acls = new ArrayList<JackrabbitAccessControlList>();
    final Map<String, String> params = new HashMap<String, String>();
    params.put(""type"", PROP_NT_REP_ACE);
    params.put(""property"", PROP_REP_PRINCIPAL_NAME);
    params.put(""property.value"", principalName);
    params.put(""p.limit"", ""-1"");
    Query query = queryBuilder.createQuery(PredicateGroup.create(params), resourceResolver.adaptTo(Session.class));
    QueryUtil.setResourceResolverOn(resourceResolver, query);
    for (final Hit hit : query.getResult().getHits()) {
        try {
            final Resource aceResource = resourceResolver.getResource(hit.getPath());
            final Resource contentResource = aceResource.getParent().getParent();
            if (!paths.contains(contentResource.getPath())) {
                paths.add(contentResource.getPath());
                for (AccessControlPolicy policy : accessControlManager.getPolicies(contentResource.getPath())) {
                    if (policy instanceof JackrabbitAccessControlList) {
                        acls.add((JackrabbitAccessControlList) policy);
                        break;
                    }
                }
            }
        } catch (RepositoryException e) {
            log.error(""Failed to get resource for query result."", e);
        }
    }
    return acls;
}","/**
     * Locates by query all the ACLs that the principal participates in.
     *
     * @param resourceResolver     the resource resolver to perform the user management
     * @param principalName        the principal name
     * @param accessControlManager Jackrabbit access control manager
     * @return a list of ACLs that principal participates in.
     */","('findAcls', {'INSTRUCTION': {'covered': 111, 'missed': 2}, 'BRANCH': {'covered': 5, 'missed': 3}, 'LINE': {'covered': 23, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",270.0,  Locates by query all the ACLs that the principal participates in.,12.0,"['The principal participates in theACLs.', 'The principal participates in all theACLs.', 'The principal participates in all of theACLs.']"
971,tablesaw,tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,/core/src/main/java/tech/tablesaw/columns/datetimes/DateTimeMapFunctions.java,timeWindow,378-430,"/**
   * Returns a column containing integers representing the nth group (0-based) that a date falls
   * into.
   *
   * <p>Example: When Unit = ChronoUnit.DAY and n = 5, we form 5 day groups. a Date that is 2 days
   * after the start is assigned to the first (""0"") group. A day 7 days after the start is assigned
   * to the second (""1"") group.
   *
   * @param unit A ChronoUnit greater than or equal to a minute
   * @param n The number of units in each group.
   * @param start The starting point of the first group; group boundaries are offsets from this
   *     point
   */
 LongColumn timeWindow(ChronoUnit unit, int n, LocalDateTime start){
    String newColumnName = """" + n + "" "" + unit.toString() + "" window ["" + name() + ""]"";
    long packedStartDate = pack(start);
    LongColumn numberColumn = LongColumn.create(newColumnName, size());
    for (int i = 0; i < size(); i++) {
        long packedDate = getLongInternal(i);
        long result;
        switch(unit) {
            case MINUTES:
                result = minutesUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case HOURS:
                result = hoursUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case DAYS:
                result = daysUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case WEEKS:
                result = weeksUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case MONTHS:
                result = monthsUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case YEARS:
                result = yearsUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            default:
                throw new UnsupportedTemporalTypeException(""The ChronoUnit "" + unit + "" is not supported for timeWindows on dates"");
        }
    }
    numberColumn.setPrintFormatter(NumberColumnFormatter.ints());
    return numberColumn;
}","LongColumn timeWindow(ChronoUnit unit, int n, LocalDateTime start){
    String newColumnName = """" + n + "" "" + unit.toString() + "" window ["" + name() + ""]"";
    long packedStartDate = pack(start);
    LongColumn numberColumn = LongColumn.create(newColumnName, size());
    for (int i = 0; i < size(); i++) {
        long packedDate = getLongInternal(i);
        long result;
        switch(unit) {
            case MINUTES:
                result = minutesUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case HOURS:
                result = hoursUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case DAYS:
                result = daysUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case WEEKS:
                result = weeksUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case MONTHS:
                result = monthsUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            case YEARS:
                result = yearsUntil(packedDate, packedStartDate) / n;
                numberColumn.set(i, result);
                break;
            default:
                throw new UnsupportedTemporalTypeException(""The ChronoUnit "" + unit + "" is not supported for timeWindows on dates"");
        }
    }
    numberColumn.setPrintFormatter(NumberColumnFormatter.ints());
    return numberColumn;
}","/**
   * Returns a column containing integers representing the nth group (0-based) that a date falls
   * into.
   *
   * <p>Example: When Unit = ChronoUnit.DAY and n = 5, we form 5 day groups. a Date that is 2 days
   * after the start is assigned to the first (""0"") group. A day 7 days after the start is assigned
   * to the second (""1"") group.
   *
   * @param unit A ChronoUnit greater than or equal to a minute
   * @param n The number of units in each group.
   * @param start The starting point of the first group; group boundaries are offsets from this
   *     point
   */","('timeWindow', {'INSTRUCTION': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",271.0,Returns a column containing integers representing the nth group (0-based) that a date falls  into.,18.0,"['A column containing numbers representing the nth group that a date falls into.', 'A column containing numbers representing the nth group is returned.', 'A column containing numbers representing the nth group that a date falls into is returned.']"
972,cdk,org/openscience/cdk/tools/DeAromatizationTool.java,/legacy/src/main/java/org/openscience/cdk/tools/DeAromatizationTool.java,deAromatize,58-93,"/**
     * Methods that takes a ring of which all bonds are aromatic, and assigns single
     * and double bonds. It does this in a non-general way by looking at the ring
     * size and take everything as a special case.
     *
     * @param ring Ring to dearomatize
     * @return  False if it could not convert the aromatic ring bond into single and double bonds
     */
public static boolean deAromatize(IRing ring){
    boolean allaromatic = true;
    for (int i = 0; i < ring.getBondCount(); i++) {
        if (!ring.getBond(i).getFlag(CDKConstants.ISAROMATIC))
            allaromatic = false;
    }
    if (!allaromatic)
        return false;
    for (int i = 0; i < ring.getBondCount(); i++) {
        if (ring.getBond(i).getFlag(CDKConstants.ISAROMATIC))
            ring.getBond(i).setOrder(IBond.Order.SINGLE);
    }
    boolean result = false;
    IMolecularFormula formula = MolecularFormulaManipulator.getMolecularFormula(ring);
    // Map elementCounts = new MFAnalyser(ring).getFormulaHashtable();
    if (ring.getRingSize() == 6) {
        if (MolecularFormulaManipulator.getElementCount(formula, new Element(""C"")) == 6) {
            result = DeAromatizationTool.deAromatizeBenzene(ring);
        } else if (MolecularFormulaManipulator.getElementCount(formula, new Element(""C"")) == 5 && MolecularFormulaManipulator.getElementCount(formula, new Element(""N"")) == 1) {
            result = DeAromatizationTool.deAromatizePyridine(ring);
        }
    }
    if (ring.getRingSize() == 5) {
        if (MolecularFormulaManipulator.getElementCount(formula, new Element(""C"")) == 4 && MolecularFormulaManipulator.getElementCount(formula, new Element(""N"")) == 1) {
            result = deAromatizePyrolle(ring);
        }
    }
    return result;
}","public static boolean deAromatize(IRing ring){
    boolean allaromatic = true;
    for (int i = 0; i < ring.getBondCount(); i++) {
        if (!ring.getBond(i).getFlag(CDKConstants.ISAROMATIC))
            allaromatic = false;
    }
    if (!allaromatic)
        return false;
    for (int i = 0; i < ring.getBondCount(); i++) {
        if (ring.getBond(i).getFlag(CDKConstants.ISAROMATIC))
            ring.getBond(i).setOrder(IBond.Order.SINGLE);
    }
    boolean result = false;
    IMolecularFormula formula = MolecularFormulaManipulator.getMolecularFormula(ring);
    // Map elementCounts = new MFAnalyser(ring).getFormulaHashtable();
    if (ring.getRingSize() == 6) {
        if (MolecularFormulaManipulator.getElementCount(formula, new Element(""C"")) == 6) {
            result = DeAromatizationTool.deAromatizeBenzene(ring);
        } else if (MolecularFormulaManipulator.getElementCount(formula, new Element(""C"")) == 5 && MolecularFormulaManipulator.getElementCount(formula, new Element(""N"")) == 1) {
            result = DeAromatizationTool.deAromatizePyridine(ring);
        }
    }
    if (ring.getRingSize() == 5) {
        if (MolecularFormulaManipulator.getElementCount(formula, new Element(""C"")) == 4 && MolecularFormulaManipulator.getElementCount(formula, new Element(""N"")) == 1) {
            result = deAromatizePyrolle(ring);
        }
    }
    return result;
}","/**
     * Methods that takes a ring of which all bonds are aromatic, and assigns single
     * and double bonds. It does this in a non-general way by looking at the ring
     * size and take everything as a special case.
     *
     * @param ring Ring to dearomatize
     * @return  False if it could not convert the aromatic ring bond into single and double bonds
     */","('deAromatize', {'INSTRUCTION': {'covered': 87, 'missed': 19}, 'BRANCH': {'covered': 15, 'missed': 9}, 'LINE': {'covered': 16, 'missed': 3}, 'COMPLEXITY': {'covered': 6, 'missed': 7}, 'METHOD': {'covered': 1, 'missed': 0}})",271.0,"  Methods that takes a ring of which all bonds are aromatic, and assigns single  and double bonds.",19.0,"['A method that takes a ring of aromatic bonds and assigns single and double bonds.', 'Methods that take a ring of aromatic bonds and assign single and double bonds.', 'A method that takes a ring of aromatic bonds and assigns single and double bonds']"
973,cdk,org/openscience/cdk/io/MDLValence.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLValence.java,apply,54-107,"/**
     * Apply the MDL valence model to the provided atom container.
     *
     * @param container an atom container loaded from an MDL format
     * @return the container (for convenience)
     */
 static IAtomContainer apply(IAtomContainer container){
    int n = container.getAtomCount();
    int[] valences = new int[n];
    Map<IAtom, Integer> atomToIndex = new HashMap<>(2 * n);
    for (IAtom atom : container.atoms()) atomToIndex.put(atom, atomToIndex.size());
    // compute the bond order sums
    for (IBond bond : container.bonds()) {
        int u = atomToIndex.get(bond.getBegin());
        int v = atomToIndex.get(bond.getEnd());
        int bondOrder = bond.getOrder().numeric();
        valences[u] += bondOrder;
        valences[v] += bondOrder;
    }
    for (int i = 0; i < n; i++) {
        IAtom atom = container.getAtom(i);
        Integer charge = atom.getFormalCharge();
        Integer element = atom.getAtomicNumber();
        if (element == null)
            continue;
        // unset = 0 in this case
        charge = charge == null ? 0 : charge;
        int explicit = valences[i];
        // if there was a valence read from the mol file use that otherwise
        // use the default value from the valence model to set the correct
        // number of implied hydrogens
        if (atom.getValency() != null) {
            atom.setImplicitHydrogenCount(atom.getValency() - explicit);
        } else {
            int implicit = implicitValence(element, charge, valences[i]);
            atom.setImplicitHydrogenCount(implicit - explicit);
            atom.setValency(implicit);
        }
    }
    return container;
}","static IAtomContainer apply(IAtomContainer container){
    int n = container.getAtomCount();
    int[] valences = new int[n];
    Map<IAtom, Integer> atomToIndex = new HashMap<>(2 * n);
    for (IAtom atom : container.atoms()) atomToIndex.put(atom, atomToIndex.size());
    // compute the bond order sums
    for (IBond bond : container.bonds()) {
        int u = atomToIndex.get(bond.getBegin());
        int v = atomToIndex.get(bond.getEnd());
        int bondOrder = bond.getOrder().numeric();
        valences[u] += bondOrder;
        valences[v] += bondOrder;
    }
    for (int i = 0; i < n; i++) {
        IAtom atom = container.getAtom(i);
        Integer charge = atom.getFormalCharge();
        Integer element = atom.getAtomicNumber();
        if (element == null)
            continue;
        // unset = 0 in this case
        charge = charge == null ? 0 : charge;
        int explicit = valences[i];
        // if there was a valence read from the mol file use that otherwise
        // use the default value from the valence model to set the correct
        // number of implied hydrogens
        if (atom.getValency() != null) {
            atom.setImplicitHydrogenCount(atom.getValency() - explicit);
        } else {
            int implicit = implicitValence(element, charge, valences[i]);
            atom.setImplicitHydrogenCount(implicit - explicit);
            atom.setValency(implicit);
        }
    }
    return container;
}","/**
     * Apply the MDL valence model to the provided atom container.
     *
     * @param container an atom container loaded from an MDL format
     * @return the container (for convenience)
     */","('apply', {'INSTRUCTION': {'covered': 139, 'missed': 3}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 25, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",271.0,  Apply the MDL valence model to the provided atom container.,11.0,"['The provided atom container has a MDL model applied to it.', 'The provided atom container has the MDL model applied to it.', 'The provided atom container has a MDL valence model applied to it.']"
974,cdk,org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,searchAndPlaceBranches,454-491,"/**
     * Search and place branches of a chain or ring.
     *
     *@param  chain          AtomContainer if atoms in an aliphatic chain or ring system
     */
private void searchAndPlaceBranches(IAtomContainer molecule, IAtomContainer chain, AtomPlacer3D ap3d, AtomTetrahedralLigandPlacer3D atlp3d, AtomPlacer atomPlacer) throws CDKException{
    List atoms = null;
    IAtomContainer branchAtoms = molecule.getBuilder().newInstance(IAtomContainer.class);
    IAtomContainer connectedAtoms = molecule.getBuilder().newInstance(IAtomContainer.class);
    for (int i = 0; i < chain.getAtomCount(); i++) {
        atoms = molecule.getConnectedAtomsList(chain.getAtom(i));
        for (int j = 0; j < atoms.size(); j++) {
            IAtom atom = (IAtom) atoms.get(j);
            if (!(atom.getSymbol()).equals(""H"") & !(atom.getFlag(CDKConstants.ISPLACED)) & !(atom.getFlag(CDKConstants.ISINRING))) {
                connectedAtoms.add(ap3d.getPlacedHeavyAtoms(molecule, chain.getAtom(i)));
                try {
                    setBranchAtom(molecule, atom, chain.getAtom(i), connectedAtoms, ap3d, atlp3d);
                } catch (CDKException ex2) {
                    logger.error(""SearchAndPlaceBranchERROR: Cannot find enough neighbour atoms due to"" + ex2.toString());
                    throw new CDKException(""SearchAndPlaceBranchERROR: Cannot find enough neighbour atoms: "" + ex2.getMessage(), ex2);
                }
                branchAtoms.addAtom(atom);
                connectedAtoms.removeAllElements();
            }
        }
    }
    placeLinearChains3D(molecule, branchAtoms, ap3d, atlp3d, atomPlacer);
}","private void searchAndPlaceBranches(IAtomContainer molecule, IAtomContainer chain, AtomPlacer3D ap3d, AtomTetrahedralLigandPlacer3D atlp3d, AtomPlacer atomPlacer) throws CDKException{
    List atoms = null;
    IAtomContainer branchAtoms = molecule.getBuilder().newInstance(IAtomContainer.class);
    IAtomContainer connectedAtoms = molecule.getBuilder().newInstance(IAtomContainer.class);
    for (int i = 0; i < chain.getAtomCount(); i++) {
        atoms = molecule.getConnectedAtomsList(chain.getAtom(i));
        for (int j = 0; j < atoms.size(); j++) {
            IAtom atom = (IAtom) atoms.get(j);
            if (!(atom.getSymbol()).equals(""H"") & !(atom.getFlag(CDKConstants.ISPLACED)) & !(atom.getFlag(CDKConstants.ISINRING))) {
                connectedAtoms.add(ap3d.getPlacedHeavyAtoms(molecule, chain.getAtom(i)));
                try {
                    setBranchAtom(molecule, atom, chain.getAtom(i), connectedAtoms, ap3d, atlp3d);
                } catch (CDKException ex2) {
                    logger.error(""SearchAndPlaceBranchERROR: Cannot find enough neighbour atoms due to"" + ex2.toString());
                    throw new CDKException(""SearchAndPlaceBranchERROR: Cannot find enough neighbour atoms: "" + ex2.getMessage(), ex2);
                }
                branchAtoms.addAtom(atom);
                connectedAtoms.removeAllElements();
            }
        }
    }
    placeLinearChains3D(molecule, branchAtoms, ap3d, atlp3d, atomPlacer);
}","/**
     * Search and place branches of a chain or ring.
     *
     *@param  chain          AtomContainer if atoms in an aliphatic chain or ring system
     */","('searchAndPlaceBranches', {'INSTRUCTION': {'covered': 102, 'missed': 26}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 16, 'missed': 5}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",272.0,  Search and place branches of a chain or ring.,10.0,"['Place branches of a chain.', 'Place branches of a chain or ring.', 'Place the branches of a chain.']"
975,cdk,org/openscience/cdk/aromaticity/AromaticityCalculator.java,/legacy/src/main/java/org/openscience/cdk/aromaticity/AromaticityCalculator.java,isAromatic,45-103,"/**
     *  Tests the <code>ring</code> in the <code>molecule</code> for aromaticity. Uses the
     *  H&uuml;ckel rule (4n + 2) pie electrons. sp<sup>2</sup> hybridized C contibute 1 electron non
     *  sp<sup>2</sup> hybridized heteroatoms contribute 2 electrons (N and O should never be sp in
     *  or anything else in a ring and d electron elements get to complicated)
     *  sp<sup>2</sup> hybridized heteroatoms contribute 1 electron hybridization is worked out by
     *  counting the number of bonds with order 2. Therefore sp<sup>2</sup> hybridization is assumed
     *  if there is one bond of order 2. Otherwise sp<sup>3</sup> hybridization is assumed.
     *
     * @param  ring      the ring to test
     * @param  atomContainer  the AtomContainer the ring is in
     * @return           true if the ring is aromatic false otherwise.
     */
public static boolean isAromatic(IRing ring, IAtomContainer atomContainer){
    java.util.Iterator<IAtom> ringAtoms = ring.atoms().iterator();
    int eCount = 0;
    java.util.List<IBond> conectedBonds;
    int numDoubleBond = 0;
    boolean allConnectedBondsSingle;
    while (ringAtoms.hasNext()) {
        IAtom atom = ringAtoms.next();
        numDoubleBond = 0;
        allConnectedBondsSingle = true;
        conectedBonds = atomContainer.getConnectedBondsList(atom);
        for (IBond conectedBond : conectedBonds) {
            if (conectedBond.getOrder() == IBond.Order.DOUBLE && ring.contains(conectedBond)) {
                numDoubleBond++;
            } else // Count the Electron if bond order = 1.5
            if (conectedBond.getFlag(CDKConstants.ISAROMATIC) && ring.contains(conectedBond)) {
                numDoubleBond = 1;
            }
            if (conectedBond.getOrder() != IBond.Order.SINGLE) {
                allConnectedBondsSingle = false;
            }
        }
        if (numDoubleBond == 1) {
            // C or heteroatoms both contibute 1 electron in sp2 hybridized form
            eCount++;
        } else if (!atom.getSymbol().equals(""C"")) {
            // Heteroatom probably in sp3 hybrid therefore 2 electrons contributed.
            eCount = eCount + 2;
        } else if (atom.getFlag(CDKConstants.ISAROMATIC)) {
            eCount++;
        } else if (allConnectedBondsSingle && atom.getSymbol().equals(""C"") && atom.getFormalCharge() == 1.0) {
            // This is for tropylium and kinds.
            // Dependence on hybridisation would be better:
            // empty p-orbital is needed
            continue;
        } else {
            return false;
        }
    }
    return eCount - 2 != 0 && (eCount - 2) % 4 == 0;
}","public static boolean isAromatic(IRing ring, IAtomContainer atomContainer){
    java.util.Iterator<IAtom> ringAtoms = ring.atoms().iterator();
    int eCount = 0;
    java.util.List<IBond> conectedBonds;
    int numDoubleBond = 0;
    boolean allConnectedBondsSingle;
    while (ringAtoms.hasNext()) {
        IAtom atom = ringAtoms.next();
        numDoubleBond = 0;
        allConnectedBondsSingle = true;
        conectedBonds = atomContainer.getConnectedBondsList(atom);
        for (IBond conectedBond : conectedBonds) {
            if (conectedBond.getOrder() == IBond.Order.DOUBLE && ring.contains(conectedBond)) {
                numDoubleBond++;
            } else // Count the Electron if bond order = 1.5
            if (conectedBond.getFlag(CDKConstants.ISAROMATIC) && ring.contains(conectedBond)) {
                numDoubleBond = 1;
            }
            if (conectedBond.getOrder() != IBond.Order.SINGLE) {
                allConnectedBondsSingle = false;
            }
        }
        if (numDoubleBond == 1) {
            // C or heteroatoms both contibute 1 electron in sp2 hybridized form
            eCount++;
        } else if (!atom.getSymbol().equals(""C"")) {
            // Heteroatom probably in sp3 hybrid therefore 2 electrons contributed.
            eCount = eCount + 2;
        } else if (atom.getFlag(CDKConstants.ISAROMATIC)) {
            eCount++;
        } else if (allConnectedBondsSingle && atom.getSymbol().equals(""C"") && atom.getFormalCharge() == 1.0) {
            // This is for tropylium and kinds.
            // Dependence on hybridisation would be better:
            // empty p-orbital is needed
            continue;
        } else {
            return false;
        }
    }
    return eCount - 2 != 0 && (eCount - 2) % 4 == 0;
}","/**
     *  Tests the <code>ring</code> in the <code>molecule</code> for aromaticity. Uses the
     *  H&uuml;ckel rule (4n + 2) pie electrons. sp<sup>2</sup> hybridized C contibute 1 electron non
     *  sp<sup>2</sup> hybridized heteroatoms contribute 2 electrons (N and O should never be sp in
     *  or anything else in a ring and d electron elements get to complicated)
     *  sp<sup>2</sup> hybridized heteroatoms contribute 1 electron hybridization is worked out by
     *  counting the number of bonds with order 2. Therefore sp<sup>2</sup> hybridization is assumed
     *  if there is one bond of order 2. Otherwise sp<sup>3</sup> hybridization is assumed.
     *
     * @param  ring      the ring to test
     * @param  atomContainer  the AtomContainer the ring is in
     * @return           true if the ring is aromatic false otherwise.
     */","('isAromatic', {'INSTRUCTION': {'covered': 90, 'missed': 23}, 'BRANCH': {'covered': 17, 'missed': 13}, 'LINE': {'covered': 23, 'missed': 4}, 'COMPLEXITY': {'covered': 6, 'missed': 10}, 'METHOD': {'covered': 1, 'missed': 0}})",274.0,  Tests the <code>ring</code> in the <code>molecule</code> for aromaticity.,21.0,"['The code>ring/code> is tested for aromaticity.', 'The code>ring/code> is tested in the code>molecule/code> for aromaticity.', 'The aromaticity of the code>ring/code> is tested.']"
978,egeria,org/odpi/openmetadata/adapters/connectors/datastore/csvfile/CSVFileStoreConnector.java,/open-metadata-implementation/adapters/open-connectors/data-store-connectors/file-connectors/csv-file-connector/src/main/java/org/odpi/openmetadata/adapters/connectors/datastore/csvfile/CSVFileStoreConnector.java,parseRecord,274-364,"/**
     * Step through the record, character by character, extracting each column and enduring that escaped double quotes
     * and other tricks found in CSV files are handled.
     *
     * @param fileRecord a single record from the CSV file store
     * @return an array of column values extracted from the record
     */
private List<String> parseRecord(String fileRecord){
    if ((fileRecord == null) || (fileRecord.isEmpty())) {
        return null;
    }
    List<String> result = new ArrayList<>();
    StringBuffer currentValue = new StringBuffer();
    boolean inQuotes = false;
    boolean startCollectingCharacters = false;
    boolean doubleQuotesInColumn = false;
    char[] characters = fileRecord.toCharArray();
    for (char character : characters) {
        if (inQuotes) {
            startCollectingCharacters = true;
            if (character == quoteChar) {
                inQuotes = false;
                doubleQuotesInColumn = false;
            } else {
                if (character == '\""') {
                    if (!doubleQuotesInColumn) {
                        currentValue.append(character);
                        doubleQuotesInColumn = true;
                    }
                } else {
                    currentValue.append(character);
                }
            }
        } else {
            if (character == quoteChar) {
                inQuotes = true;
                if (characters[0] != '""' && quoteChar == '\""') {
                    currentValue.append('""');
                }
                if (startCollectingCharacters) {
                    currentValue.append('""');
                }
            } else if (character == delimiterChar) {
                result.add(currentValue.toString());
                currentValue = new StringBuffer();
                startCollectingCharacters = false;
            } else if (character == '\n') {
                break;
            } else if (character != '\r') {
                currentValue.append(character);
            }
        }
    }
    result.add(currentValue.toString());
    return result;
}","private List<String> parseRecord(String fileRecord){
    if ((fileRecord == null) || (fileRecord.isEmpty())) {
        return null;
    }
    List<String> result = new ArrayList<>();
    StringBuffer currentValue = new StringBuffer();
    boolean inQuotes = false;
    boolean startCollectingCharacters = false;
    boolean doubleQuotesInColumn = false;
    char[] characters = fileRecord.toCharArray();
    for (char character : characters) {
        if (inQuotes) {
            startCollectingCharacters = true;
            if (character == quoteChar) {
                inQuotes = false;
                doubleQuotesInColumn = false;
            } else {
                if (character == '\""') {
                    if (!doubleQuotesInColumn) {
                        currentValue.append(character);
                        doubleQuotesInColumn = true;
                    }
                } else {
                    currentValue.append(character);
                }
            }
        } else {
            if (character == quoteChar) {
                inQuotes = true;
                if (characters[0] != '""' && quoteChar == '\""') {
                    currentValue.append('""');
                }
                if (startCollectingCharacters) {
                    currentValue.append('""');
                }
            } else if (character == delimiterChar) {
                result.add(currentValue.toString());
                currentValue = new StringBuffer();
                startCollectingCharacters = false;
            } else if (character == '\n') {
                break;
            } else if (character != '\r') {
                currentValue.append(character);
            }
        }
    }
    result.add(currentValue.toString());
    return result;
}","/**
     * Step through the record, character by character, extracting each column and enduring that escaped double quotes
     * and other tricks found in CSV files are handled.
     *
     * @param fileRecord a single record from the CSV file store
     * @return an array of column values extracted from the record
     */","('parseRecord', {'INSTRUCTION': {'covered': 118, 'missed': 12}, 'BRANCH': {'covered': 20, 'missed': 8}, 'LINE': {'covered': 30, 'missed': 5}, 'COMPLEXITY': {'covered': 8, 'missed': 7}, 'METHOD': {'covered': 1, 'missed': 0}})",276.0,"  Step through the record, character by character, extracting each column and enduring that escaped double quotes  and other tricks found in CSV files are handled.",28.0,"['Escaped double quotes and other tricks found in CSV files are handled.', 'Escaped double quotes and other tricks found in CSV files are dealt with.', 'Escaped double quotes and other tricks found in CSV files are dealt with, as are character by character.']"
979,acs-aem-commons,com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,generatePropertyChecksums,232-286,"/**
     * Returns a lexicographically sorted map of the [PROPERTY PATH] : [CHECKSUM OF PROPERTIES].
     * @param aggregateNodePath the absolute path of the node being aggregated into a checksum
     * @param node  the node to collect and checksum the properties for
     * @param options the checksum generator options
     * @return the map of the properties and their checksums
     * @throws RepositoryException
     */
protected String generatePropertyChecksums(final String aggregateNodePath, final Node node, final ChecksumGeneratorOptions options) throws RepositoryException, IOException{
    SortedMap<String, String> propertyChecksums = new TreeMap<>();
    PropertyIterator properties = node.getProperties();
    while (properties.hasNext()) {
        final Property property = properties.nextProperty();
        if (options.getExcludedProperties().contains(property.getName())) {
            log.debug(""Excluding property: {}"", node.getPath() + ""/@"" + property.getName());
            continue;
        }
        final List<String> checksums = new ArrayList<String>();
        final List<Value> values = getPropertyValues(property);
        for (final Value value : values) {
            if (value.getType() == PropertyType.BINARY) {
                checksums.add(getBinaryChecksum(value));
            } else {
                checksums.add(getStringChecksum(value));
            }
        }
        if (!options.getSortedProperties().contains(property.getName())) {
            Collections.sort(checksums);
        }
        if (log.isDebugEnabled()) {
            log.debug(""Property: {} ~> {}"", getChecksumKey(aggregateNodePath, property.getPath()), StringUtils.join(checksums, "",""));
        }
        propertyChecksums.put(getChecksumKey(aggregateNodePath, property.getPath()), StringUtils.join(checksums, "",""));
    }
    return aggregateChecksums(propertyChecksums);
}","protected String generatePropertyChecksums(final String aggregateNodePath, final Node node, final ChecksumGeneratorOptions options) throws RepositoryException, IOException{
    SortedMap<String, String> propertyChecksums = new TreeMap<>();
    PropertyIterator properties = node.getProperties();
    while (properties.hasNext()) {
        final Property property = properties.nextProperty();
        if (options.getExcludedProperties().contains(property.getName())) {
            log.debug(""Excluding property: {}"", node.getPath() + ""/@"" + property.getName());
            continue;
        }
        final List<String> checksums = new ArrayList<String>();
        final List<Value> values = getPropertyValues(property);
        for (final Value value : values) {
            if (value.getType() == PropertyType.BINARY) {
                checksums.add(getBinaryChecksum(value));
            } else {
                checksums.add(getStringChecksum(value));
            }
        }
        if (!options.getSortedProperties().contains(property.getName())) {
            Collections.sort(checksums);
        }
        if (log.isDebugEnabled()) {
            log.debug(""Property: {} ~> {}"", getChecksumKey(aggregateNodePath, property.getPath()), StringUtils.join(checksums, "",""));
        }
        propertyChecksums.put(getChecksumKey(aggregateNodePath, property.getPath()), StringUtils.join(checksums, "",""));
    }
    return aggregateChecksums(propertyChecksums);
}","/**
     * Returns a lexicographically sorted map of the [PROPERTY PATH] : [CHECKSUM OF PROPERTIES].
     * @param aggregateNodePath the absolute path of the node being aggregated into a checksum
     * @param node  the node to collect and checksum the properties for
     * @param options the checksum generator options
     * @return the map of the properties and their checksums
     * @throws RepositoryException
     */","('generatePropertyChecksums', {'INSTRUCTION': {'covered': 108, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",277.0,  Returns a lexicographically sorted map of the [PROPERTY PATH] : [CHECKSUM OF PROPERTIES].,18.0,"['A lexicographically sorted map is returned.', 'The map is sorted by the checksum of politeness.', 'A lexicographically sorted map of the [proPERTY PATH] is returned.']"
980,cdk,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,tryDoubleBondCombinations,639-688,"/**
     * Tries double bond combinations for a certain input container of which the double bonds have been stripped
     * around the mobile hydrogen positions. Recursively.
     *
     * @param container
     * @param dblBondsAdded counts double bonds added so far
     * @param bondOffSet offset for next double bond position to consider
     * @param doubleBondMax maximum number of double bonds to add
     * @param atomsInNeedOfFix atoms that require more bonds
     * @return a list of double bond positions (index) that make a valid combination, null if none found
     */
private List<Integer> tryDoubleBondCombinations(IAtomContainer container, int dblBondsAdded, int bondOffSet, int doubleBondMax, List<IAtom> atomsInNeedOfFix){
    int offSet = bondOffSet;
    List<Integer> dblBondPositions = null;
    while (offSet < container.getBondCount() && dblBondPositions == null) {
        IBond bond = container.getBond(offSet);
        if (atomsInNeedOfFix.contains(bond.getBegin()) && atomsInNeedOfFix.contains(bond.getEnd())) {
            bond.setOrder(IBond.Order.DOUBLE);
            dblBondsAdded = dblBondsAdded + 1;
            if (dblBondsAdded == doubleBondMax) {
                boolean validDoubleBondConfig = true;
                CHECK: for (IAtom atom : container.atoms()) {
                    if (atom.getValency() != atom.getImplicitHydrogenCount() + getConnectivity(atom, container)) {
                        validDoubleBondConfig = false;
                        break CHECK;
                    }
                }
                if (validDoubleBondConfig) {
                    dblBondPositions = new ArrayList<Integer>();
                    for (int idx = 0; idx < container.getBondCount(); idx++) {
                        if (container.getBond(idx).getOrder().equals(IBond.Order.DOUBLE))
                            dblBondPositions.add(idx);
                    }
                    return dblBondPositions;
                }
            } else {
                dblBondPositions = tryDoubleBondCombinations(container, dblBondsAdded, offSet + 1, doubleBondMax, atomsInNeedOfFix);
            }
            bond.setOrder(IBond.Order.SINGLE);
            dblBondsAdded = dblBondsAdded - 1;
        }
        offSet++;
    }
    return dblBondPositions;
}","private List<Integer> tryDoubleBondCombinations(IAtomContainer container, int dblBondsAdded, int bondOffSet, int doubleBondMax, List<IAtom> atomsInNeedOfFix){
    int offSet = bondOffSet;
    List<Integer> dblBondPositions = null;
    while (offSet < container.getBondCount() && dblBondPositions == null) {
        IBond bond = container.getBond(offSet);
        if (atomsInNeedOfFix.contains(bond.getBegin()) && atomsInNeedOfFix.contains(bond.getEnd())) {
            bond.setOrder(IBond.Order.DOUBLE);
            dblBondsAdded = dblBondsAdded + 1;
            if (dblBondsAdded == doubleBondMax) {
                boolean validDoubleBondConfig = true;
                CHECK: for (IAtom atom : container.atoms()) {
                    if (atom.getValency() != atom.getImplicitHydrogenCount() + getConnectivity(atom, container)) {
                        validDoubleBondConfig = false;
                        break CHECK;
                    }
                }
                if (validDoubleBondConfig) {
                    dblBondPositions = new ArrayList<Integer>();
                    for (int idx = 0; idx < container.getBondCount(); idx++) {
                        if (container.getBond(idx).getOrder().equals(IBond.Order.DOUBLE))
                            dblBondPositions.add(idx);
                    }
                    return dblBondPositions;
                }
            } else {
                dblBondPositions = tryDoubleBondCombinations(container, dblBondsAdded, offSet + 1, doubleBondMax, atomsInNeedOfFix);
            }
            bond.setOrder(IBond.Order.SINGLE);
            dblBondsAdded = dblBondsAdded - 1;
        }
        offSet++;
    }
    return dblBondPositions;
}","/**
     * Tries double bond combinations for a certain input container of which the double bonds have been stripped
     * around the mobile hydrogen positions. Recursively.
     *
     * @param container
     * @param dblBondsAdded counts double bonds added so far
     * @param bondOffSet offset for next double bond position to consider
     * @param doubleBondMax maximum number of double bonds to add
     * @param atomsInNeedOfFix atoms that require more bonds
     * @return a list of double bond positions (index) that make a valid combination, null if none found
     */","('tryDoubleBondCombinations', {'INSTRUCTION': {'covered': 113, 'missed': 0}, 'BRANCH': {'covered': 20, 'missed': 0}, 'LINE': {'covered': 27, 'missed': 0}, 'COMPLEXITY': {'covered': 11, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",278.0,  Tries double bond combinations for a certain input container of which the double bonds have been stripped  around the mobile hydrogen positions.,23.0,"['Double bonds have been stripped around the mobile hydrogen positions for a certain input container.', 'Double bonds have been stripped around the mobile hydrogen positions for a certain input container of tries double bond combinations.', 'The double bonds have been stripped around the mobile hydrogen positions in the input container.']"
981,cdk,org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/ChiIndexUtils.java,evalValenceIndex,122-178,"/**
     * Evaluates the valence corrected chi index for a set of fragments.
     * 
     * This method takes into account the S and P atom types described in
     * Kier & Hall (1986), page 20 for which empirical delta V values are used.
     *
     * @param atomContainer The target <code>AtomContainer</code>
     * @param fragList      A list of fragments
     * @return The valence corrected chi index
     * @throws CDKException if the <code>IsotopeFactory</code> cannot be created
     */
public static double evalValenceIndex(IAtomContainer atomContainer, List<List<Integer>> fragList) throws CDKException{
    try {
        IsotopeFactory ifac = Isotopes.getInstance();
        ifac.configureAtoms(atomContainer);
    } catch (IOException e) {
        throw new CDKException(""IO problem occurred when using the CDK atom config\n"" + e.getMessage(), e);
    }
    double sum = 0;
    for (List<Integer> aFragList : fragList) {
        List<Integer> frag = aFragList;
        double prod = 1.0;
        for (Object aFrag : frag) {
            int atomSerial = (Integer) aFrag;
            IAtom atom = atomContainer.getAtom(atomSerial);
            String sym = atom.getSymbol();
            if (sym.equals(""S"")) {
                double tmp = deltavSulphur(atom, atomContainer);
                if (tmp != -1) {
                    prod = prod * tmp;
                    continue;
                }
            }
            if (sym.equals(""P"")) {
                double tmp = deltavPhosphorous(atom, atomContainer);
                if (tmp != -1) {
                    prod = prod * tmp;
                    continue;
                }
            }
            int z = atom.getAtomicNumber();
            int zv = getValenceElectronCount(atom);
            int hsupp = atom.getImplicitHydrogenCount();
            double deltav = (double) (zv - hsupp) / (double) (z - zv - 1);
            prod = prod * deltav;
        }
        if (prod != 0)
            sum += 1.0 / Math.sqrt(prod);
    }
    return sum;
}","public static double evalValenceIndex(IAtomContainer atomContainer, List<List<Integer>> fragList) throws CDKException{
    try {
        IsotopeFactory ifac = Isotopes.getInstance();
        ifac.configureAtoms(atomContainer);
    } catch (IOException e) {
        throw new CDKException(""IO problem occurred when using the CDK atom config\n"" + e.getMessage(), e);
    }
    double sum = 0;
    for (List<Integer> aFragList : fragList) {
        List<Integer> frag = aFragList;
        double prod = 1.0;
        for (Object aFrag : frag) {
            int atomSerial = (Integer) aFrag;
            IAtom atom = atomContainer.getAtom(atomSerial);
            String sym = atom.getSymbol();
            if (sym.equals(""S"")) {
                double tmp = deltavSulphur(atom, atomContainer);
                if (tmp != -1) {
                    prod = prod * tmp;
                    continue;
                }
            }
            if (sym.equals(""P"")) {
                double tmp = deltavPhosphorous(atom, atomContainer);
                if (tmp != -1) {
                    prod = prod * tmp;
                    continue;
                }
            }
            int z = atom.getAtomicNumber();
            int zv = getValenceElectronCount(atom);
            int hsupp = atom.getImplicitHydrogenCount();
            double deltav = (double) (zv - hsupp) / (double) (z - zv - 1);
            prod = prod * deltav;
        }
        if (prod != 0)
            sum += 1.0 / Math.sqrt(prod);
    }
    return sum;
}","/**
     * Evaluates the valence corrected chi index for a set of fragments.
     * 
     * This method takes into account the S and P atom types described in
     * Kier & Hall (1986), page 20 for which empirical delta V values are used.
     *
     * @param atomContainer The target <code>AtomContainer</code>
     * @param fragList      A list of fragments
     * @return The valence corrected chi index
     * @throws CDKException if the <code>IsotopeFactory</code> cannot be created
     */","('evalValenceIndex', {'INSTRUCTION': {'covered': 113, 'missed': 20}, 'BRANCH': {'covered': 12, 'missed': 2}, 'LINE': {'covered': 28, 'missed': 4}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",279.0,  Evaluates the valence corrected chi index for a set of fragments.,12.0,"['Evaluates the chi index for fragments.', 'Evaluates the corrected chi index for fragments.', 'Evaluates the corrected chi index for a set of fragments.']"
982,matsim-libs,org/matsim/codeexamples/fixedTimeSignals/CreateSignalInputExample.java,/contribs/signals/src/main/java/org/matsim/codeexamples/fixedTimeSignals/CreateSignalInputExample.java,run,202-265,"/**
	 * Set up the config and scenario, create signal information 
	 * and write them to file as input for further simulations.
	 * 
	 * @throws IOException
	 */
public void run(String outputDir) throws IOException{
    Config config = ConfigUtils.createConfig();
    config.network().setInputFile(INPUT_DIR + ""network.xml.gz"");
    config.plans().setInputFile(INPUT_DIR + ""population.xml.gz"");
    SignalSystemsConfigGroup signalSystemsConfigGroup = ConfigUtils.addOrGetModule(config, SignalSystemsConfigGroup.GROUP_NAME, SignalSystemsConfigGroup.class);
    signalSystemsConfigGroup.setUseSignalSystems(true);
    config.qsim().setNodeOffset(20.0);
    config.qsim().setSnapshotStyle(SnapshotStyle.queue);
    Scenario scenario = ScenarioUtils.loadScenario(config);
    SignalsData signalsData = SignalUtils.createSignalsData(signalSystemsConfigGroup);
    scenario.addScenarioElement(SignalsData.ELEMENT_NAME, signalsData);
    this.createSignalSystemsAndGroups(signalsData.getSignalSystemsData(), signalsData.getSignalGroupsData());
    this.createSignalControl(signalsData.getSignalControlData());
    Files.createDirectories(Paths.get(outputDir));
    signalSystemsConfigGroup.setSignalSystemFile(outputDir + ""signal_systems.xml"");
    signalSystemsConfigGroup.setSignalGroupsFile(outputDir + ""signal_groups.xml"");
    signalSystemsConfigGroup.setSignalControlFile(outputDir + ""signal_control.xml"");
    String configFile = outputDir + ""config.xml"";
    ConfigWriter configWriter = new ConfigWriter(config);
    configWriter.write(configFile);
    SignalsScenarioWriter signalsWriter = new SignalsScenarioWriter();
    signalsWriter.setSignalSystemsOutputFilename(signalSystemsConfigGroup.getSignalSystemFile());
    signalsWriter.setSignalGroupsOutputFilename(signalSystemsConfigGroup.getSignalGroupsFile());
    signalsWriter.setSignalControlOutputFilename(signalSystemsConfigGroup.getSignalControlFile());
    signalsWriter.writeSignalsData(scenario);
    log.info(""Config of simple traffic light scenario is written to "" + configFile);
    log.info(""Visualize scenario by calling VisSimpleTrafficSignalScenario in the same package."");
}","public void run(String outputDir) throws IOException{
    Config config = ConfigUtils.createConfig();
    config.network().setInputFile(INPUT_DIR + ""network.xml.gz"");
    config.plans().setInputFile(INPUT_DIR + ""population.xml.gz"");
    SignalSystemsConfigGroup signalSystemsConfigGroup = ConfigUtils.addOrGetModule(config, SignalSystemsConfigGroup.GROUP_NAME, SignalSystemsConfigGroup.class);
    signalSystemsConfigGroup.setUseSignalSystems(true);
    config.qsim().setNodeOffset(20.0);
    config.qsim().setSnapshotStyle(SnapshotStyle.queue);
    Scenario scenario = ScenarioUtils.loadScenario(config);
    SignalsData signalsData = SignalUtils.createSignalsData(signalSystemsConfigGroup);
    scenario.addScenarioElement(SignalsData.ELEMENT_NAME, signalsData);
    this.createSignalSystemsAndGroups(signalsData.getSignalSystemsData(), signalsData.getSignalGroupsData());
    this.createSignalControl(signalsData.getSignalControlData());
    Files.createDirectories(Paths.get(outputDir));
    signalSystemsConfigGroup.setSignalSystemFile(outputDir + ""signal_systems.xml"");
    signalSystemsConfigGroup.setSignalGroupsFile(outputDir + ""signal_groups.xml"");
    signalSystemsConfigGroup.setSignalControlFile(outputDir + ""signal_control.xml"");
    String configFile = outputDir + ""config.xml"";
    ConfigWriter configWriter = new ConfigWriter(config);
    configWriter.write(configFile);
    SignalsScenarioWriter signalsWriter = new SignalsScenarioWriter();
    signalsWriter.setSignalSystemsOutputFilename(signalSystemsConfigGroup.getSignalSystemFile());
    signalsWriter.setSignalGroupsOutputFilename(signalSystemsConfigGroup.getSignalGroupsFile());
    signalsWriter.setSignalControlOutputFilename(signalSystemsConfigGroup.getSignalControlFile());
    signalsWriter.writeSignalsData(scenario);
    log.info(""Config of simple traffic light scenario is written to "" + configFile);
    log.info(""Visualize scenario by calling VisSimpleTrafficSignalScenario in the same package."");
}","/**
	 * Set up the config and scenario, create signal information 
	 * and write them to file as input for further simulations.
	 * 
	 * @throws IOException
	 */","('run', {'INSTRUCTION': {'covered': 105, 'missed': 0}, 'LINE': {'covered': 28, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",280.0,"  Set up the config and scenario, create signal information   and write them to file as input for further simulations.",21.0,"['Write signal information to file as input for further simulations after setting up the scenario.', 'Write signal information to file as input for further simulations after setting up the scenario and config.', 'Write signal information to file as input for further simulations once you have set up the scenario.']"
983,dcache,org/dcache/poolmanager/WeightedAvailableSpaceSelection.java,/modules/dcache/src/main/java/org/dcache/poolmanager/WeightedAvailableSpaceSelection.java,selectByAvailableSpace,216-271,"/**
     * Selects a pool from a list using the WASS algorithm.
     * <p/>
     * Returns null if all pools are full.
     */
public P selectByAvailableSpace(List<P> pools, long filesize, Function<P, PoolCostInfo> getCost){
    int length = pools.size();
    double[] available = new double[length];
    double minLoad = Double.POSITIVE_INFINITY;
    for (int i = 0; i < length; i++) {
        PoolCostInfo info = getCost.apply(pools.get(i));
        double free = getAvailable(info.getSpaceInfo(), filesize);
        if (free > 0) {
            available[i] = free;
            minLoad = Math.min(minLoad, getLoad(info));
        }
    }
    if (minLoad == Double.POSITIVE_INFINITY) {
        return null;
    }
    double sum = 0.0;
    for (int i = 0; i < length; i++) {
        PoolCostInfo info = getCost.apply(pools.get(i));
        double normalizedLoad = getLoad(info) - minLoad;
        double weightedAvailable = getWeightedAvailable(info, available[i], normalizedLoad);
        sum += weightedAvailable;
        available[i] = sum;
    }
    double threshold = random() * sum;
    for (int i = 0; i < length; i++) {
        if (threshold < available[i]) {
            return pools.get(i);
        }
    }
    if (sum == Double.POSITIVE_INFINITY) {
        throw new IllegalStateException(""WASS overflow: Configured space cost factor ("" + spaceCostFactor + "") is too large."");
    }
    throw new RuntimeException(""Unreachable statement."");
}","public P selectByAvailableSpace(List<P> pools, long filesize, Function<P, PoolCostInfo> getCost){
    int length = pools.size();
    double[] available = new double[length];
    double minLoad = Double.POSITIVE_INFINITY;
    for (int i = 0; i < length; i++) {
        PoolCostInfo info = getCost.apply(pools.get(i));
        double free = getAvailable(info.getSpaceInfo(), filesize);
        if (free > 0) {
            available[i] = free;
            minLoad = Math.min(minLoad, getLoad(info));
        }
    }
    if (minLoad == Double.POSITIVE_INFINITY) {
        return null;
    }
    double sum = 0.0;
    for (int i = 0; i < length; i++) {
        PoolCostInfo info = getCost.apply(pools.get(i));
        double normalizedLoad = getLoad(info) - minLoad;
        double weightedAvailable = getWeightedAvailable(info, available[i], normalizedLoad);
        sum += weightedAvailable;
        available[i] = sum;
    }
    double threshold = random() * sum;
    for (int i = 0; i < length; i++) {
        if (threshold < available[i]) {
            return pools.get(i);
        }
    }
    if (sum == Double.POSITIVE_INFINITY) {
        throw new IllegalStateException(""WASS overflow: Configured space cost factor ("" + spaceCostFactor + "") is too large."");
    }
    throw new RuntimeException(""Unreachable statement."");
}","/**
     * Selects a pool from a list using the WASS algorithm.
     * <p/>
     * Returns null if all pools are full.
     */","('selectByAvailableSpace', {'INSTRUCTION': {'covered': 108, 'missed': 16}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 22, 'missed': 3}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",281.0,  Selects a pool from a list using the WASS algorithm.,11.0,"['The WASS algorithm is used to select a pool.', 'The WASS algorithm is used to select a pool from a list.', 'The WASS algorithm is used to pick a pool.']"
984,cdk,org/openscience/cdk/forcefield/mmff/Mmff.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/Mmff.java,partialCharges,165-218,"/**
     * Assign the partial charges, all existing charges are cleared.
     * Atom types must be assigned first. 
     *
     * @param mol molecule
     * @return charges were assigned
     * @see #effectiveCharges(IAtomContainer)
     * @see #assignAtomTypes(IAtomContainer)
     */
public boolean partialCharges(IAtomContainer mol){
    int[][] adjList = mol.getProperty(MMFF_ADJLIST_CACHE);
    GraphUtil.EdgeToBondMap edgeMap = mol.getProperty(MMFF_EDGEMAP_CACHE);
    if (adjList == null || edgeMap == null)
        throw new IllegalArgumentException(""Invoke assignAtomTypes first."");
    effectiveCharges(mol);
    for (int v = 0; v < mol.getAtomCount(); v++) {
        IAtom atom = mol.getAtom(v);
        String symbType = atom.getAtomTypeName();
        final int thisType = mmffParamSet.intType(symbType);
        if (thisType == 0)
            continue;
        double pbci = mmffParamSet.getPartialBondChargeIncrement(thisType).doubleValue();
        for (int w : adjList[v]) {
            int otherType = mmffParamSet.intType(mol.getAtom(w).getAtomTypeName());
            if (otherType == 0)
                continue;
            IBond bond = edgeMap.get(v, w);
            int bondCls = mmffParamSet.getBondCls(thisType, otherType, bond.getOrder().numeric(), bond.getProperty(MMFF_AROM) != null);
            BigDecimal bci = mmffParamSet.getBondChargeIncrement(bondCls, thisType, otherType);
            if (bci != null) {
                atom.setCharge(atom.getCharge() - bci.doubleValue());
            } else {
                atom.setCharge(atom.getCharge() + (pbci - mmffParamSet.getPartialBondChargeIncrement(otherType).doubleValue()));
            }
        }
    }
    return true;
}","public boolean partialCharges(IAtomContainer mol){
    int[][] adjList = mol.getProperty(MMFF_ADJLIST_CACHE);
    GraphUtil.EdgeToBondMap edgeMap = mol.getProperty(MMFF_EDGEMAP_CACHE);
    if (adjList == null || edgeMap == null)
        throw new IllegalArgumentException(""Invoke assignAtomTypes first."");
    effectiveCharges(mol);
    for (int v = 0; v < mol.getAtomCount(); v++) {
        IAtom atom = mol.getAtom(v);
        String symbType = atom.getAtomTypeName();
        final int thisType = mmffParamSet.intType(symbType);
        if (thisType == 0)
            continue;
        double pbci = mmffParamSet.getPartialBondChargeIncrement(thisType).doubleValue();
        for (int w : adjList[v]) {
            int otherType = mmffParamSet.intType(mol.getAtom(w).getAtomTypeName());
            if (otherType == 0)
                continue;
            IBond bond = edgeMap.get(v, w);
            int bondCls = mmffParamSet.getBondCls(thisType, otherType, bond.getOrder().numeric(), bond.getProperty(MMFF_AROM) != null);
            BigDecimal bci = mmffParamSet.getBondChargeIncrement(bondCls, thisType, otherType);
            if (bci != null) {
                atom.setCharge(atom.getCharge() - bci.doubleValue());
            } else {
                atom.setCharge(atom.getCharge() + (pbci - mmffParamSet.getPartialBondChargeIncrement(otherType).doubleValue()));
            }
        }
    }
    return true;
}","/**
     * Assign the partial charges, all existing charges are cleared.
     * Atom types must be assigned first. 
     *
     * @param mol molecule
     * @return charges were assigned
     * @see #effectiveCharges(IAtomContainer)
     * @see #assignAtomTypes(IAtomContainer)
     */","('partialCharges', {'INSTRUCTION': {'covered': 119, 'missed': 19}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 21, 'missed': 2}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",282.0,"  Assign the partial charges, all existing charges are cleared.",11.0,"['All charges are cleared if the partial charges are assigned.', 'All charges are cleared when partial charges are assigned.', 'All existing charges are cleared when partial charges are assigned.']"
985,cdk,org/openscience/cdk/tools/diff/AtomTypeDiff.java,/misc/diff/src/main/java/org/openscience/cdk/tools/diff/AtomTypeDiff.java,difference,62-96,"/**
     * Compare two {@link IChemObject} classes and return the difference as an {@link IDifference}.
     *
     * @param first  the first of the two classes to compare
     * @param second the second of the two classes to compare
     * @return an {@link IDifference} representation of the difference between the first and second {@link IChemObject}.
     */
public static IDifference difference(IChemObject first, IChemObject second){
    if (!(first instanceof IAtomType && second instanceof IAtomType)) {
        return null;
    }
    IAtomType firstElem = (IAtomType) first;
    IAtomType secondElem = (IAtomType) second;
    ChemObjectDifference totalDiff = new ChemObjectDifference(""AtomTypeDiff"");
    totalDiff.addChild(StringDifference.construct(""N"", firstElem.getAtomTypeName(), secondElem.getAtomTypeName()));
    totalDiff.addChild(BondOrderDifference.construct(""MBO"", firstElem.getMaxBondOrder(), secondElem.getMaxBondOrder()));
    totalDiff.addChild(DoubleDifference.construct(""BOS"", firstElem.getBondOrderSum(), secondElem.getBondOrderSum()));
    totalDiff.addChild(IntegerDifference.construct(""FC"", firstElem.getFormalCharge(), secondElem.getFormalCharge()));
    totalDiff.addChild(AtomTypeHybridizationDifference.construct(""H"", firstElem.getHybridization(), secondElem.getHybridization()));
    totalDiff.addChild(IntegerDifference.construct(""NC"", firstElem.getFormalNeighbourCount(), secondElem.getFormalNeighbourCount()));
    totalDiff.addChild(DoubleDifference.construct(""CR"", firstElem.getCovalentRadius(), secondElem.getCovalentRadius()));
    totalDiff.addChild(IntegerDifference.construct(""V"", firstElem.getValency(), secondElem.getValency()));
    totalDiff.addChild(IsotopeDiff.difference(first, second));
    if (totalDiff.childCount() > 0) {
        return totalDiff;
    } else {
        return null;
    }
}","public static IDifference difference(IChemObject first, IChemObject second){
    if (!(first instanceof IAtomType && second instanceof IAtomType)) {
        return null;
    }
    IAtomType firstElem = (IAtomType) first;
    IAtomType secondElem = (IAtomType) second;
    ChemObjectDifference totalDiff = new ChemObjectDifference(""AtomTypeDiff"");
    totalDiff.addChild(StringDifference.construct(""N"", firstElem.getAtomTypeName(), secondElem.getAtomTypeName()));
    totalDiff.addChild(BondOrderDifference.construct(""MBO"", firstElem.getMaxBondOrder(), secondElem.getMaxBondOrder()));
    totalDiff.addChild(DoubleDifference.construct(""BOS"", firstElem.getBondOrderSum(), secondElem.getBondOrderSum()));
    totalDiff.addChild(IntegerDifference.construct(""FC"", firstElem.getFormalCharge(), secondElem.getFormalCharge()));
    totalDiff.addChild(AtomTypeHybridizationDifference.construct(""H"", firstElem.getHybridization(), secondElem.getHybridization()));
    totalDiff.addChild(IntegerDifference.construct(""NC"", firstElem.getFormalNeighbourCount(), secondElem.getFormalNeighbourCount()));
    totalDiff.addChild(DoubleDifference.construct(""CR"", firstElem.getCovalentRadius(), secondElem.getCovalentRadius()));
    totalDiff.addChild(IntegerDifference.construct(""V"", firstElem.getValency(), secondElem.getValency()));
    totalDiff.addChild(IsotopeDiff.difference(first, second));
    if (totalDiff.childCount() > 0) {
        return totalDiff;
    } else {
        return null;
    }
}","/**
     * Compare two {@link IChemObject} classes and return the difference as an {@link IDifference}.
     *
     * @param first  the first of the two classes to compare
     * @param second the second of the two classes to compare
     * @return an {@link IDifference} representation of the difference between the first and second {@link IChemObject}.
     */","('difference', {'INSTRUCTION': {'covered': 93, 'missed': 2}, 'BRANCH': {'covered': 4, 'missed': 2}, 'LINE': {'covered': 22, 'missed': 1}, 'COMPLEXITY': {'covered': 2, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",283.0,  Compare two {@link IChemObject} classes and return the difference as an {@link IDifference}.,20.0,"['Return the difference between the two classes as an @link IDifference.', 'You can compare two classes and return a difference.', 'Return the difference between the two classes to you as an @link IDifference.']"
986,cdk,org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,/tool/forcefield/src/main/java/org/openscience/cdk/forcefield/mmff/MmffAromaticTypeMapping.java,findAromaticRings,113-168,"/**
     * From a provided set of cycles find the 5/6 member cycles that fit the MMFF aromaticity
     * definition - {@link #isAromaticRing(int[], int[], int[], boolean[])}. The cycles of size 6
     * are listed first.
     *
     * @param cycles       initial set of cycles from
     * @param contribution vector of p electron contributions from each vertex
     * @param dbs          vector of double-bond pairs, index stored double-bonded index
     * @return the cycles that are aromatic
     */
private static int[][] findAromaticRings(int[][] cycles, int[] contribution, int[] dbs){
    boolean found;
    boolean[] checked = new boolean[cycles.length];
    final boolean[] aromaticAtoms = new boolean[contribution.length];
    final List<int[]> ringsOfSize6 = new ArrayList<int[]>();
    final List<int[]> ringsOfSize5 = new ArrayList<int[]>();
    do {
        found = false;
        for (int i = 0; i < cycles.length; i++) {
            int[] cycle = cycles[i];
            int len = cycle.length - 1;
            if (checked[i])
                continue;
            if (isAromaticRing(cycle, contribution, dbs, aromaticAtoms)) {
                checked[i] = true;
                found |= true;
                for (int j = 0; j < len; j++) {
                    aromaticAtoms[cycle[j]] = true;
                }
                if (len == 6)
                    ringsOfSize6.add(cycle);
                else if (len == 5)
                    ringsOfSize5.add(cycle);
            }
        }
    } while (found);
    List<int[]> rings = new ArrayList<int[]>();
    rings.addAll(ringsOfSize6);
    rings.addAll(ringsOfSize5);
    return rings.toArray(new int[rings.size()][]);
}","private static int[][] findAromaticRings(int[][] cycles, int[] contribution, int[] dbs){
    boolean found;
    boolean[] checked = new boolean[cycles.length];
    final boolean[] aromaticAtoms = new boolean[contribution.length];
    final List<int[]> ringsOfSize6 = new ArrayList<int[]>();
    final List<int[]> ringsOfSize5 = new ArrayList<int[]>();
    do {
        found = false;
        for (int i = 0; i < cycles.length; i++) {
            int[] cycle = cycles[i];
            int len = cycle.length - 1;
            if (checked[i])
                continue;
            if (isAromaticRing(cycle, contribution, dbs, aromaticAtoms)) {
                checked[i] = true;
                found |= true;
                for (int j = 0; j < len; j++) {
                    aromaticAtoms[cycle[j]] = true;
                }
                if (len == 6)
                    ringsOfSize6.add(cycle);
                else if (len == 5)
                    ringsOfSize5.add(cycle);
            }
        }
    } while (found);
    List<int[]> rings = new ArrayList<int[]>();
    rings.addAll(ringsOfSize6);
    rings.addAll(ringsOfSize5);
    return rings.toArray(new int[rings.size()][]);
}","/**
     * From a provided set of cycles find the 5/6 member cycles that fit the MMFF aromaticity
     * definition - {@link #isAromaticRing(int[], int[], int[], boolean[])}. The cycles of size 6
     * are listed first.
     *
     * @param cycles       initial set of cycles from
     * @param contribution vector of p electron contributions from each vertex
     * @param dbs          vector of double-bond pairs, index stored double-bonded index
     * @return the cycles that are aromatic
     */","('findAromaticRings', {'INSTRUCTION': {'covered': 103, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 22, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",283.0,"From a provided set of cycles find the 5/6 member cycles that fit the MMFF aromaticity  definition - {@link #isAromaticRing(int[], int[], int[], boolean[])}.",42.0,"['The MMFF aromaticity definition says ""@link #isAromaticRing(int[], int[], int[])""', 'The MMFF aromaticity definition says ""@link #isAromaticRing(int[], int[], int[], boolean[])""', 'The MMFF aromaticity definition says ""@link #isAromaticRing(int[], int[], int[], boolean[])"".']"
987,cdk,org/openscience/cdk/renderer/generators/standard/ConvexHull.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/ConvexHull.java,pointsOf,128-161,"/**
     * Convert a Java 2D shape to a list of points.
     *
     * @param shape a shape
     * @return list of point
     */
 static List<Point2D> pointsOf(final Shape shape){
    final List<Point2D> points = new ArrayList<Point2D>();
    final double[] coordinates = new double[6];
    for (PathIterator i = shape.getPathIterator(null); !i.isDone(); i.next()) {
        switch(i.currentSegment(coordinates)) {
            case PathIterator.SEG_CLOSE:
                break;
            case PathIterator.SEG_MOVETO:
            case PathIterator.SEG_LINETO:
                points.add(new Point2D.Double(coordinates[0], coordinates[1]));
                break;
            case PathIterator.SEG_QUADTO:
                points.add(new Point2D.Double(coordinates[0], coordinates[1]));
                points.add(new Point2D.Double(coordinates[2], coordinates[3]));
                break;
            case PathIterator.SEG_CUBICTO:
                points.add(new Point2D.Double(coordinates[0], coordinates[1]));
                points.add(new Point2D.Double(coordinates[2], coordinates[3]));
                points.add(new Point2D.Double(coordinates[4], coordinates[5]));
                break;
        }
    }
    if (!points.isEmpty() && points.get(points.size() - 1).equals(points.get(0))) {
        points.remove(points.size() - 1);
    }
    return points;
}","static List<Point2D> pointsOf(final Shape shape){
    final List<Point2D> points = new ArrayList<Point2D>();
    final double[] coordinates = new double[6];
    for (PathIterator i = shape.getPathIterator(null); !i.isDone(); i.next()) {
        switch(i.currentSegment(coordinates)) {
            case PathIterator.SEG_CLOSE:
                break;
            case PathIterator.SEG_MOVETO:
            case PathIterator.SEG_LINETO:
                points.add(new Point2D.Double(coordinates[0], coordinates[1]));
                break;
            case PathIterator.SEG_QUADTO:
                points.add(new Point2D.Double(coordinates[0], coordinates[1]));
                points.add(new Point2D.Double(coordinates[2], coordinates[3]));
                break;
            case PathIterator.SEG_CUBICTO:
                points.add(new Point2D.Double(coordinates[0], coordinates[1]));
                points.add(new Point2D.Double(coordinates[2], coordinates[3]));
                points.add(new Point2D.Double(coordinates[4], coordinates[5]));
                break;
        }
    }
    if (!points.isEmpty() && points.get(points.size() - 1).equals(points.get(0))) {
        points.remove(points.size() - 1);
    }
    return points;
}","/**
     * Convert a Java 2D shape to a list of points.
     *
     * @param shape a shape
     * @return list of point
     */","('pointsOf', {'INSTRUCTION': {'covered': 120, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 2}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",287.0,Convert a Java 2D shape to a list of points.,11.0,"['A Java 2D shape can be converted to a list of points.', 'A Java 2D shape can be turned into a list of points.', 'A Java shape can be converted to a list of points.']"
988,cdk,org/openscience/cdk/layout/IdentityTemplateLibrary.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/IdentityTemplateLibrary.java,decodeCoordinates,245-280,"/**
     * Decode coordinates that have been placed in a byte buffer.
     *
     * @param str the string to decode
     * @return array of coordinates
     */
 static Point2d[] decodeCoordinates(String str){
    if (str.startsWith(""|("")) {
        int end = str.indexOf(')', 2);
        if (end < 0)
            return new Point2d[0];
        String[] strs = str.substring(2, end).split("";"");
        Point2d[] points = new Point2d[strs.length];
        for (int i = 0; i < strs.length; i++) {
            String coord = strs[i];
            int first = coord.indexOf(',');
            int second = coord.indexOf(',', first + 1);
            String x = coord.substring(0, first);
            String y = coord.substring(first + 1, second);
            if (x.isEmpty())
                x = ""0"";
            if (y.isEmpty())
                y = ""0"";
            points[i] = new Point2d(Double.parseDouble(x), Double.parseDouble(y));
        }
        return points;
    } else {
        String[] strs = str.split("", "");
        Point2d[] points = new Point2d[strs.length / 2];
        for (int i = 0; i < strs.length; i += 2) {
            points[i / 2] = new Point2d(Double.parseDouble(strs[i]), Double.parseDouble(strs[i + 1]));
        }
        return points;
    }
}","static Point2d[] decodeCoordinates(String str){
    if (str.startsWith(""|("")) {
        int end = str.indexOf(')', 2);
        if (end < 0)
            return new Point2d[0];
        String[] strs = str.substring(2, end).split("";"");
        Point2d[] points = new Point2d[strs.length];
        for (int i = 0; i < strs.length; i++) {
            String coord = strs[i];
            int first = coord.indexOf(',');
            int second = coord.indexOf(',', first + 1);
            String x = coord.substring(0, first);
            String y = coord.substring(first + 1, second);
            if (x.isEmpty())
                x = ""0"";
            if (y.isEmpty())
                y = ""0"";
            points[i] = new Point2d(Double.parseDouble(x), Double.parseDouble(y));
        }
        return points;
    } else {
        String[] strs = str.split("", "");
        Point2d[] points = new Point2d[strs.length / 2];
        for (int i = 0; i < strs.length; i += 2) {
            points[i / 2] = new Point2d(Double.parseDouble(strs[i]), Double.parseDouble(strs[i + 1]));
        }
        return points;
    }
}","/**
     * Decode coordinates that have been placed in a byte buffer.
     *
     * @param str the string to decode
     * @return array of coordinates
     */","('decodeCoordinates', {'INSTRUCTION': {'covered': 115, 'missed': 5}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 22, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",290.0,  Decode coordinates that have been placed in a byte buffer.,11.0,"['The coordinates have been placed in a buffer.', 'The coordinates are in a buffer.', 'The coordinates have been put in a buffer.']"
989,cdk,org/openscience/cdk/hash/stereo/DoubleBondElementEncoderFactory.java,/tool/hash/src/main/java/org/openscience/cdk/hash/stereo/DoubleBondElementEncoderFactory.java,encoder,74-117,"/**
     * Create an encoder for the {@link IDoubleBondStereochemistry} element.
     *
     * @param dbs          stereo element from an atom container
     * @param atomToIndex  map of atoms to indices
     * @param graph        adjacency list of connected vertices
     * @return a new geometry encoder
     */
private static GeometryEncoder encoder(IDoubleBondStereochemistry dbs, Map<IAtom, Integer> atomToIndex, int[][] graph){
    IBond db = dbs.getStereoBond();
    int u = atomToIndex.get(db.getBegin());
    int v = atomToIndex.get(db.getEnd());
    IBond[] bs = dbs.getBonds();
    int[] us = new int[2];
    int[] vs = new int[2];
    us[0] = atomToIndex.get(bs[0].getOther(db.getBegin()));
    us[1] = graph[u].length == 2 ? u : findOther(graph[u], v, us[0]);
    vs[0] = atomToIndex.get(bs[1].getOther(db.getEnd()));
    vs[1] = graph[v].length == 2 ? v : findOther(graph[v], u, vs[0]);
    int parity = dbs.getStereo() == OPPOSITE ? +1 : -1;
    GeometricParity geomParity = GeometricParity.valueOf(parity);
    PermutationParity permParity = new CombinedPermutationParity(us[1] == u ? BasicPermutationParity.IDENTITY : new BasicPermutationParity(us), vs[1] == v ? BasicPermutationParity.IDENTITY : new BasicPermutationParity(vs));
    return new GeometryEncoder(new int[] { u, v }, permParity, geomParity);
}","private static GeometryEncoder encoder(IDoubleBondStereochemistry dbs, Map<IAtom, Integer> atomToIndex, int[][] graph){
    IBond db = dbs.getStereoBond();
    int u = atomToIndex.get(db.getBegin());
    int v = atomToIndex.get(db.getEnd());
    IBond[] bs = dbs.getBonds();
    int[] us = new int[2];
    int[] vs = new int[2];
    us[0] = atomToIndex.get(bs[0].getOther(db.getBegin()));
    us[1] = graph[u].length == 2 ? u : findOther(graph[u], v, us[0]);
    vs[0] = atomToIndex.get(bs[1].getOther(db.getEnd()));
    vs[1] = graph[v].length == 2 ? v : findOther(graph[v], u, vs[0]);
    int parity = dbs.getStereo() == OPPOSITE ? +1 : -1;
    GeometricParity geomParity = GeometricParity.valueOf(parity);
    PermutationParity permParity = new CombinedPermutationParity(us[1] == u ? BasicPermutationParity.IDENTITY : new BasicPermutationParity(us), vs[1] == v ? BasicPermutationParity.IDENTITY : new BasicPermutationParity(vs));
    return new GeometryEncoder(new int[] { u, v }, permParity, geomParity);
}","/**
     * Create an encoder for the {@link IDoubleBondStereochemistry} element.
     *
     * @param dbs          stereo element from an atom container
     * @param atomToIndex  map of atoms to indices
     * @param graph        adjacency list of connected vertices
     * @return a new geometry encoder
     */","('encoder', {'INSTRUCTION': {'covered': 143, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 0}, 'LINE': {'covered': 16, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",292.0,  Create an encoder for the {@link IDoubleBondStereochemistry} element.,12.0,"['The @link IDoubleBondStereochemistry element requires an Encoder.', 'The @link IDoubleBondStereochemistry element has an Encoder.', 'The @link IDoubleBondStereochemistry element is an example of an Encoder.']"
990,weblogic-kubernetes-operator,oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,/operator/src/main/java/oracle/kubernetes/operator/wlsconfig/WlsDomainConfig.java,parseJson,165-202,"/**
   * Parse the json string containing WLS configuration and return a list containing a map of
   * (server attribute name, attribute value).
   *
   * @param jsonString JSON string containing WLS configuration to be parsed
   * @return a ParsedJson object containing WebLogic domain configuration by parsing the given JSON
   *     string
   */
private static ParsedJson parseJson(String jsonString){
    ObjectMapper mapper = new ObjectMapper();
    try {
        ParsedJson parsedJson = new ParsedJson();
        Map result = mapper.readValue(jsonString, Map.class);
        parsedJson.domainName = (String) result.get(""name"");
        parsedJson.adminServerName = (String) result.get(""adminServerName"");
        Map servers = (Map<String, Object>) result.get(""servers"");
        if (servers != null) {
            parsedJson.servers = (List<Map<String, Object>>) servers.get(""items"");
        }
        Map serverTemplates = (Map<String, Object>) result.get(""serverTemplates"");
        if (serverTemplates != null) {
            parsedJson.serverTemplates = (List<Map<String, Object>>) serverTemplates.get(""items"");
        }
        Map clusters = (Map<String, Object>) result.get(""clusters"");
        if (clusters != null) {
            parsedJson.clusters = (List<Map<String, Object>>) clusters.get(""items"");
        }
        Map machines = (Map<String, Object>) result.get(""machines"");
        if (machines != null) {
            parsedJson.machines = (List<Map<String, Object>>) machines.get(""items"");
        }
        return parsedJson;
    } catch (Exception e) {
        LOGGER.warning(MessageKeys.JSON_PARSING_FAILED, jsonString, e.getMessage());
    }
    return null;
}","private static ParsedJson parseJson(String jsonString){
    ObjectMapper mapper = new ObjectMapper();
    try {
        ParsedJson parsedJson = new ParsedJson();
        Map result = mapper.readValue(jsonString, Map.class);
        parsedJson.domainName = (String) result.get(""name"");
        parsedJson.adminServerName = (String) result.get(""adminServerName"");
        Map servers = (Map<String, Object>) result.get(""servers"");
        if (servers != null) {
            parsedJson.servers = (List<Map<String, Object>>) servers.get(""items"");
        }
        Map serverTemplates = (Map<String, Object>) result.get(""serverTemplates"");
        if (serverTemplates != null) {
            parsedJson.serverTemplates = (List<Map<String, Object>>) serverTemplates.get(""items"");
        }
        Map clusters = (Map<String, Object>) result.get(""clusters"");
        if (clusters != null) {
            parsedJson.clusters = (List<Map<String, Object>>) clusters.get(""items"");
        }
        Map machines = (Map<String, Object>) result.get(""machines"");
        if (machines != null) {
            parsedJson.machines = (List<Map<String, Object>>) machines.get(""items"");
        }
        return parsedJson;
    } catch (Exception e) {
        LOGGER.warning(MessageKeys.JSON_PARSING_FAILED, jsonString, e.getMessage());
    }
    return null;
}","/**
   * Parse the json string containing WLS configuration and return a list containing a map of
   * (server attribute name, attribute value).
   *
   * @param jsonString JSON string containing WLS configuration to be parsed
   * @return a ParsedJson object containing WebLogic domain configuration by parsing the given JSON
   *     string
   */","('parseJson', {'INSTRUCTION': {'covered': 80, 'missed': 17}, 'BRANCH': {'covered': 7, 'missed': 1}, 'LINE': {'covered': 18, 'missed': 3}, 'COMPLEXITY': {'covered': 4, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",293.0,"  Parse the json string containing WLS configuration and return a list containing a map of  (server attribute name, attribute value).",24.0,"['A list containing a map of the server attribute name and attribute value can be returned from Parse the json string.', 'A list containing a map of server attribute name and attribute value can be returned from Parse the json string.', 'A list containing a map of server attribute name and attribute value can be returned from Parse the json string containingWLS configuration.']"
991,zxing,com/google/zxing/aztec/detector/Detector.java,/core/src/main/java/com/google/zxing/aztec/detector/Detector.java,extractParameters,100-154,"/**
   * Extracts the number of data layers and data blocks from the layer around the bull's eye.
   *
   * @param bullsEyeCorners the array of bull's eye corners
   * @throws NotFoundException in case of too many errors or invalid parameters
   */
private void extractParameters(ResultPoint[] bullsEyeCorners) throws NotFoundException{
    if (!isValid(bullsEyeCorners[0]) || !isValid(bullsEyeCorners[1]) || !isValid(bullsEyeCorners[2]) || !isValid(bullsEyeCorners[3])) {
        throw NotFoundException.getNotFoundInstance();
    }
    int length = 2 * nbCenterLayers;
    int[] sides = { sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length), sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length), sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length), sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) };
    shift = getRotation(sides, length);
    long parameterData = 0;
    for (int i = 0; i < 4; i++) {
        int side = sides[(shift + i) % 4];
        if (compact) {
            parameterData <<= 7;
            parameterData += (side >> 1) & 0x7F;
        } else {
            parameterData <<= 10;
            parameterData += ((side >> 2) & (0x1f << 5)) + ((side >> 1) & 0x1F);
        }
    }
    int correctedData = getCorrectedParameterData(parameterData, compact);
    if (compact) {
        nbLayers = (correctedData >> 6) + 1;
        nbDataBlocks = (correctedData & 0x3F) + 1;
    } else {
        nbLayers = (correctedData >> 11) + 1;
        nbDataBlocks = (correctedData & 0x7FF) + 1;
    }
}","private void extractParameters(ResultPoint[] bullsEyeCorners) throws NotFoundException{
    if (!isValid(bullsEyeCorners[0]) || !isValid(bullsEyeCorners[1]) || !isValid(bullsEyeCorners[2]) || !isValid(bullsEyeCorners[3])) {
        throw NotFoundException.getNotFoundInstance();
    }
    int length = 2 * nbCenterLayers;
    int[] sides = { sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length), sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length), sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length), sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) };
    shift = getRotation(sides, length);
    long parameterData = 0;
    for (int i = 0; i < 4; i++) {
        int side = sides[(shift + i) % 4];
        if (compact) {
            parameterData <<= 7;
            parameterData += (side >> 1) & 0x7F;
        } else {
            parameterData <<= 10;
            parameterData += ((side >> 2) & (0x1f << 5)) + ((side >> 1) & 0x1F);
        }
    }
    int correctedData = getCorrectedParameterData(parameterData, compact);
    if (compact) {
        nbLayers = (correctedData >> 6) + 1;
        nbDataBlocks = (correctedData & 0x3F) + 1;
    } else {
        nbLayers = (correctedData >> 11) + 1;
        nbDataBlocks = (correctedData & 0x7FF) + 1;
    }
}","/**
   * Extracts the number of data layers and data blocks from the layer around the bull's eye.
   *
   * @param bullsEyeCorners the array of bull's eye corners
   * @throws NotFoundException in case of too many errors or invalid parameters
   */","('extractParameters', {'INSTRUCTION': {'covered': 177, 'missed': 2}, 'BRANCH': {'covered': 10, 'missed': 4}, 'LINE': {'covered': 24, 'missed': 1}, 'COMPLEXITY': {'covered': 4, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",295.0,  Extracts the number of data layers and data blocks from the layer around the bull's eye.,18.0,"['The number of data layers and data blocks is obtained.', 'The number of data layers and data blocks are obtained.', ""The number of data layers and data blocks that are recovered from the bull's eye.""]"
992,mybatis-3,org/apache/ibatis/reflection/ArrayUtil.java,/src/main/java/org/apache/ibatis/reflection/ArrayUtil.java,hashCode,25-61,"/**
   * Returns a hash code for {@code obj}.
   *
   * @param obj
   *          The object to get a hash code for. May be an array or <code>null</code>.
   * @return A hash code of {@code obj} or 0 if {@code obj} is <code>null</code>
   */
public static int hashCode(Object obj){
    if (obj == null) {
        // for consistency with Arrays#hashCode() and Objects#hashCode()
        return 0;
    }
    final Class<?> clazz = obj.getClass();
    if (!clazz.isArray()) {
        return obj.hashCode();
    }
    final Class<?> componentType = clazz.getComponentType();
    if (long.class.equals(componentType)) {
        return Arrays.hashCode((long[]) obj);
    } else if (int.class.equals(componentType)) {
        return Arrays.hashCode((int[]) obj);
    } else if (short.class.equals(componentType)) {
        return Arrays.hashCode((short[]) obj);
    } else if (char.class.equals(componentType)) {
        return Arrays.hashCode((char[]) obj);
    } else if (byte.class.equals(componentType)) {
        return Arrays.hashCode((byte[]) obj);
    } else if (boolean.class.equals(componentType)) {
        return Arrays.hashCode((boolean[]) obj);
    } else if (float.class.equals(componentType)) {
        return Arrays.hashCode((float[]) obj);
    } else if (double.class.equals(componentType)) {
        return Arrays.hashCode((double[]) obj);
    } else {
        return Arrays.hashCode((Object[]) obj);
    }
}","public static int hashCode(Object obj){
    if (obj == null) {
        // for consistency with Arrays#hashCode() and Objects#hashCode()
        return 0;
    }
    final Class<?> clazz = obj.getClass();
    if (!clazz.isArray()) {
        return obj.hashCode();
    }
    final Class<?> componentType = clazz.getComponentType();
    if (long.class.equals(componentType)) {
        return Arrays.hashCode((long[]) obj);
    } else if (int.class.equals(componentType)) {
        return Arrays.hashCode((int[]) obj);
    } else if (short.class.equals(componentType)) {
        return Arrays.hashCode((short[]) obj);
    } else if (char.class.equals(componentType)) {
        return Arrays.hashCode((char[]) obj);
    } else if (byte.class.equals(componentType)) {
        return Arrays.hashCode((byte[]) obj);
    } else if (boolean.class.equals(componentType)) {
        return Arrays.hashCode((boolean[]) obj);
    } else if (float.class.equals(componentType)) {
        return Arrays.hashCode((float[]) obj);
    } else if (double.class.equals(componentType)) {
        return Arrays.hashCode((double[]) obj);
    } else {
        return Arrays.hashCode((Object[]) obj);
    }
}","/**
   * Returns a hash code for {@code obj}.
   *
   * @param obj
   *          The object to get a hash code for. May be an array or <code>null</code>.
   * @return A hash code of {@code obj} or 0 if {@code obj} is <code>null</code>
   */","('hashCode', {'INSTRUCTION': {'covered': 84, 'missed': 0}, 'BRANCH': {'covered': 20, 'missed': 0}, 'LINE': {'covered': 23, 'missed': 0}, 'COMPLEXITY': {'covered': 11, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",296.0,  Returns a hash code for {@code obj}.,11.0,"['A code is returned for @code obj.', 'The code is returned for @code obj.', 'Return a code for @code obj.']"
993,cdk,org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,add3DCoordinatesForSinglyBondedLigands,77-121,"/**
     *  Generate coordinates for all atoms which are singly bonded and have no
     *  coordinates. This is useful when hydrogens are present but have no coordinates.
     *  It knows about C, O, N, S only and will give tetrahedral or trigonal
     *  geometry elsewhere. Bond lengths are computed from covalent radii or taken
     *  out of a parameter set if available. Angles are tetrahedral or trigonal
     *
     * @param  atomContainer  the set of atoms involved
     * @throws CDKException
     * @cdk.keyword           coordinate calculation
     * @cdk.keyword           3D model
     */
public void add3DCoordinatesForSinglyBondedLigands(IAtomContainer atomContainer) throws CDKException{
    IAtom refAtom = null;
    IAtom atomC = null;
    int nwanted = 0;
    for (int i = 0; i < atomContainer.getAtomCount(); i++) {
        refAtom = atomContainer.getAtom(i);
        if (refAtom.getAtomicNumber() != IElement.H && hasUnsetNeighbour(refAtom, atomContainer)) {
            IAtomContainer noCoords = getUnsetAtomsInAtomContainer(refAtom, atomContainer);
            IAtomContainer withCoords = getPlacedAtomsInAtomContainer(refAtom, atomContainer);
            if (withCoords.getAtomCount() > 0) {
                atomC = getPlacedHeavyAtomInAtomContainer(withCoords.getAtom(0), refAtom, atomContainer);
            }
            if (refAtom.getFormalNeighbourCount() == 0 && refAtom.getAtomicNumber() == IElement.C) {
                nwanted = noCoords.getAtomCount();
            } else if (refAtom.getFormalNeighbourCount() == 0 && refAtom.getAtomicNumber() != IElement.C) {
                nwanted = 4;
            } else {
                nwanted = refAtom.getFormalNeighbourCount() - withCoords.getAtomCount();
            }
            Point3d[] newPoints = get3DCoordinatesForLigands(refAtom, noCoords, withCoords, atomC, nwanted, DEFAULT_BOND_LENGTH_H, -1);
            for (int j = 0; j < noCoords.getAtomCount(); j++) {
                IAtom ligand = noCoords.getAtom(j);
                Point3d newPoint = rescaleBondLength(refAtom, ligand, newPoints[j]);
                ligand.setPoint3d(newPoint);
                ligand.setFlag(CDKConstants.ISPLACED, true);
            }
            noCoords.removeAllElements();
            withCoords.removeAllElements();
        }
    }
}","public void add3DCoordinatesForSinglyBondedLigands(IAtomContainer atomContainer) throws CDKException{
    IAtom refAtom = null;
    IAtom atomC = null;
    int nwanted = 0;
    for (int i = 0; i < atomContainer.getAtomCount(); i++) {
        refAtom = atomContainer.getAtom(i);
        if (refAtom.getAtomicNumber() != IElement.H && hasUnsetNeighbour(refAtom, atomContainer)) {
            IAtomContainer noCoords = getUnsetAtomsInAtomContainer(refAtom, atomContainer);
            IAtomContainer withCoords = getPlacedAtomsInAtomContainer(refAtom, atomContainer);
            if (withCoords.getAtomCount() > 0) {
                atomC = getPlacedHeavyAtomInAtomContainer(withCoords.getAtom(0), refAtom, atomContainer);
            }
            if (refAtom.getFormalNeighbourCount() == 0 && refAtom.getAtomicNumber() == IElement.C) {
                nwanted = noCoords.getAtomCount();
            } else if (refAtom.getFormalNeighbourCount() == 0 && refAtom.getAtomicNumber() != IElement.C) {
                nwanted = 4;
            } else {
                nwanted = refAtom.getFormalNeighbourCount() - withCoords.getAtomCount();
            }
            Point3d[] newPoints = get3DCoordinatesForLigands(refAtom, noCoords, withCoords, atomC, nwanted, DEFAULT_BOND_LENGTH_H, -1);
            for (int j = 0; j < noCoords.getAtomCount(); j++) {
                IAtom ligand = noCoords.getAtom(j);
                Point3d newPoint = rescaleBondLength(refAtom, ligand, newPoints[j]);
                ligand.setPoint3d(newPoint);
                ligand.setFlag(CDKConstants.ISPLACED, true);
            }
            noCoords.removeAllElements();
            withCoords.removeAllElements();
        }
    }
}","/**
     *  Generate coordinates for all atoms which are singly bonded and have no
     *  coordinates. This is useful when hydrogens are present but have no coordinates.
     *  It knows about C, O, N, S only and will give tetrahedral or trigonal
     *  geometry elsewhere. Bond lengths are computed from covalent radii or taken
     *  out of a parameter set if available. Angles are tetrahedral or trigonal
     *
     * @param  atomContainer  the set of atoms involved
     * @throws CDKException
     * @cdk.keyword           coordinate calculation
     * @cdk.keyword           3D model
     */","('add3DCoordinatesForSinglyBondedLigands', {'INSTRUCTION': {'covered': 106, 'missed': 17}, 'BRANCH': {'covered': 12, 'missed': 6}, 'LINE': {'covered': 22, 'missed': 2}, 'COMPLEXITY': {'covered': 6, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",296.0,  Generate coordinates for all atoms which are singly bonded and have no  coordinates.,14.0,"['All atoms have no coordinates.', 'All of the atoms have no coordinates.', 'All atoms have no coordinates, but they are singly bonded.']"
994,cdk,org/openscience/cdk/depict/SvgDrawVisitor.java,/app/depict/src/main/java/org/openscience/cdk/depict/SvgDrawVisitor.java,previsit,215-258,"/**
     * Pre-visit allows us to prepare the visitor for more optimal output.
     * Currently we
     * - find the most common stoke/fill/stroke-width values and set these as defaults
     *
     * @param elements elements to be visited
     */
public void previsit(Collection<? extends IRenderingElement> elements){
    Deque<IRenderingElement> queue = new ArrayDeque<>(2 * elements.size());
    queue.addAll(elements);
    FreqMap<Color> strokeFreq = new FreqMap<>();
    FreqMap<Color> fillFreq = new FreqMap<>();
    FreqMap<Double> strokeWidthFreq = new FreqMap<>();
    while (!queue.isEmpty()) {
        IRenderingElement element = queue.poll();
        // wrappers first
        if (element instanceof Bounds) {
            queue.add(((Bounds) element).root());
        } else if (element instanceof MarkedElement) {
            queue.add(((MarkedElement) element).element());
        } else if (element instanceof ElementGroup) {
            for (IRenderingElement child : (ElementGroup) element) queue.add(child);
        } else if (element instanceof LineElement) {
            strokeFreq.add(((LineElement) element).color);
            strokeWidthFreq.add(scaled(((LineElement) element).width));
        } else if (element instanceof GeneralPath) {
            if (((GeneralPath) element).fill)
                fillFreq.add(((GeneralPath) element).color);
        } else {
            // ignored
        }
    }
    if (!defaultsWritten) {
        defaultFill = fillFreq.getMostFrequent();
        defaultStroke = strokeFreq.getMostFrequent();
        Double strokeWidth = strokeWidthFreq.getMostFrequent();
        if (strokeWidth != null)
            defaultStrokeWidth = toStr(strokeWidth);
    }
}","public void previsit(Collection<? extends IRenderingElement> elements){
    Deque<IRenderingElement> queue = new ArrayDeque<>(2 * elements.size());
    queue.addAll(elements);
    FreqMap<Color> strokeFreq = new FreqMap<>();
    FreqMap<Color> fillFreq = new FreqMap<>();
    FreqMap<Double> strokeWidthFreq = new FreqMap<>();
    while (!queue.isEmpty()) {
        IRenderingElement element = queue.poll();
        // wrappers first
        if (element instanceof Bounds) {
            queue.add(((Bounds) element).root());
        } else if (element instanceof MarkedElement) {
            queue.add(((MarkedElement) element).element());
        } else if (element instanceof ElementGroup) {
            for (IRenderingElement child : (ElementGroup) element) queue.add(child);
        } else if (element instanceof LineElement) {
            strokeFreq.add(((LineElement) element).color);
            strokeWidthFreq.add(scaled(((LineElement) element).width));
        } else if (element instanceof GeneralPath) {
            if (((GeneralPath) element).fill)
                fillFreq.add(((GeneralPath) element).color);
        } else {
            // ignored
        }
    }
    if (!defaultsWritten) {
        defaultFill = fillFreq.getMostFrequent();
        defaultStroke = strokeFreq.getMostFrequent();
        Double strokeWidth = strokeWidthFreq.getMostFrequent();
        if (strokeWidth != null)
            defaultStrokeWidth = toStr(strokeWidth);
    }
}","/**
     * Pre-visit allows us to prepare the visitor for more optimal output.
     * Currently we
     * - find the most common stoke/fill/stroke-width values and set these as defaults
     *
     * @param elements elements to be visited
     */","('previsit', {'INSTRUCTION': {'covered': 127, 'missed': 0}, 'BRANCH': {'covered': 16, 'missed': 4}, 'LINE': {'covered': 28, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",297.0,  Pre-visit allows us to prepare the visitor for more optimal output.,12.0,"['Pre-visit allows us to make sure the visitor gets the best output.', 'Pre-visit allows us to make sure the visitor is prepared for success.', 'Pre-visit allows us to make sure the visitor is prepared for the task at hand.']"
995,cdk,org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,layoutMolecule,260-312,"/**
     * Layout the molecule, starts with ring systems and than aliphatic chains.
     *
     *@param  ringSetMolecule  ringSystems of the molecule
     */
private void layoutMolecule(List ringSetMolecule, IAtomContainer molecule, AtomPlacer3D ap3d, AtomTetrahedralLigandPlacer3D atlp3d, AtomPlacer atomPlacer) throws CDKException, IOException, CloneNotSupportedException{
    IAtomContainer ac = null;
    int safetyCounter = 0;
    IAtom atom = null;
    do {
        safetyCounter++;
        atom = ap3d.getNextPlacedHeavyAtomWithUnplacedRingNeighbour(molecule);
        if (atom != null) {
            IAtom unplacedAtom = ap3d.getUnplacedRingHeavyAtom(molecule, atom);
            IRingSet ringSetA = getRingSetOfAtom(ringSetMolecule, unplacedAtom);
            IAtomContainer ringSetAContainer = RingSetManipulator.getAllInOneContainer(ringSetA);
            templateHandler.mapTemplates(ringSetAContainer, ringSetAContainer.getAtomCount());
            if (checkAllRingAtomsHasCoordinates(ringSetAContainer)) {
            } else {
                throw new IOException(""RingAtomLayoutError: Not every ring atom is placed! Molecule cannot be layout.Sorry"");
            }
            Point3d firstAtomOriginalCoord = unplacedAtom.getPoint3d();
            Point3d centerPlacedMolecule = ap3d.geometricCenterAllPlacedAtoms(molecule);
            setBranchAtom(molecule, unplacedAtom, atom, ap3d.getPlacedHeavyAtoms(molecule, atom), ap3d, atlp3d);
            layoutRingSystem(firstAtomOriginalCoord, unplacedAtom, ringSetA, centerPlacedMolecule, atom, ap3d);
            searchAndPlaceBranches(molecule, ringSetAContainer, ap3d, atlp3d, atomPlacer);
            ringSetA = null;
            unplacedAtom = null;
            firstAtomOriginalCoord = null;
            centerPlacedMolecule = null;
        } else {
            setAtomsToUnVisited(molecule);
            atom = ap3d.getNextPlacedHeavyAtomWithUnplacedAliphaticNeighbour(molecule);
            if (atom != null) {
                ac = atom.getBuilder().newInstance(IAtomContainer.class);
                ac.addAtom(atom);
                searchAndPlaceBranches(molecule, ac, ap3d, atlp3d, atomPlacer);
                ac = null;
            }
        }
    } while (!ap3d.allHeavyAtomsPlaced(molecule) || safetyCounter > molecule.getAtomCount());
}","private void layoutMolecule(List ringSetMolecule, IAtomContainer molecule, AtomPlacer3D ap3d, AtomTetrahedralLigandPlacer3D atlp3d, AtomPlacer atomPlacer) throws CDKException, IOException, CloneNotSupportedException{
    IAtomContainer ac = null;
    int safetyCounter = 0;
    IAtom atom = null;
    do {
        safetyCounter++;
        atom = ap3d.getNextPlacedHeavyAtomWithUnplacedRingNeighbour(molecule);
        if (atom != null) {
            IAtom unplacedAtom = ap3d.getUnplacedRingHeavyAtom(molecule, atom);
            IRingSet ringSetA = getRingSetOfAtom(ringSetMolecule, unplacedAtom);
            IAtomContainer ringSetAContainer = RingSetManipulator.getAllInOneContainer(ringSetA);
            templateHandler.mapTemplates(ringSetAContainer, ringSetAContainer.getAtomCount());
            if (checkAllRingAtomsHasCoordinates(ringSetAContainer)) {
            } else {
                throw new IOException(""RingAtomLayoutError: Not every ring atom is placed! Molecule cannot be layout.Sorry"");
            }
            Point3d firstAtomOriginalCoord = unplacedAtom.getPoint3d();
            Point3d centerPlacedMolecule = ap3d.geometricCenterAllPlacedAtoms(molecule);
            setBranchAtom(molecule, unplacedAtom, atom, ap3d.getPlacedHeavyAtoms(molecule, atom), ap3d, atlp3d);
            layoutRingSystem(firstAtomOriginalCoord, unplacedAtom, ringSetA, centerPlacedMolecule, atom, ap3d);
            searchAndPlaceBranches(molecule, ringSetAContainer, ap3d, atlp3d, atomPlacer);
            ringSetA = null;
            unplacedAtom = null;
            firstAtomOriginalCoord = null;
            centerPlacedMolecule = null;
        } else {
            setAtomsToUnVisited(molecule);
            atom = ap3d.getNextPlacedHeavyAtomWithUnplacedAliphaticNeighbour(molecule);
            if (atom != null) {
                ac = atom.getBuilder().newInstance(IAtomContainer.class);
                ac.addAtom(atom);
                searchAndPlaceBranches(molecule, ac, ap3d, atlp3d, atomPlacer);
                ac = null;
            }
        }
    } while (!ap3d.allHeavyAtomsPlaced(molecule) || safetyCounter > molecule.getAtomCount());
}","/**
     * Layout the molecule, starts with ring systems and than aliphatic chains.
     *
     *@param  ringSetMolecule  ringSystems of the molecule
     */","('layoutMolecule', {'INSTRUCTION': {'covered': 97, 'missed': 25}, 'BRANCH': {'covered': 6, 'missed': 4}, 'LINE': {'covered': 26, 'missed': 5}, 'COMPLEXITY': {'covered': 2, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",297.0,"  Layout the molecule, starts with ring systems and than aliphatic chains.",13.0,"['The molecule starts with ring systems and aliphatic chains.', 'The molecule starts with ring systems.', 'Ring systems and aliphatic chains are used to layout the molecule.']"
997,tablesaw,tech/tablesaw/io/ColumnTypeDetector.java,/core/src/main/java/tech/tablesaw/io/ColumnTypeDetector.java,detectColumnTypes,53-113,"/**
   * Estimates and returns the type for each column in the input text
   *
   * <p>The type is determined by checking a sample of the data. Because only a sample of the data
   * is checked, the types may be incorrect. If that is the case a Parse Exception will be thrown.
   *
   * <p>The method {@code printColumnTypes()} can be used to print a list of the detected columns
   * that can be corrected and used to explicitly specify the correct column types.
   */
public ColumnType[] detectColumnTypes(Iterator<String[]> rows, ReadOptions options){
    boolean useSampling = options.sample();
    // to hold the results
    List<ColumnType> columnTypes = new ArrayList<>();
    // to hold the data read from the file
    List<List<String>> columnData = new ArrayList<>();
    // make sure we don't go over maxRows
    int rowCount = 0;
    int nextRow = 0;
    while (rows.hasNext()) {
        String[] nextLine = rows.next();
        // initialize the arrays to hold the strings. we don't know how many we need until we read the
        // first row
        if (rowCount == 0) {
            for (int i = 0; i < nextLine.length; i++) {
                columnData.add(new ArrayList<>());
            }
        }
        int columnNumber = 0;
        if (rowCount == nextRow) {
            for (String field : nextLine) {
                columnData.get(columnNumber).add(field);
                columnNumber++;
            }
            if (useSampling) {
                nextRow = nextRow(nextRow);
            } else {
                nextRow = nextRowWithoutSampling(nextRow);
            }
        }
        rowCount++;
    }
    // now detect
    for (List<String> valuesList : columnData) {
        ColumnType detectedType = detectType(valuesList, options);
        if (detectedType.equals(STRING) && rowCount > STRING_COLUMN_ROW_COUNT_CUTOFF && options.columnTypesToDetect().contains(TEXT)) {
            HashSet<String> unique = new HashSet<>(valuesList);
            double uniquePct = unique.size() / (valuesList.size() * 1.0);
            if (uniquePct > STRING_COLUMN_CUTOFF) {
                detectedType = TEXT;
            }
        }
        columnTypes.add(detectedType);
    }
    return columnTypes.toArray(new ColumnType[0]);
}","public ColumnType[] detectColumnTypes(Iterator<String[]> rows, ReadOptions options){
    boolean useSampling = options.sample();
    // to hold the results
    List<ColumnType> columnTypes = new ArrayList<>();
    // to hold the data read from the file
    List<List<String>> columnData = new ArrayList<>();
    // make sure we don't go over maxRows
    int rowCount = 0;
    int nextRow = 0;
    while (rows.hasNext()) {
        String[] nextLine = rows.next();
        // initialize the arrays to hold the strings. we don't know how many we need until we read the
        // first row
        if (rowCount == 0) {
            for (int i = 0; i < nextLine.length; i++) {
                columnData.add(new ArrayList<>());
            }
        }
        int columnNumber = 0;
        if (rowCount == nextRow) {
            for (String field : nextLine) {
                columnData.get(columnNumber).add(field);
                columnNumber++;
            }
            if (useSampling) {
                nextRow = nextRow(nextRow);
            } else {
                nextRow = nextRowWithoutSampling(nextRow);
            }
        }
        rowCount++;
    }
    // now detect
    for (List<String> valuesList : columnData) {
        ColumnType detectedType = detectType(valuesList, options);
        if (detectedType.equals(STRING) && rowCount > STRING_COLUMN_ROW_COUNT_CUTOFF && options.columnTypesToDetect().contains(TEXT)) {
            HashSet<String> unique = new HashSet<>(valuesList);
            double uniquePct = unique.size() / (valuesList.size() * 1.0);
            if (uniquePct > STRING_COLUMN_CUTOFF) {
                detectedType = TEXT;
            }
        }
        columnTypes.add(detectedType);
    }
    return columnTypes.toArray(new ColumnType[0]);
}","/**
   * Estimates and returns the type for each column in the input text
   *
   * <p>The type is determined by checking a sample of the data. Because only a sample of the data
   * is checked, the types may be incorrect. If that is the case a Parse Exception will be thrown.
   *
   * <p>The method {@code printColumnTypes()} can be used to print a list of the detected columns
   * that can be corrected and used to explicitly specify the correct column types.
   */","('detectColumnTypes', {'INSTRUCTION': {'covered': 139, 'missed': 0}, 'BRANCH': {'covered': 22, 'missed': 0}, 'LINE': {'covered': 31, 'missed': 0}, 'COMPLEXITY': {'covered': 12, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",301.0,  Estimates and returns the type for each column in the input text   <p>The type is determined by checking a sample of the data.,27.0,"['The type is determined by checking a sample of the data.', 'Estimates and returns the type for each column in the input text.', 'The type is determined by checking a sample of the data, estimates and returns the type for each column.']"
998,dataverse,edu/harvard/iq/dataverse/authorization/providers/oauth2/OAuth2LoginBackingBean.java,/src/main/java/edu/harvard/iq/dataverse/authorization/providers/oauth2/OAuth2LoginBackingBean.java,parseStateFromRequest,156-204,"/**
     * Parse and verify the state returned from the provider.
     *
     * As it contains the providers implementation ""id"" field when send by us,
     * we can return the corresponding provider object.
     *
     * This function is not side effect free: it will (if present) set {@link #redirectPage}
     * to the value received from the state.
     *
     * @param state The state string, created in  {@link #createState(AbstractOAuth2AuthenticationProvider, Optional)}, send and returned by provider
     * @return A corresponding provider object when state verification succeeded.
     */
 Optional<AbstractOAuth2AuthenticationProvider> parseStateFromRequest(@NotNull String state){
    if (state == null || state.trim().equals("""")) {
        logger.log(Level.INFO, ""No state present in request"");
        return Optional.empty();
    }
    String[] topFields = state.split(""~"", 2);
    if (topFields.length != 2) {
        logger.log(Level.INFO, ""Wrong number of fields in state string"", state);
        return Optional.empty();
    }
    AbstractOAuth2AuthenticationProvider idp = authenticationSvc.getOAuth2Provider(topFields[0]);
    if (idp == null) {
        logger.log(Level.INFO, ""Can''t find IDP ''{0}''"", topFields[0]);
        return Optional.empty();
    }
    String raw = StringUtil.decrypt(topFields[1], idp.clientSecret);
    String[] stateFields = raw.split(""~"", -1);
    if (idp.getId().equals(stateFields[0])) {
        long timeOrigin = Long.parseLong(stateFields[1]);
        long timeDifference = this.clock.millis() - timeOrigin;
        if (timeDifference > 0 && timeDifference < STATE_TIMEOUT) {
            if (stateFields.length > 3) {
                this.redirectPage = Optional.ofNullable(stateFields[3]);
            }
            return Optional.of(idp);
        } else {
            logger.info(""State timeout"");
            return Optional.empty();
        }
    } else {
        logger.log(Level.INFO, ""Invalid id field: ''{0}''"", stateFields[0]);
        return Optional.empty();
    }
}","Optional<AbstractOAuth2AuthenticationProvider> parseStateFromRequest(@NotNull String state){
    if (state == null || state.trim().equals("""")) {
        logger.log(Level.INFO, ""No state present in request"");
        return Optional.empty();
    }
    String[] topFields = state.split(""~"", 2);
    if (topFields.length != 2) {
        logger.log(Level.INFO, ""Wrong number of fields in state string"", state);
        return Optional.empty();
    }
    AbstractOAuth2AuthenticationProvider idp = authenticationSvc.getOAuth2Provider(topFields[0]);
    if (idp == null) {
        logger.log(Level.INFO, ""Can''t find IDP ''{0}''"", topFields[0]);
        return Optional.empty();
    }
    String raw = StringUtil.decrypt(topFields[1], idp.clientSecret);
    String[] stateFields = raw.split(""~"", -1);
    if (idp.getId().equals(stateFields[0])) {
        long timeOrigin = Long.parseLong(stateFields[1]);
        long timeDifference = this.clock.millis() - timeOrigin;
        if (timeDifference > 0 && timeDifference < STATE_TIMEOUT) {
            if (stateFields.length > 3) {
                this.redirectPage = Optional.ofNullable(stateFields[3]);
            }
            return Optional.of(idp);
        } else {
            logger.info(""State timeout"");
            return Optional.empty();
        }
    } else {
        logger.log(Level.INFO, ""Invalid id field: ''{0}''"", stateFields[0]);
        return Optional.empty();
    }
}","/**
     * Parse and verify the state returned from the provider.
     *
     * As it contains the providers implementation ""id"" field when send by us,
     * we can return the corresponding provider object.
     *
     * This function is not side effect free: it will (if present) set {@link #redirectPage}
     * to the value received from the state.
     *
     * @param state The state string, created in  {@link #createState(AbstractOAuth2AuthenticationProvider, Optional)}, send and returned by provider
     * @return A corresponding provider object when state verification succeeded.
     */","('parseStateFromRequest', {'INSTRUCTION': {'covered': 112, 'missed': 0}, 'BRANCH': {'covered': 15, 'missed': 1}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",301.0,  Parse and verify the state returned from the provider.,10.0,"['Check the state returned from the provider.', 'Make sure the state returned from the provider is correct.', 'Make sure the state is returned from the provider.']"
999,cdk,org/openscience/cdk/libio/jena/Convertor.java,/storage/iordf/src/main/java/org/openscience/cdk/libio/jena/Convertor.java,molecule2Model,65-101,"/**
     * Converts a {@link IAtomContainer} into a {@link Model} representation using the CDK OWL.
     *
     * @param molecule {@link IAtomContainer} to serialize into a RDF graph.
     * @return the RDF graph representing the {@link IAtomContainer}.
     */
public static Model molecule2Model(IAtomContainer molecule){
    Model model = createCDKModel();
    Resource subject = model.createResource(createIdentifier(model, molecule));
    model.add(subject, RDF.type, CDK.MOLECULE);
    Map<IAtom, Resource> cdkToRDFAtomMap = new HashMap<IAtom, Resource>();
    for (IAtom atom : molecule.atoms()) {
        Resource rdfAtom = model.createResource(createIdentifier(model, atom));
        cdkToRDFAtomMap.put(atom, rdfAtom);
        model.add(subject, CDK.HASATOM, rdfAtom);
        if (atom instanceof IPseudoAtom) {
            model.add(rdfAtom, RDF.type, CDK.PSEUDOATOM);
            serializePseudoAtomFields(model, rdfAtom, (IPseudoAtom) atom);
        } else {
            model.add(rdfAtom, RDF.type, CDK.ATOM);
            serializeAtomFields(model, rdfAtom, atom);
        }
    }
    for (IBond bond : molecule.bonds()) {
        Resource rdfBond = model.createResource(createIdentifier(model, bond));
        model.add(rdfBond, RDF.type, CDK.BOND);
        for (IAtom atom : bond.atoms()) {
            model.add(rdfBond, CDK.BINDSATOM, cdkToRDFAtomMap.get(atom));
        }
        if (bond.getOrder() != null) {
            model.add(rdfBond, CDK.HASORDER, order2Resource(bond.getOrder()));
        }
        model.add(subject, CDK.HASBOND, rdfBond);
        serializeElectronContainerFields(model, rdfBond, bond);
    }
    return model;
}","public static Model molecule2Model(IAtomContainer molecule){
    Model model = createCDKModel();
    Resource subject = model.createResource(createIdentifier(model, molecule));
    model.add(subject, RDF.type, CDK.MOLECULE);
    Map<IAtom, Resource> cdkToRDFAtomMap = new HashMap<IAtom, Resource>();
    for (IAtom atom : molecule.atoms()) {
        Resource rdfAtom = model.createResource(createIdentifier(model, atom));
        cdkToRDFAtomMap.put(atom, rdfAtom);
        model.add(subject, CDK.HASATOM, rdfAtom);
        if (atom instanceof IPseudoAtom) {
            model.add(rdfAtom, RDF.type, CDK.PSEUDOATOM);
            serializePseudoAtomFields(model, rdfAtom, (IPseudoAtom) atom);
        } else {
            model.add(rdfAtom, RDF.type, CDK.ATOM);
            serializeAtomFields(model, rdfAtom, atom);
        }
    }
    for (IBond bond : molecule.bonds()) {
        Resource rdfBond = model.createResource(createIdentifier(model, bond));
        model.add(rdfBond, RDF.type, CDK.BOND);
        for (IAtom atom : bond.atoms()) {
            model.add(rdfBond, CDK.BINDSATOM, cdkToRDFAtomMap.get(atom));
        }
        if (bond.getOrder() != null) {
            model.add(rdfBond, CDK.HASORDER, order2Resource(bond.getOrder()));
        }
        model.add(subject, CDK.HASBOND, rdfBond);
        serializeElectronContainerFields(model, rdfBond, bond);
    }
    return model;
}","/**
     * Converts a {@link IAtomContainer} into a {@link Model} representation using the CDK OWL.
     *
     * @param molecule {@link IAtomContainer} to serialize into a RDF graph.
     * @return the RDF graph representing the {@link IAtomContainer}.
     */","('molecule2Model', {'INSTRUCTION': {'covered': 140, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 26, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",308.0,  Converts a {@link IAtomContainer} into a {@link Model} representation using the CDK OWL.,20.0,"['A @link IAtomContainer is converted into a @link Model representation using the CDK OWL.', 'A @link IAtomContainer is converted to a @link Model representation using the CDK OWL.', 'A @link IAtomContainer can be converted into a @link Model representation using the CDK OWL.']"
1000,cdk,org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/HydrogenPosition.java,usingAngularExtent,124-184,"/**
     * Using the angular extents of vectors, determine the best position for a hydrogen label. The
     * position with the most space is selected first. If multiple positions have the same amount of
     * space, the one where the hydrogen position is most centred is selected. If all position are
     * okay, the priority is Right > Left > Above > Below.
     *
     * @param vectors directional vectors for each bond from an atom
     * @return best hydrogen position
     */
 static HydrogenPosition usingAngularExtent(final List<Vector2d> vectors){
    double[] extents = VecmathUtil.extents(vectors);
    Arrays.sort(extents);
    Map<HydrogenPosition, OffsetExtent> extentMap = new HashMap<HydrogenPosition, OffsetExtent>();
    for (int i = 0; i < extents.length; i++) {
        final double before = extents[i];
        final double after = extents[(i + 1) % extents.length];
        for (final HydrogenPosition position : values()) {
            final double bias = TAU - position.direction;
            double afterBias = after + bias;
            double beforeBias = before + bias;
            if (beforeBias >= TAU)
                beforeBias -= TAU;
            if (afterBias >= TAU)
                afterBias -= TAU;
            final double afterExtent = afterBias;
            final double beforeExtent = TAU - beforeBias;
            final double totalExtent = afterExtent + beforeExtent;
            final double offset = Math.abs(totalExtent / 2 - beforeExtent);
            OffsetExtent offsetExtent = extentMap.get(position);
            if (offsetExtent == null || totalExtent < offsetExtent.extent) {
                extentMap.put(position, new OffsetExtent(totalExtent, offset));
            }
        }
    }
    Set<Map.Entry<HydrogenPosition, OffsetExtent>> extentEntries = extentMap.entrySet();
    Map.Entry<HydrogenPosition, OffsetExtent> best = null;
    for (Map.Entry<HydrogenPosition, OffsetExtent> e : extentEntries) {
        if (best == null || ExtentPriority.INSTANCE.compare(e, best) < 0)
            best = e;
    }
    assert best != null;
    return best.getKey();
}","static HydrogenPosition usingAngularExtent(final List<Vector2d> vectors){
    double[] extents = VecmathUtil.extents(vectors);
    Arrays.sort(extents);
    Map<HydrogenPosition, OffsetExtent> extentMap = new HashMap<HydrogenPosition, OffsetExtent>();
    for (int i = 0; i < extents.length; i++) {
        final double before = extents[i];
        final double after = extents[(i + 1) % extents.length];
        for (final HydrogenPosition position : values()) {
            final double bias = TAU - position.direction;
            double afterBias = after + bias;
            double beforeBias = before + bias;
            if (beforeBias >= TAU)
                beforeBias -= TAU;
            if (afterBias >= TAU)
                afterBias -= TAU;
            final double afterExtent = afterBias;
            final double beforeExtent = TAU - beforeBias;
            final double totalExtent = afterExtent + beforeExtent;
            final double offset = Math.abs(totalExtent / 2 - beforeExtent);
            OffsetExtent offsetExtent = extentMap.get(position);
            if (offsetExtent == null || totalExtent < offsetExtent.extent) {
                extentMap.put(position, new OffsetExtent(totalExtent, offset));
            }
        }
    }
    Set<Map.Entry<HydrogenPosition, OffsetExtent>> extentEntries = extentMap.entrySet();
    Map.Entry<HydrogenPosition, OffsetExtent> best = null;
    for (Map.Entry<HydrogenPosition, OffsetExtent> e : extentEntries) {
        if (best == null || ExtentPriority.INSTANCE.compare(e, best) < 0)
            best = e;
    }
    assert best != null;
    return best.getKey();
}","/**
     * Using the angular extents of vectors, determine the best position for a hydrogen label. The
     * position with the most space is selected first. If multiple positions have the same amount of
     * space, the one where the hydrogen position is most centred is selected. If all position are
     * okay, the priority is Right > Left > Above > Below.
     *
     * @param vectors directional vectors for each bond from an atom
     * @return best hydrogen position
     */","('usingAngularExtent', {'INSTRUCTION': {'covered': 147, 'missed': 4}, 'BRANCH': {'covered': 20, 'missed': 2}, 'LINE': {'covered': 26, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",308.0,"  Using the angular extents of vectors, determine the best position for a hydrogen label.",16.0,"['The best position for a hydrogen label can be determined using the angular extents of the vectors.', 'The best position for a hydrogen label is determined using the angular extents of the vectors.', 'Determine the best position for a hydrogen label by using the angular extents of the vectors.']"
1001,cdk,org/openscience/cdk/smiles/CxSmilesParser.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/CxSmilesParser.java,processAtomLabels,62-124,"/**
     * Process atom labels from extended SMILES in a char iter.
     *
     * @param iter char iteration
     * @param dest destination of labels (atomidx->label)
     * @return parse success/failure
     */
private static boolean processAtomLabels(final CharIter iter, final Map<Integer, String> dest){
    int atomIdx = 0;
    while (iter.hasNext()) {
        // fast forward through empty labels
        while (iter.nextIf(';')) atomIdx++;
        char c = iter.next();
        if (c == '$') {
            // optional
            iter.nextIf(',');
            // end of atom label
            return true;
        } else {
            // push back
            iter.pos--;
            int beg = iter.pos;
            int rollback = beg;
            while (iter.hasNext()) {
                if (iter.pos == beg && iter.curr() == '_' && iter.peek() == 'R') {
                    ++beg;
                }
                // correct step over of escaped label
                if (iter.curr() == '&') {
                    rollback = iter.pos;
                    if (iter.nextIf('&') && iter.nextIf('#') && iter.nextIfDigit()) {
                        // more digits
                        while (iter.nextIfDigit()) {
                        }
                        if (!iter.nextIf(';')) {
                            iter.pos = rollback;
                        } else {
                        }
                    } else {
                        iter.pos = rollback;
                    }
                } else if (iter.curr() == ';')
                    break;
                else if (iter.curr() == '$')
                    break;
                else
                    iter.next();
            }
            dest.put(atomIdx, unescape(iter.substr(beg, iter.pos)));
            atomIdx++;
            if (iter.nextIf('$')) {
                // optional
                iter.nextIf(',');
                return true;
            }
            if (!iter.nextIf(';'))
                return false;
        }
    }
    return false;
}","private static boolean processAtomLabels(final CharIter iter, final Map<Integer, String> dest){
    int atomIdx = 0;
    while (iter.hasNext()) {
        // fast forward through empty labels
        while (iter.nextIf(';')) atomIdx++;
        char c = iter.next();
        if (c == '$') {
            // optional
            iter.nextIf(',');
            // end of atom label
            return true;
        } else {
            // push back
            iter.pos--;
            int beg = iter.pos;
            int rollback = beg;
            while (iter.hasNext()) {
                if (iter.pos == beg && iter.curr() == '_' && iter.peek() == 'R') {
                    ++beg;
                }
                // correct step over of escaped label
                if (iter.curr() == '&') {
                    rollback = iter.pos;
                    if (iter.nextIf('&') && iter.nextIf('#') && iter.nextIfDigit()) {
                        // more digits
                        while (iter.nextIfDigit()) {
                        }
                        if (!iter.nextIf(';')) {
                            iter.pos = rollback;
                        } else {
                        }
                    } else {
                        iter.pos = rollback;
                    }
                } else if (iter.curr() == ';')
                    break;
                else if (iter.curr() == '$')
                    break;
                else
                    iter.next();
            }
            dest.put(atomIdx, unescape(iter.substr(beg, iter.pos)));
            atomIdx++;
            if (iter.nextIf('$')) {
                // optional
                iter.nextIf(',');
                return true;
            }
            if (!iter.nextIf(';'))
                return false;
        }
    }
    return false;
}","/**
     * Process atom labels from extended SMILES in a char iter.
     *
     * @param iter char iteration
     * @param dest destination of labels (atomidx->label)
     * @return parse success/failure
     */","('processAtomLabels', {'INSTRUCTION': {'covered': 118, 'missed': 10}, 'BRANCH': {'covered': 30, 'missed': 4}, 'LINE': {'covered': 34, 'missed': 2}, 'COMPLEXITY': {'covered': 14, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",309.0,  Process atom labels from extended SMILES in a char iter.,11.0,"['A char iter is used to process atom labels.', 'In a char iter, process atom labels.', 'atom labels are processed in a char iter.']"
1002,matsim-libs,org/matsim/core/utils/io/IOUtils.java,/matsim/src/main/java/org/matsim/core/utils/io/IOUtils.java,resolveFileOrResource,154-223,"/**
	 * This function takes a path and tries to find the file in the file system or
	 * in the resource path. The order of resolution is as follows:
	 * 
	 * <ol>
	 * <li>Find path in file system</li>
	 * <li>Find path in file system with compression extension (e.g. *.gz)</li>
	 * <li>Find path in class path as resource</li>
	 * <li>Find path in class path with compression extension</li>
	 * </ol>
	 *
	 * In case the filename is a URL (i.e. starting with ""file:"" or ""jar:file:""),
	 * then no resolution is done but the provided filename returned as URL.
	 * 
	 * @throws UncheckedIOException
	 */
public static URL resolveFileOrResource(String filename) throws UncheckedIOException{
    try {
        // I) do not handle URLs
        if (filename.startsWith(""jar:file:"") || filename.startsWith(""file:"") || filename.startsWith(""https:"")) {
            // looks like an URI
            return new URL(filename);
        }
        // II) Replace home identifier
        if (filename.startsWith(""~"" + File.separator)) {
            filename = System.getProperty(""user.home"") + filename.substring(1);
        }
        // III.1) First, try to find the file in the file system
        File file = new File(filename);
        if (file.exists()) {
            logger.info(String.format(""Resolved %s to %s"", filename, file));
            return file.toURI().toURL();
        }
        // III.2) Try to find file with an additional postfix for compression
        for (String postfix : COMPRESSION_EXTENSIONS.keySet()) {
            file = new File(filename + ""."" + postfix);
            if (file.exists()) {
                logger.info(String.format(""Resolved %s to %s"", filename, file));
                return file.toURI().toURL();
            }
        }
        // IV.1) First, try to find the file in the class path
        URL resource = IOUtils.class.getClassLoader().getResource(filename);
        if (resource != null) {
            logger.info(String.format(""Resolved %s to %s"", filename, resource));
            return resource;
        }
        // IV.2) Second, try to find the resource with a compression extension
        for (String postfix : COMPRESSION_EXTENSIONS.keySet()) {
            resource = IOUtils.class.getClassLoader().getResource(filename + ""."" + postfix);
            if (resource != null) {
                logger.info(String.format(""Resolved %s to %s"", filename, resource));
                return resource;
            }
        }
        throw new FileNotFoundException(filename);
    } catch (FileNotFoundException | MalformedURLException e) {
        throw new UncheckedIOException(e);
    }
}","public static URL resolveFileOrResource(String filename) throws UncheckedIOException{
    try {
        // I) do not handle URLs
        if (filename.startsWith(""jar:file:"") || filename.startsWith(""file:"") || filename.startsWith(""https:"")) {
            // looks like an URI
            return new URL(filename);
        }
        // II) Replace home identifier
        if (filename.startsWith(""~"" + File.separator)) {
            filename = System.getProperty(""user.home"") + filename.substring(1);
        }
        // III.1) First, try to find the file in the file system
        File file = new File(filename);
        if (file.exists()) {
            logger.info(String.format(""Resolved %s to %s"", filename, file));
            return file.toURI().toURL();
        }
        // III.2) Try to find file with an additional postfix for compression
        for (String postfix : COMPRESSION_EXTENSIONS.keySet()) {
            file = new File(filename + ""."" + postfix);
            if (file.exists()) {
                logger.info(String.format(""Resolved %s to %s"", filename, file));
                return file.toURI().toURL();
            }
        }
        // IV.1) First, try to find the file in the class path
        URL resource = IOUtils.class.getClassLoader().getResource(filename);
        if (resource != null) {
            logger.info(String.format(""Resolved %s to %s"", filename, resource));
            return resource;
        }
        // IV.2) Second, try to find the resource with a compression extension
        for (String postfix : COMPRESSION_EXTENSIONS.keySet()) {
            resource = IOUtils.class.getClassLoader().getResource(filename + ""."" + postfix);
            if (resource != null) {
                logger.info(String.format(""Resolved %s to %s"", filename, resource));
                return resource;
            }
        }
        throw new FileNotFoundException(filename);
    } catch (FileNotFoundException | MalformedURLException e) {
        throw new UncheckedIOException(e);
    }
}","/**
	 * This function takes a path and tries to find the file in the file system or
	 * in the resource path. The order of resolution is as follows:
	 * 
	 * <ol>
	 * <li>Find path in file system</li>
	 * <li>Find path in file system with compression extension (e.g. *.gz)</li>
	 * <li>Find path in class path as resource</li>
	 * <li>Find path in class path with compression extension</li>
	 * </ol>
	 *
	 * In case the filename is a URL (i.e. starting with ""file:"" or ""jar:file:""),
	 * then no resolution is done but the provided filename returned as URL.
	 * 
	 * @throws UncheckedIOException
	 */","('resolveFileOrResource', {'INSTRUCTION': {'covered': 159, 'missed': 7}, 'BRANCH': {'covered': 17, 'missed': 3}, 'LINE': {'covered': 26, 'missed': 1}, 'COMPLEXITY': {'covered': 8, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",311.0,  This function takes a path and tries to find the file in the file system or  in the resource path.,21.0,"['The function tries to find the file in the file system or the resource path.', 'The function tries to find the file in the file system or in the resource path.', 'This function tries to find the file in the file system or the resource path.']"
1003,cdk,org/openscience/cdk/formula/IsotopePatternGenerator.java,/tool/formula/src/main/java/org/openscience/cdk/formula/IsotopePatternGenerator.java,calculateAbundanceAndMass,190-252,"/**
     * Calculates the mass and abundance of all isotopes generated by adding one
     * atom. Receives the periodic table element and calculate the isotopes, if
     * there exist a previous calculation, add these new isotopes. In the
     * process of adding the new isotopes, remove those that has an abundance
     * less than setup parameter minIntensity, and remove duplicated masses.
     *
     * @param additional additional isotopes to 'multiple' the current pattern by
     * @return the calculation was successful
     */
private IsotopePattern calculateAbundanceAndMass(IsotopePattern current, List<IsotopeContainer> additional){
    if (additional == null || additional.size() == 0)
        return current;
    List<IsotopeContainer> containers = new ArrayList<>();
    if (current == null) {
        current = new IsotopePattern();
        for (IsotopeContainer container : additional) current.addIsotope(container);
    } else {
        for (IsotopeContainer container : current.getIsotopes()) {
            for (IsotopeContainer other : additional) {
                double abundance = container.getIntensity() * other.getIntensity() * 0.01;
                double mass = container.getMass() + other.getMass();
                IsotopeContainer existing = findExisting(containers, mass, resolution);
                if (existing != null) {
                    double newIntensity = existing.getIntensity() + abundance;
                    existing.setMass((existing.getMass() * existing.getIntensity() + mass * abundance) / newIntensity);
                    existing.setIntensity(newIntensity);
                    if (storeFormula) {
                        for (IMolecularFormula mf : container.getFormulas()) addDistinctFormula(existing, union(mf, other.getFormula()));
                    }
                    continue;
                }
                if (abundance > minAbundance) {
                    IsotopeContainer newcontainer = new IsotopeContainer(mass, abundance);
                    if (storeFormula) {
                        for (IMolecularFormula mf : container.getFormulas()) newcontainer.addFormula(union(mf, other.getFormula()));
                    }
                    containers.add(newcontainer);
                }
            }
        }
        current = new IsotopePattern();
        for (IsotopeContainer container : containers) {
            current.addIsotope(container);
        }
    }
    return current;
}","private IsotopePattern calculateAbundanceAndMass(IsotopePattern current, List<IsotopeContainer> additional){
    if (additional == null || additional.size() == 0)
        return current;
    List<IsotopeContainer> containers = new ArrayList<>();
    if (current == null) {
        current = new IsotopePattern();
        for (IsotopeContainer container : additional) current.addIsotope(container);
    } else {
        for (IsotopeContainer container : current.getIsotopes()) {
            for (IsotopeContainer other : additional) {
                double abundance = container.getIntensity() * other.getIntensity() * 0.01;
                double mass = container.getMass() + other.getMass();
                IsotopeContainer existing = findExisting(containers, mass, resolution);
                if (existing != null) {
                    double newIntensity = existing.getIntensity() + abundance;
                    existing.setMass((existing.getMass() * existing.getIntensity() + mass * abundance) / newIntensity);
                    existing.setIntensity(newIntensity);
                    if (storeFormula) {
                        for (IMolecularFormula mf : container.getFormulas()) addDistinctFormula(existing, union(mf, other.getFormula()));
                    }
                    continue;
                }
                if (abundance > minAbundance) {
                    IsotopeContainer newcontainer = new IsotopeContainer(mass, abundance);
                    if (storeFormula) {
                        for (IMolecularFormula mf : container.getFormulas()) newcontainer.addFormula(union(mf, other.getFormula()));
                    }
                    containers.add(newcontainer);
                }
            }
        }
        current = new IsotopePattern();
        for (IsotopeContainer container : containers) {
            current.addIsotope(container);
        }
    }
    return current;
}","/**
     * Calculates the mass and abundance of all isotopes generated by adding one
     * atom. Receives the periodic table element and calculate the isotopes, if
     * there exist a previous calculation, add these new isotopes. In the
     * process of adding the new isotopes, remove those that has an abundance
     * less than setup parameter minIntensity, and remove duplicated masses.
     *
     * @param additional additional isotopes to 'multiple' the current pattern by
     * @return the calculation was successful
     */","('calculateAbundanceAndMass', {'INSTRUCTION': {'covered': 177, 'missed': 2}, 'BRANCH': {'covered': 24, 'missed': 2}, 'LINE': {'covered': 31, 'missed': 0}, 'COMPLEXITY': {'covered': 12, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",314.0,  Calculates the mass and abundance of all isotopes generated by adding one  atom.,14.0,"['The mass and abundance of all isotopes are calculated.', 'The mass and abundance of all the isotopes are calculated.', 'The mass and abundance of all the isotopes is calculated.']"
1004,matsim-libs,org/matsim/contrib/freight/utils/FreightUtils.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/utils/FreightUtils.java,createShipmentsFromServices,264-308,"/**
	 * Transform all services from the existing carrier to the new carrier with
	 * shipments. The location of the depot from which the ""old"" carrier starts the
	 * tour to the service is used as fromLocation for the new Shipment.
	 *
	 * @param carrierWS the ""new"" carrier with Shipments
	 * @param carrier   the already existing carrier
	 */
private static void createShipmentsFromServices(Carrier carrierWS, Carrier carrier){
    TreeMap<Id<CarrierService>, Id<Link>> depotServiceIsdeliveredFrom = new TreeMap<>();
    try {
        carrier.getSelectedPlan();
    } catch (Exception e) {
        throw new RuntimeException(""Carrier "" + carrier.getId() + "" has NO selectedPlan. --> CanNOT create a new carrier from solution"");
    }
    Collection<ScheduledTour> tours;
    try {
        tours = carrier.getSelectedPlan().getScheduledTours();
    } catch (Exception e) {
        throw new RuntimeException(""Carrier "" + carrier.getId() + "" has NO ScheduledTours. --> CanNOT create a new carrier from solution"");
    }
    for (ScheduledTour tour : tours) {
        Id<Link> depotForTour = tour.getVehicle().getLocation();
        for (TourElement te : tour.getTour().getTourElements()) {
            if (te instanceof ServiceActivity) {
                ServiceActivity act = (ServiceActivity) te;
                depotServiceIsdeliveredFrom.put(act.getService().getId(), depotForTour);
            }
        }
    }
    for (CarrierService carrierService : carrier.getServices().values()) {
        log.debug(""Converting CarrierService to CarrierShipment: "" + carrierService.getId());
        CarrierShipment carrierShipment = CarrierShipment.Builder.newInstance(Id.create(carrierService.getId().toString(), CarrierShipment.class), depotServiceIsdeliveredFrom.get(carrierService.getId()), carrierService.getLocationLinkId(), carrierService.getCapacityDemand()).setDeliveryServiceTime(carrierService.getServiceDuration()).setDeliveryTimeWindow(carrierService.getServiceStartTimeWindow()).setPickupTimeWindow(TimeWindow.newInstance(0.0, carrierService.getServiceStartTimeWindow().getEnd())).build();
        CarrierUtils.addShipment(carrierWS, carrierShipment);
    }
}","private static void createShipmentsFromServices(Carrier carrierWS, Carrier carrier){
    TreeMap<Id<CarrierService>, Id<Link>> depotServiceIsdeliveredFrom = new TreeMap<>();
    try {
        carrier.getSelectedPlan();
    } catch (Exception e) {
        throw new RuntimeException(""Carrier "" + carrier.getId() + "" has NO selectedPlan. --> CanNOT create a new carrier from solution"");
    }
    Collection<ScheduledTour> tours;
    try {
        tours = carrier.getSelectedPlan().getScheduledTours();
    } catch (Exception e) {
        throw new RuntimeException(""Carrier "" + carrier.getId() + "" has NO ScheduledTours. --> CanNOT create a new carrier from solution"");
    }
    for (ScheduledTour tour : tours) {
        Id<Link> depotForTour = tour.getVehicle().getLocation();
        for (TourElement te : tour.getTour().getTourElements()) {
            if (te instanceof ServiceActivity) {
                ServiceActivity act = (ServiceActivity) te;
                depotServiceIsdeliveredFrom.put(act.getService().getId(), depotForTour);
            }
        }
    }
    for (CarrierService carrierService : carrier.getServices().values()) {
        log.debug(""Converting CarrierService to CarrierShipment: "" + carrierService.getId());
        CarrierShipment carrierShipment = CarrierShipment.Builder.newInstance(Id.create(carrierService.getId().toString(), CarrierShipment.class), depotServiceIsdeliveredFrom.get(carrierService.getId()), carrierService.getLocationLinkId(), carrierService.getCapacityDemand()).setDeliveryServiceTime(carrierService.getServiceDuration()).setDeliveryTimeWindow(carrierService.getServiceStartTimeWindow()).setPickupTimeWindow(TimeWindow.newInstance(0.0, carrierService.getServiceStartTimeWindow().getEnd())).build();
        CarrierUtils.addShipment(carrierWS, carrierShipment);
    }
}","/**
	 * Transform all services from the existing carrier to the new carrier with
	 * shipments. The location of the depot from which the ""old"" carrier starts the
	 * tour to the service is used as fromLocation for the new Shipment.
	 *
	 * @param carrierWS the ""new"" carrier with Shipments
	 * @param carrier   the already existing carrier
	 */","('createShipmentsFromServices', {'INSTRUCTION': {'covered': 105, 'missed': 16}, 'BRANCH': {'covered': 8, 'missed': 0}, 'LINE': {'covered': 26, 'missed': 4}, 'COMPLEXITY': {'covered': 5, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",316.0,  Transform all services from the existing carrier to the new carrier with  shipments.,14.0,"['The existing carrier should be transformed into a new carrier with shipments.', 'All services from the old carrier to the new one with shipments.', 'All services from the old carrier to the new carrier with shipments.']"
1005,cdk,org/openscience/cdk/fingerprint/CircularFingerprinter.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/CircularFingerprinter.java,calculate,227-272,"/**
     * Calculates the fingerprints for the given {@link IAtomContainer}, and stores them for subsequent retrieval.
     *
     * @param mol chemical structure; all nodes should be known legitimate elements
     */
public void calculate(IAtomContainer mol) throws CDKException{
    this.mol = mol;
    fplist.clear();
    atomClass = classType <= CLASS_ECFP6 ? ATOMCLASS_ECFP : ATOMCLASS_FCFP;
    excavateMolecule();
    if (atomClass == ATOMCLASS_FCFP)
        calculateBioTypes();
    final int na = mol.getAtomCount();
    identity = new int[na];
    resolvedChiral = new boolean[na];
    atomGroup = new int[na][];
    for (int n = 0; n < na; n++) if (amask[n]) {
        if (atomClass == ATOMCLASS_ECFP)
            identity[n] = initialIdentityECFP(n);
        else
            identity[n] = initialIdentityFCFP(n);
        atomGroup[n] = new int[] { n };
        fplist.add(new FP(identity[n], 0, atomGroup[n]));
    }
    int niter = classType == CLASS_ECFP2 || classType == CLASS_FCFP2 ? 1 : classType == CLASS_ECFP4 || classType == CLASS_FCFP4 ? 2 : classType == CLASS_ECFP6 || classType == CLASS_FCFP6 ? 3 : 0;
    for (int iter = 1; iter <= niter; iter++) {
        final int[] newident = new int[na];
        for (int n = 0; n < na; n++) if (amask[n])
            newident[n] = circularIterate(iter, n);
        identity = newident;
        for (int n = 0; n < na; n++) if (amask[n]) {
            atomGroup[n] = growAtoms(atomGroup[n]);
            considerNewFP(new FP(identity[n], iter, atomGroup[n]));
        }
    }
}","public void calculate(IAtomContainer mol) throws CDKException{
    this.mol = mol;
    fplist.clear();
    atomClass = classType <= CLASS_ECFP6 ? ATOMCLASS_ECFP : ATOMCLASS_FCFP;
    excavateMolecule();
    if (atomClass == ATOMCLASS_FCFP)
        calculateBioTypes();
    final int na = mol.getAtomCount();
    identity = new int[na];
    resolvedChiral = new boolean[na];
    atomGroup = new int[na][];
    for (int n = 0; n < na; n++) if (amask[n]) {
        if (atomClass == ATOMCLASS_ECFP)
            identity[n] = initialIdentityECFP(n);
        else
            identity[n] = initialIdentityFCFP(n);
        atomGroup[n] = new int[] { n };
        fplist.add(new FP(identity[n], 0, atomGroup[n]));
    }
    int niter = classType == CLASS_ECFP2 || classType == CLASS_FCFP2 ? 1 : classType == CLASS_ECFP4 || classType == CLASS_FCFP4 ? 2 : classType == CLASS_ECFP6 || classType == CLASS_FCFP6 ? 3 : 0;
    for (int iter = 1; iter <= niter; iter++) {
        final int[] newident = new int[na];
        for (int n = 0; n < na; n++) if (amask[n])
            newident[n] = circularIterate(iter, n);
        identity = newident;
        for (int n = 0; n < na; n++) if (amask[n]) {
            atomGroup[n] = growAtoms(atomGroup[n]);
            considerNewFP(new FP(identity[n], iter, atomGroup[n]));
        }
    }
}","/**
     * Calculates the fingerprints for the given {@link IAtomContainer}, and stores them for subsequent retrieval.
     *
     * @param mol chemical structure; all nodes should be known legitimate elements
     */","('calculate', {'INSTRUCTION': {'covered': 189, 'missed': 7}, 'BRANCH': {'covered': 26, 'missed': 6}, 'LINE': {'covered': 28, 'missed': 0}, 'COMPLEXITY': {'covered': 12, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",322.0,"  Calculates the fingerprints for the given {@link IAtomContainer}, and stores them for subsequent retrieval.",19.0,"['The fingerprints are calculated and stored for later use.', 'The fingerprints are calculated and stored for later retrieval.', 'The fingerprints are calculated and stored for future use.']"
1006,cdk,org/openscience/cdk/qsar/descriptors/atomic/InductiveAtomicHardnessDescriptor.java,/descriptor/qsaratomic/src/main/java/org/openscience/cdk/qsar/descriptors/atomic/InductiveAtomicHardnessDescriptor.java,calculate,129-196,"/**
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from
     *  the class tools.HydrogenAdder, and 3D coordinates.
     *
     *@param  atom              The IAtom for which the DescriptorValue is requested
     *@param  ac                AtomContainer
     *@return                   a double with polarizability of the heavy atom
     */
public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
    if (factory == null)
        try {
            factory = AtomTypeFactory.getInstance(""org/openscience/cdk/config/data/jmol_atomtypes.txt"", ac.getBuilder());
        } catch (Exception exception) {
            return getDummyDescriptorValue(exception);
        }
    double atomicHardness;
    double radiusTarget;
    Iterator<IAtom> allAtoms = ac.atoms().iterator();
    atomicHardness = 0;
    double partial;
    double radius;
    String symbol;
    IAtomType type;
    try {
        symbol = atom.getSymbol();
        type = factory.getAtomType(symbol);
        radiusTarget = type.getCovalentRadius();
    } catch (Exception exception) {
        logger.debug(exception);
        return getDummyDescriptorValue(exception);
    }
    while (allAtoms.hasNext()) {
        IAtom curAtom = allAtoms.next();
        if (atom.getPoint3d() == null || curAtom.getPoint3d() == null) {
            return getDummyDescriptorValue(new CDKException(""The target atom or current atom had no 3D coordinates. These are required""));
        }
        if (!atom.equals(curAtom)) {
            partial = 0;
            symbol = curAtom.getSymbol();
            try {
                type = factory.getAtomType(symbol);
            } catch (Exception exception) {
                logger.debug(exception);
                return getDummyDescriptorValue(exception);
            }
            radius = type.getCovalentRadius();
            partial += radius * radius;
            partial += (radiusTarget * radiusTarget);
            partial = partial / (calculateSquareDistanceBetweenTwoAtoms(atom, curAtom));
            atomicHardness += partial;
        }
    }
    atomicHardness = 2 * atomicHardness;
    atomicHardness = atomicHardness * 0.172;
    atomicHardness = 1 / atomicHardness;
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(atomicHardness), NAMES);
}","public DescriptorValue calculate(IAtom atom, IAtomContainer ac){
    if (factory == null)
        try {
            factory = AtomTypeFactory.getInstance(""org/openscience/cdk/config/data/jmol_atomtypes.txt"", ac.getBuilder());
        } catch (Exception exception) {
            return getDummyDescriptorValue(exception);
        }
    double atomicHardness;
    double radiusTarget;
    Iterator<IAtom> allAtoms = ac.atoms().iterator();
    atomicHardness = 0;
    double partial;
    double radius;
    String symbol;
    IAtomType type;
    try {
        symbol = atom.getSymbol();
        type = factory.getAtomType(symbol);
        radiusTarget = type.getCovalentRadius();
    } catch (Exception exception) {
        logger.debug(exception);
        return getDummyDescriptorValue(exception);
    }
    while (allAtoms.hasNext()) {
        IAtom curAtom = allAtoms.next();
        if (atom.getPoint3d() == null || curAtom.getPoint3d() == null) {
            return getDummyDescriptorValue(new CDKException(""The target atom or current atom had no 3D coordinates. These are required""));
        }
        if (!atom.equals(curAtom)) {
            partial = 0;
            symbol = curAtom.getSymbol();
            try {
                type = factory.getAtomType(symbol);
            } catch (Exception exception) {
                logger.debug(exception);
                return getDummyDescriptorValue(exception);
            }
            radius = type.getCovalentRadius();
            partial += radius * radius;
            partial += (radiusTarget * radiusTarget);
            partial = partial / (calculateSquareDistanceBetweenTwoAtoms(atom, curAtom));
            atomicHardness += partial;
        }
    }
    atomicHardness = 2 * atomicHardness;
    atomicHardness = atomicHardness * 0.172;
    atomicHardness = 1 / atomicHardness;
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new DoubleResult(atomicHardness), NAMES);
}","/**
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from
     *  the class tools.HydrogenAdder, and 3D coordinates.
     *
     *@param  atom              The IAtom for which the DescriptorValue is requested
     *@param  ac                AtomContainer
     *@return                   a double with polarizability of the heavy atom
     */","('calculate', {'INSTRUCTION': {'covered': 112, 'missed': 28}, 'BRANCH': {'covered': 7, 'missed': 3}, 'LINE': {'covered': 28, 'missed': 9}, 'COMPLEXITY': {'covered': 3, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",322.0,  It is needed to call the addExplicitHydrogensToSatisfyValency method from  the class tools.,13.0,"['It is necessary to call the addExplicitHydrogensToSatisfyValency method from the class tools.', 'It is necessary to call the addExplicitHydrogensToSatisfyValency method from class tools.', 'The class tools have a method called the addExplicitHydrogensToSatisfyValency method.']"
1007,cdk,org/openscience/cdk/smsd/filters/ChemicalFilters.java,/legacy/src/main/java/org/openscience/cdk/smsd/filters/ChemicalFilters.java,sortResultsByFragments,257-304,"/**
     * Sort solution by ascending order of the fragment count.
     */
public synchronized void sortResultsByFragments(){
    Map<Integer, Map<Integer, Integer>> allFragmentMCS = new TreeMap<Integer, Map<Integer, Integer>>();
    Map<Integer, Map<IAtom, IAtom>> allFragmentAtomMCS = new TreeMap<Integer, Map<IAtom, IAtom>>();
    Map<Integer, Double> stereoScoreMap = new TreeMap<Integer, Double>();
    Map<Integer, Double> energyScoreMap = new TreeMap<Integer, Double>();
    Map<Integer, Integer> fragmentScoreMap = new TreeMap<Integer, Integer>();
    initializeMaps(allFragmentMCS, allFragmentAtomMCS, stereoScoreMap, fragmentScoreMap, energyScoreMap);
    int minFragmentScore = 9999;
    for (Integer key : allFragmentAtomMCS.keySet()) {
        Map<IAtom, IAtom> mcsAtom = allFragmentAtomMCS.get(key);
        int fragmentCount = getMappedMoleculeFragmentSize(mcsAtom);
        fragmentScoreMap.put(key, fragmentCount);
        if (minFragmentScore > fragmentCount) {
            minFragmentScore = fragmentCount;
        }
    }
    boolean flag = false;
    if (minFragmentScore < 9999) {
        flag = true;
        clear();
    }
    int counter = 0;
    for (Map.Entry<Integer, Integer> map : fragmentScoreMap.entrySet()) {
        if (minFragmentScore == map.getValue().intValue()) {
            addSolution(counter, map.getKey(), allFragmentAtomMCS, allFragmentMCS, stereoScoreMap, energyScoreMap, fragmentScoreMap);
            counter++;
        }
    }
    if (flag) {
        firstSolution.putAll(allMCS.get(0));
        firstAtomMCS.putAll(allAtomMCS.get(0));
        clear(allFragmentMCS, allFragmentAtomMCS, stereoScoreMap, fragmentScoreMap, energyScoreMap);
    }
}","public synchronized void sortResultsByFragments(){
    Map<Integer, Map<Integer, Integer>> allFragmentMCS = new TreeMap<Integer, Map<Integer, Integer>>();
    Map<Integer, Map<IAtom, IAtom>> allFragmentAtomMCS = new TreeMap<Integer, Map<IAtom, IAtom>>();
    Map<Integer, Double> stereoScoreMap = new TreeMap<Integer, Double>();
    Map<Integer, Double> energyScoreMap = new TreeMap<Integer, Double>();
    Map<Integer, Integer> fragmentScoreMap = new TreeMap<Integer, Integer>();
    initializeMaps(allFragmentMCS, allFragmentAtomMCS, stereoScoreMap, fragmentScoreMap, energyScoreMap);
    int minFragmentScore = 9999;
    for (Integer key : allFragmentAtomMCS.keySet()) {
        Map<IAtom, IAtom> mcsAtom = allFragmentAtomMCS.get(key);
        int fragmentCount = getMappedMoleculeFragmentSize(mcsAtom);
        fragmentScoreMap.put(key, fragmentCount);
        if (minFragmentScore > fragmentCount) {
            minFragmentScore = fragmentCount;
        }
    }
    boolean flag = false;
    if (minFragmentScore < 9999) {
        flag = true;
        clear();
    }
    int counter = 0;
    for (Map.Entry<Integer, Integer> map : fragmentScoreMap.entrySet()) {
        if (minFragmentScore == map.getValue().intValue()) {
            addSolution(counter, map.getKey(), allFragmentAtomMCS, allFragmentMCS, stereoScoreMap, energyScoreMap, fragmentScoreMap);
            counter++;
        }
    }
    if (flag) {
        firstSolution.putAll(allMCS.get(0));
        firstAtomMCS.putAll(allAtomMCS.get(0));
        clear(allFragmentMCS, allFragmentAtomMCS, stereoScoreMap, fragmentScoreMap, energyScoreMap);
    }
}","/**
     * Sort solution by ascending order of the fragment count.
     */","('sortResultsByFragments', {'INSTRUCTION': {'covered': 129, 'missed': 0}, 'BRANCH': {'covered': 10, 'missed': 2}, 'LINE': {'covered': 29, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",322.0,  Sort solution by ascending order of the fragment count.,10.0,"['Sort solution by the number of fragments.', 'Sort solution by order of fragment count.', 'Sort solution by order.']"
1008,matsim-libs,org/matsim/core/config/CommandLine.java,/matsim/src/main/java/org/matsim/core/config/CommandLine.java,reportOptions,500-546,"/**
	 * Reports on the options that have been inserted into the MATSim {@link Config}
	 * via the command line.
	 */
private void reportOptions(){
    logger.info(String.format(""Received %d positional command line arguments:"", positionalArguments.size()));
    logger.info(""   "" + String.join("" , "", positionalArguments));
    Map<String, List<String>> prefixedOptions = new HashMap<>();
    List<String> nonPrefixedOptions = new LinkedList<>();
    for (String option : options.keySet()) {
        int separatorIndex = option.indexOf(':');
        if (separatorIndex > -1) {
            String prefix = option.substring(0, separatorIndex);
            option = option.substring(separatorIndex + 1);
            if (!prefixedOptions.containsKey(prefix)) {
                prefixedOptions.put(prefix, new LinkedList<>());
            }
            prefixedOptions.get(prefix).add(option);
        } else {
            nonPrefixedOptions.add(option);
        }
    }
    logger.info(String.format(""Received %d command line options with %d prefixes:"", options.size(), prefixedOptions.size()));
    Collections.sort(nonPrefixedOptions);
    for (String option : nonPrefixedOptions) {
        logger.info(String.format(""   %s = %s"", option, options.get(option)));
    }
    List<String> orderedPrefixes = new LinkedList<>(prefixedOptions.keySet());
    Collections.sort(orderedPrefixes);
    for (String prefix : orderedPrefixes) {
        logger.info(String.format(""   Prefix %s:"", prefix));
        for (String option : prefixedOptions.get(prefix)) {
            logger.info(String.format(""      %s = %s"", option, options.get(prefix + "":"" + option)));
        }
    }
}","private void reportOptions(){
    logger.info(String.format(""Received %d positional command line arguments:"", positionalArguments.size()));
    logger.info(""   "" + String.join("" , "", positionalArguments));
    Map<String, List<String>> prefixedOptions = new HashMap<>();
    List<String> nonPrefixedOptions = new LinkedList<>();
    for (String option : options.keySet()) {
        int separatorIndex = option.indexOf(':');
        if (separatorIndex > -1) {
            String prefix = option.substring(0, separatorIndex);
            option = option.substring(separatorIndex + 1);
            if (!prefixedOptions.containsKey(prefix)) {
                prefixedOptions.put(prefix, new LinkedList<>());
            }
            prefixedOptions.get(prefix).add(option);
        } else {
            nonPrefixedOptions.add(option);
        }
    }
    logger.info(String.format(""Received %d command line options with %d prefixes:"", options.size(), prefixedOptions.size()));
    Collections.sort(nonPrefixedOptions);
    for (String option : nonPrefixedOptions) {
        logger.info(String.format(""   %s = %s"", option, options.get(option)));
    }
    List<String> orderedPrefixes = new LinkedList<>(prefixedOptions.keySet());
    Collections.sort(orderedPrefixes);
    for (String prefix : orderedPrefixes) {
        logger.info(String.format(""   Prefix %s:"", prefix));
        for (String option : prefixedOptions.get(prefix)) {
            logger.info(String.format(""      %s = %s"", option, options.get(prefix + "":"" + option)));
        }
    }
}","/**
	 * Reports on the options that have been inserted into the MATSim {@link Config}
	 * via the command line.
	 */","('reportOptions', {'INSTRUCTION': {'covered': 194, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 30, 'missed': 0}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",323.0,  Reports on the options that have been inserted into the MATSim {@link Config}  via the command line.,21.0,"['There are reports on the options that have been inserted into the MATSim.', 'Reports on the options that have been inserted into the MATSim.', 'Reports on the options that have been inserted into the MATSim are available via the command line.']"
1009,cdk,org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,calculate3DCoordinates2,438-494,"/**
     *  Calculate new point(s) X in a B-A-C system, it forms a B-A(-C)-X
     *  system. (2) 2 ligands(B, C) of refAtom A (i) 1 points required; vector in
     *  ABC plane bisecting AB, AC. If ABC is linear, no points (ii) 2 points: 2
     *  points X1, X2, X1-A-X2 = angle about 2i vector
     *
     *@param  aPoint   to which substituents are added
     *@param  bPoint   first ligand of A
     *@param  cPoint   second ligand of A
     *@param  nwanted  number of points to calculate (1-2)
     *@param  length   A-X length
     *@param  angle    B-A-X angle
     *@return          Point3d[] nwanted points (or zero if failed)
     */
public Point3d[] calculate3DCoordinates2(Point3d aPoint, Point3d bPoint, Point3d cPoint, int nwanted, double length, double angle){
    Point3d[] newPoints = new Point3d[0];
    double ang2 = angle / 2.0;
    Vector3d ba = new Vector3d(aPoint);
    ba.sub(bPoint);
    Vector3d ca = new Vector3d(aPoint);
    ca.sub(cPoint);
    Vector3d baxca = new Vector3d();
    baxca.cross(ba, ca);
    if (baxca.length() < 0.00000001) {
        ;
    } else if (nwanted == 1) {
        newPoints = new Point3d[1];
        Vector3d ax = new Vector3d(ba);
        ax.add(ca);
        ax.normalize();
        ax.scale(length);
        newPoints[0] = new Point3d(aPoint);
        newPoints[0].add(ax);
    } else if (nwanted >= 2) {
        newPoints = new Point3d[2];
        Vector3d ax = new Vector3d(ba);
        ax.add(ca);
        ax.normalize();
        baxca.normalize();
        baxca.scale(Math.sin(ang2) * length);
        ax.scale(Math.cos(ang2) * length);
        newPoints[0] = new Point3d(aPoint);
        newPoints[0].add(ax);
        newPoints[0].add(baxca);
        newPoints[1] = new Point3d(aPoint);
        newPoints[1].add(ax);
        newPoints[1].sub(baxca);
    }
    baxca = null;
    ba = null;
    ca = null;
    return newPoints;
}","public Point3d[] calculate3DCoordinates2(Point3d aPoint, Point3d bPoint, Point3d cPoint, int nwanted, double length, double angle){
    Point3d[] newPoints = new Point3d[0];
    double ang2 = angle / 2.0;
    Vector3d ba = new Vector3d(aPoint);
    ba.sub(bPoint);
    Vector3d ca = new Vector3d(aPoint);
    ca.sub(cPoint);
    Vector3d baxca = new Vector3d();
    baxca.cross(ba, ca);
    if (baxca.length() < 0.00000001) {
        ;
    } else if (nwanted == 1) {
        newPoints = new Point3d[1];
        Vector3d ax = new Vector3d(ba);
        ax.add(ca);
        ax.normalize();
        ax.scale(length);
        newPoints[0] = new Point3d(aPoint);
        newPoints[0].add(ax);
    } else if (nwanted >= 2) {
        newPoints = new Point3d[2];
        Vector3d ax = new Vector3d(ba);
        ax.add(ca);
        ax.normalize();
        baxca.normalize();
        baxca.scale(Math.sin(ang2) * length);
        ax.scale(Math.cos(ang2) * length);
        newPoints[0] = new Point3d(aPoint);
        newPoints[0].add(ax);
        newPoints[0].add(baxca);
        newPoints[1] = new Point3d(aPoint);
        newPoints[1].add(ax);
        newPoints[1].sub(baxca);
    }
    baxca = null;
    ba = null;
    ca = null;
    return newPoints;
}","/**
     *  Calculate new point(s) X in a B-A-C system, it forms a B-A(-C)-X
     *  system. (2) 2 ligands(B, C) of refAtom A (i) 1 points required; vector in
     *  ABC plane bisecting AB, AC. If ABC is linear, no points (ii) 2 points: 2
     *  points X1, X2, X1-A-X2 = angle about 2i vector
     *
     *@param  aPoint   to which substituents are added
     *@param  bPoint   first ligand of A
     *@param  cPoint   second ligand of A
     *@param  nwanted  number of points to calculate (1-2)
     *@param  length   A-X length
     *@param  angle    B-A-X angle
     *@return          Point3d[] nwanted points (or zero if failed)
     */","('calculate3DCoordinates2', {'INSTRUCTION': {'covered': 111, 'missed': 30}, 'BRANCH': {'covered': 3, 'missed': 3}, 'LINE': {'covered': 28, 'missed': 7}, 'COMPLEXITY': {'covered': 1, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",323.0,"  Calculate new point(s) X in a B-A-C system, it forms a B-A(-C)-X  system.",22.0,"['A B-A-C system forms a B-A(-C)-X system.', 'A B-A-C system forms a B-A(-C)-X system by calculating new point(s) X.', 'A B-A-C system forms a B-A(-C)-X system by calculating new points.']"
1010,jeromq,org/zeromq/proto/ZPicture.java,/src/main/java/org/zeromq/proto/ZPicture.java,recvBinaryPicture,171-245,"/**
     * Receive a binary encoded 'picture' message from the socket (or actor).
     * This method is similar to {@link org.zeromq.ZMQ.Socket#recv()}, except the arguments are encoded
     * in a binary format that is compatible with zproto, and is designed to
     * reduce memory allocations.
     *
     * @param picture The picture argument is a string that defines
     *                the type of each argument. See {@link #sendBinaryPicture(Socket, String, Object...)}
     *                for the supported argument types.
     * @return the picture elements as object array
     **/
public Object[] recvBinaryPicture(Socket socket, final String picture){
    if (!BINARY_FORMAT.matcher(picture).matches()) {
        throw new ZMQException(picture + "" is not in expected binary format "" + BINARY_FORMAT.pattern(), ZError.EPROTO);
    }
    ZFrame frame = ZFrame.recvFrame(socket);
    if (frame == null) {
        return null;
    }
    ZNeedle needle = new ZNeedle(frame);
    Object[] results = new Object[picture.length()];
    for (int index = 0; index < picture.length(); index++) {
        char pattern = picture.charAt(index);
        switch(pattern) {
            case '1':
                {
                    results[index] = needle.getNumber1();
                    break;
                }
            case '2':
                {
                    results[index] = needle.getNumber2();
                    break;
                }
            case '4':
                {
                    results[index] = needle.getNumber4();
                    break;
                }
            case '8':
                {
                    results[index] = needle.getNumber8();
                    break;
                }
            case 's':
                {
                    results[index] = needle.getString();
                    break;
                }
            case 'S':
                {
                    results[index] = needle.getLongString();
                    break;
                }
            case 'b':
            case 'c':
                {
                    int size = needle.getNumber4();
                    results[index] = needle.getBlock(size);
                    break;
                }
            case 'f':
                {
                    results[index] = ZFrame.recvFrame(socket);
                    break;
                }
            case 'm':
                {
                    results[index] = ZMsg.recvMsg(socket);
                    break;
                }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    return results;
}","public Object[] recvBinaryPicture(Socket socket, final String picture){
    if (!BINARY_FORMAT.matcher(picture).matches()) {
        throw new ZMQException(picture + "" is not in expected binary format "" + BINARY_FORMAT.pattern(), ZError.EPROTO);
    }
    ZFrame frame = ZFrame.recvFrame(socket);
    if (frame == null) {
        return null;
    }
    ZNeedle needle = new ZNeedle(frame);
    Object[] results = new Object[picture.length()];
    for (int index = 0; index < picture.length(); index++) {
        char pattern = picture.charAt(index);
        switch(pattern) {
            case '1':
                {
                    results[index] = needle.getNumber1();
                    break;
                }
            case '2':
                {
                    results[index] = needle.getNumber2();
                    break;
                }
            case '4':
                {
                    results[index] = needle.getNumber4();
                    break;
                }
            case '8':
                {
                    results[index] = needle.getNumber8();
                    break;
                }
            case 's':
                {
                    results[index] = needle.getString();
                    break;
                }
            case 'S':
                {
                    results[index] = needle.getLongString();
                    break;
                }
            case 'b':
            case 'c':
                {
                    int size = needle.getNumber4();
                    results[index] = needle.getBlock(size);
                    break;
                }
            case 'f':
                {
                    results[index] = ZFrame.recvFrame(socket);
                    break;
                }
            case 'm':
                {
                    results[index] = ZMsg.recvMsg(socket);
                    break;
                }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    return results;
}","/**
     * Receive a binary encoded 'picture' message from the socket (or actor).
     * This method is similar to {@link org.zeromq.ZMQ.Socket#recv()}, except the arguments are encoded
     * in a binary format that is compatible with zproto, and is designed to
     * reduce memory allocations.
     *
     * @param picture The picture argument is a string that defines
     *                the type of each argument. See {@link #sendBinaryPicture(Socket, String, Object...)}
     *                for the supported argument types.
     * @return the picture elements as object array
     **/","('recvBinaryPicture', {'INSTRUCTION': {'covered': 113, 'missed': 18}, 'BRANCH': {'covered': 14, 'missed': 4}, 'LINE': {'covered': 29, 'missed': 2}, 'COMPLEXITY': {'covered': 11, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",324.0,  Receive a binary encoded 'picture' message from the socket (or actor).,15.0,"['Receive a picture message from the actor.', 'Receive a message from the actor.', 'A picture message is sent from the actor.']"
1011,acs-aem-commons,com/adobe/acs/commons/wcm/impl/PropertyMergePostProcessor.java,/bundle/src/main/java/com/adobe/acs/commons/wcm/impl/PropertyMergePostProcessor.java,merge,214-277,"/**
     * Merges the values found in the the source properties into the destination
     * property as a multi-value. The values of the source properties and
     * destination properties must all be the same property type.
     *
     * The unique set of properties will be stored in
     *
     * @param resource the resource to look for the source and destination
     * properties on
     * @param destination the property to store the collected properties.
     * @param sources the properties to collect values from for merging
     * @param typeHint the data type that should be used when reading and
     * storing the data
     * @param allowDuplicates true to allow duplicates values in the destination
     * property; false to make values unique
     * @return Optional resource updated, if any
     */
protected final Optional<Resource> merge(final Resource resource, final String destination, final Collection<String> sources, final Class<T> typeHint, final boolean allowDuplicates) throws PersistenceException{
    ResourceResolver rr = resource.getResourceResolver();
    @SuppressWarnings(""unchecked"")
    final T[] emptyArray = (T[]) Array.newInstance(typeHint, 0);
    Collection<T> collectedValues;
    if (allowDuplicates) {
        collectedValues = new ArrayList<>();
    } else {
        collectedValues = new LinkedHashSet<>();
    }
    for (final String source : sources) {
        Resource sourceProperties = resource;
        String sourceParam = source;
        if (source.contains(""/"")) {
            sourceParam = StringUtils.substringAfterLast(source, ""/"");
            sourceProperties = rr.getResource(resource, StringUtils.substringBeforeLast(source, ""/""));
        }
        T[] tmp = sourceProperties.adaptTo(ModifiableValueMap.class).get(sourceParam, emptyArray);
        collectedValues.addAll(Arrays.asList(tmp));
    }
    Resource targetResource = resource;
    String targetProperty = destination;
    if (destination.contains(""/"")) {
        targetProperty = StringUtils.substringAfterLast(destination, ""/"");
        targetResource = rr.getResource(resource, StringUtils.substringBeforeLast(destination, ""/""));
    }
    ModifiableValueMap targetProperties = targetResource.adaptTo(ModifiableValueMap.class);
    final T[] currentValues = targetProperties.get(targetProperty, emptyArray);
    if (!collectedValues.equals(Arrays.asList(currentValues))) {
        targetProperties.put(targetProperty, collectedValues.toArray(emptyArray));
        return Optional.of(targetResource);
    } else {
        return Optional.empty();
    }
}","protected final Optional<Resource> merge(final Resource resource, final String destination, final Collection<String> sources, final Class<T> typeHint, final boolean allowDuplicates) throws PersistenceException{
    ResourceResolver rr = resource.getResourceResolver();
    @SuppressWarnings(""unchecked"")
    final T[] emptyArray = (T[]) Array.newInstance(typeHint, 0);
    Collection<T> collectedValues;
    if (allowDuplicates) {
        collectedValues = new ArrayList<>();
    } else {
        collectedValues = new LinkedHashSet<>();
    }
    for (final String source : sources) {
        Resource sourceProperties = resource;
        String sourceParam = source;
        if (source.contains(""/"")) {
            sourceParam = StringUtils.substringAfterLast(source, ""/"");
            sourceProperties = rr.getResource(resource, StringUtils.substringBeforeLast(source, ""/""));
        }
        T[] tmp = sourceProperties.adaptTo(ModifiableValueMap.class).get(sourceParam, emptyArray);
        collectedValues.addAll(Arrays.asList(tmp));
    }
    Resource targetResource = resource;
    String targetProperty = destination;
    if (destination.contains(""/"")) {
        targetProperty = StringUtils.substringAfterLast(destination, ""/"");
        targetResource = rr.getResource(resource, StringUtils.substringBeforeLast(destination, ""/""));
    }
    ModifiableValueMap targetProperties = targetResource.adaptTo(ModifiableValueMap.class);
    final T[] currentValues = targetProperties.get(targetProperty, emptyArray);
    if (!collectedValues.equals(Arrays.asList(currentValues))) {
        targetProperties.put(targetProperty, collectedValues.toArray(emptyArray));
        return Optional.of(targetResource);
    } else {
        return Optional.empty();
    }
}","/**
     * Merges the values found in the the source properties into the destination
     * property as a multi-value. The values of the source properties and
     * destination properties must all be the same property type.
     *
     * The unique set of properties will be stored in
     *
     * @param resource the resource to look for the source and destination
     * properties on
     * @param destination the property to store the collected properties.
     * @param sources the properties to collect values from for merging
     * @param typeHint the data type that should be used when reading and
     * storing the data
     * @param allowDuplicates true to allow duplicates values in the destination
     * property; false to make values unique
     * @return Optional resource updated, if any
     */","('merge', {'INSTRUCTION': {'covered': 108, 'missed': 2}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 24, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",324.0,  Merges the values found in the the source properties into the destination  property as a multi-value.,17.0,"['The values in the source properties are merged into the destination property.', 'The source properties are combined into the destination property as a multi-value.', 'The values in the source properties are merged into the destination property as a multi-value.']"
1012,cdk,org/openscience/cdk/group/Partition.java,/tool/group/src/main/java/org/openscience/cdk/group/Partition.java,fromString,442-500,"/**
     * Parse a string like ""[0,2|1,3]"" to form the partition; cells are
     * separated by '|' characters and elements within the cell by commas.
     *
     * @param strForm the partition in string form
     * @return the partition corresponding to the string
     * @throws IllegalArgumentException thrown if the provided strFrom is
     *         null or empty
     */
public static Partition fromString(String strForm){
    if (strForm == null || strForm.isEmpty())
        throw new IllegalArgumentException(""null or empty string provided"");
    Partition p = new Partition();
    int index = 0;
    if (strForm.charAt(0) == '[') {
        index++;
    }
    int endIndex;
    if (strForm.charAt(strForm.length() - 1) == ']') {
        endIndex = strForm.length() - 2;
    } else {
        endIndex = strForm.length() - 1;
    }
    int currentCell = -1;
    int numStart = -1;
    while (index <= endIndex) {
        char c = strForm.charAt(index);
        if (Character.isDigit(c)) {
            if (numStart == -1) {
                numStart = index;
            }
        } else if (c == ',') {
            int element = Integer.parseInt(strForm.substring(numStart, index));
            if (currentCell == -1) {
                p.addCell(element);
                currentCell = 0;
            } else {
                p.addToCell(currentCell, element);
            }
            numStart = -1;
        } else if (c == '|') {
            int element = Integer.parseInt(strForm.substring(numStart, index));
            if (currentCell == -1) {
                p.addCell(element);
                currentCell = 0;
            } else {
                p.addToCell(currentCell, element);
            }
            currentCell++;
            p.addCell();
            numStart = -1;
        }
        index++;
    }
    int lastElement = Integer.parseInt(strForm.substring(numStart, endIndex + 1));
    p.addToCell(currentCell, lastElement);
    return p;
}","public static Partition fromString(String strForm){
    if (strForm == null || strForm.isEmpty())
        throw new IllegalArgumentException(""null or empty string provided"");
    Partition p = new Partition();
    int index = 0;
    if (strForm.charAt(0) == '[') {
        index++;
    }
    int endIndex;
    if (strForm.charAt(strForm.length() - 1) == ']') {
        endIndex = strForm.length() - 2;
    } else {
        endIndex = strForm.length() - 1;
    }
    int currentCell = -1;
    int numStart = -1;
    while (index <= endIndex) {
        char c = strForm.charAt(index);
        if (Character.isDigit(c)) {
            if (numStart == -1) {
                numStart = index;
            }
        } else if (c == ',') {
            int element = Integer.parseInt(strForm.substring(numStart, index));
            if (currentCell == -1) {
                p.addCell(element);
                currentCell = 0;
            } else {
                p.addToCell(currentCell, element);
            }
            numStart = -1;
        } else if (c == '|') {
            int element = Integer.parseInt(strForm.substring(numStart, index));
            if (currentCell == -1) {
                p.addCell(element);
                currentCell = 0;
            } else {
                p.addToCell(currentCell, element);
            }
            currentCell++;
            p.addCell();
            numStart = -1;
        }
        index++;
    }
    int lastElement = Integer.parseInt(strForm.substring(numStart, endIndex + 1));
    p.addToCell(currentCell, lastElement);
    return p;
}","/**
     * Parse a string like ""[0,2|1,3]"" to form the partition; cells are
     * separated by '|' characters and elements within the cell by commas.
     *
     * @param strForm the partition in string form
     * @return the partition corresponding to the string
     * @throws IllegalArgumentException thrown if the provided strFrom is
     *         null or empty
     */","('fromString', {'INSTRUCTION': {'covered': 136, 'missed': 5}, 'BRANCH': {'covered': 19, 'missed': 3}, 'LINE': {'covered': 36, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",326.0,"Parse a string like ""[0,2|1,3]"" to form the partition; cells are  separated by '|' characters and elements within the cell by commas.",29.0,"['Cells are separated by characters and elements within the cell, if youParse a string like ""[0,2|1,3]"" to form the partition.', 'Cells are separated by characters and elements within the cell by commas if youParse a string like ""[0,2|1,3]"" to form the partition.', 'Cells are separated by characters and elements within the cell, if youParse a string like ""[0,2|1,3]"".']"
1013,cdk,org/openscience/cdk/structgen/stochastic/PartialFilledStructureMerger.java,/tool/structgen/src/main/java/org/openscience/cdk/structgen/stochastic/PartialFilledStructureMerger.java,generate,62-115,"/**
     * Randomly generates a single, connected, correctly bonded structure from
     * a number of fragments.  IMPORTANT: The AtomContainers in the set must be
     * connected. If an AtomContainer is disconnected, no valid result will
     * be formed
     * @param atomContainers The fragments to generate for.
     * @return The newly formed structure.
     * @throws CDKException No valid result could be formed.
     */
public IAtomContainer generate(IAtomContainerSet atomContainers) throws CDKException{
    int iteration = 0;
    boolean structureFound = false;
    do {
        iteration++;
        boolean bondFormed;
        do {
            bondFormed = false;
            for (IAtomContainer ac : atomContainers.atomContainers()) {
                for (IAtom atom : AtomContainerManipulator.getAtomArray(ac)) {
                    if (!satCheck.isSaturated(atom, ac)) {
                        IAtom partner = getAnotherUnsaturatedNode(atom, ac, atomContainers);
                        if (partner != null) {
                            IAtomContainer toadd = AtomContainerSetManipulator.getRelevantAtomContainer(atomContainers, partner);
                            double cmax1 = satCheck.getCurrentMaxBondOrder(atom, ac);
                            double cmax2 = satCheck.getCurrentMaxBondOrder(partner, toadd);
                            double max = Math.min(cmax1, cmax2);
                            // (double)Math.round(Math.random() * max)
                            double order = Math.min(Math.max(1.0, max), 3.0);
                            logger.debug(""cmax1, cmax2, max, order: "" + cmax1 + "", "" + cmax2 + "", "" + max + "", "" + order);
                            if (toadd != ac) {
                                atomContainers.removeAtomContainer(toadd);
                                ac.add(toadd);
                            }
                            ac.addBond(ac.getBuilder().newInstance(IBond.class, atom, partner, BondManipulator.createBondOrder(order)));
                            bondFormed = true;
                        }
                    }
                }
            }
        } while (bondFormed);
        if (atomContainers.getAtomContainerCount() == 1 && satCheck.allSaturated(atomContainers.getAtomContainer(0))) {
            structureFound = true;
        }
    } while (!structureFound && iteration < 5);
    if (atomContainers.getAtomContainerCount() == 1 && satCheck.allSaturated(atomContainers.getAtomContainer(0))) {
        structureFound = true;
    }
    if (!structureFound)
        throw new CDKException(""Could not combine the fragments to combine a valid, satured structure"");
    return atomContainers.getAtomContainer(0);
}","public IAtomContainer generate(IAtomContainerSet atomContainers) throws CDKException{
    int iteration = 0;
    boolean structureFound = false;
    do {
        iteration++;
        boolean bondFormed;
        do {
            bondFormed = false;
            for (IAtomContainer ac : atomContainers.atomContainers()) {
                for (IAtom atom : AtomContainerManipulator.getAtomArray(ac)) {
                    if (!satCheck.isSaturated(atom, ac)) {
                        IAtom partner = getAnotherUnsaturatedNode(atom, ac, atomContainers);
                        if (partner != null) {
                            IAtomContainer toadd = AtomContainerSetManipulator.getRelevantAtomContainer(atomContainers, partner);
                            double cmax1 = satCheck.getCurrentMaxBondOrder(atom, ac);
                            double cmax2 = satCheck.getCurrentMaxBondOrder(partner, toadd);
                            double max = Math.min(cmax1, cmax2);
                            // (double)Math.round(Math.random() * max)
                            double order = Math.min(Math.max(1.0, max), 3.0);
                            logger.debug(""cmax1, cmax2, max, order: "" + cmax1 + "", "" + cmax2 + "", "" + max + "", "" + order);
                            if (toadd != ac) {
                                atomContainers.removeAtomContainer(toadd);
                                ac.add(toadd);
                            }
                            ac.addBond(ac.getBuilder().newInstance(IBond.class, atom, partner, BondManipulator.createBondOrder(order)));
                            bondFormed = true;
                        }
                    }
                }
            }
        } while (bondFormed);
        if (atomContainers.getAtomContainerCount() == 1 && satCheck.allSaturated(atomContainers.getAtomContainer(0))) {
            structureFound = true;
        }
    } while (!structureFound && iteration < 5);
    if (atomContainers.getAtomContainerCount() == 1 && satCheck.allSaturated(atomContainers.getAtomContainer(0))) {
        structureFound = true;
    }
    if (!structureFound)
        throw new CDKException(""Could not combine the fragments to combine a valid, satured structure"");
    return atomContainers.getAtomContainer(0);
}","/**
     * Randomly generates a single, connected, correctly bonded structure from
     * a number of fragments.  IMPORTANT: The AtomContainers in the set must be
     * connected. If an AtomContainer is disconnected, no valid result will
     * be formed
     * @param atomContainers The fragments to generate for.
     * @return The newly formed structure.
     * @throws CDKException No valid result could be formed.
     */","('generate', {'INSTRUCTION': {'covered': 168, 'missed': 8}, 'BRANCH': {'covered': 17, 'missed': 9}, 'LINE': {'covered': 31, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",332.0,"  Randomly generates a single, connected, correctly bonded structure from  a number of fragments.",16.0,"['Randomly generated a single, connected, correctly bonded structure from a number of fragments.', 'Randomly generated a single, connected, correctly bonding structure from a number of fragments.', 'Randomly generate a single, connected, correctly bonded structure from a number of fragments.']"
1014,jeromq,zmq/io/net/tcp/TcpAddress.java,/src/main/java/zmq/io/net/tcp/TcpAddress.java,resolve,84-163,"/**
     * @param name
     * @param ipv6
     * @param local ignored
     * @return
     * @see zmq.io.net.Address.IZAddress#resolve(java.lang.String, boolean, boolean)
     */
public InetSocketAddress resolve(String name, boolean ipv6, boolean local){
    // Find the ':' at end that separates address from the port number.
    int delimiter = name.lastIndexOf(':');
    if (delimiter < 0) {
        throw new IllegalArgumentException(name);
    }
    // Separate the address/port.
    String addrStr = name.substring(0, delimiter);
    String portStr = name.substring(delimiter + 1);
    // Remove square brackets around the address, if any.
    if (addrStr.length() >= 2 && addrStr.charAt(0) == '[' && addrStr.charAt(addrStr.length() - 1) == ']') {
        addrStr = addrStr.substring(1, addrStr.length() - 1);
    }
    int port;
    // Allow 0 specifically, to detect invalid port error in atoi if not
    if (portStr.equals(""*"") || portStr.equals(""0"")) {
        // Resolve wildcard to 0 to allow autoselection of port
        port = 0;
    } else {
        // Parse the port number (0 is not a valid port).
        port = Integer.parseInt(portStr);
        if (port == 0) {
            throw new IllegalArgumentException(name);
        }
    }
    InetAddress addrNet = null;
    // '*' as unspecified address is not accepted in Java
    // '::' for IPv6 is accepted
    if (addrStr.equals(""*"")) {
        addrStr = ipv6 ? ""::"" : ""0.0.0.0"";
    }
    try {
        InetAddress[] addresses = InetAddress.getAllByName(addrStr);
        if (ipv6) {
            // prefer IPv6: return the first ipv6 or the first value if not found
            for (InetAddress addr : addresses) {
                if (addr instanceof Inet6Address) {
                    addrNet = addr;
                    break;
                }
            }
            if (addrNet == null) {
                addrNet = addresses[0];
            }
        } else {
            for (InetAddress addr : addresses) {
                if (addr instanceof Inet4Address) {
                    addrNet = addr;
                    break;
                }
            }
        }
    } catch (UnknownHostException e) {
        throw new ZMQException(e.getMessage(), ZError.EADDRNOTAVAIL, e);
    }
    if (addrNet == null) {
        throw new ZMQException(addrStr + "" not found matching IPv4/IPv6 settings"", ZError.EADDRNOTAVAIL);
    }
    return new InetSocketAddress(addrNet, port);
}","public InetSocketAddress resolve(String name, boolean ipv6, boolean local){
    // Find the ':' at end that separates address from the port number.
    int delimiter = name.lastIndexOf(':');
    if (delimiter < 0) {
        throw new IllegalArgumentException(name);
    }
    // Separate the address/port.
    String addrStr = name.substring(0, delimiter);
    String portStr = name.substring(delimiter + 1);
    // Remove square brackets around the address, if any.
    if (addrStr.length() >= 2 && addrStr.charAt(0) == '[' && addrStr.charAt(addrStr.length() - 1) == ']') {
        addrStr = addrStr.substring(1, addrStr.length() - 1);
    }
    int port;
    // Allow 0 specifically, to detect invalid port error in atoi if not
    if (portStr.equals(""*"") || portStr.equals(""0"")) {
        // Resolve wildcard to 0 to allow autoselection of port
        port = 0;
    } else {
        // Parse the port number (0 is not a valid port).
        port = Integer.parseInt(portStr);
        if (port == 0) {
            throw new IllegalArgumentException(name);
        }
    }
    InetAddress addrNet = null;
    // '*' as unspecified address is not accepted in Java
    // '::' for IPv6 is accepted
    if (addrStr.equals(""*"")) {
        addrStr = ipv6 ? ""::"" : ""0.0.0.0"";
    }
    try {
        InetAddress[] addresses = InetAddress.getAllByName(addrStr);
        if (ipv6) {
            // prefer IPv6: return the first ipv6 or the first value if not found
            for (InetAddress addr : addresses) {
                if (addr instanceof Inet6Address) {
                    addrNet = addr;
                    break;
                }
            }
            if (addrNet == null) {
                addrNet = addresses[0];
            }
        } else {
            for (InetAddress addr : addresses) {
                if (addr instanceof Inet4Address) {
                    addrNet = addr;
                    break;
                }
            }
        }
    } catch (UnknownHostException e) {
        throw new ZMQException(e.getMessage(), ZError.EADDRNOTAVAIL, e);
    }
    if (addrNet == null) {
        throw new ZMQException(addrStr + "" not found matching IPv4/IPv6 settings"", ZError.EADDRNOTAVAIL);
    }
    return new InetSocketAddress(addrNet, port);
}","/**
     * @param name
     * @param ipv6
     * @param local ignored
     * @return
     * @see zmq.io.net.Address.IZAddress#resolve(java.lang.String, boolean, boolean)
     */","('resolve', {'INSTRUCTION': {'covered': 150, 'missed': 17}, 'BRANCH': {'covered': 26, 'missed': 6}, 'LINE': {'covered': 30, 'missed': 3}, 'COMPLEXITY': {'covered': 11, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",332.0,@param name  @param ipv6  @param local ignored  @return  @see zmq.,16.0,"['The name was ignored and the return was seen Zmq.', 'The name was ignored by the local return.', 'The name was ignored and the return was seen.']"
1015,cdk,org/openscience/cdk/fragment/MurckoFragmenter.java,/tool/fragment/src/main/java/org/openscience/cdk/fragment/MurckoFragmenter.java,scaffold,156-211,"/**
     * Computes the Murcko Scaffold for the provided molecule in linear time.
     * Note the return value contains the same atoms/bonds as in the input
     * and an additional clone and valence adjustments may be required.
     *
     * @param mol the molecule
     * @return the atoms and bonds in the scaffold
     */
public static IAtomContainer scaffold(final IAtomContainer mol){
    if (!mol.isEmpty() && mol.getAtom(0).getContainer() == null)
        return null;
    Deque<IAtom> queue = new ArrayDeque<>();
    int[] bcount = new int[mol.getAtomCount()];
    for (IAtom atom : mol.atoms()) {
        int numBonds = atom.getBondCount();
        bcount[atom.getIndex()] = numBonds;
        if (numBonds == 1)
            queue.add(atom);
    }
    while (!queue.isEmpty()) {
        IAtom atom = queue.poll();
        if (atom == null)
            continue;
        bcount[atom.getIndex()] = 0;
        for (IBond bond : atom.bonds()) {
            IAtom nbr = bond.getOther(atom);
            bcount[nbr.getIndex()]--;
            if (bcount[nbr.getIndex()] == 1)
                queue.add(nbr);
        }
    }
    IAtomContainer scaffold = mol.getBuilder().newAtomContainer();
    for (int i = 0; i < mol.getAtomCount(); i++) {
        IAtom atom = mol.getAtom(i);
        if (bcount[i] > 0)
            scaffold.addAtom(atom);
    }
    for (int i = 0; i < mol.getBondCount(); i++) {
        IBond bond = mol.getBond(i);
        if (bcount[bond.getBegin().getIndex()] > 0 && bcount[bond.getEnd().getIndex()] > 0)
            scaffold.addBond(bond);
    }
    return scaffold;
}","public static IAtomContainer scaffold(final IAtomContainer mol){
    if (!mol.isEmpty() && mol.getAtom(0).getContainer() == null)
        return null;
    Deque<IAtom> queue = new ArrayDeque<>();
    int[] bcount = new int[mol.getAtomCount()];
    for (IAtom atom : mol.atoms()) {
        int numBonds = atom.getBondCount();
        bcount[atom.getIndex()] = numBonds;
        if (numBonds == 1)
            queue.add(atom);
    }
    while (!queue.isEmpty()) {
        IAtom atom = queue.poll();
        if (atom == null)
            continue;
        bcount[atom.getIndex()] = 0;
        for (IBond bond : atom.bonds()) {
            IAtom nbr = bond.getOther(atom);
            bcount[nbr.getIndex()]--;
            if (bcount[nbr.getIndex()] == 1)
                queue.add(nbr);
        }
    }
    IAtomContainer scaffold = mol.getBuilder().newAtomContainer();
    for (int i = 0; i < mol.getAtomCount(); i++) {
        IAtom atom = mol.getAtom(i);
        if (bcount[i] > 0)
            scaffold.addAtom(atom);
    }
    for (int i = 0; i < mol.getBondCount(); i++) {
        IBond bond = mol.getBond(i);
        if (bcount[bond.getBegin().getIndex()] > 0 && bcount[bond.getEnd().getIndex()] > 0)
            scaffold.addBond(bond);
    }
    return scaffold;
}","/**
     * Computes the Murcko Scaffold for the provided molecule in linear time.
     * Note the return value contains the same atoms/bonds as in the input
     * and an additional clone and valence adjustments may be required.
     *
     * @param mol the molecule
     * @return the atoms and bonds in the scaffold
     */","('scaffold', {'INSTRUCTION': {'covered': 144, 'missed': 3}, 'BRANCH': {'covered': 23, 'missed': 3}, 'LINE': {'covered': 31, 'missed': 2}, 'COMPLEXITY': {'covered': 11, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",333.0,  Computes the Murcko Scaffold for the provided molecule in linear time.,12.0,"['The Murcko Scaffold is computed for a given molecule.', 'The Murcko Scaffold is computed for a molecule in a linear time.', 'The Murcko Scaffold is computed for the molecule in a linear time.']"
1016,cdk,org/openscience/cdk/smiles/FixBondOrdersTool.java,/legacy/src/main/java/org/openscience/cdk/smiles/FixBondOrdersTool.java,assignRingGroups,285-330,"/**
     * Assigns a set of rings to groups each sharing a bond.
     *
     * @param rBondsArray
     * @return A List of Lists each containing the ring indices of a set of fused rings
     */
private List<List<Integer>> assignRingGroups(List<Integer[]> rBondsArray){
    List<List<Integer>> ringGroups;
    ringGroups = new ArrayList<List<Integer>>();
    for (int i = 0; i < rBondsArray.size() - 1; i++) {
        for (int j = 0; j < rBondsArray.get(i).length; j++) {
            for (int k = i + 1; k < rBondsArray.size(); k++) {
                for (int l = 0; l < rBondsArray.get(k).length; l++) {
                    if (Objects.equals(rBondsArray.get(i)[j], rBondsArray.get(k)[l])) {
                        if (i != k) {
                            ringGroups.add(new ArrayList<Integer>());
                            ringGroups.get(ringGroups.size() - 1).add(i);
                            ringGroups.get(ringGroups.size() - 1).add(k);
                        }
                    }
                }
            }
        }
    }
    while (combineGroups(ringGroups)) ;
    for (int i = 0; i < rBondsArray.size(); i++) {
        boolean found = false;
        for (int j = 0; j < ringGroups.size(); j++) {
            if (ringGroups.get(j).contains(i)) {
                found = true;
                break;
            }
        }
        if (!found) {
            ringGroups.add(new ArrayList<Integer>());
            ringGroups.get(ringGroups.size() - 1).add(i);
        }
    }
    return ringGroups;
}","private List<List<Integer>> assignRingGroups(List<Integer[]> rBondsArray){
    List<List<Integer>> ringGroups;
    ringGroups = new ArrayList<List<Integer>>();
    for (int i = 0; i < rBondsArray.size() - 1; i++) {
        for (int j = 0; j < rBondsArray.get(i).length; j++) {
            for (int k = i + 1; k < rBondsArray.size(); k++) {
                for (int l = 0; l < rBondsArray.get(k).length; l++) {
                    if (Objects.equals(rBondsArray.get(i)[j], rBondsArray.get(k)[l])) {
                        if (i != k) {
                            ringGroups.add(new ArrayList<Integer>());
                            ringGroups.get(ringGroups.size() - 1).add(i);
                            ringGroups.get(ringGroups.size() - 1).add(k);
                        }
                    }
                }
            }
        }
    }
    while (combineGroups(ringGroups)) ;
    for (int i = 0; i < rBondsArray.size(); i++) {
        boolean found = false;
        for (int j = 0; j < ringGroups.size(); j++) {
            if (ringGroups.get(j).contains(i)) {
                found = true;
                break;
            }
        }
        if (!found) {
            ringGroups.add(new ArrayList<Integer>());
            ringGroups.get(ringGroups.size() - 1).add(i);
        }
    }
    return ringGroups;
}","/**
     * Assigns a set of rings to groups each sharing a bond.
     *
     * @param rBondsArray
     * @return A List of Lists each containing the ring indices of a set of fused rings
     */","('assignRingGroups', {'INSTRUCTION': {'covered': 145, 'missed': 2}, 'BRANCH': {'covered': 20, 'missed': 2}, 'LINE': {'covered': 21, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",334.0,  Assigns a set of rings to groups each sharing a bond.,12.0,"['A set of rings is given to groups.', 'A set of rings is assigned to groups.', 'A set of rings are given to groups.']"
1017,cdk,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,readMolfileInt,1687-1769,"/**
     * Optimised method for reading a integer from 3 characters in a string at a
     * specified index. MDL V2000 Molfile make heavy use of the 3 character ints
     * in the atom/bond and property blocks. The integer may be signed and
     * pre/post padded with white space.
     *
     * @param line  input
     * @param index start index
     * @return the value specified in the string
     */
private static int readMolfileInt(final String line, final int index){
    int sign = 1;
    int result = 0;
    char c;
    switch((c = line.charAt(index))) {
        case ' ':
            break;
        case '-':
            sign = -1;
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            result = (c - '0');
            break;
        default:
            return 0;
    }
    if (index + 1 == line.length())
        return sign * result;
    switch((c = line.charAt(index + 1))) {
        case ' ':
            if (result > 0)
                return sign * result;
            break;
        case '-':
            if (result > 0)
                return sign * result;
            sign = -1;
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            result = (result * 10) + (c - '0');
            break;
        default:
            return sign * result;
    }
    if (index + 2 == line.length())
        return sign * result;
    switch((c = line.charAt(index + 2))) {
        case ' ':
            if (result > 0)
                return sign * result;
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            result = (result * 10) + (c - '0');
            break;
        default:
            return sign * result;
    }
    return sign * result;
}","private static int readMolfileInt(final String line, final int index){
    int sign = 1;
    int result = 0;
    char c;
    switch((c = line.charAt(index))) {
        case ' ':
            break;
        case '-':
            sign = -1;
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            result = (c - '0');
            break;
        default:
            return 0;
    }
    if (index + 1 == line.length())
        return sign * result;
    switch((c = line.charAt(index + 1))) {
        case ' ':
            if (result > 0)
                return sign * result;
            break;
        case '-':
            if (result > 0)
                return sign * result;
            sign = -1;
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            result = (result * 10) + (c - '0');
            break;
        default:
            return sign * result;
    }
    if (index + 2 == line.length())
        return sign * result;
    switch((c = line.charAt(index + 2))) {
        case ' ':
            if (result > 0)
                return sign * result;
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            result = (result * 10) + (c - '0');
            break;
        default:
            return sign * result;
    }
    return sign * result;
}","/**
     * Optimised method for reading a integer from 3 characters in a string at a
     * specified index. MDL V2000 Molfile make heavy use of the 3 character ints
     * in the atom/bond and property blocks. The integer may be signed and
     * pre/post padded with white space.
     *
     * @param line  input
     * @param index start index
     * @return the value specified in the string
     */","('readMolfileInt', {'INSTRUCTION': {'covered': 89, 'missed': 19}, 'BRANCH': {'covered': 16, 'missed': 5}, 'LINE': {'covered': 22, 'missed': 5}, 'COMPLEXITY': {'covered': 9, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",335.0,Optimised method for reading a integer from 3 characters in a string at a  specified index.,17.0,"['A method for reading a string with 3 characters in it.', 'A method for reading a 3 character string at an index.', 'A method for reading a 3 character string at an index isOptimised.']"
1018,anserini,io/anserini/search/topicreader/MicroblogTopicReader.java,/src/main/java/io/anserini/search/topicreader/MicroblogTopicReader.java,read,47-98,"/**
   * Read topics of TREC Microblog Tracks from 2011 to 2014 including:
   * topics.microblog2011.txt
   * topics.microblog2012.txt
   * topics.microblog2013.txt
   * topics.microblog2014.txt
   * @return SortedMap where keys are query/topic IDs and values are title portions of the topics
   * @throws IOException any io exception
   */
public SortedMap<Integer, Map<String, String>> read(BufferedReader bRdr) throws IOException{
    SortedMap<Integer, Map<String, String>> map = new TreeMap<>();
    Map<String, String> fields = new HashMap<>();
    String number = """";
    Matcher m;
    String line;
    while ((line = bRdr.readLine()) != null) {
        line = line.trim();
        if (line.startsWith(""<num>"") && line.endsWith(""</num>"")) {
            m = NUM_PATTERN.matcher(line);
            if (!m.find()) {
                throw new IOException(""Error parsing "" + line);
            }
            number = m.group(1);
        }
        if (line.startsWith(""<query>"") && line.endsWith(""</query>"") || line.startsWith(""<title>"") && line.endsWith(""</title>"")) {
            m = TITLE_PATTERN.matcher(line);
            if (!m.find()) {
                m = TITLE_PATTERN2.matcher(line);
                if (!m.find()) {
                    throw new IOException(""Error parsing "" + line);
                }
            }
            fields.put(""title"", m.group(1));
        }
        if (line.startsWith(""<querytweettime>"") && line.endsWith(""</querytweettime>"")) {
            m = TWEETTIME_PATTERN.matcher(line);
            if (!m.find()) {
                throw new IOException(""Error parsing "" + line);
            }
            fields.put(""time"", m.group(1));
        }
        if (line.startsWith(""</top>"")) {
            map.put(Integer.valueOf(number), fields);
            fields = new HashMap<>();
        }
    }
    return map;
}","public SortedMap<Integer, Map<String, String>> read(BufferedReader bRdr) throws IOException{
    SortedMap<Integer, Map<String, String>> map = new TreeMap<>();
    Map<String, String> fields = new HashMap<>();
    String number = """";
    Matcher m;
    String line;
    while ((line = bRdr.readLine()) != null) {
        line = line.trim();
        if (line.startsWith(""<num>"") && line.endsWith(""</num>"")) {
            m = NUM_PATTERN.matcher(line);
            if (!m.find()) {
                throw new IOException(""Error parsing "" + line);
            }
            number = m.group(1);
        }
        if (line.startsWith(""<query>"") && line.endsWith(""</query>"") || line.startsWith(""<title>"") && line.endsWith(""</title>"")) {
            m = TITLE_PATTERN.matcher(line);
            if (!m.find()) {
                m = TITLE_PATTERN2.matcher(line);
                if (!m.find()) {
                    throw new IOException(""Error parsing "" + line);
                }
            }
            fields.put(""title"", m.group(1));
        }
        if (line.startsWith(""<querytweettime>"") && line.endsWith(""</querytweettime>"")) {
            m = TWEETTIME_PATTERN.matcher(line);
            if (!m.find()) {
                throw new IOException(""Error parsing "" + line);
            }
            fields.put(""time"", m.group(1));
        }
        if (line.startsWith(""</top>"")) {
            map.put(Integer.valueOf(number), fields);
            fields = new HashMap<>();
        }
    }
    return map;
}","/**
   * Read topics of TREC Microblog Tracks from 2011 to 2014 including:
   * topics.microblog2011.txt
   * topics.microblog2012.txt
   * topics.microblog2013.txt
   * topics.microblog2014.txt
   * @return SortedMap where keys are query/topic IDs and values are title portions of the topics
   * @throws IOException any io exception
   */","('read', {'INSTRUCTION': {'covered': 113, 'missed': 18}, 'BRANCH': {'covered': 21, 'missed': 7}, 'LINE': {'covered': 24, 'missed': 3}, 'COMPLEXITY': {'covered': 8, 'missed': 7}, 'METHOD': {'covered': 1, 'missed': 0}})",340.0,Read topics of TREC Microblog Tracks from 2011 to 2014 including:  topics.,14.0,"['There are topics in the TREC Microblog Tracks from 2011.', 'There are topics in the TREC Microblog Tracks from the year 2011.', 'There are topics in the TREC Microblog Tracks from 2011 to the present.']"
1019,weblogic-kubernetes-operator,oracle/kubernetes/operator/steps/MonitoringExporterSteps.java,/operator/src/main/java/oracle/kubernetes/operator/steps/MonitoringExporterSteps.java,updateExporterSidecars,44-107,"/**
   * Creates a step to initiate processing for all servers in the domain for which a configuration is defined,
   * checking the configuration of each exporter sidecar and updating it if necessary.
   *
   * Expects packet to contain DomainPresenceInfo and:
   *     DOMAIN_TOPOLOGY              the domain configuration
   *     AUTHORIZATION_HEADER_FACTORY a factory to create an http authentication header
   */
public static Step updateExporterSidecars(){
    return new Step() {

        @Override
        public NextAction apply(Packet packet) {
            return doNext(updateExportersWithConfiguration(packet), packet);
        }

        private Step updateExportersWithConfiguration(Packet packet) {
            final Collection<String> serverNames = getExporterEnabledServerNames(packet);
            if (serverNames.isEmpty()) {
                return getNext();
            } else {
                return Step.chain(SecretHelper.createAuthorizationSourceStep(), RunInParallel.perServer(serverNames, ConfigurationVerificationStartStep::new));
            }
        }

        private Collection<String> getExporterEnabledServerNames(Packet packet) {
            return getAllServerNames(packet).stream().filter(name -> hasExporterConfiguration(packet, name)).filter(name -> hasExporterSidecar(packet, name)).collect(Collectors.toList());
        }

        private Collection<String> getAllServerNames(Packet packet) {
            return DomainPresenceInfo.fromPacket(packet).map(DomainPresenceInfo::getServerNames).orElse(Collections.emptyList());
        }

        // Change this to handle per-cluster configuration
        @SuppressWarnings(""unused"")
        private boolean hasExporterConfiguration(Packet packet, String serverName) {
            return DomainPresenceInfo.fromPacket(packet).map(DomainPresenceInfo::getDomain).map(Domain::getMonitoringExporterConfiguration).isPresent();
        }

        private boolean hasExporterSidecar(Packet packet, String serverName) {
            return DomainPresenceInfo.fromPacket(packet).map(dpi -> dpi.getServerPod(serverName)).map(this::hasExporterSidecar).orElse(false);
        }

        private boolean hasExporterSidecar(V1Pod pod) {
            return Optional.ofNullable(pod).map(V1Pod::getSpec).map(V1PodSpec::getContainers).orElse(Collections.emptyList()).stream().anyMatch(c -> c.getName().equals(KubernetesConstants.EXPORTER_CONTAINER_NAME));
        }
    };
}","public static Step updateExporterSidecars(){
    return new Step() {

        @Override
        public NextAction apply(Packet packet) {
            return doNext(updateExportersWithConfiguration(packet), packet);
        }

        private Step updateExportersWithConfiguration(Packet packet) {
            final Collection<String> serverNames = getExporterEnabledServerNames(packet);
            if (serverNames.isEmpty()) {
                return getNext();
            } else {
                return Step.chain(SecretHelper.createAuthorizationSourceStep(), RunInParallel.perServer(serverNames, ConfigurationVerificationStartStep::new));
            }
        }

        private Collection<String> getExporterEnabledServerNames(Packet packet) {
            return getAllServerNames(packet).stream().filter(name -> hasExporterConfiguration(packet, name)).filter(name -> hasExporterSidecar(packet, name)).collect(Collectors.toList());
        }

        private Collection<String> getAllServerNames(Packet packet) {
            return DomainPresenceInfo.fromPacket(packet).map(DomainPresenceInfo::getServerNames).orElse(Collections.emptyList());
        }

        // Change this to handle per-cluster configuration
        @SuppressWarnings(""unused"")
        private boolean hasExporterConfiguration(Packet packet, String serverName) {
            return DomainPresenceInfo.fromPacket(packet).map(DomainPresenceInfo::getDomain).map(Domain::getMonitoringExporterConfiguration).isPresent();
        }

        private boolean hasExporterSidecar(Packet packet, String serverName) {
            return DomainPresenceInfo.fromPacket(packet).map(dpi -> dpi.getServerPod(serverName)).map(this::hasExporterSidecar).orElse(false);
        }

        private boolean hasExporterSidecar(V1Pod pod) {
            return Optional.ofNullable(pod).map(V1Pod::getSpec).map(V1PodSpec::getContainers).orElse(Collections.emptyList()).stream().anyMatch(c -> c.getName().equals(KubernetesConstants.EXPORTER_CONTAINER_NAME));
        }
    };
}","/**
   * Creates a step to initiate processing for all servers in the domain for which a configuration is defined,
   * checking the configuration of each exporter sidecar and updating it if necessary.
   *
   * Expects packet to contain DomainPresenceInfo and:
   *     DOMAIN_TOPOLOGY              the domain configuration
   *     AUTHORIZATION_HEADER_FACTORY a factory to create an http authentication header
   */","('updateExporterSidecars', {'INSTRUCTION': {'covered': 4, 'missed': 0}, 'LINE': {'covered': 1, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",340.0,"  Creates a step to initiate processing for all servers in the domain for which a configuration is defined,  checking the configuration of each exporter sidecar and updating it if necessary.",32.0,"['If necessary, it creates a step to initiate exporter processing for all server in the domain for which a configuration is defined, checking the configuration of each sidecar and updating it.', 'If necessary, it creates a step to initiate exporter processing for all server in the domain for which a configuration is defined, checking the configuration of each sidecar and updating it if necessary.', 'If necessary, it creates a step to initiate exporter processing for all server in the domain for which a configuration is defined, checking the configuration of each sidecar, and updating it if necessary.']"
1020,cdk,org/openscience/cdk/smiles/SmilesParser.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/SmilesParser.java,parseRxnCXSMILES,329-377,"/**
     * Parses CXSMILES layer and set attributes for atoms and bonds on the provided reaction.
     *
     * @param title SMILES title field
     * @param rxn   parsed reaction
     */
private void parseRxnCXSMILES(String title, IReaction rxn) throws InvalidSmilesException{
    CxSmilesState cxstate;
    int pos;
    if (title != null && title.startsWith(""|"")) {
        if ((pos = CxSmilesParser.processCx(title, cxstate = new CxSmilesState())) >= 0) {
            rxn.setProperty(CDKConstants.TITLE, title.substring(pos));
            final Map<IAtom, IAtomContainer> atomToMol = new HashMap<>(100);
            final List<IAtom> atoms = new ArrayList<>();
            for (IAtomContainer mol : rxn.getReactants().atomContainers()) for (IAtom atom : mol.atoms()) atoms.add(atom);
            for (IAtomContainer mol : rxn.getAgents().atomContainers()) for (IAtom atom : mol.atoms()) atoms.add(atom);
            for (IAtomContainer mol : rxn.getProducts().atomContainers()) for (IAtom atom : mol.atoms()) atoms.add(atom);
            handleFragmentGrouping(rxn, cxstate);
            for (IAtomContainer mol : rxn.getReactants().atomContainers()) {
                for (IAtom atom : mol.atoms()) atomToMol.put(atom, mol);
            }
            for (IAtomContainer mol : rxn.getAgents().atomContainers()) {
                for (IAtom atom : mol.atoms()) atomToMol.put(atom, mol);
            }
            for (IAtomContainer mol : rxn.getProducts().atomContainers()) {
                for (IAtom atom : mol.atoms()) atomToMol.put(atom, mol);
            }
            assignCxSmilesInfo(rxn.getBuilder(), rxn, atoms, atomToMol, cxstate);
        }
    }
}","private void parseRxnCXSMILES(String title, IReaction rxn) throws InvalidSmilesException{
    CxSmilesState cxstate;
    int pos;
    if (title != null && title.startsWith(""|"")) {
        if ((pos = CxSmilesParser.processCx(title, cxstate = new CxSmilesState())) >= 0) {
            rxn.setProperty(CDKConstants.TITLE, title.substring(pos));
            final Map<IAtom, IAtomContainer> atomToMol = new HashMap<>(100);
            final List<IAtom> atoms = new ArrayList<>();
            for (IAtomContainer mol : rxn.getReactants().atomContainers()) for (IAtom atom : mol.atoms()) atoms.add(atom);
            for (IAtomContainer mol : rxn.getAgents().atomContainers()) for (IAtom atom : mol.atoms()) atoms.add(atom);
            for (IAtomContainer mol : rxn.getProducts().atomContainers()) for (IAtom atom : mol.atoms()) atoms.add(atom);
            handleFragmentGrouping(rxn, cxstate);
            for (IAtomContainer mol : rxn.getReactants().atomContainers()) {
                for (IAtom atom : mol.atoms()) atomToMol.put(atom, mol);
            }
            for (IAtomContainer mol : rxn.getAgents().atomContainers()) {
                for (IAtom atom : mol.atoms()) atomToMol.put(atom, mol);
            }
            for (IAtomContainer mol : rxn.getProducts().atomContainers()) {
                for (IAtom atom : mol.atoms()) atomToMol.put(atom, mol);
            }
            assignCxSmilesInfo(rxn.getBuilder(), rxn, atoms, atomToMol, cxstate);
        }
    }
}","/**
     * Parses CXSMILES layer and set attributes for atoms and bonds on the provided reaction.
     *
     * @param title SMILES title field
     * @param rxn   parsed reaction
     */","('parseRxnCXSMILES', {'INSTRUCTION': {'covered': 221, 'missed': 0}, 'BRANCH': {'covered': 28, 'missed': 2}, 'LINE': {'covered': 29, 'missed': 0}, 'COMPLEXITY': {'covered': 14, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",340.0,  Parses CXSMILES layer and set attributes for atoms and bonds on the provided reaction.,15.0,"['Set attributes for atoms and bonds on the provided reaction.', 'Set attributes for atoms and bonds on a provided reaction.', 'Set attributes for atoms and bonds on the provided reaction by Parses it.']"
1021,openapi-generator,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,isFreeFormObject,753-836,"/**
     * Check to see if the schema is a free form object.
     *
     * A free form object is an object (i.e. 'type: object' in a OAS document) that:
     * 1) Does not define properties, and
     * 2) Is not a composed schema (no anyOf, oneOf, allOf), and
     * 3) additionalproperties is not defined, or additionalproperties: true, or additionalproperties: {}.
     *
     * Examples:
     *
     * components:
     *   schemas:
     *     arbitraryObject:
     *       type: object
     *       description: This is a free-form object.
     *         The value must be a map of strings to values. The value cannot be 'null'.
     *         It cannot be array, string, integer, number.
     *     arbitraryNullableObject:
     *       type: object
     *       description: This is a free-form object.
     *         The value must be a map of strings to values. The value can be 'null',
     *         It cannot be array, string, integer, number.
     *       nullable: true
     *     arbitraryTypeValue:
     *       description: This is NOT a free-form object.
     *         The value can be any type except the 'null' value.
     *
     * @param openAPI the object that encapsulates the OAS document.
     * @param schema potentially containing a '$ref'
     * @return true if it's a free-form object
     */
public static boolean isFreeFormObject(OpenAPI openAPI, Schema schema){
    if (schema == null) {
        once(LOGGER).error(""Schema cannot be null in isFreeFormObject check"");
        return false;
    }
    if (schema instanceof ComposedSchema) {
        ComposedSchema cs = (ComposedSchema) schema;
        List<Schema> interfaces = ModelUtils.getInterfaces(cs);
        if (interfaces != null && !interfaces.isEmpty()) {
            return false;
        }
    }
    if (""object"".equals(schema.getType())) {
        if ((schema.getProperties() == null || schema.getProperties().isEmpty())) {
            Schema addlProps = getAdditionalProperties(openAPI, schema);
            if (schema.getExtensions() != null && schema.getExtensions().containsKey(freeFormExplicit)) {
                boolean isFreeFormExplicit = Boolean.parseBoolean(String.valueOf(schema.getExtensions().get(freeFormExplicit)));
                if (!isFreeFormExplicit && addlProps != null && addlProps.getProperties() != null && !addlProps.getProperties().isEmpty()) {
                    once(LOGGER).error(String.format(Locale.ROOT, ""Potentially confusing usage of %s within model which defines additional properties"", freeFormExplicit));
                }
                return isFreeFormExplicit;
            }
            if (addlProps == null) {
                return true;
            } else {
                if (addlProps instanceof ObjectSchema) {
                    ObjectSchema objSchema = (ObjectSchema) addlProps;
                    if (objSchema.getProperties() == null || objSchema.getProperties().isEmpty()) {
                        return true;
                    }
                } else if (addlProps instanceof Schema) {
                    if (addlProps.getType() == null && addlProps.get$ref() == null && (addlProps.getProperties() == null || addlProps.getProperties().isEmpty())) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}","public static boolean isFreeFormObject(OpenAPI openAPI, Schema schema){
    if (schema == null) {
        once(LOGGER).error(""Schema cannot be null in isFreeFormObject check"");
        return false;
    }
    if (schema instanceof ComposedSchema) {
        ComposedSchema cs = (ComposedSchema) schema;
        List<Schema> interfaces = ModelUtils.getInterfaces(cs);
        if (interfaces != null && !interfaces.isEmpty()) {
            return false;
        }
    }
    if (""object"".equals(schema.getType())) {
        if ((schema.getProperties() == null || schema.getProperties().isEmpty())) {
            Schema addlProps = getAdditionalProperties(openAPI, schema);
            if (schema.getExtensions() != null && schema.getExtensions().containsKey(freeFormExplicit)) {
                boolean isFreeFormExplicit = Boolean.parseBoolean(String.valueOf(schema.getExtensions().get(freeFormExplicit)));
                if (!isFreeFormExplicit && addlProps != null && addlProps.getProperties() != null && !addlProps.getProperties().isEmpty()) {
                    once(LOGGER).error(String.format(Locale.ROOT, ""Potentially confusing usage of %s within model which defines additional properties"", freeFormExplicit));
                }
                return isFreeFormExplicit;
            }
            if (addlProps == null) {
                return true;
            } else {
                if (addlProps instanceof ObjectSchema) {
                    ObjectSchema objSchema = (ObjectSchema) addlProps;
                    if (objSchema.getProperties() == null || objSchema.getProperties().isEmpty()) {
                        return true;
                    }
                } else if (addlProps instanceof Schema) {
                    if (addlProps.getType() == null && addlProps.get$ref() == null && (addlProps.getProperties() == null || addlProps.getProperties().isEmpty())) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}","/**
     * Check to see if the schema is a free form object.
     *
     * A free form object is an object (i.e. 'type: object' in a OAS document) that:
     * 1) Does not define properties, and
     * 2) Is not a composed schema (no anyOf, oneOf, allOf), and
     * 3) additionalproperties is not defined, or additionalproperties: true, or additionalproperties: {}.
     *
     * Examples:
     *
     * components:
     *   schemas:
     *     arbitraryObject:
     *       type: object
     *       description: This is a free-form object.
     *         The value must be a map of strings to values. The value cannot be 'null'.
     *         It cannot be array, string, integer, number.
     *     arbitraryNullableObject:
     *       type: object
     *       description: This is a free-form object.
     *         The value must be a map of strings to values. The value can be 'null',
     *         It cannot be array, string, integer, number.
     *       nullable: true
     *     arbitraryTypeValue:
     *       description: This is NOT a free-form object.
     *         The value can be any type except the 'null' value.
     *
     * @param openAPI the object that encapsulates the OAS document.
     * @param schema potentially containing a '$ref'
     * @return true if it's a free-form object
     */","('isFreeFormObject', {'INSTRUCTION': {'covered': 97, 'missed': 23}, 'BRANCH': {'covered': 33, 'missed': 11}, 'LINE': {'covered': 25, 'missed': 1}, 'COMPLEXITY': {'covered': 15, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",341.0,  Check to see if the schema is a free form object.,12.0,"['Check to see if it is a free form object.', 'Check to see if the object is free form.', 'If the schema is a free form object, you should check it.']"
1022,matsim-libs,org/matsim/core/utils/geometry/CoordUtils.java,/matsim/src/main/java/org/matsim/core/utils/geometry/CoordUtils.java,orthogonalProjectionOnLineSegment,331-394,"/**
	 * Calculates the coordinate of the intersection point of the orthogonal projection
	 * of a given point on a line segment with that line segment. The line segment
	 * is given by two points, <code>lineFrom</code> and <code>lineTo</code>. If the
	 * projection point does not lie *on* the line segment (but only somewhere on
	 * the extension of the line segment, i.e. the infinite line), the end point of
	 * the line segment which is closest to the given point is returned.
	 *
	 * <br><br>
	 * The 3D version was adapted from the documentation of 
	 * <a href=""http://www.geometrictools.com/Documentation/DistancePointLine.pdf"">
	 * David Eberly/a>. 
	 *
	 * @param lineFrom The start point of the line segment
	 * @param lineTo The end point of the line segment
	 * @param point The point whose distance to the line segment should be calculated
	 * @return the <code>coordinate</code> of the intersection point of the orthogonal
	 * projection of a given point on a line segment with that line segment
	 *
	 * @author dziemke, jwjoubert
	 */
public static Coord orthogonalProjectionOnLineSegment(final Coord lineFrom, final Coord lineTo, final Coord point){
    if (!lineFrom.hasZ() && !lineTo.hasZ() && !point.hasZ()) {
        double lineDX = lineTo.getX() - lineFrom.getX();
        double lineDY = lineTo.getY() - lineFrom.getY();
        if ((lineDX == 0.0) && (lineDY == 0.0)) {
            return lineFrom;
        }
        double u = ((point.getX() - lineFrom.getX()) * lineDX + (point.getY() - lineFrom.getY()) * lineDY) / (lineDX * lineDX + lineDY * lineDY);
        if (u <= 0) {
            return lineFrom;
        }
        if (u >= 1) {
            return lineTo;
        }
        return new Coord(lineFrom.getX() + u * lineDX, lineFrom.getY() + u * lineDY);
    } else if (lineFrom.hasZ() && lineTo.hasZ() && point.hasZ()) {
        Coord direction = minus(lineTo, lineFrom);
        double t0 = dotProduct(direction, minus(point, lineFrom)) / dotProduct(direction, direction);
        Coord q = plus(lineFrom, scalarMult(t0, direction));
        return q;
    } else {
        if (!onlyOnceWarnGiven) {
            Logger.getLogger(CoordUtils.class).warn(""Mix of 2D / 3D coordinates. Assuming 2D only.\n"" + Gbl.ONLYONCE);
            onlyOnceWarnGiven = true;
        }
        return orthogonalProjectionOnLineSegment(new Coord(lineFrom.getX(), lineFrom.getY()), new Coord(lineTo.getX(), lineTo.getY()), new Coord(point.getX(), point.getY()));
    }
}","public static Coord orthogonalProjectionOnLineSegment(final Coord lineFrom, final Coord lineTo, final Coord point){
    if (!lineFrom.hasZ() && !lineTo.hasZ() && !point.hasZ()) {
        double lineDX = lineTo.getX() - lineFrom.getX();
        double lineDY = lineTo.getY() - lineFrom.getY();
        if ((lineDX == 0.0) && (lineDY == 0.0)) {
            return lineFrom;
        }
        double u = ((point.getX() - lineFrom.getX()) * lineDX + (point.getY() - lineFrom.getY()) * lineDY) / (lineDX * lineDX + lineDY * lineDY);
        if (u <= 0) {
            return lineFrom;
        }
        if (u >= 1) {
            return lineTo;
        }
        return new Coord(lineFrom.getX() + u * lineDX, lineFrom.getY() + u * lineDY);
    } else if (lineFrom.hasZ() && lineTo.hasZ() && point.hasZ()) {
        Coord direction = minus(lineTo, lineFrom);
        double t0 = dotProduct(direction, minus(point, lineFrom)) / dotProduct(direction, direction);
        Coord q = plus(lineFrom, scalarMult(t0, direction));
        return q;
    } else {
        if (!onlyOnceWarnGiven) {
            Logger.getLogger(CoordUtils.class).warn(""Mix of 2D / 3D coordinates. Assuming 2D only.\n"" + Gbl.ONLYONCE);
            onlyOnceWarnGiven = true;
        }
        return orthogonalProjectionOnLineSegment(new Coord(lineFrom.getX(), lineFrom.getY()), new Coord(lineTo.getX(), lineTo.getY()), new Coord(point.getX(), point.getY()));
    }
}","/**
	 * Calculates the coordinate of the intersection point of the orthogonal projection
	 * of a given point on a line segment with that line segment. The line segment
	 * is given by two points, <code>lineFrom</code> and <code>lineTo</code>. If the
	 * projection point does not lie *on* the line segment (but only somewhere on
	 * the extension of the line segment, i.e. the infinite line), the end point of
	 * the line segment which is closest to the given point is returned.
	 *
	 * <br><br>
	 * The 3D version was adapted from the documentation of 
	 * <a href=""http://www.geometrictools.com/Documentation/DistancePointLine.pdf"">
	 * David Eberly/a>. 
	 *
	 * @param lineFrom The start point of the line segment
	 * @param lineTo The end point of the line segment
	 * @param point The point whose distance to the line segment should be calculated
	 * @return the <code>coordinate</code> of the intersection point of the orthogonal
	 * projection of a given point on a line segment with that line segment
	 *
	 * @author dziemke, jwjoubert
	 */","('orthogonalProjectionOnLineSegment', {'INSTRUCTION': {'covered': 114, 'missed': 31}, 'BRANCH': {'covered': 15, 'missed': 7}, 'LINE': {'covered': 16, 'missed': 4}, 'COMPLEXITY': {'covered': 6, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",344.0,  Calculates the coordinate of the intersection point of the orthogonal projection  of a given point on a line segment with that line segment.,24.0,"['The coordinate of the intersection point of a given point on a line segment is calculated.', 'The intersection point of a given point on a line segment is calculated.', 'The coordinate of the intersection point of a given point on a line segment with another is calculated.']"
1023,matsim-libs,org/matsim/core/network/algorithms/NetworkCleaner.java,/matsim/src/main/java/org/matsim/core/network/algorithms/NetworkCleaner.java,findCluster,51-109,"/**
	 * Finds the cluster of nodes of which <code>startNode</code> is part of. The cluster
	 * contains all nodes which can be reached starting at <code>startNode</code>
	 * and from where it is also possible to return again to <code>startNode</code>.
	 *
	 * @param startNode the node to start building the cluster
	 * @param network the network the startNode is part of
	 * @return cluster of nodes of which <code>startNode</code> is part of
	 */
private Map<Id<Node>, Node> findCluster(final Node startNode, final Network network){
    final Map<Node, DoubleFlagRole> nodeRoles = new HashMap<>(network.getNodes().size());
    ArrayList<Node> pendingForward = new ArrayList<>();
    ArrayList<Node> pendingBackward = new ArrayList<>();
    TreeMap<Id<Node>, Node> clusterNodes = new TreeMap<>();
    clusterNodes.put(startNode.getId(), startNode);
    DoubleFlagRole r = getDoubleFlag(startNode, nodeRoles);
    r.forwardFlag = true;
    r.backwardFlag = true;
    pendingForward.add(startNode);
    pendingBackward.add(startNode);
    // step through the network in forward mode
    while (pendingForward.size() > 0) {
        int idx = pendingForward.size() - 1;
        // get the last element to prevent object shifting in the array
        Node currNode = pendingForward.remove(idx);
        for (Link link : currNode.getOutLinks().values()) {
            Node node = link.getToNode();
            r = getDoubleFlag(node, nodeRoles);
            if (!r.forwardFlag) {
                r.forwardFlag = true;
                pendingForward.add(node);
            }
        }
    }
    // now step through the network in backward mode
    while (pendingBackward.size() > 0) {
        int idx = pendingBackward.size() - 1;
        // get the last element to prevent object shifting in the array
        Node currNode = pendingBackward.remove(idx);
        for (Link link : currNode.getInLinks().values()) {
            Node node = link.getFromNode();
            r = getDoubleFlag(node, nodeRoles);
            if (!r.backwardFlag) {
                r.backwardFlag = true;
                pendingBackward.add(node);
                if (r.forwardFlag) {
                    // the node can be reached forward and backward, add it to the cluster
                    clusterNodes.put(node.getId(), node);
                }
            }
        }
    }
    return clusterNodes;
}","private Map<Id<Node>, Node> findCluster(final Node startNode, final Network network){
    final Map<Node, DoubleFlagRole> nodeRoles = new HashMap<>(network.getNodes().size());
    ArrayList<Node> pendingForward = new ArrayList<>();
    ArrayList<Node> pendingBackward = new ArrayList<>();
    TreeMap<Id<Node>, Node> clusterNodes = new TreeMap<>();
    clusterNodes.put(startNode.getId(), startNode);
    DoubleFlagRole r = getDoubleFlag(startNode, nodeRoles);
    r.forwardFlag = true;
    r.backwardFlag = true;
    pendingForward.add(startNode);
    pendingBackward.add(startNode);
    // step through the network in forward mode
    while (pendingForward.size() > 0) {
        int idx = pendingForward.size() - 1;
        // get the last element to prevent object shifting in the array
        Node currNode = pendingForward.remove(idx);
        for (Link link : currNode.getOutLinks().values()) {
            Node node = link.getToNode();
            r = getDoubleFlag(node, nodeRoles);
            if (!r.forwardFlag) {
                r.forwardFlag = true;
                pendingForward.add(node);
            }
        }
    }
    // now step through the network in backward mode
    while (pendingBackward.size() > 0) {
        int idx = pendingBackward.size() - 1;
        // get the last element to prevent object shifting in the array
        Node currNode = pendingBackward.remove(idx);
        for (Link link : currNode.getInLinks().values()) {
            Node node = link.getFromNode();
            r = getDoubleFlag(node, nodeRoles);
            if (!r.backwardFlag) {
                r.backwardFlag = true;
                pendingBackward.add(node);
                if (r.forwardFlag) {
                    // the node can be reached forward and backward, add it to the cluster
                    clusterNodes.put(node.getId(), node);
                }
            }
        }
    }
    return clusterNodes;
}","/**
	 * Finds the cluster of nodes of which <code>startNode</code> is part of. The cluster
	 * contains all nodes which can be reached starting at <code>startNode</code>
	 * and from where it is also possible to return again to <code>startNode</code>.
	 *
	 * @param startNode the node to start building the cluster
	 * @param network the network the startNode is part of
	 * @return cluster of nodes of which <code>startNode</code> is part of
	 */","('findCluster', {'INSTRUCTION': {'covered': 142, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 35, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",344.0,  Finds the cluster of nodes of which <code>startNode</code> is part of.,18.0,"['Finds the cluster of the code>startNode/code> that is part of it.', 'Finds the cluster of the code>startNode/code> that is part of.', 'Finds the cluster of code>startNode/code> which is part of it.']"
1024,cdk,org/openscience/cdk/layout/StructureDiagramGenerator.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/StructureDiagramGenerator.java,lookupRingSystem,1583-1649,"/**
     * Using a fast identity template library, lookup the the ring system and assign coordinates.
     * The method indicates whether a match was found and coordinates were assigned.
     *
     * @param rs       the ring set
     * @param molecule the rest of the compound
     * @param anon     check for anonmised templates
     * @return coordinates were assigned
     */
private boolean lookupRingSystem(IRingSet rs, IAtomContainer molecule, boolean anon){
    if (!useIdentTemplates)
        return false;
    final IChemObjectBuilder bldr = molecule.getBuilder();
    final IAtomContainer ringSystem = bldr.newInstance(IAtomContainer.class);
    for (IAtomContainer container : rs.atomContainers()) ringSystem.add(container);
    final Set<IAtom> ringAtoms = new HashSet<>();
    for (IAtom atom : ringSystem.atoms()) ringAtoms.add(atom);
    final IAtomContainer ringWithStubs = bldr.newInstance(IAtomContainer.class);
    ringWithStubs.add(ringSystem);
    for (IBond bond : molecule.bonds()) {
        IAtom atom1 = bond.getBegin();
        IAtom atom2 = bond.getEnd();
        if (isHydrogen(atom1) || isHydrogen(atom2))
            continue;
        if (ringAtoms.contains(atom1) ^ ringAtoms.contains(atom2)) {
            ringWithStubs.addAtom(atom1);
            ringWithStubs.addAtom(atom2);
            ringWithStubs.addBond(bond);
        }
    }
    final IAtomContainer skeletonStub = clearHydrogenCounts(AtomContainerManipulator.skeleton(ringWithStubs));
    final IAtomContainer skeleton = clearHydrogenCounts(AtomContainerManipulator.skeleton(ringSystem));
    final IAtomContainer anonymous = clearHydrogenCounts(AtomContainerManipulator.anonymise(ringSystem));
    for (IAtomContainer container : Arrays.asList(skeletonStub, skeleton, anonymous)) {
        if (!anon && container == anonymous)
            continue;
        if (identityLibrary.assignLayout(container)) {
            for (int i = 0; i < ringSystem.getAtomCount(); i++) {
                IAtom atom = ringSystem.getAtom(i);
                atom.setPoint2d(container.getAtom(i).getPoint2d());
                atom.setFlag(CDKConstants.ISPLACED, true);
            }
            return true;
        }
    }
    return false;
}","private boolean lookupRingSystem(IRingSet rs, IAtomContainer molecule, boolean anon){
    if (!useIdentTemplates)
        return false;
    final IChemObjectBuilder bldr = molecule.getBuilder();
    final IAtomContainer ringSystem = bldr.newInstance(IAtomContainer.class);
    for (IAtomContainer container : rs.atomContainers()) ringSystem.add(container);
    final Set<IAtom> ringAtoms = new HashSet<>();
    for (IAtom atom : ringSystem.atoms()) ringAtoms.add(atom);
    final IAtomContainer ringWithStubs = bldr.newInstance(IAtomContainer.class);
    ringWithStubs.add(ringSystem);
    for (IBond bond : molecule.bonds()) {
        IAtom atom1 = bond.getBegin();
        IAtom atom2 = bond.getEnd();
        if (isHydrogen(atom1) || isHydrogen(atom2))
            continue;
        if (ringAtoms.contains(atom1) ^ ringAtoms.contains(atom2)) {
            ringWithStubs.addAtom(atom1);
            ringWithStubs.addAtom(atom2);
            ringWithStubs.addBond(bond);
        }
    }
    final IAtomContainer skeletonStub = clearHydrogenCounts(AtomContainerManipulator.skeleton(ringWithStubs));
    final IAtomContainer skeleton = clearHydrogenCounts(AtomContainerManipulator.skeleton(ringSystem));
    final IAtomContainer anonymous = clearHydrogenCounts(AtomContainerManipulator.anonymise(ringSystem));
    for (IAtomContainer container : Arrays.asList(skeletonStub, skeleton, anonymous)) {
        if (!anon && container == anonymous)
            continue;
        if (identityLibrary.assignLayout(container)) {
            for (int i = 0; i < ringSystem.getAtomCount(); i++) {
                IAtom atom = ringSystem.getAtom(i);
                atom.setPoint2d(container.getAtom(i).getPoint2d());
                atom.setFlag(CDKConstants.ISPLACED, true);
            }
            return true;
        }
    }
    return false;
}","/**
     * Using a fast identity template library, lookup the the ring system and assign coordinates.
     * The method indicates whether a match was found and coordinates were assigned.
     *
     * @param rs       the ring set
     * @param molecule the rest of the compound
     * @param anon     check for anonmised templates
     * @return coordinates were assigned
     */","('lookupRingSystem', {'INSTRUCTION': {'covered': 175, 'missed': 1}, 'BRANCH': {'covered': 22, 'missed': 2}, 'LINE': {'covered': 32, 'missed': 1}, 'COMPLEXITY': {'covered': 11, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",345.0,"  Using a fast identity template library, lookup the the ring system and assign coordinates.",16.0,"['The ring system and coordinates can be assigned using a fast identity template library.', 'You can assign coordinates using a fast identity template library.', 'The ring system and coordinates can be assigned using a fast identity library.']"
1025,jackson-databind,com/fasterxml/jackson/databind/util/NameTransformer.java,/src/main/java/com/fasterxml/jackson/databind/util/NameTransformer.java,simpleTransformer,35-93,"/**
     * Factory method for constructing a simple transformer based on
     * prefix and/or suffix.
     */
public static NameTransformer simpleTransformer(final String prefix, final String suffix){
    boolean hasPrefix = (prefix != null) && !prefix.isEmpty();
    boolean hasSuffix = (suffix != null) && !suffix.isEmpty();
    if (hasPrefix) {
        if (hasSuffix) {
            return new NameTransformer() {

                @Override
                public String transform(String name) {
                    return prefix + name + suffix;
                }

                @Override
                public String reverse(String transformed) {
                    if (transformed.startsWith(prefix)) {
                        String str = transformed.substring(prefix.length());
                        if (str.endsWith(suffix)) {
                            return str.substring(0, str.length() - suffix.length());
                        }
                    }
                    return null;
                }

                @Override
                public String toString() {
                    return ""[PreAndSuffixTransformer('"" + prefix + ""','"" + suffix + ""')]"";
                }
            };
        }
        return new NameTransformer() {

            @Override
            public String transform(String name) {
                return prefix + name;
            }

            @Override
            public String reverse(String transformed) {
                if (transformed.startsWith(prefix)) {
                    return transformed.substring(prefix.length());
                }
                return null;
            }

            @Override
            public String toString() {
                return ""[PrefixTransformer('"" + prefix + ""')]"";
            }
        };
    }
    if (hasSuffix) {
        return new NameTransformer() {

            @Override
            public String transform(String name) {
                return name + suffix;
            }

            @Override
            public String reverse(String transformed) {
                if (transformed.endsWith(suffix)) {
                    return transformed.substring(0, transformed.length() - suffix.length());
                }
                return null;
            }

            @Override
            public String toString() {
                return ""[SuffixTransformer('"" + suffix + ""')]"";
            }
        };
    }
    return NOP;
}","public static NameTransformer simpleTransformer(final String prefix, final String suffix){
    boolean hasPrefix = (prefix != null) && !prefix.isEmpty();
    boolean hasSuffix = (suffix != null) && !suffix.isEmpty();
    if (hasPrefix) {
        if (hasSuffix) {
            return new NameTransformer() {

                @Override
                public String transform(String name) {
                    return prefix + name + suffix;
                }

                @Override
                public String reverse(String transformed) {
                    if (transformed.startsWith(prefix)) {
                        String str = transformed.substring(prefix.length());
                        if (str.endsWith(suffix)) {
                            return str.substring(0, str.length() - suffix.length());
                        }
                    }
                    return null;
                }

                @Override
                public String toString() {
                    return ""[PreAndSuffixTransformer('"" + prefix + ""','"" + suffix + ""')]"";
                }
            };
        }
        return new NameTransformer() {

            @Override
            public String transform(String name) {
                return prefix + name;
            }

            @Override
            public String reverse(String transformed) {
                if (transformed.startsWith(prefix)) {
                    return transformed.substring(prefix.length());
                }
                return null;
            }

            @Override
            public String toString() {
                return ""[PrefixTransformer('"" + prefix + ""')]"";
            }
        };
    }
    if (hasSuffix) {
        return new NameTransformer() {

            @Override
            public String transform(String name) {
                return name + suffix;
            }

            @Override
            public String reverse(String transformed) {
                if (transformed.endsWith(suffix)) {
                    return transformed.substring(0, transformed.length() - suffix.length());
                }
                return null;
            }

            @Override
            public String toString() {
                return ""[SuffixTransformer('"" + suffix + ""')]"";
            }
        };
    }
    return NOP;
}","/**
     * Factory method for constructing a simple transformer based on
     * prefix and/or suffix.
     */","('simpleTransformer', {'INSTRUCTION': {'covered': 42, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 9, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",346.0,  Factory method for constructing a simple transformer based on  prefix and/or suffix.,13.0,"['A simple transformer can be constructed using the factory method.', 'A simple transformer is constructed using the factory method.', 'A factory method for constructing a transformer.']"
1026,matsim-libs,org/matsim/core/network/algorithms/MultimodalNetworkCleaner.java,/matsim/src/main/java/org/matsim/core/network/algorithms/MultimodalNetworkCleaner.java,findCluster,168-224,"/**
	 * Finds the cluster of links <pre>startLink</pre> is part of. The cluster
	 * contains all links which can be reached starting at <code>startLink</code>
	 * and from where it is also possible to return again to <code>startLink</code>.
	 *
	 * @param startLink the link to start building the cluster
	 * @param modes the set of modes that are allowed to
	 * @return cluster of links <pre>startLink</pre> is part of
	 */
private Map<Id<Link>, Link> findCluster(final Link startLink, final Set<String> modes){
    final Map<Id<Link>, DoubleFlagRole> linkRoles = new HashMap<>(this.network.getLinks().size());
    ArrayList<Node> pendingForward = new ArrayList<>();
    ArrayList<Node> pendingBackward = new ArrayList<>();
    TreeMap<Id<Link>, Link> clusterLinks = new TreeMap<>();
    pendingForward.add(startLink.getToNode());
    pendingBackward.add(startLink.getFromNode());
    while (pendingForward.size() > 0) {
        int idx = pendingForward.size() - 1;
        Node currNode = pendingForward.remove(idx);
        for (Link link : currNode.getOutLinks().values()) {
            if (intersectingSets(modes, link.getAllowedModes())) {
                DoubleFlagRole r = getDoubleFlag(link, linkRoles);
                if (!r.forwardFlag) {
                    r.forwardFlag = true;
                    pendingForward.add(link.getToNode());
                }
            }
        }
    }
    while (pendingBackward.size() > 0) {
        int idx = pendingBackward.size() - 1;
        Node currNode = pendingBackward.remove(idx);
        for (Link link : currNode.getInLinks().values()) {
            if (intersectingSets(modes, link.getAllowedModes())) {
                DoubleFlagRole r = getDoubleFlag(link, linkRoles);
                if (!r.backwardFlag) {
                    r.backwardFlag = true;
                    pendingBackward.add(link.getFromNode());
                    if (r.forwardFlag) {
                        clusterLinks.put(link.getId(), link);
                    }
                }
            }
        }
    }
    return clusterLinks;
}","private Map<Id<Link>, Link> findCluster(final Link startLink, final Set<String> modes){
    final Map<Id<Link>, DoubleFlagRole> linkRoles = new HashMap<>(this.network.getLinks().size());
    ArrayList<Node> pendingForward = new ArrayList<>();
    ArrayList<Node> pendingBackward = new ArrayList<>();
    TreeMap<Id<Link>, Link> clusterLinks = new TreeMap<>();
    pendingForward.add(startLink.getToNode());
    pendingBackward.add(startLink.getFromNode());
    while (pendingForward.size() > 0) {
        int idx = pendingForward.size() - 1;
        Node currNode = pendingForward.remove(idx);
        for (Link link : currNode.getOutLinks().values()) {
            if (intersectingSets(modes, link.getAllowedModes())) {
                DoubleFlagRole r = getDoubleFlag(link, linkRoles);
                if (!r.forwardFlag) {
                    r.forwardFlag = true;
                    pendingForward.add(link.getToNode());
                }
            }
        }
    }
    while (pendingBackward.size() > 0) {
        int idx = pendingBackward.size() - 1;
        Node currNode = pendingBackward.remove(idx);
        for (Link link : currNode.getInLinks().values()) {
            if (intersectingSets(modes, link.getAllowedModes())) {
                DoubleFlagRole r = getDoubleFlag(link, linkRoles);
                if (!r.backwardFlag) {
                    r.backwardFlag = true;
                    pendingBackward.add(link.getFromNode());
                    if (r.forwardFlag) {
                        clusterLinks.put(link.getId(), link);
                    }
                }
            }
        }
    }
    return clusterLinks;
}","/**
	 * Finds the cluster of links <pre>startLink</pre> is part of. The cluster
	 * contains all links which can be reached starting at <code>startLink</code>
	 * and from where it is also possible to return again to <code>startLink</code>.
	 *
	 * @param startLink the link to start building the cluster
	 * @param modes the set of modes that are allowed to
	 * @return cluster of links <pre>startLink</pre> is part of
	 */","('findCluster', {'INSTRUCTION': {'covered': 137, 'missed': 0}, 'BRANCH': {'covered': 18, 'missed': 0}, 'LINE': {'covered': 31, 'missed': 0}, 'COMPLEXITY': {'covered': 10, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",347.0,  Finds the cluster of links <pre>startLink</pre> is part of.,16.0,"['The cluster of links is part of.', 'The cluster of links is found.', 'The cluster of links is part of it.']"
1027,cdk,org/openscience/cdk/io/XYZWriter.java,/storage/io/src/main/java/org/openscience/cdk/io/XYZWriter.java,writeMolecule,136-185,"/**
    * writes a single frame in XYZ format to the Writer.
    * @param mol the Molecule to write
    */
public void writeMolecule(IAtomContainer mol) throws IOException{
    String st = """";
    boolean writecharge = true;
    try {
        String s1 = """" + mol.getAtomCount();
        writer.write(s1, 0, s1.length());
        writer.write('\n');
        String s2 = mol.getTitle();
        if (s2 != null) {
            writer.write(s2, 0, s2.length());
        }
        writer.write('\n');
        Iterator<IAtom> atoms = mol.atoms().iterator();
        while (atoms.hasNext()) {
            IAtom a = atoms.next();
            st = a.getSymbol();
            Point3d p3 = a.getPoint3d();
            if (p3 != null) {
                st = st + ""\t"" + (p3.x < 0 ? """" : "" "") + fsb.format(p3.x) + ""\t"" + (p3.y < 0 ? """" : "" "") + fsb.format(p3.y) + ""\t"" + (p3.z < 0 ? """" : "" "") + fsb.format(p3.z);
            } else {
                st = st + ""\t "" + fsb.format(0.0) + ""\t "" + fsb.format(0.0) + ""\t "" + fsb.format(0.0);
            }
            if (writecharge) {
                double ct = a.getCharge() == CDKConstants.UNSET ? 0.0 : a.getCharge();
                st = st + ""\t"" + ct;
            }
            writer.write(st, 0, st.length());
            writer.write('\n');
        }
    } catch (IOException e) {
        logger.error(""Error while writing file: "", e.getMessage());
        logger.debug(e);
    }
}","public void writeMolecule(IAtomContainer mol) throws IOException{
    String st = """";
    boolean writecharge = true;
    try {
        String s1 = """" + mol.getAtomCount();
        writer.write(s1, 0, s1.length());
        writer.write('\n');
        String s2 = mol.getTitle();
        if (s2 != null) {
            writer.write(s2, 0, s2.length());
        }
        writer.write('\n');
        Iterator<IAtom> atoms = mol.atoms().iterator();
        while (atoms.hasNext()) {
            IAtom a = atoms.next();
            st = a.getSymbol();
            Point3d p3 = a.getPoint3d();
            if (p3 != null) {
                st = st + ""\t"" + (p3.x < 0 ? """" : "" "") + fsb.format(p3.x) + ""\t"" + (p3.y < 0 ? """" : "" "") + fsb.format(p3.y) + ""\t"" + (p3.z < 0 ? """" : "" "") + fsb.format(p3.z);
            } else {
                st = st + ""\t "" + fsb.format(0.0) + ""\t "" + fsb.format(0.0) + ""\t "" + fsb.format(0.0);
            }
            if (writecharge) {
                double ct = a.getCharge() == CDKConstants.UNSET ? 0.0 : a.getCharge();
                st = st + ""\t"" + ct;
            }
            writer.write(st, 0, st.length());
            writer.write('\n');
        }
    } catch (IOException e) {
        logger.error(""Error while writing file: "", e.getMessage());
        logger.debug(e);
    }
}","/**
    * writes a single frame in XYZ format to the Writer.
    * @param mol the Molecule to write
    */","('writeMolecule', {'INSTRUCTION': {'covered': 172, 'missed': 26}, 'BRANCH': {'covered': 12, 'missed': 4}, 'LINE': {'covered': 25, 'missed': 4}, 'COMPLEXITY': {'covered': 5, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",347.0,  writes a single frame in XYZ format to the Writer.,11.0,"['A single frame is written to the writer.', 'The writer writes a single frame.', 'A single frame is written to the Writer.']"
1028,cdk,org/openscience/cdk/geometry/surface/NumericalSurface.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/geometry/surface/NumericalSurface.java,init,115-170,"/**
     * Initialize the surface, generating the points on the accessible surface
     * area of each atom as well as calculating the surface area of each atom.
     */
private void init(){
    for (IAtom atom : atoms) {
        if (atom.getPoint3d() == null)
            throw new IllegalArgumentException(""One or more atoms had no 3D coordinate set"");
    }
    Point3d cp = new Point3d(0, 0, 0);
    double maxRadius = 0;
    for (IAtom atom : atoms) {
        double vdwr = PeriodicTable.getVdwRadius(atom.getSymbol());
        if (vdwr + solventRadius > maxRadius)
            maxRadius = PeriodicTable.getVdwRadius(atom.getSymbol()) + solventRadius;
        cp.x = cp.x + atom.getPoint3d().x;
        cp.y = cp.y + atom.getPoint3d().y;
        cp.z = cp.z + atom.getPoint3d().z;
    }
    cp.x = cp.x / atoms.length;
    cp.y = cp.y / atoms.length;
    cp.z = cp.z / atoms.length;
    Tessellate tess = new Tessellate(""ico"", tesslevel);
    tess.doTessellate();
    logger.info(""Got tesselation, number of triangles = "" + tess.getNumberOfTriangles());
    NeighborList nbrlist = new NeighborList(atoms, maxRadius + solventRadius);
    logger.info(""Got neighbor list"");
    this.surfPoints = (List<Point3d>[]) new List[atoms.length];
    this.areas = new double[atoms.length];
    this.volumes = new double[atoms.length];
    for (int i = 0; i < atoms.length; i++) {
        int pointDensity = tess.getNumberOfTriangles() * 3;
        Point3d[][] points = atomicSurfacePoints(nbrlist, i, atoms[i], tess);
        translatePoints(i, points, pointDensity, atoms[i], cp);
    }
    logger.info(""Obtained points, areas and volumes"");
}","private void init(){
    for (IAtom atom : atoms) {
        if (atom.getPoint3d() == null)
            throw new IllegalArgumentException(""One or more atoms had no 3D coordinate set"");
    }
    Point3d cp = new Point3d(0, 0, 0);
    double maxRadius = 0;
    for (IAtom atom : atoms) {
        double vdwr = PeriodicTable.getVdwRadius(atom.getSymbol());
        if (vdwr + solventRadius > maxRadius)
            maxRadius = PeriodicTable.getVdwRadius(atom.getSymbol()) + solventRadius;
        cp.x = cp.x + atom.getPoint3d().x;
        cp.y = cp.y + atom.getPoint3d().y;
        cp.z = cp.z + atom.getPoint3d().z;
    }
    cp.x = cp.x / atoms.length;
    cp.y = cp.y / atoms.length;
    cp.z = cp.z / atoms.length;
    Tessellate tess = new Tessellate(""ico"", tesslevel);
    tess.doTessellate();
    logger.info(""Got tesselation, number of triangles = "" + tess.getNumberOfTriangles());
    NeighborList nbrlist = new NeighborList(atoms, maxRadius + solventRadius);
    logger.info(""Got neighbor list"");
    this.surfPoints = (List<Point3d>[]) new List[atoms.length];
    this.areas = new double[atoms.length];
    this.volumes = new double[atoms.length];
    for (int i = 0; i < atoms.length; i++) {
        int pointDensity = tess.getNumberOfTriangles() * 3;
        Point3d[][] points = atomicSurfacePoints(nbrlist, i, atoms[i], tess);
        translatePoints(i, points, pointDensity, atoms[i], cp);
    }
    logger.info(""Obtained points, areas and volumes"");
}","/**
     * Initialize the surface, generating the points on the accessible surface
     * area of each atom as well as calculating the surface area of each atom.
     */","('init', {'INSTRUCTION': {'covered': 206, 'missed': 5}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 28, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",348.0,"  Initialize the surface, generating the points on the accessible surface  area of each atom as well as calculating the surface area of each atom.",26.0,"['The surface area of each atom can be calculated by generating points on the accessible surface area of each atom.', 'The surface area of each atom can be calculated by generating points on the accessible surface area.', 'The surface area of each atom can be calculated by generating points on the accessible surface area of the atom.']"
1029,jacoco-plugin,hudson/plugins/jacoco/JacocoBuildAction.java,/src/main/java/hudson/plugins/jacoco/JacocoBuildAction.java,loadRatios,326-363,"/**
	 * Extracts top-level coverage information from the JaCoCo report document.
	 */
private static Map<Type, Coverage> loadRatios(JacocoReportDir layout, String[] includes, String... excludes) throws IOException{
    Map<CoverageElement.Type, Coverage> ratios = new LinkedHashMap<>();
    ExecutionFileLoader efl = layout.parse(includes, excludes);
    IBundleCoverage bundleCoverage = efl.getBundleCoverage();
    if (bundleCoverage == null) {
        return null;
    }
    Coverage ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getClassCounter().getMissedCount(), bundleCoverage.getClassCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.CLASS, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getBranchCounter().getMissedCount(), bundleCoverage.getBranchCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.BRANCH, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getInstructionCounter().getMissedCount(), bundleCoverage.getInstructionCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.INSTRUCTION, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getMethodCounter().getMissedCount(), bundleCoverage.getMethodCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.METHOD, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getComplexityCounter().getMissedCount(), bundleCoverage.getComplexityCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.COMPLEXITY, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getLineCounter().getMissedCount(), bundleCoverage.getLineCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.LINE, ratio);
    return ratios;
}","private static Map<Type, Coverage> loadRatios(JacocoReportDir layout, String[] includes, String... excludes) throws IOException{
    Map<CoverageElement.Type, Coverage> ratios = new LinkedHashMap<>();
    ExecutionFileLoader efl = layout.parse(includes, excludes);
    IBundleCoverage bundleCoverage = efl.getBundleCoverage();
    if (bundleCoverage == null) {
        return null;
    }
    Coverage ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getClassCounter().getMissedCount(), bundleCoverage.getClassCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.CLASS, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getBranchCounter().getMissedCount(), bundleCoverage.getBranchCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.BRANCH, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getInstructionCounter().getMissedCount(), bundleCoverage.getInstructionCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.INSTRUCTION, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getMethodCounter().getMissedCount(), bundleCoverage.getMethodCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.METHOD, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getComplexityCounter().getMissedCount(), bundleCoverage.getComplexityCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.COMPLEXITY, ratio);
    ratio = new Coverage();
    ratio.accumulatePP(bundleCoverage.getLineCounter().getMissedCount(), bundleCoverage.getLineCounter().getCoveredCount());
    ratios.put(CoverageElement.Type.LINE, ratio);
    return ratios;
}","/**
	 * Extracts top-level coverage information from the JaCoCo report document.
	 */","('loadRatios', {'INSTRUCTION': {'covered': 120, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",349.0,  Extracts top-level coverage information from the JaCoCo report document.,10.0,"['The report document contains top-level coverage information.', 'The report document has top-level coverage information.', 'Top-level coverage information from the report document is extracts.']"
1030,cdk,org/openscience/cdk/aromaticity/DoubleBondAcceptingAromaticityDetector.java,/legacy/src/main/java/org/openscience/cdk/aromaticity/DoubleBondAcceptingAromaticityDetector.java,isHueckelValid,124-170,"/**
     * Tests if the electron count matches the H&uuml;ckel 4n+2 rule.
     */
private static boolean isHueckelValid(IAtomContainer singleRing) throws CDKException{
    int electronCount = 0;
    for (IAtom ringAtom : singleRing.atoms()) {
        if (ringAtom.getHybridization() != CDKConstants.UNSET && (ringAtom.getHybridization() == Hybridization.SP2) || ringAtom.getHybridization() == Hybridization.PLANAR3) {
            // for example, a carbon
            // note: the double bond is in the ring, that has been tested earlier
            // FIXME: this does assume bond orders to be resolved too, when detecting
            // sprouting double bonds
            if (""N.planar3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""N.minus.planar3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""N.amide"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""S.2"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""S.planar3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""C.minus.planar"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""O.planar3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""N.sp2.3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 1;
            } else {
                if (factory == null) {
                    factory = AtomTypeFactory.getInstance(""org/openscience/cdk/dict/data/cdk-atom-types.owl"", ringAtom.getBuilder());
                }
                IAtomType type = factory.getAtomType(ringAtom.getAtomTypeName());
                Object property = type.getProperty(CDKConstants.PI_BOND_COUNT);
                if (property != null && property instanceof Integer) {
                    electronCount += ((Integer) property).intValue();
                }
            }
        } else if (ringAtom.getHybridization() != null && ringAtom.getHybridization() == Hybridization.SP3 && getLonePairCount(ringAtom) > 0) {
            // for example, a nitrogen or oxygen
            electronCount += 2;
        }
    }
    return (electronCount % 4 == 2) && (electronCount > 2);
}","private static boolean isHueckelValid(IAtomContainer singleRing) throws CDKException{
    int electronCount = 0;
    for (IAtom ringAtom : singleRing.atoms()) {
        if (ringAtom.getHybridization() != CDKConstants.UNSET && (ringAtom.getHybridization() == Hybridization.SP2) || ringAtom.getHybridization() == Hybridization.PLANAR3) {
            // for example, a carbon
            // note: the double bond is in the ring, that has been tested earlier
            // FIXME: this does assume bond orders to be resolved too, when detecting
            // sprouting double bonds
            if (""N.planar3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""N.minus.planar3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""N.amide"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""S.2"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""S.planar3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""C.minus.planar"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""O.planar3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 2;
            } else if (""N.sp2.3"".equals(ringAtom.getAtomTypeName())) {
                electronCount += 1;
            } else {
                if (factory == null) {
                    factory = AtomTypeFactory.getInstance(""org/openscience/cdk/dict/data/cdk-atom-types.owl"", ringAtom.getBuilder());
                }
                IAtomType type = factory.getAtomType(ringAtom.getAtomTypeName());
                Object property = type.getProperty(CDKConstants.PI_BOND_COUNT);
                if (property != null && property instanceof Integer) {
                    electronCount += ((Integer) property).intValue();
                }
            }
        } else if (ringAtom.getHybridization() != null && ringAtom.getHybridization() == Hybridization.SP3 && getLonePairCount(ringAtom) > 0) {
            // for example, a nitrogen or oxygen
            electronCount += 2;
        }
    }
    return (electronCount % 4 == 2) && (electronCount > 2);
}","/**
     * Tests if the electron count matches the H&uuml;ckel 4n+2 rule.
     */","('isHueckelValid', {'INSTRUCTION': {'covered': 118, 'missed': 15}, 'BRANCH': {'covered': 27, 'missed': 13}, 'LINE': {'covered': 28, 'missed': 5}, 'COMPLEXITY': {'covered': 11, 'missed': 10}, 'METHOD': {'covered': 1, 'missed': 0}})",351.0,Tests if the electron count matches the H&uuml;ckel 4n+2 rule.,15.0,"['The H&uuml;ckel 4n+2 rule requires tests if the electron count matches it.', 'The H&uuml;ckel 4n+2 rule requires tests if the electron count matches.', 'If the electron count matches the rule.']"
1031,cdk,org/openscience/cdk/isomorphism/StereoMatch.java,/base/isomorphism/src/main/java/org/openscience/cdk/isomorphism/StereoMatch.java,checkGeometric,222-280,"/**
     * Verify the geometric stereochemistry (cis/trans) of the double bond
     * {@code u1=u2} is preserved in the target when the {@code mapping} is
     * used.
     *
     * @param u1      one index of the double bond
     * @param u2      other index of the double bond
     * @param mapping mapping of vertices
     * @return the geometric configuration is preserved
     */
private boolean checkGeometric(int u1, int u2, int[] mapping){
    int v1 = mapping[u1];
    int v2 = mapping[u2];
    if (targetTypes[v1] != Type.Geometric || targetTypes[v2] != Type.Geometric)
        return false;
    IDoubleBondStereochemistry queryElement = (IDoubleBondStereochemistry) queryElements[u1];
    IDoubleBondStereochemistry targetElement = (IDoubleBondStereochemistry) targetElements[v1];
    if (!targetElement.getStereoBond().contains(target.getAtom(v1)) || !targetElement.getStereoBond().contains(target.getAtom(v2)))
        return false;
    boolean swap = false;
    if (!targetElement.getStereoBond().getBegin().equals(target.getAtom(v1))) {
        int tmp = v1;
        v1 = v2;
        v2 = tmp;
        swap = true;
    }
    IBond[] queryBonds = queryElement.getBonds();
    IBond[] targetBonds = targetElement.getBonds();
    int p = parity(queryElement.getStereo());
    int q = parity(targetElement.getStereo());
    int uLeft = queryMap.get(queryBonds[0].getOther(query.getAtom(u1)));
    int uRight = queryMap.get(queryBonds[1].getOther(query.getAtom(u2)));
    int vLeft = targetMap.get(targetBonds[0].getOther(target.getAtom(v1)));
    int vRight = targetMap.get(targetBonds[1].getOther(target.getAtom(v2)));
    if (swap) {
        int tmp = vLeft;
        vLeft = vRight;
        vRight = tmp;
    }
    if (mapping[uLeft] != vLeft)
        p *= -1;
    if (mapping[uRight] != vRight)
        p *= -1;
    return p == q;
}","private boolean checkGeometric(int u1, int u2, int[] mapping){
    int v1 = mapping[u1];
    int v2 = mapping[u2];
    if (targetTypes[v1] != Type.Geometric || targetTypes[v2] != Type.Geometric)
        return false;
    IDoubleBondStereochemistry queryElement = (IDoubleBondStereochemistry) queryElements[u1];
    IDoubleBondStereochemistry targetElement = (IDoubleBondStereochemistry) targetElements[v1];
    if (!targetElement.getStereoBond().contains(target.getAtom(v1)) || !targetElement.getStereoBond().contains(target.getAtom(v2)))
        return false;
    boolean swap = false;
    if (!targetElement.getStereoBond().getBegin().equals(target.getAtom(v1))) {
        int tmp = v1;
        v1 = v2;
        v2 = tmp;
        swap = true;
    }
    IBond[] queryBonds = queryElement.getBonds();
    IBond[] targetBonds = targetElement.getBonds();
    int p = parity(queryElement.getStereo());
    int q = parity(targetElement.getStereo());
    int uLeft = queryMap.get(queryBonds[0].getOther(query.getAtom(u1)));
    int uRight = queryMap.get(queryBonds[1].getOther(query.getAtom(u2)));
    int vLeft = targetMap.get(targetBonds[0].getOther(target.getAtom(v1)));
    int vRight = targetMap.get(targetBonds[1].getOther(target.getAtom(v2)));
    if (swap) {
        int tmp = vLeft;
        vLeft = vRight;
        vRight = tmp;
    }
    if (mapping[uLeft] != vLeft)
        p *= -1;
    if (mapping[uRight] != vRight)
        p *= -1;
    return p == q;
}","/**
     * Verify the geometric stereochemistry (cis/trans) of the double bond
     * {@code u1=u2} is preserved in the target when the {@code mapping} is
     * used.
     *
     * @param u1      one index of the double bond
     * @param u2      other index of the double bond
     * @param mapping mapping of vertices
     * @return the geometric configuration is preserved
     */","('checkGeometric', {'INSTRUCTION': {'covered': 150, 'missed': 26}, 'BRANCH': {'covered': 10, 'missed': 8}, 'LINE': {'covered': 21, 'missed': 7}, 'COMPLEXITY': {'covered': 2, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",354.0,Verify the geometric stereochemistry (cis/trans) of the double bond  {@code u1=u2} is preserved in the target when the {@code mapping} is  used.,31.0,"['When the @code mapping is used, make sure the geometric stereochemistry of the double bond @code U1 is preserved in the target.', 'When the @code mapping is used, make sure the geometric stereochemistry of the double bond @codeu1 is preserved in the target.', 'When the @code mapping is used, make sure the geometric stereochemistry of the double bond @code U1 is preserved.']"
1032,cdk,org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomTetrahedralLigandPlacer3D.java,calculate3DCoordinates1,370-436,"/**
     *  Calculate new point(s) X in a B-A system to form B-A-X. Use C as reference
     *  for * staggering about the B-A bond (1a) 1 ligand(B) of refAtom (A) which
     *  itself has a ligand (C) (i) 1 points required; vector along AB vector (ii)
     *  2 points: 2 vectors in ABC plane, staggered and eclipsed wrt C (iii) 3
     *  points: 1 staggered wrt C, the others +- gauche wrt C If C is null, a
     *  random non-colinear C is generated
     *
     *@param  aPoint   to which substituents are added
     *@param  nwanted  number of points to calculate (1-3)
     *@param  length   A-X length
     *@param  angle    B-A-X angle
     *@param  bPoint   Description of the Parameter
     *@param  cPoint   Description of the Parameter
     *@return          Point3d[] nwanted points (or zero if failed)
     */
public Point3d[] calculate3DCoordinates1(Point3d aPoint, Point3d bPoint, Point3d cPoint, int nwanted, double length, double angle){
    Point3d[] points = new Point3d[nwanted];
    Vector3d ba = new Vector3d(aPoint);
    ba.sub(bPoint);
    ba.normalize();
    if (cPoint == null) {
        Vector3d cVector = getNonColinearVector(ba);
        cPoint = new Point3d(cVector);
    }
    Vector3d cb = new Vector3d(bPoint);
    cb.sub(cPoint);
    cb.normalize();
    double cbdotba = cb.dot(ba);
    if (cbdotba > 0.999999) {
        Vector3d cVector = getNonColinearVector(ba);
        cPoint = new Point3d(cVector);
        cb = new Vector3d(bPoint);
        cb.sub(cPoint);
    }
    Vector3d cbxba = new Vector3d();
    cbxba.cross(cb, ba);
    cbxba.normalize();
    Vector3d ax = new Vector3d();
    ax.cross(cbxba, ba);
    ax.normalize();
    double drot = Math.PI * 2.0 / (double) nwanted;
    for (int i = 0; i < nwanted; i++) {
        double rot = (double) i * drot;
        points[i] = new Point3d(aPoint);
        Vector3d vx = new Vector3d(ba);
        vx.scale(-Math.cos(angle) * length);
        Vector3d vy = new Vector3d(ax);
        vy.scale(Math.cos(rot) * length);
        Vector3d vz = new Vector3d(cbxba);
        vz.scale(Math.sin(rot) * length);
        points[i].add(vx);
        points[i].add(vy);
        points[i].add(vz);
    }
    return points;
}","public Point3d[] calculate3DCoordinates1(Point3d aPoint, Point3d bPoint, Point3d cPoint, int nwanted, double length, double angle){
    Point3d[] points = new Point3d[nwanted];
    Vector3d ba = new Vector3d(aPoint);
    ba.sub(bPoint);
    ba.normalize();
    if (cPoint == null) {
        Vector3d cVector = getNonColinearVector(ba);
        cPoint = new Point3d(cVector);
    }
    Vector3d cb = new Vector3d(bPoint);
    cb.sub(cPoint);
    cb.normalize();
    double cbdotba = cb.dot(ba);
    if (cbdotba > 0.999999) {
        Vector3d cVector = getNonColinearVector(ba);
        cPoint = new Point3d(cVector);
        cb = new Vector3d(bPoint);
        cb.sub(cPoint);
    }
    Vector3d cbxba = new Vector3d();
    cbxba.cross(cb, ba);
    cbxba.normalize();
    Vector3d ax = new Vector3d();
    ax.cross(cbxba, ba);
    ax.normalize();
    double drot = Math.PI * 2.0 / (double) nwanted;
    for (int i = 0; i < nwanted; i++) {
        double rot = (double) i * drot;
        points[i] = new Point3d(aPoint);
        Vector3d vx = new Vector3d(ba);
        vx.scale(-Math.cos(angle) * length);
        Vector3d vy = new Vector3d(ax);
        vy.scale(Math.cos(rot) * length);
        Vector3d vz = new Vector3d(cbxba);
        vz.scale(Math.sin(rot) * length);
        points[i].add(vx);
        points[i].add(vy);
        points[i].add(vz);
    }
    return points;
}","/**
     *  Calculate new point(s) X in a B-A system to form B-A-X. Use C as reference
     *  for * staggering about the B-A bond (1a) 1 ligand(B) of refAtom (A) which
     *  itself has a ligand (C) (i) 1 points required; vector along AB vector (ii)
     *  2 points: 2 vectors in ABC plane, staggered and eclipsed wrt C (iii) 3
     *  points: 1 staggered wrt C, the others +- gauche wrt C If C is null, a
     *  random non-colinear C is generated
     *
     *@param  aPoint   to which substituents are added
     *@param  nwanted  number of points to calculate (1-3)
     *@param  length   A-X length
     *@param  angle    B-A-X angle
     *@param  bPoint   Description of the Parameter
     *@param  cPoint   Description of the Parameter
     *@return          Point3d[] nwanted points (or zero if failed)
     */","('calculate3DCoordinates1', {'INSTRUCTION': {'covered': 137, 'missed': 17}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 32, 'missed': 4}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",354.0,  Calculate new point(s) X in a B-A system to form B-A-X.,15.0,"['B-A-X is formed by calculating new point(s) X in a B-A system.', 'To form B-A-X, calculate new point(s) X in a B-A system.', 'To form B-A-X, you have to calculate new point(s) X.']"
1033,cdk,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,parseMobileHydrogens,344-408,"/**
     * Parses mobile H group(s) in an InChI String.
     * <p>
     * Multiple InChI sequences of mobile hydrogens are joined into a single sequence (list),
     * see step 1 of algorithm in paper.
     * <br>
     * Mobile H group has syntax (H[n][-[m]],a1,a2[,a3[,a4...]])
     * Brackets [ ] surround optional terms.
     * <ul>
     *  <li>Term H[n] stands for 1 or, if the number n (n>1) is present, n mobile hydrogen atoms.</li>
     *  <li>Term [-[m]], if present, stands for 1 or, if the number m (m>1) is present, m mobile negative charges.</li>
     *  <li>a1,a2[,a3[,a4...]] are canonical numbers of atoms in the mobile H group.</li>
     *  <li>no two mobile H groups may have an atom (a canonical number) in common.</li>
     * </ul>
     * @param mobHydrAttachPositions list of positions where mobile H can attach
     * @param inputInchi InChI input
     * @return overall count of hydrogens to be dispersed over the positions
     */
private int parseMobileHydrogens(List<Integer> mobHydrAttachPositions, String inputInchi){
    int totalMobHydrCount = 0;
    String hydrogens = """";
    String inchi = inputInchi;
    if (inchi.indexOf(""/h"") != -1) {
        hydrogens = inchi.substring(inchi.indexOf(""/h"") + 2);
        if (hydrogens.indexOf('/') != -1) {
            hydrogens = hydrogens.substring(0, hydrogens.indexOf('/'));
        }
        String mobileHydrogens = hydrogens.substring(hydrogens.indexOf('('));
        Pattern mobileHydrPattern = Pattern.compile(""\\((.)*?\\)"");
        Matcher match = mobileHydrPattern.matcher(mobileHydrogens);
        while (match.find()) {
            String mobileHGroup = match.group();
            int mobHCount = 0;
            String head = mobileHGroup.substring(0, mobileHGroup.indexOf(',') + 1);
            if (head.contains(""H,""))
                head = head.replace(""H,"", ""H1,"");
            if (head.contains(""-,""))
                head = head.replace(""-,"", ""-1,"");
            head = head.substring(2);
            Pattern subPattern = Pattern.compile(""[0-9]*"");
            Matcher subMatch = subPattern.matcher(head);
            while (subMatch.find()) {
                if (!subMatch.group().equals("""")) {
                    mobHCount += Integer.valueOf(subMatch.group());
                }
            }
            totalMobHydrCount += mobHCount;
            mobileHGroup = mobileHGroup.substring(mobileHGroup.indexOf(',') + 1).replace("")"", """");
            StringTokenizer tokenizer = new StringTokenizer(mobileHGroup, "","");
            while (tokenizer.hasMoreTokens()) {
                Integer position = Integer.valueOf(tokenizer.nextToken());
                mobHydrAttachPositions.add(position);
            }
        }
    }
    LOGGER.debug(""#total mobile hydrogens: "", totalMobHydrCount);
    return totalMobHydrCount;
}","private int parseMobileHydrogens(List<Integer> mobHydrAttachPositions, String inputInchi){
    int totalMobHydrCount = 0;
    String hydrogens = """";
    String inchi = inputInchi;
    if (inchi.indexOf(""/h"") != -1) {
        hydrogens = inchi.substring(inchi.indexOf(""/h"") + 2);
        if (hydrogens.indexOf('/') != -1) {
            hydrogens = hydrogens.substring(0, hydrogens.indexOf('/'));
        }
        String mobileHydrogens = hydrogens.substring(hydrogens.indexOf('('));
        Pattern mobileHydrPattern = Pattern.compile(""\\((.)*?\\)"");
        Matcher match = mobileHydrPattern.matcher(mobileHydrogens);
        while (match.find()) {
            String mobileHGroup = match.group();
            int mobHCount = 0;
            String head = mobileHGroup.substring(0, mobileHGroup.indexOf(',') + 1);
            if (head.contains(""H,""))
                head = head.replace(""H,"", ""H1,"");
            if (head.contains(""-,""))
                head = head.replace(""-,"", ""-1,"");
            head = head.substring(2);
            Pattern subPattern = Pattern.compile(""[0-9]*"");
            Matcher subMatch = subPattern.matcher(head);
            while (subMatch.find()) {
                if (!subMatch.group().equals("""")) {
                    mobHCount += Integer.valueOf(subMatch.group());
                }
            }
            totalMobHydrCount += mobHCount;
            mobileHGroup = mobileHGroup.substring(mobileHGroup.indexOf(',') + 1).replace("")"", """");
            StringTokenizer tokenizer = new StringTokenizer(mobileHGroup, "","");
            while (tokenizer.hasMoreTokens()) {
                Integer position = Integer.valueOf(tokenizer.nextToken());
                mobHydrAttachPositions.add(position);
            }
        }
    }
    LOGGER.debug(""#total mobile hydrogens: "", totalMobHydrCount);
    return totalMobHydrCount;
}","/**
     * Parses mobile H group(s) in an InChI String.
     * <p>
     * Multiple InChI sequences of mobile hydrogens are joined into a single sequence (list),
     * see step 1 of algorithm in paper.
     * <br>
     * Mobile H group has syntax (H[n][-[m]],a1,a2[,a3[,a4...]])
     * Brackets [ ] surround optional terms.
     * <ul>
     *  <li>Term H[n] stands for 1 or, if the number n (n>1) is present, n mobile hydrogen atoms.</li>
     *  <li>Term [-[m]], if present, stands for 1 or, if the number m (m>1) is present, m mobile negative charges.</li>
     *  <li>a1,a2[,a3[,a4...]] are canonical numbers of atoms in the mobile H group.</li>
     *  <li>no two mobile H groups may have an atom (a canonical number) in common.</li>
     * </ul>
     * @param mobHydrAttachPositions list of positions where mobile H can attach
     * @param inputInchi InChI input
     * @return overall count of hydrogens to be dispersed over the positions
     */","('parseMobileHydrogens', {'INSTRUCTION': {'covered': 140, 'missed': 12}, 'BRANCH': {'covered': 13, 'missed': 3}, 'LINE': {'covered': 31, 'missed': 1}, 'COMPLEXITY': {'covered': 6, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",357.0,  Parses mobile H group(s) in an InChI String.,12.0,"['Parses the mobile H group in an InChI string.', 'Parses the mobile H group in an InChI String.', 'Parses the mobile H group in the InChI String.']"
1034,acs-aem-commons,com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,/bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java,generatedNodeChecksum,159-230,"/**
     * Generates a checksum for a single node and its node sub-system, respecting the options.
     * @param aggregateNodePath the absolute path of the node being aggregated into a checksum
     * @param node the node whose subsystem to create a checksum for
     * @param options the {@link ChecksumGeneratorOptions} options
     * @return a map containing 1 entry in the form [ node.getPath() ] : [ CHECKSUM OF NODE SYSTEM ]
     * @throws RepositoryException
     * @throws IOException
     */
protected String generatedNodeChecksum(final String aggregateNodePath, final Node node, final ChecksumGeneratorOptions options) throws RepositoryException, IOException{
    if (isExcludedSubTree(node, options)) {
        return """";
    }
    final Map<String, String> checksums = new LinkedHashMap<>();
    if (!isExcludedNodeName(node, options)) {
        final String checksum = generatePropertyChecksums(aggregateNodePath, node, options);
        if (checksum != null) {
            checksums.put(getChecksumKey(aggregateNodePath, node.getPath()), checksum);
        }
    }
    final Map<String, String> lexicographicallySortedChecksums = new TreeMap<>();
    final boolean hasOrderedChildren = hasOrderedChildren(node);
    final NodeIterator children = node.getNodes();
    while (children.hasNext()) {
        final Node child = children.nextNode();
        if (isExcludedSubTree(child, options)) {
        } else if (!isExcludedNodeType(child, options)) {
            if (hasOrderedChildren) {
                final String checksum = generatedNodeChecksum(aggregateNodePath, child, options);
                if (checksum != null) {
                    checksums.put(getChecksumKey(aggregateNodePath, child.getPath()), checksum);
                    log.debug(""Aggregated Ordered Node: {} ~> {}"", getChecksumKey(aggregateNodePath, child.getPath()), checksum);
                }
            } else {
                final String checksum = generatedNodeChecksum(aggregateNodePath, child, options);
                if (checksum != null) {
                    lexicographicallySortedChecksums.put(getChecksumKey(aggregateNodePath, child.getPath()), checksum);
                    log.debug(""Aggregated Unordered Node: {} ~> {}"", getChecksumKey(aggregateNodePath, child.getPath()), checksum);
                }
            }
        }
    }
    if (!hasOrderedChildren && lexicographicallySortedChecksums.size() > 0) {
        checksums.putAll(lexicographicallySortedChecksums);
    }
    final String nodeChecksum = aggregateChecksums(checksums);
    log.debug(""Node [ {} ] has a aggregated checksum of [ {} ]"", getChecksumKey(aggregateNodePath, node.getPath()), nodeChecksum);
    return nodeChecksum;
}","protected String generatedNodeChecksum(final String aggregateNodePath, final Node node, final ChecksumGeneratorOptions options) throws RepositoryException, IOException{
    if (isExcludedSubTree(node, options)) {
        return """";
    }
    final Map<String, String> checksums = new LinkedHashMap<>();
    if (!isExcludedNodeName(node, options)) {
        final String checksum = generatePropertyChecksums(aggregateNodePath, node, options);
        if (checksum != null) {
            checksums.put(getChecksumKey(aggregateNodePath, node.getPath()), checksum);
        }
    }
    final Map<String, String> lexicographicallySortedChecksums = new TreeMap<>();
    final boolean hasOrderedChildren = hasOrderedChildren(node);
    final NodeIterator children = node.getNodes();
    while (children.hasNext()) {
        final Node child = children.nextNode();
        if (isExcludedSubTree(child, options)) {
        } else if (!isExcludedNodeType(child, options)) {
            if (hasOrderedChildren) {
                final String checksum = generatedNodeChecksum(aggregateNodePath, child, options);
                if (checksum != null) {
                    checksums.put(getChecksumKey(aggregateNodePath, child.getPath()), checksum);
                    log.debug(""Aggregated Ordered Node: {} ~> {}"", getChecksumKey(aggregateNodePath, child.getPath()), checksum);
                }
            } else {
                final String checksum = generatedNodeChecksum(aggregateNodePath, child, options);
                if (checksum != null) {
                    lexicographicallySortedChecksums.put(getChecksumKey(aggregateNodePath, child.getPath()), checksum);
                    log.debug(""Aggregated Unordered Node: {} ~> {}"", getChecksumKey(aggregateNodePath, child.getPath()), checksum);
                }
            }
        }
    }
    if (!hasOrderedChildren && lexicographicallySortedChecksums.size() > 0) {
        checksums.putAll(lexicographicallySortedChecksums);
    }
    final String nodeChecksum = aggregateChecksums(checksums);
    log.debug(""Node [ {} ] has a aggregated checksum of [ {} ]"", getChecksumKey(aggregateNodePath, node.getPath()), nodeChecksum);
    return nodeChecksum;
}","/**
     * Generates a checksum for a single node and its node sub-system, respecting the options.
     * @param aggregateNodePath the absolute path of the node being aggregated into a checksum
     * @param node the node whose subsystem to create a checksum for
     * @param options the {@link ChecksumGeneratorOptions} options
     * @return a map containing 1 entry in the form [ node.getPath() ] : [ CHECKSUM OF NODE SYSTEM ]
     * @throws RepositoryException
     * @throws IOException
     */","('generatedNodeChecksum', {'INSTRUCTION': {'covered': 138, 'missed': 2}, 'BRANCH': {'covered': 19, 'missed': 3}, 'LINE': {'covered': 31, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",363.0,"  Generates a checksum for a single node and its node sub-system, respecting the options.",16.0,"['A checksum is created for a single and a sub-system.', 'A checksum is generated for a single and its sub-system.', 'The option to generate a checksum for a single node and its sub-system is respected.']"
1035,cdk,org/openscience/cdk/qsar/descriptors/molecular/SmallRingDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/SmallRingDescriptor.java,calculate,136-197,"/**
     * Performs the calculation: the graph will be analyzed and ring information will be determined and wrapped
     * up into descriptors.
     *
     * @param mol the atoms and bonds that make up the molecular object
     * @return the various ring-based descriptors generated
     */
public DescriptorValue calculate(IAtomContainer mol){
    this.mol = mol;
    excavateMolecule();
    int nSmallRings = smallRings.length;
    int nAromRings = 0;
    int nRingBlocks = 0;
    int nAromBlocks = countAromaticComponents();
    int nRings3 = 0, nRings4 = 0, nRings5 = 0, nRings6 = 0, nRings7 = 0, nRings8 = 0, nRings9 = 0;
    for (int[] r : smallRings) {
        final int sz = r.length;
        if (sz == 3)
            nRings3++;
        else if (sz == 4)
            nRings4++;
        else if (sz == 5)
            nRings5++;
        else if (sz == 6)
            nRings6++;
        else if (sz == 7)
            nRings7++;
        else if (sz == 8)
            nRings8++;
        else if (sz == 9)
            nRings9++;
        boolean aromatic = true;
        for (int n = 0; n < r.length; n++) if (!bondArom[findBond(r[n], r[n < sz - 1 ? n + 1 : 0])]) {
            aromatic = false;
            break;
        }
        if (aromatic)
            nAromRings++;
    }
    for (int n = ringBlock.length - 1; n >= 0; n--) nRingBlocks = Math.max(nRingBlocks, ringBlock[n]);
    IntegerArrayResult result = new IntegerArrayResult();
    result.add(nSmallRings);
    result.add(nAromRings);
    result.add(nRingBlocks);
    result.add(nAromBlocks);
    result.add(nRings3);
    result.add(nRings4);
    result.add(nRings5);
    result.add(nRings6);
    result.add(nRings7);
    result.add(nRings8);
    result.add(nRings9);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result, NAMES);
}","public DescriptorValue calculate(IAtomContainer mol){
    this.mol = mol;
    excavateMolecule();
    int nSmallRings = smallRings.length;
    int nAromRings = 0;
    int nRingBlocks = 0;
    int nAromBlocks = countAromaticComponents();
    int nRings3 = 0, nRings4 = 0, nRings5 = 0, nRings6 = 0, nRings7 = 0, nRings8 = 0, nRings9 = 0;
    for (int[] r : smallRings) {
        final int sz = r.length;
        if (sz == 3)
            nRings3++;
        else if (sz == 4)
            nRings4++;
        else if (sz == 5)
            nRings5++;
        else if (sz == 6)
            nRings6++;
        else if (sz == 7)
            nRings7++;
        else if (sz == 8)
            nRings8++;
        else if (sz == 9)
            nRings9++;
        boolean aromatic = true;
        for (int n = 0; n < r.length; n++) if (!bondArom[findBond(r[n], r[n < sz - 1 ? n + 1 : 0])]) {
            aromatic = false;
            break;
        }
        if (aromatic)
            nAromRings++;
    }
    for (int n = ringBlock.length - 1; n >= 0; n--) nRingBlocks = Math.max(nRingBlocks, ringBlock[n]);
    IntegerArrayResult result = new IntegerArrayResult();
    result.add(nSmallRings);
    result.add(nAromRings);
    result.add(nRingBlocks);
    result.add(nAromBlocks);
    result.add(nRings3);
    result.add(nRings4);
    result.add(nRings5);
    result.add(nRings6);
    result.add(nRings7);
    result.add(nRings8);
    result.add(nRings9);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), result, NAMES);
}","/**
     * Performs the calculation: the graph will be analyzed and ring information will be determined and wrapped
     * up into descriptors.
     *
     * @param mol the atoms and bonds that make up the molecular object
     * @return the various ring-based descriptors generated
     */","('calculate', {'INSTRUCTION': {'covered': 169, 'missed': 18}, 'BRANCH': {'covered': 17, 'missed': 9}, 'LINE': {'covered': 36, 'missed': 7}, 'COMPLEXITY': {'covered': 8, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",363.0,  Performs the calculation: the graph will be analyzed and ring information will be determined and wrapped  up into descriptors.,21.0,"['The graph will be analyzed and ring information will be wrapped up into descriptors.', 'The graph will be analyzed and ring information wrapped up into descriptors.', 'The graph will be analyzed and the ring information will be wrapped up.']"
1037,cdk,org/openscience/cdk/io/iterator/IteratingSDFReader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/iterator/IteratingSDFReader.java,hasNext,217-304,"/**
     * Returns true if another {@link IAtomContainer} can be read.
     */
public boolean hasNext(){
    if (nextAvailableIsKnown) {
        return hasNext;
    }
    hasNext = false;
    nextMolecule = null;
    try {
        currentFormat = (IChemFormat) MDLFormat.getInstance();
        int lineNum = 0;
        buffer.setLength(0);
        while ((currentLine = input.readLine()) != null) {
            buffer.append(currentLine).append(LINE_SEPARATOR);
            lineNum++;
            if (lineNum == 4) {
                Matcher versionMatcher = MDL_VERSION.matcher(currentLine);
                if (versionMatcher.find()) {
                    currentFormat = ""2000"".equals(versionMatcher.group(1)) ? (IChemFormat) MDLV2000Format.getInstance() : (IChemFormat) MDLV3000Format.getInstance();
                }
            }
            if (currentLine.startsWith(M_END)) {
                logger.debug(""MDL file part read: "", buffer);
                IAtomContainer molecule = null;
                try {
                    ISimpleChemObjectReader reader = getReader(currentFormat);
                    reader.setReader(new StringReader(buffer.toString()));
                    molecule = reader.read(builder.newAtomContainer());
                } catch (Exception exception) {
                    logger.error(""Error while reading next molecule: "" + exception.getMessage());
                    logger.debug(exception);
                }
                if (molecule != null) {
                    readDataBlockInto(molecule);
                    hasNext = true;
                    nextAvailableIsKnown = true;
                    nextMolecule = molecule;
                    return true;
                } else if (skip) {
                    String line;
                    while ((line = input.readLine()) != null) {
                        if (line.startsWith(SDF_RECORD_SEPARATOR)) {
                            break;
                        }
                    }
                } else {
                    return false;
                }
                buffer.setLength(0);
                lineNum = 0;
            }
            if (currentLine.startsWith(SDF_RECORD_SEPARATOR)) {
                buffer.setLength(0);
                lineNum = 0;
            }
        }
    } catch (IOException exception) {
        logger.error(""Error while reading next molecule: "" + exception.getMessage());
        logger.debug(exception);
    }
    return false;
}","public boolean hasNext(){
    if (nextAvailableIsKnown) {
        return hasNext;
    }
    hasNext = false;
    nextMolecule = null;
    try {
        currentFormat = (IChemFormat) MDLFormat.getInstance();
        int lineNum = 0;
        buffer.setLength(0);
        while ((currentLine = input.readLine()) != null) {
            buffer.append(currentLine).append(LINE_SEPARATOR);
            lineNum++;
            if (lineNum == 4) {
                Matcher versionMatcher = MDL_VERSION.matcher(currentLine);
                if (versionMatcher.find()) {
                    currentFormat = ""2000"".equals(versionMatcher.group(1)) ? (IChemFormat) MDLV2000Format.getInstance() : (IChemFormat) MDLV3000Format.getInstance();
                }
            }
            if (currentLine.startsWith(M_END)) {
                logger.debug(""MDL file part read: "", buffer);
                IAtomContainer molecule = null;
                try {
                    ISimpleChemObjectReader reader = getReader(currentFormat);
                    reader.setReader(new StringReader(buffer.toString()));
                    molecule = reader.read(builder.newAtomContainer());
                } catch (Exception exception) {
                    logger.error(""Error while reading next molecule: "" + exception.getMessage());
                    logger.debug(exception);
                }
                if (molecule != null) {
                    readDataBlockInto(molecule);
                    hasNext = true;
                    nextAvailableIsKnown = true;
                    nextMolecule = molecule;
                    return true;
                } else if (skip) {
                    String line;
                    while ((line = input.readLine()) != null) {
                        if (line.startsWith(SDF_RECORD_SEPARATOR)) {
                            break;
                        }
                    }
                } else {
                    return false;
                }
                buffer.setLength(0);
                lineNum = 0;
            }
            if (currentLine.startsWith(SDF_RECORD_SEPARATOR)) {
                buffer.setLength(0);
                lineNum = 0;
            }
        }
    } catch (IOException exception) {
        logger.error(""Error while reading next molecule: "" + exception.getMessage());
        logger.debug(exception);
    }
    return false;
}","/**
     * Returns true if another {@link IAtomContainer} can be read.
     */","('hasNext', {'INSTRUCTION': {'covered': 157, 'missed': 27}, 'BRANCH': {'covered': 18, 'missed': 4}, 'LINE': {'covered': 40, 'missed': 7}, 'COMPLEXITY': {'covered': 8, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",368.0,  Returns true if another {@link IAtomContainer} can be read.,13.0,"['If another @link IAtomContainer can be read, this is true.', ""If another @link IAtomContainer can be read, it's true."", 'If another @link IAtomContainer can be read, returns true.']"
1042,cdk,org/openscience/cdk/qsar/descriptors/molecular/RotatableBondsCountDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/RotatableBondsCountDescriptor.java,calculate,135-190,"/**
     *  The method calculates the number of rotatable bonds of an atom container.
     *  If the boolean parameter is set to true, terminal bonds are included.
     *
     *@param  ac                AtomContainer
     *@return                   number of rotatable bonds
     */
public DescriptorValue calculate(IAtomContainer ac){
    ac = clone(ac);
    int rotatableBondsCount = 0;
    int degree0;
    int degree1;
    IRingSet ringSet;
    try {
        ringSet = new SpanningTree(ac).getBasicRings();
    } catch (NoSuchAtomException e) {
        return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult((int) Double.NaN), getDescriptorNames(), e);
    }
    for (IBond bond : ac.bonds()) {
        if (ringSet.getRings(bond).getAtomContainerCount() > 0) {
            bond.setFlag(CDKConstants.ISINRING, true);
        }
    }
    for (IBond bond : ac.bonds()) {
        IAtom atom0 = bond.getBegin();
        IAtom atom1 = bond.getEnd();
        if (atom0.getAtomicNumber() == IElement.H || atom1.getAtomicNumber() == IElement.H)
            continue;
        if (bond.getOrder() == Order.SINGLE) {
            if ((BondManipulator.isLowerOrder(ac.getMaximumBondOrder(atom0), IBond.Order.TRIPLE)) && (BondManipulator.isLowerOrder(ac.getMaximumBondOrder(atom1), IBond.Order.TRIPLE))) {
                if (!bond.getFlag(CDKConstants.ISINRING)) {
                    if (excludeAmides && (isAmide(atom0, atom1, ac) || isAmide(atom1, atom0, ac))) {
                        continue;
                    }
                    degree0 = ac.getConnectedBondsCount(atom0) - getConnectedHCount(ac, atom0);
                    degree1 = ac.getConnectedBondsCount(atom1) - getConnectedHCount(ac, atom1);
                    if ((degree0 == 1) || (degree1 == 1)) {
                        if (includeTerminals) {
                            rotatableBondsCount += 1;
                        }
                    } else {
                        rotatableBondsCount += 1;
                    }
                }
            }
        }
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(rotatableBondsCount), getDescriptorNames());
}","public DescriptorValue calculate(IAtomContainer ac){
    ac = clone(ac);
    int rotatableBondsCount = 0;
    int degree0;
    int degree1;
    IRingSet ringSet;
    try {
        ringSet = new SpanningTree(ac).getBasicRings();
    } catch (NoSuchAtomException e) {
        return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult((int) Double.NaN), getDescriptorNames(), e);
    }
    for (IBond bond : ac.bonds()) {
        if (ringSet.getRings(bond).getAtomContainerCount() > 0) {
            bond.setFlag(CDKConstants.ISINRING, true);
        }
    }
    for (IBond bond : ac.bonds()) {
        IAtom atom0 = bond.getBegin();
        IAtom atom1 = bond.getEnd();
        if (atom0.getAtomicNumber() == IElement.H || atom1.getAtomicNumber() == IElement.H)
            continue;
        if (bond.getOrder() == Order.SINGLE) {
            if ((BondManipulator.isLowerOrder(ac.getMaximumBondOrder(atom0), IBond.Order.TRIPLE)) && (BondManipulator.isLowerOrder(ac.getMaximumBondOrder(atom1), IBond.Order.TRIPLE))) {
                if (!bond.getFlag(CDKConstants.ISINRING)) {
                    if (excludeAmides && (isAmide(atom0, atom1, ac) || isAmide(atom1, atom0, ac))) {
                        continue;
                    }
                    degree0 = ac.getConnectedBondsCount(atom0) - getConnectedHCount(ac, atom0);
                    degree1 = ac.getConnectedBondsCount(atom1) - getConnectedHCount(ac, atom1);
                    if ((degree0 == 1) || (degree1 == 1)) {
                        if (includeTerminals) {
                            rotatableBondsCount += 1;
                        }
                    } else {
                        rotatableBondsCount += 1;
                    }
                }
            }
        }
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(rotatableBondsCount), getDescriptorNames());
}","/**
     *  The method calculates the number of rotatable bonds of an atom container.
     *  If the boolean parameter is set to true, terminal bonds are included.
     *
     *@param  ac                AtomContainer
     *@return                   number of rotatable bonds
     */","('calculate', {'INSTRUCTION': {'covered': 144, 'missed': 18}, 'BRANCH': {'covered': 26, 'missed': 4}, 'LINE': {'covered': 27, 'missed': 3}, 'COMPLEXITY': {'covered': 12, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",374.0,  The method calculates the number of rotatable bonds of an atom container.,13.0,"['The method calculates the number of bonds.', 'The method calculates the number of bonds in an atom container.', 'The method is used to calculate the number of bonds in an atom container.']"
1043,cdk,org/openscience/cdk/smsd/filters/ChemicalFilters.java,/legacy/src/main/java/org/openscience/cdk/smsd/filters/ChemicalFilters.java,sortResultsByStereoAndBondMatch,190-255,"/**
     * Sort MCS solution by stereo and bond type matches.
     * @throws CDKException
     */
public synchronized void sortResultsByStereoAndBondMatch() throws CDKException{
    // System.out.println(""\n\n\n\nSort By ResultsByStereoAndBondMatch"");
    Map<Integer, Map<Integer, Integer>> allStereoMCS = new HashMap<Integer, Map<Integer, Integer>>();
    Map<Integer, Map<IAtom, IAtom>> allStereoAtomMCS = new HashMap<Integer, Map<IAtom, IAtom>>();
    Map<Integer, Integer> fragmentScoreMap = new TreeMap<Integer, Integer>();
    Map<Integer, Double> energyScoreMap = new TreeMap<Integer, Double>();
    Map<Integer, Double> stereoScoreMap = new HashMap<Integer, Double>();
    initializeMaps(allStereoMCS, allStereoAtomMCS, stereoScoreMap, fragmentScoreMap, energyScoreMap);
    boolean stereoMatchFlag = getStereoBondChargeMatch(stereoScoreMap, allStereoMCS, allStereoAtomMCS);
    boolean flag = false;
    if (stereoMatchFlag) {
        // Higher Score is mapped preferred over lower
        stereoScoreMap = sortMapByValueInDecendingOrder(stereoScoreMap);
        double higestStereoScore = stereoScoreMap.isEmpty() ? 0 : stereoScoreMap.values().iterator().next();
        double secondhigestStereoScore = higestStereoScore;
        for (Integer key : stereoScoreMap.keySet()) {
            if (secondhigestStereoScore < higestStereoScore && stereoScoreMap.get(key) > secondhigestStereoScore) {
                secondhigestStereoScore = stereoScoreMap.get(key);
            } else if (secondhigestStereoScore == higestStereoScore && stereoScoreMap.get(key) < secondhigestStereoScore) {
                secondhigestStereoScore = stereoScoreMap.get(key);
            }
        }
        if (!stereoScoreMap.isEmpty()) {
            flag = true;
            clear();
        }
        /* Put back the sorted solutions */
        int counter = 0;
        for (Integer i : stereoScoreMap.keySet()) {
            // System.out.println(""Sorted Map key "" + I + "" Sorted Value: "" + stereoScoreMap.get(I));
            // System.out.println(""Stereo MCS "" + allStereoMCS.get(I) + "" Stereo Value: ""
            // + stereoScoreMap.get(I));
            if (higestStereoScore == stereoScoreMap.get(i).doubleValue()) {
                // || secondhigestStereoScore == stereoScoreMap.get(I).doubleValue()) {
                addSolution(counter, i, allStereoAtomMCS, allStereoMCS, stereoScoreMap, energyScoreMap, fragmentScoreMap);
                counter++;
                // System.out.println(""Sorted Map key "" + I + "" Sorted Value: "" + stereoScoreMap.get(I));
                // System.out.println(""Stereo MCS "" + allStereoMCS.get(I) + "" Stereo Value: ""
                // + stereoScoreMap.get(I));
            }
        }
        if (flag) {
            firstSolution.putAll(allMCS.get(0));
            firstAtomMCS.putAll(allAtomMCS.get(0));
            clear(allStereoMCS, allStereoAtomMCS, stereoScoreMap, fragmentScoreMap, energyScoreMap);
        }
    }
}","public synchronized void sortResultsByStereoAndBondMatch() throws CDKException{
    // System.out.println(""\n\n\n\nSort By ResultsByStereoAndBondMatch"");
    Map<Integer, Map<Integer, Integer>> allStereoMCS = new HashMap<Integer, Map<Integer, Integer>>();
    Map<Integer, Map<IAtom, IAtom>> allStereoAtomMCS = new HashMap<Integer, Map<IAtom, IAtom>>();
    Map<Integer, Integer> fragmentScoreMap = new TreeMap<Integer, Integer>();
    Map<Integer, Double> energyScoreMap = new TreeMap<Integer, Double>();
    Map<Integer, Double> stereoScoreMap = new HashMap<Integer, Double>();
    initializeMaps(allStereoMCS, allStereoAtomMCS, stereoScoreMap, fragmentScoreMap, energyScoreMap);
    boolean stereoMatchFlag = getStereoBondChargeMatch(stereoScoreMap, allStereoMCS, allStereoAtomMCS);
    boolean flag = false;
    if (stereoMatchFlag) {
        // Higher Score is mapped preferred over lower
        stereoScoreMap = sortMapByValueInDecendingOrder(stereoScoreMap);
        double higestStereoScore = stereoScoreMap.isEmpty() ? 0 : stereoScoreMap.values().iterator().next();
        double secondhigestStereoScore = higestStereoScore;
        for (Integer key : stereoScoreMap.keySet()) {
            if (secondhigestStereoScore < higestStereoScore && stereoScoreMap.get(key) > secondhigestStereoScore) {
                secondhigestStereoScore = stereoScoreMap.get(key);
            } else if (secondhigestStereoScore == higestStereoScore && stereoScoreMap.get(key) < secondhigestStereoScore) {
                secondhigestStereoScore = stereoScoreMap.get(key);
            }
        }
        if (!stereoScoreMap.isEmpty()) {
            flag = true;
            clear();
        }
        /* Put back the sorted solutions */
        int counter = 0;
        for (Integer i : stereoScoreMap.keySet()) {
            // System.out.println(""Sorted Map key "" + I + "" Sorted Value: "" + stereoScoreMap.get(I));
            // System.out.println(""Stereo MCS "" + allStereoMCS.get(I) + "" Stereo Value: ""
            // + stereoScoreMap.get(I));
            if (higestStereoScore == stereoScoreMap.get(i).doubleValue()) {
                // || secondhigestStereoScore == stereoScoreMap.get(I).doubleValue()) {
                addSolution(counter, i, allStereoAtomMCS, allStereoMCS, stereoScoreMap, energyScoreMap, fragmentScoreMap);
                counter++;
                // System.out.println(""Sorted Map key "" + I + "" Sorted Value: "" + stereoScoreMap.get(I));
                // System.out.println(""Stereo MCS "" + allStereoMCS.get(I) + "" Stereo Value: ""
                // + stereoScoreMap.get(I));
            }
        }
        if (flag) {
            firstSolution.putAll(allMCS.get(0));
            firstAtomMCS.putAll(allAtomMCS.get(0));
            clear(allStereoMCS, allStereoAtomMCS, stereoScoreMap, fragmentScoreMap, energyScoreMap);
        }
    }
}","/**
     * Sort MCS solution by stereo and bond type matches.
     * @throws CDKException
     */","('sortResultsByStereoAndBondMatch', {'INSTRUCTION': {'covered': 160, 'missed': 9}, 'BRANCH': {'covered': 17, 'missed': 5}, 'LINE': {'covered': 32, 'missed': 1}, 'COMPLEXITY': {'covered': 7, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",376.0,  Sort MCS solution by stereo and bond type matches.,10.0,"['Sort the solution by stereo and bond type.', 'Sort by stereo and bond type.', 'Sort by stereo and bond type matches.']"
1044,jeromq,org/zeromq/proto/ZPicture.java,/src/main/java/org/zeromq/proto/ZPicture.java,recvPicture,341-430,"/**
     * Receive a 'picture' message to the socket (or actor).
     *
     *
     * @param picture The picture is a string that defines the type of each frame.
     *                This makes it easy to recv a complex multiframe message in
     *                one call. The picture can contain any of these characters,
     *                each corresponding to zero or one elements in the result:
     *
     *                <table>
     *               <caption> </caption>
     *                <tr><td>i = int (stores signed integer)</td></tr>
     *                <tr><td>1 = int (stores 8-bit unsigned integer)</td></tr>
     *                <tr><td>2 = int (stores 16-bit unsigned integer)</td></tr>
     *                <tr><td>4 = long (stores 32-bit unsigned integer)</td></tr>
     *                <tr><td>8 = long (stores 64-bit unsigned integer)</td></tr>
     *                <tr><td>s = String</td></tr>
     *                <tr><td>b = byte[]</td></tr>
     *                <tr><td>f = ZFrame (creates zframe)</td></tr>
     *                <tr><td>m = ZMsg (creates a zmsg with the remaing frames)</td></tr>
     *                <tr><td>z = null, asserts empty frame (0 arguments)</td></tr>
     *                </table>
     *
     *                Also see {@link #sendPicture(Socket, String, Object...)} how to send a
     *                multiframe picture.
     *
     * @return the picture elements as object array
     */
public Object[] recvPicture(Socket socket, String picture){
    if (!FORMAT.matcher(picture).matches()) {
        throw new ZMQException(picture + "" is not in expected format "" + FORMAT.pattern(), ZError.EPROTO);
    }
    Object[] elements = new Object[picture.length()];
    for (int index = 0; index < picture.length(); index++) {
        char pattern = picture.charAt(index);
        switch(pattern) {
            case 'i':
                {
                    elements[index] = Integer.valueOf(socket.recvStr());
                    break;
                }
            case '1':
                {
                    elements[index] = (0xff) & Integer.valueOf(socket.recvStr());
                    break;
                }
            case '2':
                {
                    elements[index] = (0xffff) & Integer.valueOf(socket.recvStr());
                    break;
                }
            case '4':
                {
                    elements[index] = (0xffffffff) & Integer.valueOf(socket.recvStr());
                    break;
                }
            case '8':
                {
                    elements[index] = Long.valueOf(socket.recvStr());
                    break;
                }
            case 's':
                {
                    elements[index] = socket.recvStr();
                    break;
                }
            case 'b':
            case 'c':
                {
                    elements[index] = socket.recv();
                    break;
                }
            case 'f':
                {
                    elements[index] = ZFrame.recvFrame(socket);
                    break;
                }
            case 'm':
                {
                    elements[index] = ZMsg.recvMsg(socket);
                    break;
                }
            case 'z':
                {
                    ZFrame zeroFrame = ZFrame.recvFrame(socket);
                    if (zeroFrame == null || zeroFrame.size() > 0) {
                        throw new ZMQException(""zero frame is not empty"", ZError.EPROTO);
                    }
                    elements[index] = new ZFrame((byte[]) null);
                    break;
                }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    return elements;
}","public Object[] recvPicture(Socket socket, String picture){
    if (!FORMAT.matcher(picture).matches()) {
        throw new ZMQException(picture + "" is not in expected format "" + FORMAT.pattern(), ZError.EPROTO);
    }
    Object[] elements = new Object[picture.length()];
    for (int index = 0; index < picture.length(); index++) {
        char pattern = picture.charAt(index);
        switch(pattern) {
            case 'i':
                {
                    elements[index] = Integer.valueOf(socket.recvStr());
                    break;
                }
            case '1':
                {
                    elements[index] = (0xff) & Integer.valueOf(socket.recvStr());
                    break;
                }
            case '2':
                {
                    elements[index] = (0xffff) & Integer.valueOf(socket.recvStr());
                    break;
                }
            case '4':
                {
                    elements[index] = (0xffffffff) & Integer.valueOf(socket.recvStr());
                    break;
                }
            case '8':
                {
                    elements[index] = Long.valueOf(socket.recvStr());
                    break;
                }
            case 's':
                {
                    elements[index] = socket.recvStr();
                    break;
                }
            case 'b':
            case 'c':
                {
                    elements[index] = socket.recv();
                    break;
                }
            case 'f':
                {
                    elements[index] = ZFrame.recvFrame(socket);
                    break;
                }
            case 'm':
                {
                    elements[index] = ZMsg.recvMsg(socket);
                    break;
                }
            case 'z':
                {
                    ZFrame zeroFrame = ZFrame.recvFrame(socket);
                    if (zeroFrame == null || zeroFrame.size() > 0) {
                        throw new ZMQException(""zero frame is not empty"", ZError.EPROTO);
                    }
                    elements[index] = new ZFrame((byte[]) null);
                    break;
                }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    return elements;
}","/**
     * Receive a 'picture' message to the socket (or actor).
     *
     *
     * @param picture The picture is a string that defines the type of each frame.
     *                This makes it easy to recv a complex multiframe message in
     *                one call. The picture can contain any of these characters,
     *                each corresponding to zero or one elements in the result:
     *
     *                <table>
     *               <caption> </caption>
     *                <tr><td>i = int (stores signed integer)</td></tr>
     *                <tr><td>1 = int (stores 8-bit unsigned integer)</td></tr>
     *                <tr><td>2 = int (stores 16-bit unsigned integer)</td></tr>
     *                <tr><td>4 = long (stores 32-bit unsigned integer)</td></tr>
     *                <tr><td>8 = long (stores 64-bit unsigned integer)</td></tr>
     *                <tr><td>s = String</td></tr>
     *                <tr><td>b = byte[]</td></tr>
     *                <tr><td>f = ZFrame (creates zframe)</td></tr>
     *                <tr><td>m = ZMsg (creates a zmsg with the remaing frames)</td></tr>
     *                <tr><td>z = null, asserts empty frame (0 arguments)</td></tr>
     *                </table>
     *
     *                Also see {@link #sendPicture(Socket, String, Object...)} how to send a
     *                multiframe picture.
     *
     * @return the picture elements as object array
     */","('recvPicture', {'INSTRUCTION': {'covered': 129, 'missed': 22}, 'BRANCH': {'covered': 16, 'missed': 5}, 'LINE': {'covered': 29, 'missed': 2}, 'COMPLEXITY': {'covered': 12, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",380.0,  Receive a 'picture' message to the socket (or actor).,13.0,"['Receive a picture message from the actor.', 'Receive a picture message to the actor.', 'A picture message to the actor.']"
1045,matsim-libs,org/matsim/core/utils/collections/QuadTree.java,/matsim/src/main/java/org/matsim/core/utils/collections/QuadTree.java,values,276-359,"/**
	 * Returns a collection view of the values contained in this map.  The
	 * collection's iterator will return the values in the order that their
	 * corresponding keys appear in the tree.  The collection is backed by
	 * this <tt>QuadMap</tt> instance, so changes to this map are reflected in
	 * the collection.
	 *
	 * @return a collection view of the values contained in this map.
	 */
public Collection<T> values(){
    if (this.values == null) {
        this.values = new AbstractCollection<T>() {

            @Override
            public Iterator<T> iterator() {
                Iterator<T> iterator = new Iterator<T>() {

                    private final int expectedModCount = QuadTree.this.modCount;

                    private Leaf<T> currentLeaf = firstLeaf();

                    private int nextIndex = 0;

                    private T next = first();

                    private T first() {
                        if (this.currentLeaf == null) {
                            return null;
                        }
                        this.nextIndex = 0;
                        loadNext();
                        return this.next;
                    }

                    @Override
                    public boolean hasNext() {
                        return this.next != null;
                    }

                    @Override
                    public T next() {
                        if (this.next == null) {
                            return null;
                        }
                        if (QuadTree.this.modCount != this.expectedModCount) {
                            throw new ConcurrentModificationException();
                        }
                        T current = this.next;
                        loadNext();
                        return current;
                    }

                    private void loadNext() {
                        boolean searching = true;
                        while (searching) {
                            int size = this.currentLeaf.value != null ? 1 : this.currentLeaf.values.size();
                            if (this.nextIndex < size) {
                                this.nextIndex++;
                                this.next = this.currentLeaf.value != null ? this.currentLeaf.value : this.currentLeaf.values.get(this.nextIndex - 1);
                                searching = false;
                            } else {
                                this.currentLeaf = nextLeaf(this.currentLeaf);
                                if (this.currentLeaf == null) {
                                    this.next = null;
                                    searching = false;
                                } else {
                                    this.nextIndex = 0;
                                }
                            }
                        }
                    }

                    @Override
                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
                return iterator;
            }

            @Override
            public int size() {
                return QuadTree.this.size;
            }
        };
    }
    return this.values;
}","public Collection<T> values(){
    if (this.values == null) {
        this.values = new AbstractCollection<T>() {

            @Override
            public Iterator<T> iterator() {
                Iterator<T> iterator = new Iterator<T>() {

                    private final int expectedModCount = QuadTree.this.modCount;

                    private Leaf<T> currentLeaf = firstLeaf();

                    private int nextIndex = 0;

                    private T next = first();

                    private T first() {
                        if (this.currentLeaf == null) {
                            return null;
                        }
                        this.nextIndex = 0;
                        loadNext();
                        return this.next;
                    }

                    @Override
                    public boolean hasNext() {
                        return this.next != null;
                    }

                    @Override
                    public T next() {
                        if (this.next == null) {
                            return null;
                        }
                        if (QuadTree.this.modCount != this.expectedModCount) {
                            throw new ConcurrentModificationException();
                        }
                        T current = this.next;
                        loadNext();
                        return current;
                    }

                    private void loadNext() {
                        boolean searching = true;
                        while (searching) {
                            int size = this.currentLeaf.value != null ? 1 : this.currentLeaf.values.size();
                            if (this.nextIndex < size) {
                                this.nextIndex++;
                                this.next = this.currentLeaf.value != null ? this.currentLeaf.value : this.currentLeaf.values.get(this.nextIndex - 1);
                                searching = false;
                            } else {
                                this.currentLeaf = nextLeaf(this.currentLeaf);
                                if (this.currentLeaf == null) {
                                    this.next = null;
                                    searching = false;
                                } else {
                                    this.nextIndex = 0;
                                }
                            }
                        }
                    }

                    @Override
                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
                return iterator;
            }

            @Override
            public int size() {
                return QuadTree.this.size;
            }
        };
    }
    return this.values;
}","/**
	 * Returns a collection view of the values contained in this map.  The
	 * collection's iterator will return the values in the order that their
	 * corresponding keys appear in the tree.  The collection is backed by
	 * this <tt>QuadMap</tt> instance, so changes to this map are reflected in
	 * the collection.
	 *
	 * @return a collection view of the values contained in this map.
	 */","('values', {'INSTRUCTION': {'covered': 12, 'missed': 0}, 'BRANCH': {'covered': 2, 'missed': 0}, 'LINE': {'covered': 3, 'missed': 0}, 'COMPLEXITY': {'covered': 2, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",380.0,  Returns a collection view of the values contained in this map.,12.0,"['A collection view of the values is returned.', 'A collection view is a view of the values on the map.', 'A collection view is a view of the values contained in the map.']"
1046,cdk,org/openscience/cdk/qsar/descriptors/molecular/RuleOfFiveDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/RuleOfFiveDescriptor.java,calculate,136-199,"/**
     *  the method take a boolean checkAromaticity: if the boolean is true, it means that
     *  aromaticity has to be checked.
     *
     *@param  mol   AtomContainer for which this descriptor is to be calculated
     *@return    The number of failures of the Lipinski rule
     */
public DescriptorValue calculate(IAtomContainer mol){
    mol = clone(mol);
    int lipinskifailures = 0;
    IMolecularDescriptor xlogP = new XLogPDescriptor();
    Object[] xlogPparams = { checkAromaticity, Boolean.TRUE };
    try {
        xlogP.setParameters(xlogPparams);
        double xlogPvalue = ((DoubleResult) xlogP.calculate(mol).getValue()).doubleValue();
        IMolecularDescriptor acc = new HBondAcceptorCountDescriptor();
        Object[] hBondparams = { checkAromaticity };
        acc.setParameters(hBondparams);
        int acceptors = ((IntegerResult) acc.calculate(mol).getValue()).intValue();
        IMolecularDescriptor don = new HBondDonorCountDescriptor();
        don.setParameters(hBondparams);
        int donors = ((IntegerResult) don.calculate(mol).getValue()).intValue();
        IMolecularDescriptor mw = new WeightDescriptor();
        Object[] mwparams = { ""*"" };
        mw.setParameters(mwparams);
        double mwvalue = ((DoubleResult) mw.calculate(mol).getValue()).doubleValue();
        IMolecularDescriptor rotata = new RotatableBondsCountDescriptor();
        Object[] rotatableBondsParams = { false, true };
        rotata.setParameters(rotatableBondsParams);
        int rotatablebonds = ((IntegerResult) rotata.calculate(mol).getValue()).intValue();
        if (xlogPvalue > 5.0) {
            lipinskifailures += 1;
        }
        if (acceptors > 10) {
            lipinskifailures += 1;
        }
        if (donors > 5) {
            lipinskifailures += 1;
        }
        if (mwvalue > 500.0) {
            lipinskifailures += 1;
        }
        if (rotatablebonds > 10.0) {
            lipinskifailures += 1;
        }
    } catch (CDKException e) {
        new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult((int) Double.NaN), getDescriptorNames(), e);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(lipinskifailures), getDescriptorNames());
}","public DescriptorValue calculate(IAtomContainer mol){
    mol = clone(mol);
    int lipinskifailures = 0;
    IMolecularDescriptor xlogP = new XLogPDescriptor();
    Object[] xlogPparams = { checkAromaticity, Boolean.TRUE };
    try {
        xlogP.setParameters(xlogPparams);
        double xlogPvalue = ((DoubleResult) xlogP.calculate(mol).getValue()).doubleValue();
        IMolecularDescriptor acc = new HBondAcceptorCountDescriptor();
        Object[] hBondparams = { checkAromaticity };
        acc.setParameters(hBondparams);
        int acceptors = ((IntegerResult) acc.calculate(mol).getValue()).intValue();
        IMolecularDescriptor don = new HBondDonorCountDescriptor();
        don.setParameters(hBondparams);
        int donors = ((IntegerResult) don.calculate(mol).getValue()).intValue();
        IMolecularDescriptor mw = new WeightDescriptor();
        Object[] mwparams = { ""*"" };
        mw.setParameters(mwparams);
        double mwvalue = ((DoubleResult) mw.calculate(mol).getValue()).doubleValue();
        IMolecularDescriptor rotata = new RotatableBondsCountDescriptor();
        Object[] rotatableBondsParams = { false, true };
        rotata.setParameters(rotatableBondsParams);
        int rotatablebonds = ((IntegerResult) rotata.calculate(mol).getValue()).intValue();
        if (xlogPvalue > 5.0) {
            lipinskifailures += 1;
        }
        if (acceptors > 10) {
            lipinskifailures += 1;
        }
        if (donors > 5) {
            lipinskifailures += 1;
        }
        if (mwvalue > 500.0) {
            lipinskifailures += 1;
        }
        if (rotatablebonds > 10.0) {
            lipinskifailures += 1;
        }
    } catch (CDKException e) {
        new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult((int) Double.NaN), getDescriptorNames(), e);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(lipinskifailures), getDescriptorNames());
}","/**
     *  the method take a boolean checkAromaticity: if the boolean is true, it means that
     *  aromaticity has to be checked.
     *
     *@param  mol   AtomContainer for which this descriptor is to be calculated
     *@return    The number of failures of the Lipinski rule
     */","('calculate', {'INSTRUCTION': {'covered': 156, 'missed': 20}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 32, 'missed': 5}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",383.0,"  the method take a boolean checkAromaticity: if the boolean is true, it means that  aromaticity has to be checked.",22.0,"['If the boolean is true, it means that aromaticity has to be checked.', 'The method checks aromaticity if the boolean is true.', 'If the boolean is true, aromaticity has to be checked.']"
1047,cdk,org/openscience/cdk/geometry/ZMatrixTools.java,/storage/io/src/main/java/org/openscience/cdk/geometry/ZMatrixTools.java,zmatrixToCartesian,42-91,"/**
     * Takes the given Z Matrix coordinates and converts them to cartesian coordinates.
     * The first Atom end up in the origin, the second on on the x axis, and the third
     * one in the XY plane. The rest is added by applying the Zmatrix distances, angles
     * and dihedrals. Angles are in degrees.
     *
     * @param distances     Array of distance variables of the Z matrix
     * @param angles        Array of angle variables of the Z matrix
     * @param dihedrals     Array of distance variables of the Z matrix
     * @param first_atoms   Array of atom ids of the first invoked atom in distance, angle and dihedral
     * @param second_atoms  Array of atom ids of the second invoked atom in angle and dihedral
     * @param third_atoms   Array of atom ids of the third invoked atom in dihedral
     *
     * @cdk.dictref blue-obelisk:zmatrixCoordinatesIntoCartesianCoordinates
     */
public static Point3d[] zmatrixToCartesian(double[] distances, int[] first_atoms, double[] angles, int[] second_atoms, double[] dihedrals, int[] third_atoms){
    Point3d[] cartesianCoords = new Point3d[distances.length];
    for (int index = 0; index < distances.length; index++) {
        if (index == 0) {
            cartesianCoords[index] = new Point3d(0d, 0d, 0d);
        } else if (index == 1) {
            cartesianCoords[index] = new Point3d(distances[1], 0d, 0d);
        } else if (index == 2) {
            cartesianCoords[index] = new Point3d(-Math.cos((angles[2] / 180) * Math.PI) * distances[2] + distances[1], Math.sin((angles[2] / 180) * Math.PI) * distances[2], 0d);
            if (first_atoms[index] == 0)
                cartesianCoords[index].x = (cartesianCoords[index].x - distances[1]) * -1;
        } else {
            Vector3d cd = new Vector3d();
            cd.sub(cartesianCoords[third_atoms[index]], cartesianCoords[second_atoms[index]]);
            Vector3d bc = new Vector3d();
            bc.sub(cartesianCoords[second_atoms[index]], cartesianCoords[first_atoms[index]]);
            Vector3d n1 = new Vector3d();
            n1.cross(cd, bc);
            Vector3d n2 = rotate(n1, bc, -dihedrals[index]);
            Vector3d ba = rotate(bc, n2, -angles[index]);
            ba.normalize();
            ba.scale(distances[index]);
            Point3d result = new Point3d();
            result.add(cartesianCoords[first_atoms[index]], ba);
            cartesianCoords[index] = result;
        }
    }
    return cartesianCoords;
}","public static Point3d[] zmatrixToCartesian(double[] distances, int[] first_atoms, double[] angles, int[] second_atoms, double[] dihedrals, int[] third_atoms){
    Point3d[] cartesianCoords = new Point3d[distances.length];
    for (int index = 0; index < distances.length; index++) {
        if (index == 0) {
            cartesianCoords[index] = new Point3d(0d, 0d, 0d);
        } else if (index == 1) {
            cartesianCoords[index] = new Point3d(distances[1], 0d, 0d);
        } else if (index == 2) {
            cartesianCoords[index] = new Point3d(-Math.cos((angles[2] / 180) * Math.PI) * distances[2] + distances[1], Math.sin((angles[2] / 180) * Math.PI) * distances[2], 0d);
            if (first_atoms[index] == 0)
                cartesianCoords[index].x = (cartesianCoords[index].x - distances[1]) * -1;
        } else {
            Vector3d cd = new Vector3d();
            cd.sub(cartesianCoords[third_atoms[index]], cartesianCoords[second_atoms[index]]);
            Vector3d bc = new Vector3d();
            bc.sub(cartesianCoords[second_atoms[index]], cartesianCoords[first_atoms[index]]);
            Vector3d n1 = new Vector3d();
            n1.cross(cd, bc);
            Vector3d n2 = rotate(n1, bc, -dihedrals[index]);
            Vector3d ba = rotate(bc, n2, -angles[index]);
            ba.normalize();
            ba.scale(distances[index]);
            Point3d result = new Point3d();
            result.add(cartesianCoords[first_atoms[index]], ba);
            cartesianCoords[index] = result;
        }
    }
    return cartesianCoords;
}","/**
     * Takes the given Z Matrix coordinates and converts them to cartesian coordinates.
     * The first Atom end up in the origin, the second on on the x axis, and the third
     * one in the XY plane. The rest is added by applying the Zmatrix distances, angles
     * and dihedrals. Angles are in degrees.
     *
     * @param distances     Array of distance variables of the Z matrix
     * @param angles        Array of angle variables of the Z matrix
     * @param dihedrals     Array of distance variables of the Z matrix
     * @param first_atoms   Array of atom ids of the first invoked atom in distance, angle and dihedral
     * @param second_atoms  Array of atom ids of the second invoked atom in angle and dihedral
     * @param third_atoms   Array of atom ids of the third invoked atom in dihedral
     *
     * @cdk.dictref blue-obelisk:zmatrixCoordinatesIntoCartesianCoordinates
     */","('zmatrixToCartesian', {'INSTRUCTION': {'covered': 178, 'missed': 0}, 'BRANCH': {'covered': 9, 'missed': 1}, 'LINE': {'covered': 24, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",384.0,  Takes the given Z Matrix coordinates and converts them to cartesian coordinates.,13.0,"['The Z Matrix coordinates can be converted to cartesian coordinates.', 'The Z Matrix coordinates are converted to cartesian coordinates.', 'The given Z Matrix coordinates can be converted to cartesian coordinates.']"
1048,cdk,org/openscience/cdk/smarts/SmartsFragmentExtractor.java,/tool/smarts/src/main/java/org/openscience/cdk/smarts/SmartsFragmentExtractor.java,encodeExpr,259-319,"/**
     * Recursively encodes a SMARTS expression into the provides
     * string builder.
     *
     * @param idx   atom index
     * @param bprev previous bond
     * @param sb    destition to write SMARTS to
     */
private void encodeExpr(int idx, int bprev, StringBuilder sb){
    avisit[idx] = numVisit++;
    sb.append(aexpr[idx]);
    final int d = deg[idx];
    int remain = d;
    for (int j = 0; j < d; j++) {
        int nbr = atomAdj[idx][j];
        int bidx = bondAdj[idx][j];
        if (rbnds[bidx] < 0) {
            final int rnum = chooseRingNumber();
            if (rnum > 9)
                sb.append('%');
            sb.append(rnum);
            rbnds[bidx] = rnum;
        } else if (rbnds[bidx] > 0) {
            final int rnum = rbnds[bidx];
            releaseRingNumber(rnum);
            if (rnum > 9)
                sb.append('%');
            sb.append(rnum);
        }
        if (mode == MODE_EXACT && avisit[nbr] == 0 || bidx == bprev || rbnds[bidx] != 0)
            remain--;
    }
    for (int j = 0; j < d; j++) {
        int nbr = atomAdj[idx][j];
        int bidx = bondAdj[idx][j];
        if (mode == MODE_EXACT && avisit[nbr] == 0 || bidx == bprev || rbnds[bidx] != 0)
            continue;
        remain--;
        if (avisit[nbr] == 0) {
            if (remain > 0)
                sb.append('(');
            sb.append(bexpr[bidx]);
            sb.append(mol.getAtom(nbr).isAromatic() ? 'a' : '*');
            if (remain > 0)
                sb.append(')');
        } else {
            if (remain > 0)
                sb.append('(');
            sb.append(bexpr[bidx]);
            encodeExpr(nbr, bidx, sb);
            if (remain > 0)
                sb.append(')');
        }
    }
}","private void encodeExpr(int idx, int bprev, StringBuilder sb){
    avisit[idx] = numVisit++;
    sb.append(aexpr[idx]);
    final int d = deg[idx];
    int remain = d;
    for (int j = 0; j < d; j++) {
        int nbr = atomAdj[idx][j];
        int bidx = bondAdj[idx][j];
        if (rbnds[bidx] < 0) {
            final int rnum = chooseRingNumber();
            if (rnum > 9)
                sb.append('%');
            sb.append(rnum);
            rbnds[bidx] = rnum;
        } else if (rbnds[bidx] > 0) {
            final int rnum = rbnds[bidx];
            releaseRingNumber(rnum);
            if (rnum > 9)
                sb.append('%');
            sb.append(rnum);
        }
        if (mode == MODE_EXACT && avisit[nbr] == 0 || bidx == bprev || rbnds[bidx] != 0)
            remain--;
    }
    for (int j = 0; j < d; j++) {
        int nbr = atomAdj[idx][j];
        int bidx = bondAdj[idx][j];
        if (mode == MODE_EXACT && avisit[nbr] == 0 || bidx == bprev || rbnds[bidx] != 0)
            continue;
        remain--;
        if (avisit[nbr] == 0) {
            if (remain > 0)
                sb.append('(');
            sb.append(bexpr[bidx]);
            sb.append(mol.getAtom(nbr).isAromatic() ? 'a' : '*');
            if (remain > 0)
                sb.append(')');
        } else {
            if (remain > 0)
                sb.append('(');
            sb.append(bexpr[bidx]);
            encodeExpr(nbr, bidx, sb);
            if (remain > 0)
                sb.append(')');
        }
    }
}","/**
     * Recursively encodes a SMARTS expression into the provides
     * string builder.
     *
     * @param idx   atom index
     * @param bprev previous bond
     * @param sb    destition to write SMARTS to
     */","('encodeExpr', {'INSTRUCTION': {'covered': 215, 'missed': 0}, 'BRANCH': {'covered': 40, 'missed': 0}, 'LINE': {'covered': 35, 'missed': 0}, 'COMPLEXITY': {'covered': 21, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",386.0,  Recursively encodes a SMARTS expression into the provides  string builder.,11.0,"['The provides string builder contains a SMARTS expression.', 'The provides string builder has a SMARTS expression in it.', 'The provides string builder has a SMARTS expression.']"
1049,matsim-libs,playground/vsp/andreas/osmBB/PTCountsNetworkSimplifier.java,/contribs/vsp/src/main/java/playground/vsp/andreas/osmBB/PTCountsNetworkSimplifier.java,checkNodeIsMarkedAsCountStation,354-408,"/**
	 * Check whether the node is marked as count station. If that is the case, migrate its count data to outCounts and mark it as non modifiable
	 * @param node The node to be checked
	 */
private void checkNodeIsMarkedAsCountStation(Node node){
    Link linkToBlock = null;
    if (this.shortNameMap.keySet().contains(node.getId().toString())) {
        // node is marked as count station
        if (node.getInLinks().size() == 1 && node.getOutLinks().size() == 1) {
            // ok, node has one in and one outLink, so put the count station on the shorter one and block it
            // Prefer the inLink, if both have the same length
            for (Link inLink : node.getInLinks().values()) {
                for (Link outLink : node.getOutLinks().values()) {
                    if (inLink.getLength() > outLink.getLength()) {
                        linkToBlock = outLink;
                    } else {
                        linkToBlock = inLink;
                    }
                    break;
                }
                break;
            }
            // check, if count data is present
            Id<Link> shortNameId = Id.create(this.shortNameMap.get(node.getId().toString()), Link.class);
            if (this.outCounts.getCount(shortNameId) == null) {
                // Count station wasn't added to outCounts, yet
                Count<Link> oldCount = this.inCounts.getCount(shortNameId);
                if (oldCount == null) {
                    // count station was mapped, but data can not be provided, do nothing
                    // TODO [AN] Check, if linkToBlock can be removed
                } else {
                    // create new count with correct locId and migrate data
                    if (linkToBlock != null) {
                        this.outCounts.createAndAddCount(linkToBlock.getId(), oldCount.getCsLabel());
                        Count<Link> newCount = this.outCounts.getCount(linkToBlock.getId());
                        newCount.setCoord(oldCount.getCoord());
                        for (Volume volume : oldCount.getVolumes().values()) {
                            newCount.createVolume(volume.getHourOfDayStartingWithOne(), volume.getValue());
                        }
                    }
                }
            } else {
                // count station was already processed and moved to outCounts
            }
        } else {
            log.warn(""Count station "" + this.shortNameMap.get(node.getId().toString()) + "" is registerd to node "" + node.getId().toString() + "" which has "" + node.getInLinks().size() + "" inLinks and "" + node.getOutLinks().size() + "" outLinks. Can only map one to one. Removing count station from counts data."");
        }
    }
    // everything worked fine, check if a link was blocked
    if (linkToBlock != null) {
        this.linksBlockedByFacility.add(linkToBlock.getId().toString());
    }
}","private void checkNodeIsMarkedAsCountStation(Node node){
    Link linkToBlock = null;
    if (this.shortNameMap.keySet().contains(node.getId().toString())) {
        // node is marked as count station
        if (node.getInLinks().size() == 1 && node.getOutLinks().size() == 1) {
            // ok, node has one in and one outLink, so put the count station on the shorter one and block it
            // Prefer the inLink, if both have the same length
            for (Link inLink : node.getInLinks().values()) {
                for (Link outLink : node.getOutLinks().values()) {
                    if (inLink.getLength() > outLink.getLength()) {
                        linkToBlock = outLink;
                    } else {
                        linkToBlock = inLink;
                    }
                    break;
                }
                break;
            }
            // check, if count data is present
            Id<Link> shortNameId = Id.create(this.shortNameMap.get(node.getId().toString()), Link.class);
            if (this.outCounts.getCount(shortNameId) == null) {
                // Count station wasn't added to outCounts, yet
                Count<Link> oldCount = this.inCounts.getCount(shortNameId);
                if (oldCount == null) {
                    // count station was mapped, but data can not be provided, do nothing
                    // TODO [AN] Check, if linkToBlock can be removed
                } else {
                    // create new count with correct locId and migrate data
                    if (linkToBlock != null) {
                        this.outCounts.createAndAddCount(linkToBlock.getId(), oldCount.getCsLabel());
                        Count<Link> newCount = this.outCounts.getCount(linkToBlock.getId());
                        newCount.setCoord(oldCount.getCoord());
                        for (Volume volume : oldCount.getVolumes().values()) {
                            newCount.createVolume(volume.getHourOfDayStartingWithOne(), volume.getValue());
                        }
                    }
                }
            } else {
                // count station was already processed and moved to outCounts
            }
        } else {
            log.warn(""Count station "" + this.shortNameMap.get(node.getId().toString()) + "" is registerd to node "" + node.getId().toString() + "" which has "" + node.getInLinks().size() + "" inLinks and "" + node.getOutLinks().size() + "" outLinks. Can only map one to one. Removing count station from counts data."");
        }
    }
    // everything worked fine, check if a link was blocked
    if (linkToBlock != null) {
        this.linksBlockedByFacility.add(linkToBlock.getId().toString());
    }
}","/**
	 * Check whether the node is marked as count station. If that is the case, migrate its count data to outCounts and mark it as non modifiable
	 * @param node The node to be checked
	 */","('checkNodeIsMarkedAsCountStation', {'INSTRUCTION': {'covered': 146, 'missed': 4}, 'BRANCH': {'covered': 15, 'missed': 7}, 'LINE': {'covered': 25, 'missed': 1}, 'COMPLEXITY': {'covered': 5, 'missed': 7}, 'METHOD': {'covered': 1, 'missed': 0}})",389.0,  Check whether the node is marked as count station.,10.0,"['The count station is marked on the side of the building.', 'The count station is marked by the node being marked as a count station.', 'The count station is marked on the side of the house.']"
1050,acs-aem-commons,com/adobe/acs/commons/hc/impl/HealthCheckStatusEmailer.java,/bundle/src/main/java/com/adobe/acs/commons/hc/impl/HealthCheckStatusEmailer.java,sendEmail,218-260,"/**
     * Creates the e-mail template parameter map and invokes the OSGi E-Mail Service.
     *
     * @param success the list of successful Health Check Execution Results
     * @param failure the list of unsuccessful Health Check Execution Results
     * @param timeTaken the time taken to execute all Health Checks
     */
protected final void sendEmail(final List<HealthCheckExecutionResult> success, final List<HealthCheckExecutionResult> failure, final long timeTaken){
    final ProductInfo[] productInfos = productInfoService.getInfos();
    final String hostname = getHostname();
    final Map<String, String> emailParams = new HashMap<>();
    emailParams.put(""subject"", String.format(""%s [ %d Failures ] [ %d Success ] [ %s ]"", emailSubject, failure.size(), success.size(), hostname));
    emailParams.put(""failure"", resultToPlainText(""Failing Health Checks"", failure));
    emailParams.put(""success"", resultToPlainText(""Successful Health Checks"", success));
    emailParams.put(""executedAt"", Calendar.getInstance().getTime().toString());
    emailParams.put(""runModes"", StringUtils.join(slingSettingsService.getRunModes(), "", ""));
    emailParams.put(""mode"", ModeUtil.isAuthor() ? ""Author"" : ""Publish"");
    emailParams.put(""hostname"", hostname);
    emailParams.put(""timeTaken"", String.valueOf(timeTaken));
    if (productInfos.length == 1) {
        emailParams.put(""productName"", productInfos[0].getShortName());
        emailParams.put(""productVersion"", productInfos[0].getShortVersion());
    }
    emailParams.put(""successCount"", String.valueOf(success.size()));
    emailParams.put(""failureCount"", String.valueOf(failure.size()));
    emailParams.put(""totalCount"", String.valueOf(failure.size() + success.size()));
    if (ArrayUtils.isNotEmpty(recipientEmailAddresses)) {
        final List<String> failureList = emailService.sendEmail(emailTemplatePath, emailParams, recipientEmailAddresses);
        if (failureList.size() > 0) {
            log.warn(""Could not send health status check e-mails to recipients [ {} ]"", StringUtils.join(failureList, "", ""));
        } else {
            log.info(""Successfully sent Health Check email to [ {} ] recipients"", recipientEmailAddresses.length - failureList.size());
        }
    } else {
        log.warn(""No e-mail addresses provided to e-mail results of health checks. Either add the appropriate e-mail recipients or remove the health check status e-mail configuration entirely."");
    }
}","protected final void sendEmail(final List<HealthCheckExecutionResult> success, final List<HealthCheckExecutionResult> failure, final long timeTaken){
    final ProductInfo[] productInfos = productInfoService.getInfos();
    final String hostname = getHostname();
    final Map<String, String> emailParams = new HashMap<>();
    emailParams.put(""subject"", String.format(""%s [ %d Failures ] [ %d Success ] [ %s ]"", emailSubject, failure.size(), success.size(), hostname));
    emailParams.put(""failure"", resultToPlainText(""Failing Health Checks"", failure));
    emailParams.put(""success"", resultToPlainText(""Successful Health Checks"", success));
    emailParams.put(""executedAt"", Calendar.getInstance().getTime().toString());
    emailParams.put(""runModes"", StringUtils.join(slingSettingsService.getRunModes(), "", ""));
    emailParams.put(""mode"", ModeUtil.isAuthor() ? ""Author"" : ""Publish"");
    emailParams.put(""hostname"", hostname);
    emailParams.put(""timeTaken"", String.valueOf(timeTaken));
    if (productInfos.length == 1) {
        emailParams.put(""productName"", productInfos[0].getShortName());
        emailParams.put(""productVersion"", productInfos[0].getShortVersion());
    }
    emailParams.put(""successCount"", String.valueOf(success.size()));
    emailParams.put(""failureCount"", String.valueOf(failure.size()));
    emailParams.put(""totalCount"", String.valueOf(failure.size() + success.size()));
    if (ArrayUtils.isNotEmpty(recipientEmailAddresses)) {
        final List<String> failureList = emailService.sendEmail(emailTemplatePath, emailParams, recipientEmailAddresses);
        if (failureList.size() > 0) {
            log.warn(""Could not send health status check e-mails to recipients [ {} ]"", StringUtils.join(failureList, "", ""));
        } else {
            log.info(""Successfully sent Health Check email to [ {} ] recipients"", recipientEmailAddresses.length - failureList.size());
        }
    } else {
        log.warn(""No e-mail addresses provided to e-mail results of health checks. Either add the appropriate e-mail recipients or remove the health check status e-mail configuration entirely."");
    }
}","/**
     * Creates the e-mail template parameter map and invokes the OSGi E-Mail Service.
     *
     * @param success the list of successful Health Check Execution Results
     * @param failure the list of unsuccessful Health Check Execution Results
     * @param timeTaken the time taken to execute all Health Checks
     */","('sendEmail', {'INSTRUCTION': {'covered': 162, 'missed': 12}, 'BRANCH': {'covered': 4, 'missed': 4}, 'LINE': {'covered': 23, 'missed': 2}, 'COMPLEXITY': {'covered': 1, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",389.0,  Creates the e-mail template parameter map and invokes the OSGi E-Mail Service.,13.0,"['The OSGi E-Mail Service is invoked when the e-mail template parameters map is created.', 'The OSGi E-Mail Service is invoked after the creation of the e-mail template parameters map.', 'The OSGi E-Mail Service is invoked after the creation of the e-mail template.']"
1051,cdk,org/openscience/cdk/qsar/descriptors/molecular/CarbonTypesDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/CarbonTypesDescriptor.java,calculate,139-200,"/**
     * Calculates the 9 carbon types descriptors
     *
     * @param container Parameter is the atom container.
     * @return An ArrayList containing 9 elements in the order described above
     */
public DescriptorValue calculate(IAtomContainer container){
    int c1sp1 = 0;
    int c2sp1 = 0;
    int c1sp2 = 0;
    int c2sp2 = 0;
    int c3sp2 = 0;
    int c1sp3 = 0;
    int c2sp3 = 0;
    int c3sp3 = 0;
    int c4sp3 = 0;
    for (IAtom atom : container.atoms()) {
        if (atom.getAtomicNumber() != IElement.C)
            continue;
        List<IAtom> connectedAtoms = container.getConnectedAtomsList(atom);
        int cc = 0;
        for (IAtom connectedAtom : connectedAtoms) {
            if (connectedAtom.getAtomicNumber() == IElement.C)
                cc++;
        }
        IBond.Order maxBondOrder = getHighestBondOrder(container, atom);
        if (maxBondOrder == IBond.Order.TRIPLE && cc == 1)
            c1sp1++;
        else if (maxBondOrder == IBond.Order.TRIPLE && cc == 2)
            c2sp1++;
        else if (maxBondOrder == IBond.Order.DOUBLE && cc == 1)
            c1sp2++;
        else if (maxBondOrder == IBond.Order.DOUBLE && cc == 2)
            c2sp2++;
        else if (maxBondOrder == IBond.Order.DOUBLE && cc == 3)
            c3sp2++;
        else if (maxBondOrder == IBond.Order.SINGLE && cc == 1)
            c1sp3++;
        else if (maxBondOrder == IBond.Order.SINGLE && cc == 2)
            c2sp3++;
        else if (maxBondOrder == IBond.Order.SINGLE && cc == 3)
            c3sp3++;
        else if (maxBondOrder == IBond.Order.SINGLE && cc == 4)
            c4sp3++;
    }
    IntegerArrayResult retval = new IntegerArrayResult(9);
    retval.add(c1sp1);
    retval.add(c2sp1);
    retval.add(c1sp2);
    retval.add(c2sp2);
    retval.add(c3sp2);
    retval.add(c1sp3);
    retval.add(c2sp3);
    retval.add(c3sp3);
    retval.add(c4sp3);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), retval, getDescriptorNames());
}","public DescriptorValue calculate(IAtomContainer container){
    int c1sp1 = 0;
    int c2sp1 = 0;
    int c1sp2 = 0;
    int c2sp2 = 0;
    int c3sp2 = 0;
    int c1sp3 = 0;
    int c2sp3 = 0;
    int c3sp3 = 0;
    int c4sp3 = 0;
    for (IAtom atom : container.atoms()) {
        if (atom.getAtomicNumber() != IElement.C)
            continue;
        List<IAtom> connectedAtoms = container.getConnectedAtomsList(atom);
        int cc = 0;
        for (IAtom connectedAtom : connectedAtoms) {
            if (connectedAtom.getAtomicNumber() == IElement.C)
                cc++;
        }
        IBond.Order maxBondOrder = getHighestBondOrder(container, atom);
        if (maxBondOrder == IBond.Order.TRIPLE && cc == 1)
            c1sp1++;
        else if (maxBondOrder == IBond.Order.TRIPLE && cc == 2)
            c2sp1++;
        else if (maxBondOrder == IBond.Order.DOUBLE && cc == 1)
            c1sp2++;
        else if (maxBondOrder == IBond.Order.DOUBLE && cc == 2)
            c2sp2++;
        else if (maxBondOrder == IBond.Order.DOUBLE && cc == 3)
            c3sp2++;
        else if (maxBondOrder == IBond.Order.SINGLE && cc == 1)
            c1sp3++;
        else if (maxBondOrder == IBond.Order.SINGLE && cc == 2)
            c2sp3++;
        else if (maxBondOrder == IBond.Order.SINGLE && cc == 3)
            c3sp3++;
        else if (maxBondOrder == IBond.Order.SINGLE && cc == 4)
            c4sp3++;
    }
    IntegerArrayResult retval = new IntegerArrayResult(9);
    retval.add(c1sp1);
    retval.add(c2sp1);
    retval.add(c1sp2);
    retval.add(c2sp2);
    retval.add(c3sp2);
    retval.add(c1sp3);
    retval.add(c2sp3);
    retval.add(c3sp3);
    retval.add(c4sp3);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), retval, getDescriptorNames());
}","/**
     * Calculates the 9 carbon types descriptors
     *
     * @param container Parameter is the atom container.
     * @return An ArrayList containing 9 elements in the order described above
     */","('calculate', {'INSTRUCTION': {'covered': 179, 'missed': 1}, 'BRANCH': {'covered': 37, 'missed': 7}, 'LINE': {'covered': 47, 'missed': 0}, 'COMPLEXITY': {'covered': 16, 'missed': 7}, 'METHOD': {'covered': 1, 'missed': 0}})",391.0,Calculates the 9 carbon types descriptors   @param container Parameter is the atom container.,15.0,"['The 9 carbon types are calculated using the atom container.', 'The 9 carbon types are calculated using the atom container as the input.', 'The 9 carbon types are calculated by using the atom container as a reference.']"
1052,logstash-logback-encoder,net/logstash/logback/appender/WaitStrategyFactory.java,/src/main/java/net/logstash/logback/appender/WaitStrategyFactory.java,createWaitStrategyFromString,41-136,"/**
     * Creates a {@link WaitStrategy} from a string.
     * <p>
     * The following strategies are supported:
     * <ul>
     * <li><code>blocking</code> - {@link BlockingWaitStrategy}</li>
     * <li><code>busySpin</code> - {@link BusySpinWaitStrategy}</li>
     * <li><code>liteBlocking</code> - {@link LiteBlockingWaitStrategy}</li>
     * <li><code>sleeping{retries,sleepTimeNs}</code> - {@link SleepingWaitStrategy}
     *         - <code>retries</code> an integer number of times to spin before sleeping. (default = 200)
     *           <code>sleepTimeNs</code> nanosecond time to sleep each iteration after spinning (default = 100)
     * </li>
     * <li><code>yielding</code> - {@link YieldingWaitStrategy}</li>
     * <li><code>phasedBackoff{spinTimeout,yieldTimeout,timeUnit,fallackStrategy}</code> - {@link PhasedBackoffWaitStrategy}
     *         - <code>spinTimeout</code> and <code>yieldTimeout</code> are long values.
     *           <code>timeUnit</code> is a string name of one of the {@link TimeUnit} values.
     *           <code>fallbackStrategy</code> is a wait strategy string (e.g. <code>blocking</code>).
     * </li>
     * <li><code>timeoutBlocking{timeout,timeUnit}</code> - {@link TimeoutBlockingWaitStrategy}
     *         - <code>timeout</code> is a long value.
     *           <code>timeUnit</code> is a string name of one of the {@link TimeUnit} values.
     * </li>
     * <li><code>liteTimeoutBlocking{timeout,timeUnit}</code> - {@link LiteTimeoutBlockingWaitStrategy}
     *         - <code>timeout</code> is a long value.
     *           <code>timeUnit</code> is a string name of one of the {@link TimeUnit} values.
     * </li>
     * </ul>
     *
     * @param waitStrategyType the name of the desired wait strategy
     * @return a {@link WaitStrategy} instance or {@code null} if the supplied name is {@code null} or empty
     * @throws IllegalArgumentException if an unknown wait strategy type is given, or the parameters are unable to be parsed.
     */
public static WaitStrategy createWaitStrategyFromString(String waitStrategyType){
    if (waitStrategyType == null) {
        return null;
    }
    waitStrategyType = waitStrategyType.trim().toLowerCase();
    if (waitStrategyType.isEmpty()) {
        return null;
    }
    if (waitStrategyType.equals(""blocking"")) {
        return new BlockingWaitStrategy();
    }
    if (waitStrategyType.equals(""busyspin"")) {
        return new BusySpinWaitStrategy();
    }
    if (waitStrategyType.equals(""liteblocking"")) {
        return new LiteBlockingWaitStrategy();
    }
    if (waitStrategyType.startsWith(""sleeping"")) {
        if (waitStrategyType.equals(""sleeping"")) {
            return new SleepingWaitStrategy();
        } else {
            List<Object> params = parseParams(waitStrategyType, Integer.class, Long.class);
            return new SleepingWaitStrategy((Integer) params.get(0), (Long) params.get(1));
        }
    }
    if (waitStrategyType.equals(""yielding"")) {
        return new YieldingWaitStrategy();
    }
    if (waitStrategyType.startsWith(""phasedbackoff"")) {
        List<Object> params = parseParams(waitStrategyType, Long.class, Long.class, TimeUnit.class, WaitStrategy.class);
        return new PhasedBackoffWaitStrategy((Long) params.get(0), (Long) params.get(1), (TimeUnit) params.get(2), (WaitStrategy) params.get(3));
    }
    if (waitStrategyType.startsWith(""timeoutblocking"")) {
        List<Object> params = parseParams(waitStrategyType, Long.class, TimeUnit.class);
        return new TimeoutBlockingWaitStrategy((Long) params.get(0), (TimeUnit) params.get(1));
    }
    if (waitStrategyType.startsWith(""litetimeoutblocking"")) {
        List<Object> params = parseParams(waitStrategyType, Long.class, TimeUnit.class);
        return new LiteTimeoutBlockingWaitStrategy((Long) params.get(0), (TimeUnit) params.get(1));
    }
    throw new IllegalArgumentException(""Unknown wait strategy type: "" + waitStrategyType);
}","public static WaitStrategy createWaitStrategyFromString(String waitStrategyType){
    if (waitStrategyType == null) {
        return null;
    }
    waitStrategyType = waitStrategyType.trim().toLowerCase();
    if (waitStrategyType.isEmpty()) {
        return null;
    }
    if (waitStrategyType.equals(""blocking"")) {
        return new BlockingWaitStrategy();
    }
    if (waitStrategyType.equals(""busyspin"")) {
        return new BusySpinWaitStrategy();
    }
    if (waitStrategyType.equals(""liteblocking"")) {
        return new LiteBlockingWaitStrategy();
    }
    if (waitStrategyType.startsWith(""sleeping"")) {
        if (waitStrategyType.equals(""sleeping"")) {
            return new SleepingWaitStrategy();
        } else {
            List<Object> params = parseParams(waitStrategyType, Integer.class, Long.class);
            return new SleepingWaitStrategy((Integer) params.get(0), (Long) params.get(1));
        }
    }
    if (waitStrategyType.equals(""yielding"")) {
        return new YieldingWaitStrategy();
    }
    if (waitStrategyType.startsWith(""phasedbackoff"")) {
        List<Object> params = parseParams(waitStrategyType, Long.class, Long.class, TimeUnit.class, WaitStrategy.class);
        return new PhasedBackoffWaitStrategy((Long) params.get(0), (Long) params.get(1), (TimeUnit) params.get(2), (WaitStrategy) params.get(3));
    }
    if (waitStrategyType.startsWith(""timeoutblocking"")) {
        List<Object> params = parseParams(waitStrategyType, Long.class, TimeUnit.class);
        return new TimeoutBlockingWaitStrategy((Long) params.get(0), (TimeUnit) params.get(1));
    }
    if (waitStrategyType.startsWith(""litetimeoutblocking"")) {
        List<Object> params = parseParams(waitStrategyType, Long.class, TimeUnit.class);
        return new LiteTimeoutBlockingWaitStrategy((Long) params.get(0), (TimeUnit) params.get(1));
    }
    throw new IllegalArgumentException(""Unknown wait strategy type: "" + waitStrategyType);
}","/**
     * Creates a {@link WaitStrategy} from a string.
     * <p>
     * The following strategies are supported:
     * <ul>
     * <li><code>blocking</code> - {@link BlockingWaitStrategy}</li>
     * <li><code>busySpin</code> - {@link BusySpinWaitStrategy}</li>
     * <li><code>liteBlocking</code> - {@link LiteBlockingWaitStrategy}</li>
     * <li><code>sleeping{retries,sleepTimeNs}</code> - {@link SleepingWaitStrategy}
     *         - <code>retries</code> an integer number of times to spin before sleeping. (default = 200)
     *           <code>sleepTimeNs</code> nanosecond time to sleep each iteration after spinning (default = 100)
     * </li>
     * <li><code>yielding</code> - {@link YieldingWaitStrategy}</li>
     * <li><code>phasedBackoff{spinTimeout,yieldTimeout,timeUnit,fallackStrategy}</code> - {@link PhasedBackoffWaitStrategy}
     *         - <code>spinTimeout</code> and <code>yieldTimeout</code> are long values.
     *           <code>timeUnit</code> is a string name of one of the {@link TimeUnit} values.
     *           <code>fallbackStrategy</code> is a wait strategy string (e.g. <code>blocking</code>).
     * </li>
     * <li><code>timeoutBlocking{timeout,timeUnit}</code> - {@link TimeoutBlockingWaitStrategy}
     *         - <code>timeout</code> is a long value.
     *           <code>timeUnit</code> is a string name of one of the {@link TimeUnit} values.
     * </li>
     * <li><code>liteTimeoutBlocking{timeout,timeUnit}</code> - {@link LiteTimeoutBlockingWaitStrategy}
     *         - <code>timeout</code> is a long value.
     *           <code>timeUnit</code> is a string name of one of the {@link TimeUnit} values.
     * </li>
     * </ul>
     *
     * @param waitStrategyType the name of the desired wait strategy
     * @return a {@link WaitStrategy} instance or {@code null} if the supplied name is {@code null} or empty
     * @throws IllegalArgumentException if an unknown wait strategy type is given, or the parameters are unable to be parsed.
     */","('createWaitStrategyFromString', {'INSTRUCTION': {'covered': 191, 'missed': 12}, 'BRANCH': {'covered': 21, 'missed': 1}, 'LINE': {'covered': 37, 'missed': 1}, 'COMPLEXITY': {'covered': 11, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",391.0,  Creates a {@link WaitStrategy} from a string.,11.0,"['A @link WaitStrategy is created from a string.', 'A @link WaitStrategy is created from a string', 'From a string, creates a WaitStrategy.']"
1053,egeria,org/odpi/openmetadata/accessservices/assetcatalog/handlers/AssetCatalogHandler.java,/open-metadata-implementation/access-services/asset-catalog/asset-catalog-server/src/main/java/org/odpi/openmetadata/accessservices/assetcatalog/handlers/AssetCatalogHandler.java,searchByType,367-431,"/**
     * @param userId           user identifier that issues the call
     * @param searchCriteria   search criteria string used for finding the entities
     * @param searchParameters additional parameters for searching and filtering
     * @return a list of matching criteria entities
     * @throws org.odpi.openmetadata.repositoryservices.ffdc.exception.UserNotAuthorizedException - is thrown by an OMRS Connector when the supplied UserId
     *                                                                                            is not permitted to perform a specific operation on the metadata collection.
     * @throws FunctionNotSupportedException                                                      - provides a checked exception for reporting that an
     *                                                                                            OMRS repository connector does not support the method called
     * @throws org.odpi.openmetadata.repositoryservices.ffdc.exception.InvalidParameterException  - is thrown by an OMRS Connector when the parameters passed to a repository connector are not valid
     * @throws PropertyErrorException                                                             - is thrown by an OMRS Connector when the properties defined for a specific entity
     *                                                                                            or relationship instance do not match the TypeDefs for the metadata collection.
     * @throws TypeErrorException                                                                 - is thrown by an OMRS Connector when the requested type for an instance is not represented by a known TypeDef.
     * @throws PagingErrorException                                                               - is thrown by an OMRS Connector when the caller has passed invalid paging attributes on a search call.
     * @throws InvalidParameterException                                                          - is thrown by the OMAG Service when a parameter is null or an invalid value.
     * @throws RepositoryErrorException                                                           - there is a problem communicating with the metadata repository.
     */
public List<Elements> searchByType(String userId, String searchCriteria, SearchParameters searchParameters) throws org.odpi.openmetadata.repositoryservices.ffdc.exception.UserNotAuthorizedException, FunctionNotSupportedException, org.odpi.openmetadata.repositoryservices.ffdc.exception.InvalidParameterException, PropertyErrorException, TypeErrorException, PagingErrorException, InvalidParameterException, RepositoryErrorException, EntityNotKnownException{
    String methodName = ""searchByType"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateSearchString(userId, searchCriteria, methodName);
    invalidParameterHandler.validateObject(searchParameters, SEARCH_PARAMETER, methodName);
    invalidParameterHandler.validatePaging(searchParameters.getFrom(), searchParameters.getPageSize(), methodName);
    List<EntityDetail> result;
    List<String> typesFilter;
    if (CollectionUtils.isNotEmpty(searchParameters.getEntityTypes())) {
        typesFilter = commonHandler.getTypesGUID(userId, searchParameters.getEntityTypes());
        if (CollectionUtils.isEmpty(typesFilter)) {
            ExceptionMessageDefinition messageDefinition = AssetCatalogErrorCode.TYPE_DEF_NOT_FOUND.getMessageDefinition();
            throw new EntityNotKnownException(messageDefinition, this.getClass().getName(), messageDefinition.getUserAction());
        }
        result = collectSearchedEntitiesByType(userId, searchCriteria, searchParameters, typesFilter);
    } else {
        result = collectSearchedEntitiesByType(userId, searchCriteria, searchParameters, defaultSearchTypes);
    }
    Set<Elements> searchResults = new HashSet<>();
    for (EntityDetail entityDetail : result) {
        try {
            invalidParameterHandler.validateAssetInSupportedZone(entityDetail.getGUID(), GUID_PARAMETER, commonHandler.getAssetZoneMembership(entityDetail.getClassifications()), supportedZones, serverUserName, methodName);
            Elements elements = assetCatalogConverter.buildAssetElements(entityDetail);
            searchResults.add(elements);
        } catch (org.odpi.openmetadata.commonservices.ffdc.exceptions.InvalidParameterException e) {
            log.debug(THIS_ASSET_IF_A_DIFFERENT_ZONE, entityDetail.getGUID());
        }
    }
    SequencingOrder sequencingOrder = searchParameters.getSequencingOrder();
    String sequencingProperty = searchParameters.getSequencingProperty();
    List<Elements> results = new ArrayList<>(searchResults);
    results.sort((firstAsset, secondAsset) -> orderElements(firstAsset, secondAsset, sequencingProperty, sequencingOrder));
    return results;
}","public List<Elements> searchByType(String userId, String searchCriteria, SearchParameters searchParameters) throws org.odpi.openmetadata.repositoryservices.ffdc.exception.UserNotAuthorizedException, FunctionNotSupportedException, org.odpi.openmetadata.repositoryservices.ffdc.exception.InvalidParameterException, PropertyErrorException, TypeErrorException, PagingErrorException, InvalidParameterException, RepositoryErrorException, EntityNotKnownException{
    String methodName = ""searchByType"";
    invalidParameterHandler.validateUserId(userId, methodName);
    invalidParameterHandler.validateSearchString(userId, searchCriteria, methodName);
    invalidParameterHandler.validateObject(searchParameters, SEARCH_PARAMETER, methodName);
    invalidParameterHandler.validatePaging(searchParameters.getFrom(), searchParameters.getPageSize(), methodName);
    List<EntityDetail> result;
    List<String> typesFilter;
    if (CollectionUtils.isNotEmpty(searchParameters.getEntityTypes())) {
        typesFilter = commonHandler.getTypesGUID(userId, searchParameters.getEntityTypes());
        if (CollectionUtils.isEmpty(typesFilter)) {
            ExceptionMessageDefinition messageDefinition = AssetCatalogErrorCode.TYPE_DEF_NOT_FOUND.getMessageDefinition();
            throw new EntityNotKnownException(messageDefinition, this.getClass().getName(), messageDefinition.getUserAction());
        }
        result = collectSearchedEntitiesByType(userId, searchCriteria, searchParameters, typesFilter);
    } else {
        result = collectSearchedEntitiesByType(userId, searchCriteria, searchParameters, defaultSearchTypes);
    }
    Set<Elements> searchResults = new HashSet<>();
    for (EntityDetail entityDetail : result) {
        try {
            invalidParameterHandler.validateAssetInSupportedZone(entityDetail.getGUID(), GUID_PARAMETER, commonHandler.getAssetZoneMembership(entityDetail.getClassifications()), supportedZones, serverUserName, methodName);
            Elements elements = assetCatalogConverter.buildAssetElements(entityDetail);
            searchResults.add(elements);
        } catch (org.odpi.openmetadata.commonservices.ffdc.exceptions.InvalidParameterException e) {
            log.debug(THIS_ASSET_IF_A_DIFFERENT_ZONE, entityDetail.getGUID());
        }
    }
    SequencingOrder sequencingOrder = searchParameters.getSequencingOrder();
    String sequencingProperty = searchParameters.getSequencingProperty();
    List<Elements> results = new ArrayList<>(searchResults);
    results.sort((firstAsset, secondAsset) -> orderElements(firstAsset, secondAsset, sequencingProperty, sequencingOrder));
    return results;
}","/**
     * @param userId           user identifier that issues the call
     * @param searchCriteria   search criteria string used for finding the entities
     * @param searchParameters additional parameters for searching and filtering
     * @return a list of matching criteria entities
     * @throws org.odpi.openmetadata.repositoryservices.ffdc.exception.UserNotAuthorizedException - is thrown by an OMRS Connector when the supplied UserId
     *                                                                                            is not permitted to perform a specific operation on the metadata collection.
     * @throws FunctionNotSupportedException                                                      - provides a checked exception for reporting that an
     *                                                                                            OMRS repository connector does not support the method called
     * @throws org.odpi.openmetadata.repositoryservices.ffdc.exception.InvalidParameterException  - is thrown by an OMRS Connector when the parameters passed to a repository connector are not valid
     * @throws PropertyErrorException                                                             - is thrown by an OMRS Connector when the properties defined for a specific entity
     *                                                                                            or relationship instance do not match the TypeDefs for the metadata collection.
     * @throws TypeErrorException                                                                 - is thrown by an OMRS Connector when the requested type for an instance is not represented by a known TypeDef.
     * @throws PagingErrorException                                                               - is thrown by an OMRS Connector when the caller has passed invalid paging attributes on a search call.
     * @throws InvalidParameterException                                                          - is thrown by the OMAG Service when a parameter is null or an invalid value.
     * @throws RepositoryErrorException                                                           - there is a problem communicating with the metadata repository.
     */","('searchByType', {'INSTRUCTION': {'covered': 125, 'missed': 14}, 'BRANCH': {'covered': 5, 'missed': 1}, 'LINE': {'covered': 24, 'missed': 3}, 'COMPLEXITY': {'covered': 3, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",392.0,  @param userId user identifier that issues the call  @param searchCriteria search criteria string used for finding the entities  @param searchParameters additional parameters for searching and filtering  @return a list of matching criteria entities  @throws org.,41.0,"['The user id is used to issue the call to the search criteria string.', 'The user id is used to issue the call to the searchCriteria string used for finding the entities.', 'The user id is used to issue the call to the searchCriteria string used to find the entities.']"
1054,cdk,org/openscience/cdk/layout/AtomPlacer.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/AtomPlacer.java,breadthFirstSearch,659-718,"/**
     *  Performs a breadthFirstSearch in an AtomContainer starting with a
     *  particular sphere, which usually consists of one start atom, and searches
     *  for the longest aliphatic chain which is yet unplaced. If the search
     *  encounters an unplaced ring atom, it is also appended to the chain so that
     *  this last bond of the chain can also be laid out. This gives us the
     *  orientation for the attachment of the ring system.
     *
     *@param  ac                                              The AtomContainer to
     *      be searched
     *@param  sphere                                          A sphere of atoms to
     *      start the search with
     *@param  pathes                                          A vector of N pathes
     *      (N = no of heavy atoms).
     *@exception  org.openscience.cdk.exception.CDKException  Description of the
     *      Exception
     */
public static void breadthFirstSearch(IAtomContainer ac, List<IAtom> sphere, IAtomContainer[] pathes) throws CDKException{
    IAtom atom = null;
    IAtom nextAtom = null;
    int atomNr;
    int nextAtomNr;
    List<IAtom> newSphere = new ArrayList<IAtom>();
    logger.debug(""Start of breadthFirstSearch"");
    for (int f = 0; f < sphere.size(); f++) {
        atom = sphere.get(f);
        if (!atom.getFlag(CDKConstants.ISINRING)) {
            atomNr = ac.indexOf(atom);
            logger.debug(""BreadthFirstSearch around atom "" + (atomNr + 1));
            List bonds = ac.getConnectedBondsList(atom);
            for (int g = 0; g < bonds.size(); g++) {
                IBond curBond = (IBond) bonds.get(g);
                nextAtom = curBond.getOther(atom);
                if (!nextAtom.getFlag(CDKConstants.VISITED) && !nextAtom.getFlag(CDKConstants.ISPLACED)) {
                    nextAtomNr = ac.indexOf(nextAtom);
                    logger.debug(""BreadthFirstSearch is meeting new atom "" + (nextAtomNr + 1));
                    pathes[nextAtomNr] = ac.getBuilder().newInstance(IAtomContainer.class, pathes[atomNr]);
                    logger.debug(""Making copy of path "" + (atomNr + 1) + "" to form new path "" + (nextAtomNr + 1));
                    pathes[nextAtomNr].addAtom(nextAtom);
                    logger.debug(""Adding atom "" + (nextAtomNr + 1) + "" to path "" + (nextAtomNr + 1));
                    pathes[nextAtomNr].addBond(curBond);
                    if (ac.getConnectedBondsCount(nextAtom) > 1) {
                        newSphere.add(nextAtom);
                    }
                }
            }
        }
    }
    if (newSphere.size() > 0) {
        for (int f = 0; f < newSphere.size(); f++) {
            newSphere.get(f).setFlag(CDKConstants.VISITED, true);
        }
        breadthFirstSearch(ac, newSphere, pathes);
    }
    logger.debug(""End of breadthFirstSearch"");
}","public static void breadthFirstSearch(IAtomContainer ac, List<IAtom> sphere, IAtomContainer[] pathes) throws CDKException{
    IAtom atom = null;
    IAtom nextAtom = null;
    int atomNr;
    int nextAtomNr;
    List<IAtom> newSphere = new ArrayList<IAtom>();
    logger.debug(""Start of breadthFirstSearch"");
    for (int f = 0; f < sphere.size(); f++) {
        atom = sphere.get(f);
        if (!atom.getFlag(CDKConstants.ISINRING)) {
            atomNr = ac.indexOf(atom);
            logger.debug(""BreadthFirstSearch around atom "" + (atomNr + 1));
            List bonds = ac.getConnectedBondsList(atom);
            for (int g = 0; g < bonds.size(); g++) {
                IBond curBond = (IBond) bonds.get(g);
                nextAtom = curBond.getOther(atom);
                if (!nextAtom.getFlag(CDKConstants.VISITED) && !nextAtom.getFlag(CDKConstants.ISPLACED)) {
                    nextAtomNr = ac.indexOf(nextAtom);
                    logger.debug(""BreadthFirstSearch is meeting new atom "" + (nextAtomNr + 1));
                    pathes[nextAtomNr] = ac.getBuilder().newInstance(IAtomContainer.class, pathes[atomNr]);
                    logger.debug(""Making copy of path "" + (atomNr + 1) + "" to form new path "" + (nextAtomNr + 1));
                    pathes[nextAtomNr].addAtom(nextAtom);
                    logger.debug(""Adding atom "" + (nextAtomNr + 1) + "" to path "" + (nextAtomNr + 1));
                    pathes[nextAtomNr].addBond(curBond);
                    if (ac.getConnectedBondsCount(nextAtom) > 1) {
                        newSphere.add(nextAtom);
                    }
                }
            }
        }
    }
    if (newSphere.size() > 0) {
        for (int f = 0; f < newSphere.size(); f++) {
            newSphere.get(f).setFlag(CDKConstants.VISITED, true);
        }
        breadthFirstSearch(ac, newSphere, pathes);
    }
    logger.debug(""End of breadthFirstSearch"");
}","/**
     *  Performs a breadthFirstSearch in an AtomContainer starting with a
     *  particular sphere, which usually consists of one start atom, and searches
     *  for the longest aliphatic chain which is yet unplaced. If the search
     *  encounters an unplaced ring atom, it is also appended to the chain so that
     *  this last bond of the chain can also be laid out. This gives us the
     *  orientation for the attachment of the ring system.
     *
     *@param  ac                                              The AtomContainer to
     *      be searched
     *@param  sphere                                          A sphere of atoms to
     *      start the search with
     *@param  pathes                                          A vector of N pathes
     *      (N = no of heavy atoms).
     *@exception  org.openscience.cdk.exception.CDKException  Description of the
     *      Exception
     */","('breadthFirstSearch', {'INSTRUCTION': {'covered': 186, 'missed': 0}, 'BRANCH': {'covered': 16, 'missed': 0}, 'LINE': {'covered': 29, 'missed': 0}, 'COMPLEXITY': {'covered': 9, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",392.0,"  Performs a breadthFirstSearch in an AtomContainer starting with a  particular sphere, which usually consists of one start atom, and searches  for the longest aliphatic chain which is yet unplaced.",32.0,"['A broad first search in an atom container starts with a particular sphere and searches for the longest aliphatic chain which is yet unplace.', 'A broad first search in an atom container starts with a particular sphere and searches for the longest aliphatic chain which is yet un placed.', 'A broad first search in an atom container starts with a particular sphere, and searches for the longest aliphatic chain which is yet unplace.']"
1055,jeromq,org/zeromq/proto/ZPicture.java,/src/main/java/org/zeromq/proto/ZPicture.java,sendPicture,247-339,"/**
     * Queues a 'picture' message to the socket (or actor), so it can be sent.
     *
     * @param picture The picture is a string that defines the type of each frame.
     *                This makes it easy to send a complex multiframe message in
     *                one call. The picture can contain any of these characters,
     *                each corresponding to zero or one arguments:
     *
     *                <table>
     *                <caption> </caption>
     *                <tr><td>i = int  (stores signed integer)</td></tr>
     *                <tr><td>1 = byte (stores 8-bit unsigned integer)</td></tr>
     *                <tr><td>2 = int  (stores 16-bit unsigned integer)</td></tr>
     *                <tr><td>4 = long (stores 32-bit unsigned integer)</td></tr>
     *                <tr><td>8 = long (stores 64-bit unsigned integer)</td></tr>
     *                <tr><td>s = String</td></tr>
     *                <tr><td>b = byte[]</td></tr>
     *                <tr><td>c = byte[]</td></tr>
     *                <tr><td>f = ZFrame</td></tr>
     *                <tr><td>m = ZMsg (sends all frames in the ZMsg)<b>Has to be the last element of the picture</b></td></tr>
     *                <tr><td>z = sends zero-sized frame (0 arguments)</td></tr>
     *                </table>
     *                Note that s, b, f and m are encoded the same way and the choice is
     *                offered as a convenience to the sender, which may or may not already
     *                have data in a ZFrame or ZMsg. Does not change or take ownership of
     *                any arguments.
     *
     *                Also see {@link #recvPicture(Socket, String)}} how to recv a
     *                multiframe picture.
     * @param args    Arguments according to the picture
     * @return true if successful, false if sending failed for any reason
     */
public boolean sendPicture(Socket socket, String picture, Object... args){
    if (!FORMAT.matcher(picture).matches()) {
        throw new ZMQException(picture + "" is not in expected format "" + FORMAT.pattern(), ZError.EPROTO);
    }
    ZMsg msg = new ZMsg();
    for (int pictureIndex = 0, argIndex = 0; pictureIndex < picture.length(); pictureIndex++, argIndex++) {
        char pattern = picture.charAt(pictureIndex);
        switch(pattern) {
            case 'i':
                {
                    msg.add(String.format(""%d"", (int) args[argIndex]));
                    break;
                }
            case '1':
                {
                    msg.add(String.format(""%d"", (0xff) & (int) args[argIndex]));
                    break;
                }
            case '2':
                {
                    msg.add(String.format(""%d"", (0xffff) & (int) args[argIndex]));
                    break;
                }
            case '4':
                {
                    msg.add(String.format(""%d"", (0xffffffff) & (int) args[argIndex]));
                    break;
                }
            case '8':
                {
                    msg.add(String.format(""%d"", (long) args[argIndex]));
                    break;
                }
            case 's':
                {
                    msg.add((String) args[argIndex]);
                    break;
                }
            case 'b':
            case 'c':
                {
                    msg.add((byte[]) args[argIndex]);
                    break;
                }
            case 'f':
                {
                    msg.add((ZFrame) args[argIndex]);
                    break;
                }
            case 'm':
                {
                    ZMsg msgParm = (ZMsg) args[argIndex];
                    while (msgParm.size() > 0) {
                        msg.add(msgParm.pop());
                    }
                    break;
                }
            case 'z':
                {
                    msg.add((byte[]) null);
                    argIndex--;
                    break;
                }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    return msg.send(socket, false);
}","public boolean sendPicture(Socket socket, String picture, Object... args){
    if (!FORMAT.matcher(picture).matches()) {
        throw new ZMQException(picture + "" is not in expected format "" + FORMAT.pattern(), ZError.EPROTO);
    }
    ZMsg msg = new ZMsg();
    for (int pictureIndex = 0, argIndex = 0; pictureIndex < picture.length(); pictureIndex++, argIndex++) {
        char pattern = picture.charAt(pictureIndex);
        switch(pattern) {
            case 'i':
                {
                    msg.add(String.format(""%d"", (int) args[argIndex]));
                    break;
                }
            case '1':
                {
                    msg.add(String.format(""%d"", (0xff) & (int) args[argIndex]));
                    break;
                }
            case '2':
                {
                    msg.add(String.format(""%d"", (0xffff) & (int) args[argIndex]));
                    break;
                }
            case '4':
                {
                    msg.add(String.format(""%d"", (0xffffffff) & (int) args[argIndex]));
                    break;
                }
            case '8':
                {
                    msg.add(String.format(""%d"", (long) args[argIndex]));
                    break;
                }
            case 's':
                {
                    msg.add((String) args[argIndex]);
                    break;
                }
            case 'b':
            case 'c':
                {
                    msg.add((byte[]) args[argIndex]);
                    break;
                }
            case 'f':
                {
                    msg.add((ZFrame) args[argIndex]);
                    break;
                }
            case 'm':
                {
                    ZMsg msgParm = (ZMsg) args[argIndex];
                    while (msgParm.size() > 0) {
                        msg.add(msgParm.pop());
                    }
                    break;
                }
            case 'z':
                {
                    msg.add((byte[]) null);
                    argIndex--;
                    break;
                }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    return msg.send(socket, false);
}","/**
     * Queues a 'picture' message to the socket (or actor), so it can be sent.
     *
     * @param picture The picture is a string that defines the type of each frame.
     *                This makes it easy to send a complex multiframe message in
     *                one call. The picture can contain any of these characters,
     *                each corresponding to zero or one arguments:
     *
     *                <table>
     *                <caption> </caption>
     *                <tr><td>i = int  (stores signed integer)</td></tr>
     *                <tr><td>1 = byte (stores 8-bit unsigned integer)</td></tr>
     *                <tr><td>2 = int  (stores 16-bit unsigned integer)</td></tr>
     *                <tr><td>4 = long (stores 32-bit unsigned integer)</td></tr>
     *                <tr><td>8 = long (stores 64-bit unsigned integer)</td></tr>
     *                <tr><td>s = String</td></tr>
     *                <tr><td>b = byte[]</td></tr>
     *                <tr><td>c = byte[]</td></tr>
     *                <tr><td>f = ZFrame</td></tr>
     *                <tr><td>m = ZMsg (sends all frames in the ZMsg)<b>Has to be the last element of the picture</b></td></tr>
     *                <tr><td>z = sends zero-sized frame (0 arguments)</td></tr>
     *                </table>
     *                Note that s, b, f and m are encoded the same way and the choice is
     *                offered as a convenience to the sender, which may or may not already
     *                have data in a ZFrame or ZMsg. Does not change or take ownership of
     *                any arguments.
     *
     *                Also see {@link #recvPicture(Socket, String)}} how to recv a
     *                multiframe picture.
     * @param args    Arguments according to the picture
     * @return true if successful, false if sending failed for any reason
     */","('sendPicture', {'INSTRUCTION': {'covered': 183, 'missed': 16}, 'BRANCH': {'covered': 16, 'missed': 3}, 'LINE': {'covered': 29, 'missed': 1}, 'COMPLEXITY': {'covered': 13, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",400.0,"  Queues a 'picture' message to the socket (or actor), so it can be sent.",19.0,"['A picture message can be sent.', 'A picture message can be sent if it is queueed.', ""A picture message can be sent if it's queueed.""]"
1058,cdk,org/openscience/cdk/libio/jena/Convertor.java,/storage/iordf/src/main/java/org/openscience/cdk/libio/jena/Convertor.java,model2Molecule,306-357,"/**
     * Converts a {@link Model} into an {@link IAtomContainer} using the given {@link IChemObjectBuilder}.
     *
     * @param model RDF graph to deserialize into an {@link IAtomContainer}.
     * @param builder {@link IChemObjectBuilder} used to create new {@link IChemObject}s.
     * @return a {@link IAtomContainer} deserialized from the RDF graph.
     */
public static IAtomContainer model2Molecule(Model model, IChemObjectBuilder builder){
    ResIterator mols = model.listSubjectsWithProperty(RDF.type, CDK.MOLECULE);
    IAtomContainer mol = null;
    if (mols.hasNext()) {
        Resource rdfMol = mols.next();
        mol = builder.newInstance(IAtomContainer.class);
        Map<Resource, IAtom> rdfToCDKAtomMap = new HashMap<Resource, IAtom>();
        StmtIterator atoms = rdfMol.listProperties(CDK.HASATOM);
        while (atoms.hasNext()) {
            Resource rdfAtom = atoms.nextStatement().getResource();
            IAtom atom;
            if (rdfAtom.hasProperty(RDF.type, CDK.PSEUDOATOM)) {
                atom = builder.newInstance(IPseudoAtom.class);
                atom.setStereoParity(0);
                Statement label = rdfAtom.getProperty(CDK.HASLABEL);
                if (label != null)
                    ((IPseudoAtom) atom).setLabel(label.getString());
            } else {
                atom = builder.newInstance(IAtom.class);
            }
            Statement symbol = rdfAtom.getProperty(CDK.SYMBOL);
            if (symbol != null)
                atom.setSymbol(symbol.getString());
            rdfToCDKAtomMap.put(rdfAtom, atom);
            deserializeAtomTypeFields(rdfAtom, atom);
            mol.addAtom(atom);
        }
        StmtIterator bonds = rdfMol.listProperties(CDK.HASBOND);
        while (bonds.hasNext()) {
            Resource rdfBond = bonds.nextStatement().getResource();
            IBond bond = builder.newInstance(IBond.class);
            StmtIterator bondAtoms = rdfBond.listProperties(CDK.BINDSATOM);
            int atomCounter = 0;
            while (bondAtoms.hasNext()) {
                Statement rdfAtom = bondAtoms.nextStatement();
                IAtom atom = rdfToCDKAtomMap.get(rdfAtom.getResource());
                bond.setAtom(atom, atomCounter);
                atomCounter++;
            }
            Resource order = rdfBond.getProperty(CDK.HASORDER).getResource();
            bond.setOrder(resource2Order(order));
            mol.addBond(bond);
            deserializeElectronContainerFields(rdfBond, bond);
        }
    }
    return mol;
}","public static IAtomContainer model2Molecule(Model model, IChemObjectBuilder builder){
    ResIterator mols = model.listSubjectsWithProperty(RDF.type, CDK.MOLECULE);
    IAtomContainer mol = null;
    if (mols.hasNext()) {
        Resource rdfMol = mols.next();
        mol = builder.newInstance(IAtomContainer.class);
        Map<Resource, IAtom> rdfToCDKAtomMap = new HashMap<Resource, IAtom>();
        StmtIterator atoms = rdfMol.listProperties(CDK.HASATOM);
        while (atoms.hasNext()) {
            Resource rdfAtom = atoms.nextStatement().getResource();
            IAtom atom;
            if (rdfAtom.hasProperty(RDF.type, CDK.PSEUDOATOM)) {
                atom = builder.newInstance(IPseudoAtom.class);
                atom.setStereoParity(0);
                Statement label = rdfAtom.getProperty(CDK.HASLABEL);
                if (label != null)
                    ((IPseudoAtom) atom).setLabel(label.getString());
            } else {
                atom = builder.newInstance(IAtom.class);
            }
            Statement symbol = rdfAtom.getProperty(CDK.SYMBOL);
            if (symbol != null)
                atom.setSymbol(symbol.getString());
            rdfToCDKAtomMap.put(rdfAtom, atom);
            deserializeAtomTypeFields(rdfAtom, atom);
            mol.addAtom(atom);
        }
        StmtIterator bonds = rdfMol.listProperties(CDK.HASBOND);
        while (bonds.hasNext()) {
            Resource rdfBond = bonds.nextStatement().getResource();
            IBond bond = builder.newInstance(IBond.class);
            StmtIterator bondAtoms = rdfBond.listProperties(CDK.BINDSATOM);
            int atomCounter = 0;
            while (bondAtoms.hasNext()) {
                Statement rdfAtom = bondAtoms.nextStatement();
                IAtom atom = rdfToCDKAtomMap.get(rdfAtom.getResource());
                bond.setAtom(atom, atomCounter);
                atomCounter++;
            }
            Resource order = rdfBond.getProperty(CDK.HASORDER).getResource();
            bond.setOrder(resource2Order(order));
            mol.addBond(bond);
            deserializeElectronContainerFields(rdfBond, bond);
        }
    }
    return mol;
}","/**
     * Converts a {@link Model} into an {@link IAtomContainer} using the given {@link IChemObjectBuilder}.
     *
     * @param model RDF graph to deserialize into an {@link IAtomContainer}.
     * @param builder {@link IChemObjectBuilder} used to create new {@link IChemObject}s.
     * @return a {@link IAtomContainer} deserialized from the RDF graph.
     */","('model2Molecule', {'INSTRUCTION': {'covered': 153, 'missed': 0}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 40, 'missed': 0}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",407.0,  Converts a {@link Model} into an {@link IAtomContainer} using the given {@link IChemObjectBuilder}.,23.0,"['The given @link IAtomContainer is used to convert a @link Model into an IAtomContainer.', 'The given @link IAtomContainer is used to convert the @link Model into it.', 'The given @link IAtomContainer is used to convert a @link Model into an @link IAtomContainer.']"
1060,cdk,org/openscience/cdk/layout/StructureDiagramGenerator.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/StructureDiagramGenerator.java,layoutAcyclicParts,1829-1900,"/**
     * Does a layout of all aliphatic parts connected to the parts of the molecule
     * that have already been laid out. Starts at the first bond with unplaced
     * neighbours and stops when a ring is encountered.
     *
     * @throws CDKException if an error occurs
     */
private void layoutAcyclicParts() throws CDKException{
    logger.debug(""Start of handleAliphatics"");
    int safetyCounter = 0;
    IAtomContainer unplacedAtoms = null;
    IAtomContainer placedAtoms = null;
    IAtomContainer longestUnplacedChain = null;
    IAtom atom = null;
    Vector2d direction = null;
    Vector2d startVector = null;
    boolean done;
    do {
        safetyCounter++;
        done = false;
        atom = getNextAtomWithAliphaticUnplacedNeigbors();
        if (atom != null) {
            unplacedAtoms = getUnplacedAtoms(atom);
            placedAtoms = getPlacedAtoms(atom);
            longestUnplacedChain = atomPlacer.getLongestUnplacedChain(molecule, atom);
            logger.debug(""---start of longest unplaced chain---"");
            try {
                logger.debug(""Start at atom no. "" + (molecule.indexOf(atom) + 1));
                logger.debug(AtomPlacer.listNumbers(molecule, longestUnplacedChain));
            } catch (Exception exc) {
                logger.debug(exc);
            }
            logger.debug(""---end of longest unplaced chain---"");
            if (longestUnplacedChain.getAtomCount() > 1) {
                if (placedAtoms.getAtomCount() > 1) {
                    logger.debug(""More than one atoms placed already"");
                    logger.debug(""trying to place neighbors of atom "" + (molecule.indexOf(atom) + 1));
                    atomPlacer.distributePartners(atom, placedAtoms, GeometryUtil.get2DCenter(placedAtoms), unplacedAtoms, bondLength);
                    direction = new Vector2d(longestUnplacedChain.getAtom(1).getPoint2d());
                    startVector = new Vector2d(atom.getPoint2d());
                    direction.sub(startVector);
                    logger.debug(""Done placing neighbors of atom "" + (molecule.indexOf(atom) + 1));
                } else {
                    logger.debug(""Less than or equal one atoms placed already"");
                    logger.debug(""Trying to get next bond vector."");
                    direction = atomPlacer.getNextBondVector(atom, placedAtoms.getAtom(0), GeometryUtil.get2DCenter(molecule), true);
                }
                for (int f = 1; f < longestUnplacedChain.getAtomCount(); f++) {
                    longestUnplacedChain.getAtom(f).setFlag(CDKConstants.ISPLACED, false);
                }
                atomPlacer.placeLinearChain(longestUnplacedChain, direction, bondLength);
            } else {
                done = true;
            }
        } else {
            done = true;
        }
    } while (!done && safetyCounter <= molecule.getAtomCount());
    logger.debug(""End of handleAliphatics"");
}","private void layoutAcyclicParts() throws CDKException{
    logger.debug(""Start of handleAliphatics"");
    int safetyCounter = 0;
    IAtomContainer unplacedAtoms = null;
    IAtomContainer placedAtoms = null;
    IAtomContainer longestUnplacedChain = null;
    IAtom atom = null;
    Vector2d direction = null;
    Vector2d startVector = null;
    boolean done;
    do {
        safetyCounter++;
        done = false;
        atom = getNextAtomWithAliphaticUnplacedNeigbors();
        if (atom != null) {
            unplacedAtoms = getUnplacedAtoms(atom);
            placedAtoms = getPlacedAtoms(atom);
            longestUnplacedChain = atomPlacer.getLongestUnplacedChain(molecule, atom);
            logger.debug(""---start of longest unplaced chain---"");
            try {
                logger.debug(""Start at atom no. "" + (molecule.indexOf(atom) + 1));
                logger.debug(AtomPlacer.listNumbers(molecule, longestUnplacedChain));
            } catch (Exception exc) {
                logger.debug(exc);
            }
            logger.debug(""---end of longest unplaced chain---"");
            if (longestUnplacedChain.getAtomCount() > 1) {
                if (placedAtoms.getAtomCount() > 1) {
                    logger.debug(""More than one atoms placed already"");
                    logger.debug(""trying to place neighbors of atom "" + (molecule.indexOf(atom) + 1));
                    atomPlacer.distributePartners(atom, placedAtoms, GeometryUtil.get2DCenter(placedAtoms), unplacedAtoms, bondLength);
                    direction = new Vector2d(longestUnplacedChain.getAtom(1).getPoint2d());
                    startVector = new Vector2d(atom.getPoint2d());
                    direction.sub(startVector);
                    logger.debug(""Done placing neighbors of atom "" + (molecule.indexOf(atom) + 1));
                } else {
                    logger.debug(""Less than or equal one atoms placed already"");
                    logger.debug(""Trying to get next bond vector."");
                    direction = atomPlacer.getNextBondVector(atom, placedAtoms.getAtom(0), GeometryUtil.get2DCenter(molecule), true);
                }
                for (int f = 1; f < longestUnplacedChain.getAtomCount(); f++) {
                    longestUnplacedChain.getAtom(f).setFlag(CDKConstants.ISPLACED, false);
                }
                atomPlacer.placeLinearChain(longestUnplacedChain, direction, bondLength);
            } else {
                done = true;
            }
        } else {
            done = true;
        }
    } while (!done && safetyCounter <= molecule.getAtomCount());
    logger.debug(""End of handleAliphatics"");
}","/**
     * Does a layout of all aliphatic parts connected to the parts of the molecule
     * that have already been laid out. Starts at the first bond with unplaced
     * neighbours and stops when a ring is encountered.
     *
     * @throws CDKException if an error occurs
     */","('layoutAcyclicParts', {'INSTRUCTION': {'covered': 192, 'missed': 4}, 'BRANCH': {'covered': 11, 'missed': 1}, 'LINE': {'covered': 41, 'missed': 2}, 'COMPLEXITY': {'covered': 6, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",413.0,  Does a layout of all aliphatic parts connected to the parts of the molecule  that have already been laid out.,21.0,"['A layout of all aliphatic parts connected to the parts of the molecule that have already been laid out.', 'Does a layout of all the aliphatic parts of the molecule.', 'A layout of all aliphatic parts connected to the parts that have already been laid out.']"
1061,cdk,org/openscience/cdk/qsar/descriptors/molecular/LargestPiSystemDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/LargestPiSystemDescriptor.java,calculate,141-206,"/**
     * Calculate the count of atoms of the largest pi system in the supplied {@link IAtomContainer}.
     * 
     * <p>The method require one parameter:
     * <ol>
     * <li>if checkAromaticity is true, the method check the aromaticity,
     * <li>if false, means that the aromaticity has already been checked
     * </ol>
     *
     * @param container The {@link IAtomContainer} for which this descriptor is to be calculated
     * @return the number of atoms in the largest pi system of this AtomContainer
     * @see #setParameters
     */
public DescriptorValue calculate(IAtomContainer container){
    boolean[] originalFlag4 = new boolean[container.getAtomCount()];
    for (int i = 0; i < originalFlag4.length; i++) {
        originalFlag4[i] = container.getAtom(i).getFlag(CDKConstants.VISITED);
    }
    if (checkAromaticity) {
        try {
            AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(container);
            Aromaticity.cdkLegacy().apply(container);
        } catch (CDKException e) {
            return getDummyDescriptorValue(e);
        }
    }
    int largestPiSystemAtomsCount = 0;
    List<IAtom> startSphere;
    List<IAtom> path;
    for (int i = 0; i < container.getAtomCount(); i++) {
        container.getAtom(i).setFlag(CDKConstants.VISITED, false);
    }
    for (int i = 0; i < container.getAtomCount(); i++) {
        if ((container.getMaximumBondOrder(container.getAtom(i)) != IBond.Order.SINGLE || Math.abs(container.getAtom(i).getFormalCharge()) >= 1 || container.getAtom(i).getFlag(CDKConstants.ISAROMATIC) || container.getAtom(i).getAtomicNumber() == IElement.N || container.getAtom(i).getAtomicNumber() == IElement.O) && !container.getAtom(i).getFlag(CDKConstants.VISITED)) {
            startSphere = new ArrayList<IAtom>();
            path = new ArrayList<IAtom>();
            startSphere.add(container.getAtom(i));
            try {
                breadthFirstSearch(container, startSphere, path);
            } catch (CDKException e) {
                return getDummyDescriptorValue(e);
            }
            if (path.size() > largestPiSystemAtomsCount) {
                largestPiSystemAtomsCount = path.size();
            }
        }
    }
    for (int i = 0; i < originalFlag4.length; i++) {
        container.getAtom(i).setFlag(CDKConstants.VISITED, originalFlag4[i]);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(largestPiSystemAtomsCount), getDescriptorNames());
}","public DescriptorValue calculate(IAtomContainer container){
    boolean[] originalFlag4 = new boolean[container.getAtomCount()];
    for (int i = 0; i < originalFlag4.length; i++) {
        originalFlag4[i] = container.getAtom(i).getFlag(CDKConstants.VISITED);
    }
    if (checkAromaticity) {
        try {
            AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(container);
            Aromaticity.cdkLegacy().apply(container);
        } catch (CDKException e) {
            return getDummyDescriptorValue(e);
        }
    }
    int largestPiSystemAtomsCount = 0;
    List<IAtom> startSphere;
    List<IAtom> path;
    for (int i = 0; i < container.getAtomCount(); i++) {
        container.getAtom(i).setFlag(CDKConstants.VISITED, false);
    }
    for (int i = 0; i < container.getAtomCount(); i++) {
        if ((container.getMaximumBondOrder(container.getAtom(i)) != IBond.Order.SINGLE || Math.abs(container.getAtom(i).getFormalCharge()) >= 1 || container.getAtom(i).getFlag(CDKConstants.ISAROMATIC) || container.getAtom(i).getAtomicNumber() == IElement.N || container.getAtom(i).getAtomicNumber() == IElement.O) && !container.getAtom(i).getFlag(CDKConstants.VISITED)) {
            startSphere = new ArrayList<IAtom>();
            path = new ArrayList<IAtom>();
            startSphere.add(container.getAtom(i));
            try {
                breadthFirstSearch(container, startSphere, path);
            } catch (CDKException e) {
                return getDummyDescriptorValue(e);
            }
            if (path.size() > largestPiSystemAtomsCount) {
                largestPiSystemAtomsCount = path.size();
            }
        }
    }
    for (int i = 0; i < originalFlag4.length; i++) {
        container.getAtom(i).setFlag(CDKConstants.VISITED, originalFlag4[i]);
    }
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), new IntegerResult(largestPiSystemAtomsCount), getDescriptorNames());
}","/**
     * Calculate the count of atoms of the largest pi system in the supplied {@link IAtomContainer}.
     * 
     * <p>The method require one parameter:
     * <ol>
     * <li>if checkAromaticity is true, the method check the aromaticity,
     * <li>if false, means that the aromaticity has already been checked
     * </ol>
     *
     * @param container The {@link IAtomContainer} for which this descriptor is to be calculated
     * @return the number of atoms in the largest pi system of this AtomContainer
     * @see #setParameters
     */","('calculate', {'INSTRUCTION': {'covered': 147, 'missed': 17}, 'BRANCH': {'covered': 22, 'missed': 2}, 'LINE': {'covered': 24, 'missed': 7}, 'COMPLEXITY': {'covered': 11, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",416.0,  Calculate the count of atoms of the largest pi system in the supplied {@link IAtomContainer}.,19.0,"['The supplied @link IAtomContainer has a count of the largest pi system.', 'The supplied @link IAtomContainer has a count of atoms of the largest pi system.', 'The supplied @link IAtomContainer contains the count of the largest pi system.']"
1062,cdk,org/openscience/cdk/layout/StructureDiagramGenerator.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/StructureDiagramGenerator.java,layoutCyclicParts,1902-2009,"/**
     * Does the layout for the next RingSystem that is connected to those parts of
     * the molecule that have already been laid out. Finds the next ring with an
     * unplaced ring atom and lays out this ring. Then lays out the ring substituents
     * of this ring. Then moves and rotates the laid out ring to match the position
     * of its attachment bond to the rest of the molecule.
     *
     * @throws CDKException if an error occurs
     */
private void layoutCyclicParts() throws CDKException{
    logger.debug(""Start of layoutNextRingSystem()"");
    resetUnplacedRings();
    IAtomContainer placedAtoms = AtomPlacer.getPlacedAtoms(molecule);
    logger.debug(""Finding attachment bond to already placed part..."");
    IBond nextRingAttachmentBond = getNextBondWithUnplacedRingAtom();
    if (nextRingAttachmentBond != null) {
        logger.debug(""...bond found."");
        IAtom ringAttachmentAtom = getRingAtom(nextRingAttachmentBond);
        IAtom chainAttachmentAtom = getOtherBondAtom(ringAttachmentAtom, nextRingAttachmentBond);
        IRingSet nextRingSystem = getRingSystemOfAtom(ringSystems, ringAttachmentAtom);
        IAtomContainer ringSystem = RingSetManipulator.getAllInOneContainer(nextRingSystem);
        Point2d oldRingAttachmentAtomPoint = ringAttachmentAtom.getPoint2d();
        Point2d oldChainAttachmentAtomPoint = chainAttachmentAtom.getPoint2d();
        layoutRingSet(firstBondVector, nextRingSystem);
        AtomPlacer.markNotPlaced(placedAtoms);
        IAtomContainer placedRingSubstituents = ringPlacer.placeRingSubstituents(nextRingSystem, bondLength);
        ringSystem.add(placedRingSubstituents);
        AtomPlacer.markPlaced(placedAtoms);
        logger.debug(""Computing translation/rotation of new ringset to fit old attachment bond orientation..."");
        Point2d oldPoint2 = oldRingAttachmentAtomPoint;
        Point2d oldPoint1 = oldChainAttachmentAtomPoint;
        Point2d newPoint2 = ringAttachmentAtom.getPoint2d();
        Point2d newPoint1 = chainAttachmentAtom.getPoint2d();
        logger.debug(""oldPoint1: "" + oldPoint1);
        logger.debug(""oldPoint2: "" + oldPoint2);
        logger.debug(""newPoint1: "" + newPoint1);
        logger.debug(""newPoint2: "" + newPoint2);
        double oldAngle = GeometryUtil.getAngle(oldPoint2.x - oldPoint1.x, oldPoint2.y - oldPoint1.y);
        double newAngle = GeometryUtil.getAngle(newPoint2.x - newPoint1.x, newPoint2.y - newPoint1.y);
        double angleDiff = oldAngle - newAngle;
        logger.debug(""oldAngle: "" + oldAngle + "", newAngle: "" + newAngle + ""; diff = "" + angleDiff);
        Vector2d translationVector = new Vector2d(oldPoint1);
        translationVector.sub(new Vector2d(newPoint1));
        GeometryUtil.translate2D(ringSystem, translationVector);
        GeometryUtil.rotate(ringSystem, oldPoint1, angleDiff);
        logger.debug(""...done translating/rotating new ringset to fit old attachment bond orientation."");
    } else {
        logger.debug(""...no bond found"");
        if (ringSystems != null) {
            for (IRingSet ringset : ringSystems) {
                for (IAtomContainer ring : ringset.atomContainers()) ringPlacer.completePartiallyPlacedRing(ringset, (IRing) ring, bondLength);
                if (allPlaced(ringset))
                    ringPlacer.placeRingSubstituents(ringset, bondLength);
            }
        }
    }
    logger.debug(""End of layoutNextRingSystem()"");
}","private void layoutCyclicParts() throws CDKException{
    logger.debug(""Start of layoutNextRingSystem()"");
    resetUnplacedRings();
    IAtomContainer placedAtoms = AtomPlacer.getPlacedAtoms(molecule);
    logger.debug(""Finding attachment bond to already placed part..."");
    IBond nextRingAttachmentBond = getNextBondWithUnplacedRingAtom();
    if (nextRingAttachmentBond != null) {
        logger.debug(""...bond found."");
        IAtom ringAttachmentAtom = getRingAtom(nextRingAttachmentBond);
        IAtom chainAttachmentAtom = getOtherBondAtom(ringAttachmentAtom, nextRingAttachmentBond);
        IRingSet nextRingSystem = getRingSystemOfAtom(ringSystems, ringAttachmentAtom);
        IAtomContainer ringSystem = RingSetManipulator.getAllInOneContainer(nextRingSystem);
        Point2d oldRingAttachmentAtomPoint = ringAttachmentAtom.getPoint2d();
        Point2d oldChainAttachmentAtomPoint = chainAttachmentAtom.getPoint2d();
        layoutRingSet(firstBondVector, nextRingSystem);
        AtomPlacer.markNotPlaced(placedAtoms);
        IAtomContainer placedRingSubstituents = ringPlacer.placeRingSubstituents(nextRingSystem, bondLength);
        ringSystem.add(placedRingSubstituents);
        AtomPlacer.markPlaced(placedAtoms);
        logger.debug(""Computing translation/rotation of new ringset to fit old attachment bond orientation..."");
        Point2d oldPoint2 = oldRingAttachmentAtomPoint;
        Point2d oldPoint1 = oldChainAttachmentAtomPoint;
        Point2d newPoint2 = ringAttachmentAtom.getPoint2d();
        Point2d newPoint1 = chainAttachmentAtom.getPoint2d();
        logger.debug(""oldPoint1: "" + oldPoint1);
        logger.debug(""oldPoint2: "" + oldPoint2);
        logger.debug(""newPoint1: "" + newPoint1);
        logger.debug(""newPoint2: "" + newPoint2);
        double oldAngle = GeometryUtil.getAngle(oldPoint2.x - oldPoint1.x, oldPoint2.y - oldPoint1.y);
        double newAngle = GeometryUtil.getAngle(newPoint2.x - newPoint1.x, newPoint2.y - newPoint1.y);
        double angleDiff = oldAngle - newAngle;
        logger.debug(""oldAngle: "" + oldAngle + "", newAngle: "" + newAngle + ""; diff = "" + angleDiff);
        Vector2d translationVector = new Vector2d(oldPoint1);
        translationVector.sub(new Vector2d(newPoint1));
        GeometryUtil.translate2D(ringSystem, translationVector);
        GeometryUtil.rotate(ringSystem, oldPoint1, angleDiff);
        logger.debug(""...done translating/rotating new ringset to fit old attachment bond orientation."");
    } else {
        logger.debug(""...no bond found"");
        if (ringSystems != null) {
            for (IRingSet ringset : ringSystems) {
                for (IAtomContainer ring : ringset.atomContainers()) ringPlacer.completePartiallyPlacedRing(ringset, (IRing) ring, bondLength);
                if (allPlaced(ringset))
                    ringPlacer.placeRingSubstituents(ringset, bondLength);
            }
        }
    }
    logger.debug(""End of layoutNextRingSystem()"");
}","/**
     * Does the layout for the next RingSystem that is connected to those parts of
     * the molecule that have already been laid out. Finds the next ring with an
     * unplaced ring atom and lays out this ring. Then lays out the ring substituents
     * of this ring. Then moves and rotates the laid out ring to match the position
     * of its attachment bond to the rest of the molecule.
     *
     * @throws CDKException if an error occurs
     */","('layoutCyclicParts', {'INSTRUCTION': {'covered': 236, 'missed': 0}, 'BRANCH': {'covered': 8, 'missed': 2}, 'LINE': {'covered': 47, 'missed': 0}, 'COMPLEXITY': {'covered': 4, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",420.0,  Does the layout for the next RingSystem that is connected to those parts of  the molecule that have already been laid out.,23.0,"['Does the layout for the next RingSystem connect to the parts of the molecule that have already been laid out?', 'Does the layout for the next RingSystem connect to the parts that have already been laid out?', 'Does the layout for the next RingSystem connect to the parts of the molecule already laid out?']"
1063,cdk,org/openscience/cdk/layout/NonplanarBonds.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/NonplanarBonds.java,hasPriority,1065-1133,"/**
     * Does the atom at index {@code i} have priority over the atom at index
     * {@code j} for the tetrahedral atom {@code focus}.
     *
     * @param focus tetrahedral centre (or -1 if double bond)
     * @param i     adjacent atom index
     * @param j     adjacent atom index
     * @return whether atom i has priority
     */
 boolean hasPriority(int focus, int i, int j){
    if (tetrahedralElements[i] == null && tetrahedralElements[j] != null)
        return true;
    if (tetrahedralElements[i] != null && tetrahedralElements[j] == null)
        return false;
    if (doubleBondElements[i] == null && doubleBondElements[j] != null)
        return true;
    if (doubleBondElements[i] != null && doubleBondElements[j] == null)
        return false;
    IAtom iAtom = container.getAtom(i);
    IAtom jAtom = container.getAtom(j);
    boolean iIsSp3 = isSp3Carbon(iAtom, graph[i].length);
    boolean jIsSp3 = isSp3Carbon(jAtom, graph[j].length);
    if (iIsSp3 != jIsSp3)
        return !iIsSp3;
    if (tetrahedralElements[i] == null && tetrahedralElements[j] != null)
        return true;
    if (tetrahedralElements[i] != null && tetrahedralElements[j] == null)
        return false;
    boolean iCyclic = focus >= 0 ? ringSearch.cyclic(focus, i) : ringSearch.cyclic(i);
    boolean jCyclic = focus >= 0 ? ringSearch.cyclic(focus, j) : ringSearch.cyclic(j);
    if (!iCyclic && jCyclic)
        return true;
    if (iCyclic && !jCyclic)
        return false;
    if (iAtom.getAtomicNumber() > 0 && jAtom.getAtomicNumber() == 0)
        return true;
    if (iAtom.getAtomicNumber() == 0 && jAtom.getAtomicNumber() > 0)
        return false;
    final int iDegree = graph[i].length;
    int iElem = iAtom.getAtomicNumber();
    final int jDegree = graph[j].length;
    int jElem = jAtom.getAtomicNumber();
    if (iElem == 6)
        iElem = 256;
    if (jElem == 6)
        jElem = 256;
    if (iDegree == 1 && jDegree > 1)
        return true;
    if (jDegree == 1 && iDegree > 1)
        return false;
    if (iElem < jElem)
        return true;
    if (iElem > jElem)
        return false;
    if (iDegree < jDegree)
        return true;
    if (iDegree > jDegree)
        return false;
    return false;
}","boolean hasPriority(int focus, int i, int j){
    if (tetrahedralElements[i] == null && tetrahedralElements[j] != null)
        return true;
    if (tetrahedralElements[i] != null && tetrahedralElements[j] == null)
        return false;
    if (doubleBondElements[i] == null && doubleBondElements[j] != null)
        return true;
    if (doubleBondElements[i] != null && doubleBondElements[j] == null)
        return false;
    IAtom iAtom = container.getAtom(i);
    IAtom jAtom = container.getAtom(j);
    boolean iIsSp3 = isSp3Carbon(iAtom, graph[i].length);
    boolean jIsSp3 = isSp3Carbon(jAtom, graph[j].length);
    if (iIsSp3 != jIsSp3)
        return !iIsSp3;
    if (tetrahedralElements[i] == null && tetrahedralElements[j] != null)
        return true;
    if (tetrahedralElements[i] != null && tetrahedralElements[j] == null)
        return false;
    boolean iCyclic = focus >= 0 ? ringSearch.cyclic(focus, i) : ringSearch.cyclic(i);
    boolean jCyclic = focus >= 0 ? ringSearch.cyclic(focus, j) : ringSearch.cyclic(j);
    if (!iCyclic && jCyclic)
        return true;
    if (iCyclic && !jCyclic)
        return false;
    if (iAtom.getAtomicNumber() > 0 && jAtom.getAtomicNumber() == 0)
        return true;
    if (iAtom.getAtomicNumber() == 0 && jAtom.getAtomicNumber() > 0)
        return false;
    final int iDegree = graph[i].length;
    int iElem = iAtom.getAtomicNumber();
    final int jDegree = graph[j].length;
    int jElem = jAtom.getAtomicNumber();
    if (iElem == 6)
        iElem = 256;
    if (jElem == 6)
        jElem = 256;
    if (iDegree == 1 && jDegree > 1)
        return true;
    if (jDegree == 1 && iDegree > 1)
        return false;
    if (iElem < jElem)
        return true;
    if (iElem > jElem)
        return false;
    if (iDegree < jDegree)
        return true;
    if (iDegree > jDegree)
        return false;
    return false;
}","/**
     * Does the atom at index {@code i} have priority over the atom at index
     * {@code j} for the tetrahedral atom {@code focus}.
     *
     * @param focus tetrahedral centre (or -1 if double bond)
     * @param i     adjacent atom index
     * @param j     adjacent atom index
     * @return whether atom i has priority
     */","('hasPriority', {'INSTRUCTION': {'covered': 217, 'missed': 18}, 'BRANCH': {'covered': 58, 'missed': 10}, 'LINE': {'covered': 35, 'missed': 2}, 'COMPLEXITY': {'covered': 26, 'missed': 9}, 'METHOD': {'covered': 1, 'missed': 0}})",421.0,  Does the atom at index {@code i} have priority over the atom at index  {@code j} for the tetrahedral atom {@code focus}.,32.0,"['Does the atom at index @code i have priority over the atom at index @code j?', 'Does the atom at index @code i have priority over the atom at index @code j for the tetrahedral atom?', 'Does the atom at index @code i have priority over the atom at index @code j for the tetrahedral atom.']"
1064,openapi-generator,org/openapitools/codegen/utils/ModelUtils.java,/modules/openapi-generator/src/main/java/org/openapitools/codegen/utils/ModelUtils.java,visitSchema,312-375,"/**
     * Invoke the specified visitor function for every schema that matches mimeType in the OpenAPI document.
     *
     * To avoid infinite recursion, referenced schemas are visited only once. When a referenced schema is visited,
     * it is added to visitedSchemas.
     *
     * @param openAPI the OpenAPI document that contains schema objects.
     * @param schema the root schema object to be visited.
     * @param mimeType the mime type. TODO: does not seem to be used in a meaningful way.
     * @param visitedSchemas the list of referenced schemas that have been visited.
     * @param visitor the visitor function which is invoked for every visited schema.
     */
private static void visitSchema(OpenAPI openAPI, Schema schema, String mimeType, List<String> visitedSchemas, OpenAPISchemaVisitor visitor){
    visitor.visit(schema, mimeType);
    if (schema.get$ref() != null) {
        String ref = getSimpleRef(schema.get$ref());
        if (!visitedSchemas.contains(ref)) {
            visitedSchemas.add(ref);
            Schema referencedSchema = getSchemas(openAPI).get(ref);
            if (referencedSchema != null) {
                visitSchema(openAPI, referencedSchema, mimeType, visitedSchemas, visitor);
            }
        }
    }
    if (schema instanceof ComposedSchema) {
        List<Schema> oneOf = ((ComposedSchema) schema).getOneOf();
        if (oneOf != null) {
            for (Schema s : oneOf) {
                visitSchema(openAPI, s, mimeType, visitedSchemas, visitor);
            }
        }
        List<Schema> allOf = ((ComposedSchema) schema).getAllOf();
        if (allOf != null) {
            for (Schema s : allOf) {
                visitSchema(openAPI, s, mimeType, visitedSchemas, visitor);
            }
        }
        List<Schema> anyOf = ((ComposedSchema) schema).getAnyOf();
        if (anyOf != null) {
            for (Schema s : anyOf) {
                visitSchema(openAPI, s, mimeType, visitedSchemas, visitor);
            }
        }
    } else if (schema instanceof ArraySchema) {
        Schema itemsSchema = ((ArraySchema) schema).getItems();
        if (itemsSchema != null) {
            visitSchema(openAPI, itemsSchema, mimeType, visitedSchemas, visitor);
        }
    } else if (isMapSchema(schema)) {
        Object additionalProperties = schema.getAdditionalProperties();
        if (additionalProperties instanceof Schema) {
            visitSchema(openAPI, (Schema) additionalProperties, mimeType, visitedSchemas, visitor);
        }
    }
    if (schema.getNot() != null) {
        visitSchema(openAPI, schema.getNot(), mimeType, visitedSchemas, visitor);
    }
    Map<String, Schema> properties = schema.getProperties();
    if (properties != null) {
        for (Schema property : properties.values()) {
            visitSchema(openAPI, property, mimeType, visitedSchemas, visitor);
        }
    }
}","private static void visitSchema(OpenAPI openAPI, Schema schema, String mimeType, List<String> visitedSchemas, OpenAPISchemaVisitor visitor){
    visitor.visit(schema, mimeType);
    if (schema.get$ref() != null) {
        String ref = getSimpleRef(schema.get$ref());
        if (!visitedSchemas.contains(ref)) {
            visitedSchemas.add(ref);
            Schema referencedSchema = getSchemas(openAPI).get(ref);
            if (referencedSchema != null) {
                visitSchema(openAPI, referencedSchema, mimeType, visitedSchemas, visitor);
            }
        }
    }
    if (schema instanceof ComposedSchema) {
        List<Schema> oneOf = ((ComposedSchema) schema).getOneOf();
        if (oneOf != null) {
            for (Schema s : oneOf) {
                visitSchema(openAPI, s, mimeType, visitedSchemas, visitor);
            }
        }
        List<Schema> allOf = ((ComposedSchema) schema).getAllOf();
        if (allOf != null) {
            for (Schema s : allOf) {
                visitSchema(openAPI, s, mimeType, visitedSchemas, visitor);
            }
        }
        List<Schema> anyOf = ((ComposedSchema) schema).getAnyOf();
        if (anyOf != null) {
            for (Schema s : anyOf) {
                visitSchema(openAPI, s, mimeType, visitedSchemas, visitor);
            }
        }
    } else if (schema instanceof ArraySchema) {
        Schema itemsSchema = ((ArraySchema) schema).getItems();
        if (itemsSchema != null) {
            visitSchema(openAPI, itemsSchema, mimeType, visitedSchemas, visitor);
        }
    } else if (isMapSchema(schema)) {
        Object additionalProperties = schema.getAdditionalProperties();
        if (additionalProperties instanceof Schema) {
            visitSchema(openAPI, (Schema) additionalProperties, mimeType, visitedSchemas, visitor);
        }
    }
    if (schema.getNot() != null) {
        visitSchema(openAPI, schema.getNot(), mimeType, visitedSchemas, visitor);
    }
    Map<String, Schema> properties = schema.getProperties();
    if (properties != null) {
        for (Schema property : properties.values()) {
            visitSchema(openAPI, property, mimeType, visitedSchemas, visitor);
        }
    }
}","/**
     * Invoke the specified visitor function for every schema that matches mimeType in the OpenAPI document.
     *
     * To avoid infinite recursion, referenced schemas are visited only once. When a referenced schema is visited,
     * it is added to visitedSchemas.
     *
     * @param openAPI the OpenAPI document that contains schema objects.
     * @param schema the root schema object to be visited.
     * @param mimeType the mime type. TODO: does not seem to be used in a meaningful way.
     * @param visitedSchemas the list of referenced schemas that have been visited.
     * @param visitor the visitor function which is invoked for every visited schema.
     */","('visitSchema', {'INSTRUCTION': {'covered': 172, 'missed': 0}, 'BRANCH': {'covered': 32, 'missed': 2}, 'LINE': {'covered': 40, 'missed': 0}, 'COMPLEXITY': {'covered': 16, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",424.0,  Invoke the specified visitor function for every schema that matches mimeType in the OpenAPI document.,16.0,"['The visitor function should be used for every schema that matches mimeType.', 'The specified visitor function should be used for every schema that matches mimeType.', 'The specified visitor function should be used for every schema that matches mimeType in the OpenAPI document.']"
1067,zxing,com/google/zxing/aztec/decoder/Decoder.java,/core/src/main/java/com/google/zxing/aztec/decoder/Decoder.java,correctBits,199-270,"/**
   * <p>Performs RS error correction on an array of bits.</p>
   *
   * @return the corrected array
   * @throws FormatException if the input contains too many errors
   */
private boolean[] correctBits(boolean[] rawbits) throws FormatException{
    GenericGF gf;
    int codewordSize;
    if (ddata.getNbLayers() <= 2) {
        codewordSize = 6;
        gf = GenericGF.AZTEC_DATA_6;
    } else if (ddata.getNbLayers() <= 8) {
        codewordSize = 8;
        gf = GenericGF.AZTEC_DATA_8;
    } else if (ddata.getNbLayers() <= 22) {
        codewordSize = 10;
        gf = GenericGF.AZTEC_DATA_10;
    } else {
        codewordSize = 12;
        gf = GenericGF.AZTEC_DATA_12;
    }
    int numDataCodewords = ddata.getNbDatablocks();
    int numCodewords = rawbits.length / codewordSize;
    if (numCodewords < numDataCodewords) {
        throw FormatException.getFormatInstance();
    }
    int offset = rawbits.length % codewordSize;
    int[] dataWords = new int[numCodewords];
    for (int i = 0; i < numCodewords; i++, offset += codewordSize) {
        dataWords[i] = readCode(rawbits, offset, codewordSize);
    }
    try {
        ReedSolomonDecoder rsDecoder = new ReedSolomonDecoder(gf);
        rsDecoder.decode(dataWords, numCodewords - numDataCodewords);
    } catch (ReedSolomonException ex) {
        throw FormatException.getFormatInstance(ex);
    }
    int mask = (1 << codewordSize) - 1;
    int stuffedBits = 0;
    for (int i = 0; i < numDataCodewords; i++) {
        int dataWord = dataWords[i];
        if (dataWord == 0 || dataWord == mask) {
            throw FormatException.getFormatInstance();
        } else if (dataWord == 1 || dataWord == mask - 1) {
            stuffedBits++;
        }
    }
    boolean[] correctedBits = new boolean[numDataCodewords * codewordSize - stuffedBits];
    int index = 0;
    for (int i = 0; i < numDataCodewords; i++) {
        int dataWord = dataWords[i];
        if (dataWord == 1 || dataWord == mask - 1) {
            Arrays.fill(correctedBits, index, index + codewordSize - 1, dataWord > 1);
            index += codewordSize - 1;
        } else {
            for (int bit = codewordSize - 1; bit >= 0; --bit) {
                correctedBits[index++] = (dataWord & (1 << bit)) != 0;
            }
        }
    }
    return correctedBits;
}","private boolean[] correctBits(boolean[] rawbits) throws FormatException{
    GenericGF gf;
    int codewordSize;
    if (ddata.getNbLayers() <= 2) {
        codewordSize = 6;
        gf = GenericGF.AZTEC_DATA_6;
    } else if (ddata.getNbLayers() <= 8) {
        codewordSize = 8;
        gf = GenericGF.AZTEC_DATA_8;
    } else if (ddata.getNbLayers() <= 22) {
        codewordSize = 10;
        gf = GenericGF.AZTEC_DATA_10;
    } else {
        codewordSize = 12;
        gf = GenericGF.AZTEC_DATA_12;
    }
    int numDataCodewords = ddata.getNbDatablocks();
    int numCodewords = rawbits.length / codewordSize;
    if (numCodewords < numDataCodewords) {
        throw FormatException.getFormatInstance();
    }
    int offset = rawbits.length % codewordSize;
    int[] dataWords = new int[numCodewords];
    for (int i = 0; i < numCodewords; i++, offset += codewordSize) {
        dataWords[i] = readCode(rawbits, offset, codewordSize);
    }
    try {
        ReedSolomonDecoder rsDecoder = new ReedSolomonDecoder(gf);
        rsDecoder.decode(dataWords, numCodewords - numDataCodewords);
    } catch (ReedSolomonException ex) {
        throw FormatException.getFormatInstance(ex);
    }
    int mask = (1 << codewordSize) - 1;
    int stuffedBits = 0;
    for (int i = 0; i < numDataCodewords; i++) {
        int dataWord = dataWords[i];
        if (dataWord == 0 || dataWord == mask) {
            throw FormatException.getFormatInstance();
        } else if (dataWord == 1 || dataWord == mask - 1) {
            stuffedBits++;
        }
    }
    boolean[] correctedBits = new boolean[numDataCodewords * codewordSize - stuffedBits];
    int index = 0;
    for (int i = 0; i < numDataCodewords; i++) {
        int dataWord = dataWords[i];
        if (dataWord == 1 || dataWord == mask - 1) {
            Arrays.fill(correctedBits, index, index + codewordSize - 1, dataWord > 1);
            index += codewordSize - 1;
        } else {
            for (int bit = codewordSize - 1; bit >= 0; --bit) {
                correctedBits[index++] = (dataWord & (1 << bit)) != 0;
            }
        }
    }
    return correctedBits;
}","/**
   * <p>Performs RS error correction on an array of bits.</p>
   *
   * @return the corrected array
   * @throws FormatException if the input contains too many errors
   */","('correctBits', {'INSTRUCTION': {'covered': 193, 'missed': 4}, 'BRANCH': {'covered': 29, 'missed': 3}, 'LINE': {'covered': 40, 'missed': 2}, 'COMPLEXITY': {'covered': 14, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",429.0,  <p>Performs RS error correction on an array of bits.,13.0,"['The error correction is performed on an array of bits.', 'The error correction is done on an array of bits.', 'p>Corrects the error on the array of bits.']"
1068,cdk,org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,/display/renderbasic/src/main/java/org/openscience/cdk/renderer/generators/standard/AbbreviationLabel.java,parse,146-247,"/**
     * Split a label it to recognised tokens for reversing, the
     * validity of the label is not checked! The method is intended
     * for zero/single attachments only and linkers are not supported.
     * 
     * 
     * Example: 
     * {@code NHCH2Ph -> N,H,C,H2,Ph -> reverse/join -> PhH2CHN}
     * 
     * 
     * 
     * The method return value signals whether formula
     * formatting (sub- and super- script) can be applied.
     *
     * @param label  abbreviation label
     * @param tokens the list of tokens from the input (n>0)
     * @return whether the label parsed okay (i.e. apply formatting)
     */
 static boolean parse(String label, List<String> tokens){
    int i = 0;
    int len = label.length();
    while (i < len) {
        int st = i;
        int last;
        char c = label.charAt(i);
        // BRACKETS we treat as separate
        if (c == '(' || c == ')') {
            tokens.add(Character.toString(c));
            i++;
            // digits following closing brackets
            if (c == ')') {
                st = i;
                while (i < len && isDigit(c = label.charAt(i))) {
                    i++;
                }
                if (i > st)
                    tokens.add(label.substring(st, i));
            }
            continue;
        }
        // separators
        if (c == '/' || c == '' || c == '.' || c == '' || c == '=') {
            tokens.add(Character.toString(c));
            i++;
            int beg = i;
            while (i < label.length() && isDigit(label.charAt(i))) {
                i++;
            }
            if (i > beg)
                tokens.add(label.substring(beg, i));
            continue;
        }
        // SYMBOL Tokens
        // optional prefix o- m- p- etc.
        if ((last = findPrefix(PREFIX_TRIE, label, i, -1)) > 0) {
            i += (last - i);
        }
        final int symSt = i;
        // a valid symbol token
        if ((last = findPrefix(SYMBOL_TRIE, label, i, -1)) > 0) {
            i += (last - i);
            // an optional number suffix e.g. O2 F3 Ph3 etc.
            while (i < len && isDigit(label.charAt(i))) {
                i++;
            }
        } else // a charge token, only if it's after some other parts
        if (i == st && st > 0) {
            c = norm(label.charAt(i));
            if (c == '-' || c == '+') {
                i++;
                while (i < len && isDigit(label.charAt(i))) {
                    i++;
                }
                // we expect charge at the end of the string.. if there is
                // still more it's not good input
                if (i < len) {
                    return failParse(label, tokens);
                }
            }
        }
        if (i == st || i == symSt) {
            return failParse(label, tokens);
        }
        tokens.add(label.substring(st, i));
    }
    return true;
}","static boolean parse(String label, List<String> tokens){
    int i = 0;
    int len = label.length();
    while (i < len) {
        int st = i;
        int last;
        char c = label.charAt(i);
        // BRACKETS we treat as separate
        if (c == '(' || c == ')') {
            tokens.add(Character.toString(c));
            i++;
            // digits following closing brackets
            if (c == ')') {
                st = i;
                while (i < len && isDigit(c = label.charAt(i))) {
                    i++;
                }
                if (i > st)
                    tokens.add(label.substring(st, i));
            }
            continue;
        }
        // separators
        if (c == '/' || c == '' || c == '.' || c == '' || c == '=') {
            tokens.add(Character.toString(c));
            i++;
            int beg = i;
            while (i < label.length() && isDigit(label.charAt(i))) {
                i++;
            }
            if (i > beg)
                tokens.add(label.substring(beg, i));
            continue;
        }
        // SYMBOL Tokens
        // optional prefix o- m- p- etc.
        if ((last = findPrefix(PREFIX_TRIE, label, i, -1)) > 0) {
            i += (last - i);
        }
        final int symSt = i;
        // a valid symbol token
        if ((last = findPrefix(SYMBOL_TRIE, label, i, -1)) > 0) {
            i += (last - i);
            // an optional number suffix e.g. O2 F3 Ph3 etc.
            while (i < len && isDigit(label.charAt(i))) {
                i++;
            }
        } else // a charge token, only if it's after some other parts
        if (i == st && st > 0) {
            c = norm(label.charAt(i));
            if (c == '-' || c == '+') {
                i++;
                while (i < len && isDigit(label.charAt(i))) {
                    i++;
                }
                // we expect charge at the end of the string.. if there is
                // still more it's not good input
                if (i < len) {
                    return failParse(label, tokens);
                }
            }
        }
        if (i == st || i == symSt) {
            return failParse(label, tokens);
        }
        tokens.add(label.substring(st, i));
    }
    return true;
}","/**
     * Split a label it to recognised tokens for reversing, the
     * validity of the label is not checked! The method is intended
     * for zero/single attachments only and linkers are not supported.
     * 
     * 
     * Example: 
     * {@code NHCH2Ph -> N,H,C,H2,Ph -> reverse/join -> PhH2CHN}
     * 
     * 
     * 
     * The method return value signals whether formula
     * formatting (sub- and super- script) can be applied.
     *
     * @param label  abbreviation label
     * @param tokens the list of tokens from the input (n>0)
     * @return whether the label parsed okay (i.e. apply formatting)
     */","('parse', {'INSTRUCTION': {'covered': 179, 'missed': 14}, 'BRANCH': {'covered': 46, 'missed': 10}, 'LINE': {'covered': 40, 'missed': 2}, 'COMPLEXITY': {'covered': 21, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",431.0,"  Split a label it to recognised tokens for reversing, the  validity of the label is not checked! The method is intended  for zero/single attachments only and linkers are not supported.",33.0,"['The validity of the label is not checked if it is split to recognised token for reversing.', 'The validity of the label is not checked if it is split to recognised token.', 'The validity of the label is not checked when it is split to recognised token.']"
1070,matsim-libs,org/matsim/contrib/freight/jsprit/DistanceConstraint.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/jsprit/DistanceConstraint.java,findMinimalAdditionalDistance,208-285,"/**
	 * Finds a minimal additional distance for the tour, when a pickup is added to
	 * the plan. The AssociatedActivities contains both activities of a job which
	 * should be added to the existing tour. The TourActivities which are already in
	 * the tour are found in context.getRoute().getTourActivities. In this method
	 * the position of the new pickup is fixed and three options of the location of
	 * the delivery activity will be checked: delivery between every other activity
	 * after the pickup, delivery as the last activity before the end and delivery
	 * directly behind the new pickup. This method gives back the minimal distance
	 * of this three options.
	 *
	 * @param context
	 * @param newInvestigatedPickup
	 * @param nextAct
	 * @return minimal distance of the associated delivery
	 */
private double findMinimalAdditionalDistance(JobInsertionContext context, TourActivity newInvestigatedPickup, TourActivity nextAct){
    double minimalAdditionalDistance = 0;
    if (context.getAssociatedActivities().get(1) instanceof DeliverShipment) {
        TourActivity assignedDelivery = context.getAssociatedActivities().get(1);
        minimalAdditionalDistance = 0;
        int indexNextActicity = nextAct.getIndex();
        int tourPositionOfAcitivityBehindNewPickup = 0;
        int countIndex = 0;
        Vehicle newVehicle = context.getNewVehicle();
        VehicleRoute route = context.getRoute();
        a: for (TourActivity tourActivity : route.getTourActivities().getActivities()) {
            if (tourActivity.getIndex() == indexNextActicity) {
                while (countIndex < route.getTourActivities().getActivities().size()) {
                    if (route.getTourActivities().getActivities().get(countIndex).getIndex() == indexNextActicity) {
                        tourPositionOfAcitivityBehindNewPickup = countIndex;
                        break a;
                    }
                    countIndex++;
                }
            }
        }
        while ((tourPositionOfAcitivityBehindNewPickup + 1) < route.getTourActivities().getActivities().size()) {
            TourActivity activityBefore = route.getTourActivities().getActivities().get(tourPositionOfAcitivityBehindNewPickup);
            TourActivity activityAfter = route.getTourActivities().getActivities().get(tourPositionOfAcitivityBehindNewPickup + 1);
            double possibleAdditionalDistance = getDistance(activityBefore, assignedDelivery, newVehicle) + getDistance(assignedDelivery, activityAfter, newVehicle) - getDistance(activityBefore, activityAfter, newVehicle);
            minimalAdditionalDistance = findMinimalDistance(minimalAdditionalDistance, possibleAdditionalDistance);
            tourPositionOfAcitivityBehindNewPickup++;
        }
        if (route.getTourActivities().getActivities().size() > 0) {
            TourActivity activityLastDelivery = route.getTourActivities().getActivities().get(route.getTourActivities().getActivities().size() - 1);
            TourActivity activityEnd = route.getEnd();
            double possibleAdditionalDistance = getDistance(activityLastDelivery, assignedDelivery, newVehicle) + getDistance(assignedDelivery, activityEnd, newVehicle) - getDistance(activityLastDelivery, activityEnd, newVehicle);
            minimalAdditionalDistance = findMinimalDistance(minimalAdditionalDistance, possibleAdditionalDistance);
            TourActivity activityAfter = route.getTourActivities().getActivities().get(tourPositionOfAcitivityBehindNewPickup);
            possibleAdditionalDistance = getDistance(newInvestigatedPickup, assignedDelivery, newVehicle) + getDistance(assignedDelivery, activityAfter, newVehicle) - getDistance(newInvestigatedPickup, activityAfter, newVehicle);
            minimalAdditionalDistance = findMinimalDistance(minimalAdditionalDistance, possibleAdditionalDistance);
        }
    }
    return minimalAdditionalDistance;
}","private double findMinimalAdditionalDistance(JobInsertionContext context, TourActivity newInvestigatedPickup, TourActivity nextAct){
    double minimalAdditionalDistance = 0;
    if (context.getAssociatedActivities().get(1) instanceof DeliverShipment) {
        TourActivity assignedDelivery = context.getAssociatedActivities().get(1);
        minimalAdditionalDistance = 0;
        int indexNextActicity = nextAct.getIndex();
        int tourPositionOfAcitivityBehindNewPickup = 0;
        int countIndex = 0;
        Vehicle newVehicle = context.getNewVehicle();
        VehicleRoute route = context.getRoute();
        a: for (TourActivity tourActivity : route.getTourActivities().getActivities()) {
            if (tourActivity.getIndex() == indexNextActicity) {
                while (countIndex < route.getTourActivities().getActivities().size()) {
                    if (route.getTourActivities().getActivities().get(countIndex).getIndex() == indexNextActicity) {
                        tourPositionOfAcitivityBehindNewPickup = countIndex;
                        break a;
                    }
                    countIndex++;
                }
            }
        }
        while ((tourPositionOfAcitivityBehindNewPickup + 1) < route.getTourActivities().getActivities().size()) {
            TourActivity activityBefore = route.getTourActivities().getActivities().get(tourPositionOfAcitivityBehindNewPickup);
            TourActivity activityAfter = route.getTourActivities().getActivities().get(tourPositionOfAcitivityBehindNewPickup + 1);
            double possibleAdditionalDistance = getDistance(activityBefore, assignedDelivery, newVehicle) + getDistance(assignedDelivery, activityAfter, newVehicle) - getDistance(activityBefore, activityAfter, newVehicle);
            minimalAdditionalDistance = findMinimalDistance(minimalAdditionalDistance, possibleAdditionalDistance);
            tourPositionOfAcitivityBehindNewPickup++;
        }
        if (route.getTourActivities().getActivities().size() > 0) {
            TourActivity activityLastDelivery = route.getTourActivities().getActivities().get(route.getTourActivities().getActivities().size() - 1);
            TourActivity activityEnd = route.getEnd();
            double possibleAdditionalDistance = getDistance(activityLastDelivery, assignedDelivery, newVehicle) + getDistance(assignedDelivery, activityEnd, newVehicle) - getDistance(activityLastDelivery, activityEnd, newVehicle);
            minimalAdditionalDistance = findMinimalDistance(minimalAdditionalDistance, possibleAdditionalDistance);
            TourActivity activityAfter = route.getTourActivities().getActivities().get(tourPositionOfAcitivityBehindNewPickup);
            possibleAdditionalDistance = getDistance(newInvestigatedPickup, assignedDelivery, newVehicle) + getDistance(assignedDelivery, activityAfter, newVehicle) - getDistance(newInvestigatedPickup, activityAfter, newVehicle);
            minimalAdditionalDistance = findMinimalDistance(minimalAdditionalDistance, possibleAdditionalDistance);
        }
    }
    return minimalAdditionalDistance;
}","/**
	 * Finds a minimal additional distance for the tour, when a pickup is added to
	 * the plan. The AssociatedActivities contains both activities of a job which
	 * should be added to the existing tour. The TourActivities which are already in
	 * the tour are found in context.getRoute().getTourActivities. In this method
	 * the position of the new pickup is fixed and three options of the location of
	 * the delivery activity will be checked: delivery between every other activity
	 * after the pickup, delivery as the last activity before the end and delivery
	 * directly behind the new pickup. This method gives back the minimal distance
	 * of this three options.
	 *
	 * @param context
	 * @param newInvestigatedPickup
	 * @param nextAct
	 * @return minimal distance of the associated delivery
	 */","('findMinimalAdditionalDistance', {'INSTRUCTION': {'covered': 170, 'missed': 20}, 'BRANCH': {'covered': 8, 'missed': 6}, 'LINE': {'covered': 38, 'missed': 5}, 'COMPLEXITY': {'covered': 4, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",441.0,"  Finds a minimal additional distance for the tour, when a pickup is added to  the plan.",18.0,"['When a pickup is added to the plan, it adds a little more distance for the tour.', 'When a pickup is added to the plan, there is a minimal additional distance.', 'When a pickup is added to the plan, it adds a minimal additional distance.']"
1071,cdk,org/openscience/cdk/tautomers/InChITautomerGenerator.java,/tool/tautomer/src/main/java/org/openscience/cdk/tautomers/InChITautomerGenerator.java,connectAtoms,249-313,"/**
     * Pops and pushes its ways through the InChI connection table to build up a simple molecule.
     * @param inputInchi user input InChI
     * @param inputMolecule user input molecule
     * @param inchiAtomsByPosition
     * @return molecule with single bonds and no hydrogens.
     */
private IAtomContainer connectAtoms(String inputInchi, IAtomContainer inputMolecule, Map<Integer, IAtom> inchiAtomsByPosition) throws CDKException{
    String inchi = inputInchi;
    inchi = inchi.substring(inchi.indexOf('/') + 1);
    inchi = inchi.substring(inchi.indexOf('/') + 1);
    String connections = inchi.substring(1, inchi.indexOf('/'));
    Pattern connectionPattern = Pattern.compile(""(-|\\(|\\)|,|([0-9])*)"");
    Matcher match = connectionPattern.matcher(connections);
    Stack<IAtom> atomStack = new Stack<IAtom>();
    IAtomContainer inchiMolGraph = inputMolecule.getBuilder().newInstance(IAtomContainer.class);
    boolean pop = false;
    boolean push = true;
    while (match.find()) {
        String group = match.group();
        push = true;
        if (!group.isEmpty()) {
            if (group.matches(""[0-9]*"")) {
                IAtom atom = inchiAtomsByPosition.get(Integer.valueOf(group));
                if (!inchiMolGraph.contains(atom))
                    inchiMolGraph.addAtom(atom);
                IAtom prevAtom = null;
                if (atomStack.size() != 0) {
                    if (pop) {
                        prevAtom = atomStack.pop();
                    } else {
                        prevAtom = atomStack.get(atomStack.size() - 1);
                    }
                    IBond bond = inputMolecule.getBuilder().newInstance(IBond.class, prevAtom, atom, IBond.Order.SINGLE);
                    inchiMolGraph.addBond(bond);
                }
                if (push) {
                    atomStack.push(atom);
                }
            } else if (group.equals(""-"")) {
                pop = true;
                push = true;
            } else if (group.equals("","")) {
                atomStack.pop();
                pop = false;
                push = false;
            } else if (group.equals(""("")) {
                pop = false;
                push = true;
            } else if (group.equals("")"")) {
                atomStack.pop();
                pop = true;
                push = true;
            } else {
                throw new CDKException(""Unexpected token "" + group + "" in connection table encountered."");
            }
        }
    }
    for (IAtom at : inchiAtomsByPosition.values()) {
        if (!inchiMolGraph.contains(at))
            inchiMolGraph.addAtom(at);
    }
    return inchiMolGraph;
}","private IAtomContainer connectAtoms(String inputInchi, IAtomContainer inputMolecule, Map<Integer, IAtom> inchiAtomsByPosition) throws CDKException{
    String inchi = inputInchi;
    inchi = inchi.substring(inchi.indexOf('/') + 1);
    inchi = inchi.substring(inchi.indexOf('/') + 1);
    String connections = inchi.substring(1, inchi.indexOf('/'));
    Pattern connectionPattern = Pattern.compile(""(-|\\(|\\)|,|([0-9])*)"");
    Matcher match = connectionPattern.matcher(connections);
    Stack<IAtom> atomStack = new Stack<IAtom>();
    IAtomContainer inchiMolGraph = inputMolecule.getBuilder().newInstance(IAtomContainer.class);
    boolean pop = false;
    boolean push = true;
    while (match.find()) {
        String group = match.group();
        push = true;
        if (!group.isEmpty()) {
            if (group.matches(""[0-9]*"")) {
                IAtom atom = inchiAtomsByPosition.get(Integer.valueOf(group));
                if (!inchiMolGraph.contains(atom))
                    inchiMolGraph.addAtom(atom);
                IAtom prevAtom = null;
                if (atomStack.size() != 0) {
                    if (pop) {
                        prevAtom = atomStack.pop();
                    } else {
                        prevAtom = atomStack.get(atomStack.size() - 1);
                    }
                    IBond bond = inputMolecule.getBuilder().newInstance(IBond.class, prevAtom, atom, IBond.Order.SINGLE);
                    inchiMolGraph.addBond(bond);
                }
                if (push) {
                    atomStack.push(atom);
                }
            } else if (group.equals(""-"")) {
                pop = true;
                push = true;
            } else if (group.equals("","")) {
                atomStack.pop();
                pop = false;
                push = false;
            } else if (group.equals(""("")) {
                pop = false;
                push = true;
            } else if (group.equals("")"")) {
                atomStack.pop();
                pop = true;
                push = true;
            } else {
                throw new CDKException(""Unexpected token "" + group + "" in connection table encountered."");
            }
        }
    }
    for (IAtom at : inchiAtomsByPosition.values()) {
        if (!inchiMolGraph.contains(at))
            inchiMolGraph.addAtom(at);
    }
    return inchiMolGraph;
}","/**
     * Pops and pushes its ways through the InChI connection table to build up a simple molecule.
     * @param inputInchi user input InChI
     * @param inputMolecule user input molecule
     * @param inchiAtomsByPosition
     * @return molecule with single bonds and no hydrogens.
     */","('connectAtoms', {'INSTRUCTION': {'covered': 179, 'missed': 25}, 'BRANCH': {'covered': 22, 'missed': 4}, 'LINE': {'covered': 42, 'missed': 4}, 'COMPLEXITY': {'covered': 10, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",447.0,  Pops and pushes its ways through the InChI connection table to build up a simple molecule.,17.0,"['Pops and pushes its way through the table to build a molecule.', 'Pops and pushes its way through the table to make a molecule.', 'Pops and pushes its way through the table to build up a molecule.']"
1072,liquibase,liquibase/integration/commandline/Main.java,/liquibase-core/src/main/java/liquibase/integration/commandline/Main.java,isCommand,621-678,"/**
     * Returns true if the given arg is a valid main command of Liquibase.
     *
     * @param arg the String to test
     * @return true if it is a valid main command, false if not
     */
private static boolean isCommand(String arg){
    return COMMANDS.MIGRATE.equals(arg) || COMMANDS.MIGRATE_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE.equalsIgnoreCase(arg) || COMMANDS.UPDATE_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE_COUNT.equalsIgnoreCase(arg) || COMMANDS.UPDATE_COUNT_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE_TO_TAG.equalsIgnoreCase(arg) || COMMANDS.UPDATE_TO_TAG_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_TO_DATE.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_COUNT.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_TO_DATE_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_COUNT_SQL.equalsIgnoreCase(arg) || COMMANDS.REGISTER_CHANGELOG.equalsIgnoreCase(arg) || COMMANDS.DEACTIVATE_CHANGELOG.equalsIgnoreCase(arg) || COMMANDS.FUTURE_ROLLBACK_SQL.equalsIgnoreCase(arg) || COMMANDS.FUTURE_ROLLBACK_COUNT_SQL.equalsIgnoreCase(arg) || COMMANDS.FUTURE_ROLLBACK_FROM_TAG_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE_TESTING_ROLLBACK.equalsIgnoreCase(arg) || COMMANDS.TAG.equalsIgnoreCase(arg) || COMMANDS.TAG_EXISTS.equalsIgnoreCase(arg) || COMMANDS.LIST_LOCKS.equalsIgnoreCase(arg) || COMMANDS.HISTORY.equalsIgnoreCase(arg) || COMMANDS.DROP_ALL.equalsIgnoreCase(arg) || COMMANDS.RELEASE_LOCKS.equalsIgnoreCase(arg) || COMMANDS.STATUS.equalsIgnoreCase(arg) || COMMANDS.UNEXPECTED_CHANGESETS.equalsIgnoreCase(arg) || COMMANDS.VALIDATE.equalsIgnoreCase(arg) || COMMANDS.HELP.equalsIgnoreCase(arg) || COMMANDS.DIFF.equalsIgnoreCase(arg) || COMMANDS.DIFF_CHANGELOG.equalsIgnoreCase(arg) || COMMANDS.GENERATE_CHANGELOG.equalsIgnoreCase(arg) || COMMANDS.SNAPSHOT.equalsIgnoreCase(arg) || COMMANDS.SNAPSHOT_REFERENCE.equalsIgnoreCase(arg) || COMMANDS.SYNC_HUB.equalsIgnoreCase(arg) || COMMANDS.EXECUTE_SQL.equalsIgnoreCase(arg) || COMMANDS.CALCULATE_CHECKSUM.equalsIgnoreCase(arg) || COMMANDS.CLEAR_CHECKSUMS.equalsIgnoreCase(arg) || COMMANDS.DB_DOC.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC_TO_TAG.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC_TO_TAG_SQL.equalsIgnoreCase(arg) || COMMANDS.MARK_NEXT_CHANGESET_RAN.equalsIgnoreCase(arg) || COMMANDS.MARK_NEXT_CHANGESET_RAN_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_ONE_CHANGE_SET.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_ONE_CHANGE_SET_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_ONE_UPDATE.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_ONE_UPDATE_SQL.equalsIgnoreCase(arg);
}","private static boolean isCommand(String arg){
    return COMMANDS.MIGRATE.equals(arg) || COMMANDS.MIGRATE_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE.equalsIgnoreCase(arg) || COMMANDS.UPDATE_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE_COUNT.equalsIgnoreCase(arg) || COMMANDS.UPDATE_COUNT_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE_TO_TAG.equalsIgnoreCase(arg) || COMMANDS.UPDATE_TO_TAG_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_TO_DATE.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_COUNT.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_TO_DATE_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_COUNT_SQL.equalsIgnoreCase(arg) || COMMANDS.REGISTER_CHANGELOG.equalsIgnoreCase(arg) || COMMANDS.DEACTIVATE_CHANGELOG.equalsIgnoreCase(arg) || COMMANDS.FUTURE_ROLLBACK_SQL.equalsIgnoreCase(arg) || COMMANDS.FUTURE_ROLLBACK_COUNT_SQL.equalsIgnoreCase(arg) || COMMANDS.FUTURE_ROLLBACK_FROM_TAG_SQL.equalsIgnoreCase(arg) || COMMANDS.UPDATE_TESTING_ROLLBACK.equalsIgnoreCase(arg) || COMMANDS.TAG.equalsIgnoreCase(arg) || COMMANDS.TAG_EXISTS.equalsIgnoreCase(arg) || COMMANDS.LIST_LOCKS.equalsIgnoreCase(arg) || COMMANDS.HISTORY.equalsIgnoreCase(arg) || COMMANDS.DROP_ALL.equalsIgnoreCase(arg) || COMMANDS.RELEASE_LOCKS.equalsIgnoreCase(arg) || COMMANDS.STATUS.equalsIgnoreCase(arg) || COMMANDS.UNEXPECTED_CHANGESETS.equalsIgnoreCase(arg) || COMMANDS.VALIDATE.equalsIgnoreCase(arg) || COMMANDS.HELP.equalsIgnoreCase(arg) || COMMANDS.DIFF.equalsIgnoreCase(arg) || COMMANDS.DIFF_CHANGELOG.equalsIgnoreCase(arg) || COMMANDS.GENERATE_CHANGELOG.equalsIgnoreCase(arg) || COMMANDS.SNAPSHOT.equalsIgnoreCase(arg) || COMMANDS.SNAPSHOT_REFERENCE.equalsIgnoreCase(arg) || COMMANDS.SYNC_HUB.equalsIgnoreCase(arg) || COMMANDS.EXECUTE_SQL.equalsIgnoreCase(arg) || COMMANDS.CALCULATE_CHECKSUM.equalsIgnoreCase(arg) || COMMANDS.CLEAR_CHECKSUMS.equalsIgnoreCase(arg) || COMMANDS.DB_DOC.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC_TO_TAG.equalsIgnoreCase(arg) || COMMANDS.CHANGELOG_SYNC_TO_TAG_SQL.equalsIgnoreCase(arg) || COMMANDS.MARK_NEXT_CHANGESET_RAN.equalsIgnoreCase(arg) || COMMANDS.MARK_NEXT_CHANGESET_RAN_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_ONE_CHANGE_SET.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_ONE_CHANGE_SET_SQL.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_ONE_UPDATE.equalsIgnoreCase(arg) || COMMANDS.ROLLBACK_ONE_UPDATE_SQL.equalsIgnoreCase(arg);
}","/**
     * Returns true if the given arg is a valid main command of Liquibase.
     *
     * @param arg the String to test
     * @return true if it is a valid main command, false if not
     */","('isCommand', {'INSTRUCTION': {'covered': 204, 'missed': 0}, 'BRANCH': {'covered': 70, 'missed': 30}, 'LINE': {'covered': 50, 'missed': 0}, 'COMPLEXITY': {'covered': 21, 'missed': 30}, 'METHOD': {'covered': 1, 'missed': 0}})",461.0,  Returns true if the given arg is a valid main command of Liquibase.,14.0,"['If the given arg is a valid main command, this is true.', 'If the given arg is a valid main command, then this is true.', 'If the given arg is a valid main command, then it is true.']"
1073,dcache,org/dcache/services/billing/text/BillingParserBuilder.java,/modules/dcache/src/main/java/org/dcache/services/billing/text/BillingParserBuilder.java,toPattern,153-250,"/**
     * Returns a Pattern for matching the provided billing format.
     * <p>
     * Attributes are turned into named capturing groups.
     */
private static Pattern toPattern(String name, String format){
    StringBuilder regex = new StringBuilder();
    Matcher matcher = ATTRIBUTE_PATTERN.matcher(format);
    int pos = 0;
    while (matcher.find()) {
        if (pos < matcher.start()) {
            regex.append(Pattern.quote(format.substring(pos, matcher.start())));
        }
        String expression = matcher.group(1);
        if (isIf(expression)) {
            regex.append(""(?:"");
        } else if (isElse(expression)) {
            regex.append(""|"");
        } else if (isEndIf(expression)) {
            regex.append("")"");
        } else {
            regex.append(""(?<"").append(toGroupName(expression)).append("">"");
            switch(expression) {
                case ""date"":
                    regex.append("".+?"");
                    break;
                case ""pnfsid"":
                    regex.append(""[0-9A-F]{24}(?:[0-9A-F]{12})?"");
                    break;
                case ""filesize"":
                case ""transferred"":
                case ""connectionTime"":
                case ""transactionTime"":
                case ""queuingTime"":
                case ""transferTime"":
                case ""rc"":
                case ""uid"":
                case ""gid"":
                    regex.append(""-?\\d+"");
                    break;
                case ""cached"":
                case ""created"":
                    regex.append(""(?:true|false)"");
                    break;
                case ""cellType"":
                    switch(name) {
                        case ""mover-info-message"":
                        case ""remove-file-info-message"":
                        case ""storage-info-message"":
                        case ""pool-hit-info-message"":
                            regex.append(""pool"");
                            break;
                        case ""door-request-info-message"":
                            regex.append(""door"");
                            break;
                        default:
                            regex.append(""\\w+"");
                            break;
                    }
                    break;
                case ""cellName"":
                    regex.append("".+?"");
                    break;
                case ""type"":
                    switch(name) {
                        case ""mover-info-message"":
                            regex.append(""transfer"");
                            break;
                        case ""remove-file-info-message"":
                            regex.append(""remove"");
                            break;
                        case ""storage-info-message"":
                            regex.append(""(?:re)?store"");
                            break;
                        case ""pool-hit-info-message"":
                            regex.append(""hit"");
                            break;
                        case ""warning-pnfs-file-info-message"":
                            regex.append(""warning"");
                            break;
                        default:
                            regex.append(""\\w+"");
                            break;
                    }
                    break;
                default:
                    regex.append("".*?"");
            }
            regex.append("")"");
        }
        pos = matcher.end();
    }
    if (pos < format.length()) {
        regex.append(Pattern.quote(format.substring(pos)));
    }
    return Pattern.compile(regex.toString(), Pattern.CASE_INSENSITIVE);
}","private static Pattern toPattern(String name, String format){
    StringBuilder regex = new StringBuilder();
    Matcher matcher = ATTRIBUTE_PATTERN.matcher(format);
    int pos = 0;
    while (matcher.find()) {
        if (pos < matcher.start()) {
            regex.append(Pattern.quote(format.substring(pos, matcher.start())));
        }
        String expression = matcher.group(1);
        if (isIf(expression)) {
            regex.append(""(?:"");
        } else if (isElse(expression)) {
            regex.append(""|"");
        } else if (isEndIf(expression)) {
            regex.append("")"");
        } else {
            regex.append(""(?<"").append(toGroupName(expression)).append("">"");
            switch(expression) {
                case ""date"":
                    regex.append("".+?"");
                    break;
                case ""pnfsid"":
                    regex.append(""[0-9A-F]{24}(?:[0-9A-F]{12})?"");
                    break;
                case ""filesize"":
                case ""transferred"":
                case ""connectionTime"":
                case ""transactionTime"":
                case ""queuingTime"":
                case ""transferTime"":
                case ""rc"":
                case ""uid"":
                case ""gid"":
                    regex.append(""-?\\d+"");
                    break;
                case ""cached"":
                case ""created"":
                    regex.append(""(?:true|false)"");
                    break;
                case ""cellType"":
                    switch(name) {
                        case ""mover-info-message"":
                        case ""remove-file-info-message"":
                        case ""storage-info-message"":
                        case ""pool-hit-info-message"":
                            regex.append(""pool"");
                            break;
                        case ""door-request-info-message"":
                            regex.append(""door"");
                            break;
                        default:
                            regex.append(""\\w+"");
                            break;
                    }
                    break;
                case ""cellName"":
                    regex.append("".+?"");
                    break;
                case ""type"":
                    switch(name) {
                        case ""mover-info-message"":
                            regex.append(""transfer"");
                            break;
                        case ""remove-file-info-message"":
                            regex.append(""remove"");
                            break;
                        case ""storage-info-message"":
                            regex.append(""(?:re)?store"");
                            break;
                        case ""pool-hit-info-message"":
                            regex.append(""hit"");
                            break;
                        case ""warning-pnfs-file-info-message"":
                            regex.append(""warning"");
                            break;
                        default:
                            regex.append(""\\w+"");
                            break;
                    }
                    break;
                default:
                    regex.append("".*?"");
            }
            regex.append("")"");
        }
        pos = matcher.end();
    }
    if (pos < format.length()) {
        regex.append(Pattern.quote(format.substring(pos)));
    }
    return Pattern.compile(regex.toString(), Pattern.CASE_INSENSITIVE);
}","/**
     * Returns a Pattern for matching the provided billing format.
     * <p>
     * Attributes are turned into named capturing groups.
     */","('toPattern', {'INSTRUCTION': {'covered': 171, 'missed': 14}, 'BRANCH': {'covered': 25, 'missed': 4}, 'LINE': {'covered': 47, 'missed': 5}, 'COMPLEXITY': {'covered': 17, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",463.0,  Returns a Pattern for matching the provided billing format.,10.0,"['The pattern is used to match the provided billing format.', 'The pattern is used to match the billing format.', 'A pattern is returned for matching the billing format.']"
1075,cdk,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,arcConstructor,837-898,"/**
     *  Build edges of the RGraphs
     *  This method create the edge of the CDKRGraph and
     *  calculates the incompatibility and neighbourhood
     *  relationships between CDKRGraph nodes.
     *
     * @param  graph   the rGraph
     * @param  ac1   first molecule. Must not be an IQueryAtomContainer.
     * @param  ac2   second molecule. May be an IQueryAtomContainer.
     * @throws org.openscience.cdk.exception.CDKException if it takes too long to get the overlaps
     */
private static void arcConstructor(CDKRGraph graph, IAtomContainer ac1, IAtomContainer ac2) throws CDKException{
    for (int i = 0; i < graph.getGraph().size(); i++) {
        CDKRNode rNodeX = graph.getGraph().get(i);
        rNodeX.getForbidden().set(i);
    }
    IBond bondA1;
    IBond bondA2;
    IBond bondB1;
    IBond bondB2;
    graph.setFirstGraphSize(ac1.getBondCount());
    graph.setSecondGraphSize(ac2.getBondCount());
    for (int i = 0; i < graph.getGraph().size(); i++) {
        CDKRNode rNodeX = graph.getGraph().get(i);
        for (int j = i + 1; j < graph.getGraph().size(); j++) {
            CDKRNode rNodeY = graph.getGraph().get(j);
            bondA1 = ac1.getBond(graph.getGraph().get(i).getRMap().getId1());
            bondA2 = ac2.getBond(graph.getGraph().get(i).getRMap().getId2());
            bondB1 = ac1.getBond(graph.getGraph().get(j).getRMap().getId1());
            bondB2 = ac2.getBond(graph.getGraph().get(j).getRMap().getId2());
            if (bondA2 instanceof IQueryBond) {
                if (bondA1.equals(bondB1) || bondA2.equals(bondB2) || !queryAdjacencyAndOrder(bondA1, bondB1, bondA2, bondB2)) {
                    rNodeX.getForbidden().set(j);
                    rNodeY.getForbidden().set(i);
                } else if (hasCommonAtom(bondA1, bondB1)) {
                    rNodeX.getExtension().set(j);
                    rNodeY.getExtension().set(i);
                }
            } else {
                if (bondA1.equals(bondB1) || bondA2.equals(bondB2) || (!getCommonSymbol(bondA1, bondB1).equals(getCommonSymbol(bondA2, bondB2)))) {
                    rNodeX.getForbidden().set(j);
                    rNodeY.getForbidden().set(i);
                } else if (hasCommonAtom(bondA1, bondB1)) {
                    rNodeX.getExtension().set(j);
                    rNodeY.getExtension().set(i);
                }
            }
        }
    }
}","private static void arcConstructor(CDKRGraph graph, IAtomContainer ac1, IAtomContainer ac2) throws CDKException{
    for (int i = 0; i < graph.getGraph().size(); i++) {
        CDKRNode rNodeX = graph.getGraph().get(i);
        rNodeX.getForbidden().set(i);
    }
    IBond bondA1;
    IBond bondA2;
    IBond bondB1;
    IBond bondB2;
    graph.setFirstGraphSize(ac1.getBondCount());
    graph.setSecondGraphSize(ac2.getBondCount());
    for (int i = 0; i < graph.getGraph().size(); i++) {
        CDKRNode rNodeX = graph.getGraph().get(i);
        for (int j = i + 1; j < graph.getGraph().size(); j++) {
            CDKRNode rNodeY = graph.getGraph().get(j);
            bondA1 = ac1.getBond(graph.getGraph().get(i).getRMap().getId1());
            bondA2 = ac2.getBond(graph.getGraph().get(i).getRMap().getId2());
            bondB1 = ac1.getBond(graph.getGraph().get(j).getRMap().getId1());
            bondB2 = ac2.getBond(graph.getGraph().get(j).getRMap().getId2());
            if (bondA2 instanceof IQueryBond) {
                if (bondA1.equals(bondB1) || bondA2.equals(bondB2) || !queryAdjacencyAndOrder(bondA1, bondB1, bondA2, bondB2)) {
                    rNodeX.getForbidden().set(j);
                    rNodeY.getForbidden().set(i);
                } else if (hasCommonAtom(bondA1, bondB1)) {
                    rNodeX.getExtension().set(j);
                    rNodeY.getExtension().set(i);
                }
            } else {
                if (bondA1.equals(bondB1) || bondA2.equals(bondB2) || (!getCommonSymbol(bondA1, bondB1).equals(getCommonSymbol(bondA2, bondB2)))) {
                    rNodeX.getForbidden().set(j);
                    rNodeY.getForbidden().set(i);
                } else if (hasCommonAtom(bondA1, bondB1)) {
                    rNodeX.getExtension().set(j);
                    rNodeY.getExtension().set(i);
                }
            }
        }
    }
}","/**
     *  Build edges of the RGraphs
     *  This method create the edge of the CDKRGraph and
     *  calculates the incompatibility and neighbourhood
     *  relationships between CDKRGraph nodes.
     *
     * @param  graph   the rGraph
     * @param  ac1   first molecule. Must not be an IQueryAtomContainer.
     * @param  ac2   second molecule. May be an IQueryAtomContainer.
     * @throws org.openscience.cdk.exception.CDKException if it takes too long to get the overlaps
     */","('arcConstructor', {'INSTRUCTION': {'covered': 176, 'missed': 0}, 'BRANCH': {'covered': 24, 'missed': 0}, 'LINE': {'covered': 29, 'missed': 0}, 'COMPLEXITY': {'covered': 13, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",474.0,  Build edges of the RGraphs  This method create the edge of the CDKRGraph and  calculates the incompatibility and neighbourhood  relationships between CDKRGraph nodes.,24.0,"['The edge of the CDKRGraph can be built using this method.', 'This method builds the edges of the RGraphs and calculates the incompatibility and neighbourhood relationships between the CDKRGraph nodes.', 'This method builds the edges of the RGraphs and calculates the incompatibility and neighbourhood relationships of the CDKRGraph.']"
1077,cdk,org/openscience/cdk/smiles/FixBondOrdersTool.java,/legacy/src/main/java/org/openscience/cdk/smiles/FixBondOrdersTool.java,kekuliseAromaticRings,140-231,"/**
     * kekuliseAromaticRings - function to add double/single bond order information for molecules having rings containing all atoms marked SP2 or Planar3 hybridisation.
     * @param molecule The {@link IAtomContainer} to kekulise
     * @return The {@link IAtomContainer} with kekule structure
     * @throws CDKException
     */
public IAtomContainer kekuliseAromaticRings(IAtomContainer molecule) throws CDKException{
    IAtomContainer mNew = null;
    try {
        mNew = (IAtomContainer) molecule.clone();
    } catch (Exception e) {
        throw new CDKException(""Failed to clone source molecule"");
    }
    IRingSet ringSet;
    try {
        ringSet = removeExtraRings(mNew);
    } catch (CDKException x) {
        throw x;
    } catch (Exception x) {
        throw new CDKException(""failure in SSSRFinder.findAllRings"", x);
    }
    if (ringSet == null) {
        throw new CDKException(""failure in SSSRFinder.findAllRings"");
    }
    // We need to establish which rings share bonds and set up sets of such interdependant rings
    List<Integer[]> rBondsArray = null;
    List<List<Integer>> ringGroups = null;
    // Start by getting a list (same dimensions and ordering as ringset) of all the ring bond numbers in the reduced ring set
    rBondsArray = getRingSystem(mNew, ringSet);
    // Now find out which share a bond and assign them accordingly to groups
    ringGroups = assignRingGroups(rBondsArray);
    // Loop through each group of rings checking all choices of double bond combis and seeing if you can get a
    // proper molecule.
    for (int i = 0; i < ringGroups.size(); i++) {
        // Set all ring bonds with single order to allow Matrix solving to work
        setAllRingBondsSingleOrder(ringGroups.get(i), ringSet);
        // Set up  lists of atoms, bonds and atom pairs for this ringGroup
        List<Integer> atomNos = null;
        atomNos = getAtomNosForRingGroup(mNew, ringGroups.get(i), ringSet);
        List<Integer> bondNos = null;
        bondNos = getBondNosForRingGroup(mNew, ringGroups.get(i), ringSet);
        // Array of same dimensions as bondNos (cols in Matrix)
        List<Integer[]> atomNoPairs = null;
        atomNoPairs = getAtomNoPairsForRingGroup(mNew, bondNos);
        // Set up ajacency Matrix
        Matrix M = new Matrix(atomNos.size(), bondNos.size());
        for (int x = 0; x < M.getRows(); x++) {
            for (int y = 0; y < M.getCols(); y++) {
                if (Objects.equals(atomNos.get(x), atomNoPairs.get(y)[0])) {
                    M.set(x, y, 1);
                } else {
                    if (Objects.equals(atomNos.get(x), atomNoPairs.get(y)[1])) {
                        M.set(x, y, 1);
                    } else {
                        M.set(x, y, 0);
                    }
                }
            }
        }
        // Array of same dimensions as atomNos (rows in Matrix)
        List<Integer> freeValencies = null;
        freeValencies = getFreeValenciesForRingGroup(mNew, atomNos, M, ringSet);
        // Array of ""answers""
        List<Integer> bondOrders = new ArrayList<Integer>();
        for (int j = 0; j < bondNos.size(); j++) {
            bondOrders.add(0);
        }
        if (solveMatrix(M, atomNos, bondNos, freeValencies, atomNoPairs, bondOrders)) {
            for (int j = 0; j < bondOrders.size(); j++) {
                mNew.getBond(bondNos.get(j)).setOrder(bondOrders.get(j) == 1 ? IBond.Order.SINGLE : IBond.Order.DOUBLE);
            }
        } else {
            // TODO Put any failure code here
        }
    }
    return mNew;
}","public IAtomContainer kekuliseAromaticRings(IAtomContainer molecule) throws CDKException{
    IAtomContainer mNew = null;
    try {
        mNew = (IAtomContainer) molecule.clone();
    } catch (Exception e) {
        throw new CDKException(""Failed to clone source molecule"");
    }
    IRingSet ringSet;
    try {
        ringSet = removeExtraRings(mNew);
    } catch (CDKException x) {
        throw x;
    } catch (Exception x) {
        throw new CDKException(""failure in SSSRFinder.findAllRings"", x);
    }
    if (ringSet == null) {
        throw new CDKException(""failure in SSSRFinder.findAllRings"");
    }
    // We need to establish which rings share bonds and set up sets of such interdependant rings
    List<Integer[]> rBondsArray = null;
    List<List<Integer>> ringGroups = null;
    // Start by getting a list (same dimensions and ordering as ringset) of all the ring bond numbers in the reduced ring set
    rBondsArray = getRingSystem(mNew, ringSet);
    // Now find out which share a bond and assign them accordingly to groups
    ringGroups = assignRingGroups(rBondsArray);
    // Loop through each group of rings checking all choices of double bond combis and seeing if you can get a
    // proper molecule.
    for (int i = 0; i < ringGroups.size(); i++) {
        // Set all ring bonds with single order to allow Matrix solving to work
        setAllRingBondsSingleOrder(ringGroups.get(i), ringSet);
        // Set up  lists of atoms, bonds and atom pairs for this ringGroup
        List<Integer> atomNos = null;
        atomNos = getAtomNosForRingGroup(mNew, ringGroups.get(i), ringSet);
        List<Integer> bondNos = null;
        bondNos = getBondNosForRingGroup(mNew, ringGroups.get(i), ringSet);
        // Array of same dimensions as bondNos (cols in Matrix)
        List<Integer[]> atomNoPairs = null;
        atomNoPairs = getAtomNoPairsForRingGroup(mNew, bondNos);
        // Set up ajacency Matrix
        Matrix M = new Matrix(atomNos.size(), bondNos.size());
        for (int x = 0; x < M.getRows(); x++) {
            for (int y = 0; y < M.getCols(); y++) {
                if (Objects.equals(atomNos.get(x), atomNoPairs.get(y)[0])) {
                    M.set(x, y, 1);
                } else {
                    if (Objects.equals(atomNos.get(x), atomNoPairs.get(y)[1])) {
                        M.set(x, y, 1);
                    } else {
                        M.set(x, y, 0);
                    }
                }
            }
        }
        // Array of same dimensions as atomNos (rows in Matrix)
        List<Integer> freeValencies = null;
        freeValencies = getFreeValenciesForRingGroup(mNew, atomNos, M, ringSet);
        // Array of ""answers""
        List<Integer> bondOrders = new ArrayList<Integer>();
        for (int j = 0; j < bondNos.size(); j++) {
            bondOrders.add(0);
        }
        if (solveMatrix(M, atomNos, bondNos, freeValencies, atomNoPairs, bondOrders)) {
            for (int j = 0; j < bondOrders.size(); j++) {
                mNew.getBond(bondNos.get(j)).setOrder(bondOrders.get(j) == 1 ? IBond.Order.SINGLE : IBond.Order.DOUBLE);
            }
        } else {
            // TODO Put any failure code here
        }
    }
    return mNew;
}","/**
     * kekuliseAromaticRings - function to add double/single bond order information for molecules having rings containing all atoms marked SP2 or Planar3 hybridisation.
     * @param molecule The {@link IAtomContainer} to kekulise
     * @return The {@link IAtomContainer} with kekule structure
     * @throws CDKException
     */","('kekuliseAromaticRings', {'INSTRUCTION': {'covered': 211, 'missed': 21}, 'BRANCH': {'covered': 18, 'missed': 2}, 'LINE': {'covered': 36, 'missed': 7}, 'COMPLEXITY': {'covered': 9, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",527.0,kekuliseAromaticRings - function to add double/single bond order information for molecules having rings containing all atoms marked SP2 or Planar3 hybridisation.,22.0,"['The function of kekuliseAromaticRings is to add double/ single bond order information for the rings of the molecule.', 'The function of kekuliseAromaticRings is to add double/ single bond order information for molecules with rings containing all atoms.', 'The function of kekuliseAromaticRings is to add double/ single bond order information for molecules with rings containing all of the same atoms.']"
1078,cdk,org/openscience/cdk/layout/IdentityTemplateLibrary.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/IdentityTemplateLibrary.java,cansmi,111-193,"/**
     * Internal - create a canonical SMILES string temporarily adjusting to default
     * hydrogen count. This method may be moved to the SMILESGenerator in future.
     *
     * @param mol molecule
     * @param ordering ordering output
     * @return SMILES
     * @throws CDKException SMILES could be generate
     */
private String cansmi(IAtomContainer mol, int[] ordering) throws CDKException{
    Integer[] hcntBackup = new Integer[mol.getAtomCount()];
    Map<IAtom, Integer> idxs = new HashMap<>();
    for (int i = 0; i < mol.getAtomCount(); i++) {
        hcntBackup[i] = mol.getAtom(i).getImplicitHydrogenCount();
        idxs.put(mol.getAtom(i), i);
    }
    int[] bondedValence = new int[mol.getAtomCount()];
    for (int i = 0; i < mol.getBondCount(); i++) {
        IBond bond = mol.getBond(i);
        bondedValence[idxs.get(bond.getBegin())] += bond.getOrder().numeric();
        bondedValence[idxs.get(bond.getEnd())] += bond.getOrder().numeric();
    }
    for (int i = 0; i < mol.getAtomCount(); i++) {
        IAtom atom = mol.getAtom(i);
        atom.setImplicitHydrogenCount(0);
        switch(atom.getAtomicNumber()) {
            case 5:
                if (bondedValence[i] <= 3)
                    atom.setImplicitHydrogenCount(3 - bondedValence[i]);
                break;
            case 6:
                if (bondedValence[i] <= 4)
                    atom.setImplicitHydrogenCount(4 - bondedValence[i]);
                break;
            case 7:
            case 15:
                if (bondedValence[i] <= 3)
                    atom.setImplicitHydrogenCount(3 - bondedValence[i]);
                else if (bondedValence[i] <= 5)
                    atom.setImplicitHydrogenCount(5 - bondedValence[i]);
                break;
            case 8:
                if (bondedValence[i] <= 2)
                    atom.setImplicitHydrogenCount(2 - bondedValence[i]);
                break;
            case 16:
                if (bondedValence[i] <= 2)
                    atom.setImplicitHydrogenCount(2 - bondedValence[i]);
                else if (bondedValence[i] <= 4)
                    atom.setImplicitHydrogenCount(4 - bondedValence[i]);
                else if (bondedValence[i] <= 6)
                    atom.setImplicitHydrogenCount(6 - bondedValence[i]);
                break;
            case 9:
            case 17:
            case 35:
            case 53:
                if (bondedValence[i] <= 1)
                    atom.setImplicitHydrogenCount(1 - bondedValence[i]);
                break;
            default:
                atom.setImplicitHydrogenCount(0);
                break;
        }
    }
    String smi = null;
    try {
        smi = smigen.create(mol, ordering);
    } finally {
        for (int i = 0; i < mol.getAtomCount(); i++) mol.getAtom(i).setImplicitHydrogenCount(hcntBackup[i]);
    }
    return smi;
}","private String cansmi(IAtomContainer mol, int[] ordering) throws CDKException{
    Integer[] hcntBackup = new Integer[mol.getAtomCount()];
    Map<IAtom, Integer> idxs = new HashMap<>();
    for (int i = 0; i < mol.getAtomCount(); i++) {
        hcntBackup[i] = mol.getAtom(i).getImplicitHydrogenCount();
        idxs.put(mol.getAtom(i), i);
    }
    int[] bondedValence = new int[mol.getAtomCount()];
    for (int i = 0; i < mol.getBondCount(); i++) {
        IBond bond = mol.getBond(i);
        bondedValence[idxs.get(bond.getBegin())] += bond.getOrder().numeric();
        bondedValence[idxs.get(bond.getEnd())] += bond.getOrder().numeric();
    }
    for (int i = 0; i < mol.getAtomCount(); i++) {
        IAtom atom = mol.getAtom(i);
        atom.setImplicitHydrogenCount(0);
        switch(atom.getAtomicNumber()) {
            case 5:
                if (bondedValence[i] <= 3)
                    atom.setImplicitHydrogenCount(3 - bondedValence[i]);
                break;
            case 6:
                if (bondedValence[i] <= 4)
                    atom.setImplicitHydrogenCount(4 - bondedValence[i]);
                break;
            case 7:
            case 15:
                if (bondedValence[i] <= 3)
                    atom.setImplicitHydrogenCount(3 - bondedValence[i]);
                else if (bondedValence[i] <= 5)
                    atom.setImplicitHydrogenCount(5 - bondedValence[i]);
                break;
            case 8:
                if (bondedValence[i] <= 2)
                    atom.setImplicitHydrogenCount(2 - bondedValence[i]);
                break;
            case 16:
                if (bondedValence[i] <= 2)
                    atom.setImplicitHydrogenCount(2 - bondedValence[i]);
                else if (bondedValence[i] <= 4)
                    atom.setImplicitHydrogenCount(4 - bondedValence[i]);
                else if (bondedValence[i] <= 6)
                    atom.setImplicitHydrogenCount(6 - bondedValence[i]);
                break;
            case 9:
            case 17:
            case 35:
            case 53:
                if (bondedValence[i] <= 1)
                    atom.setImplicitHydrogenCount(1 - bondedValence[i]);
                break;
            default:
                atom.setImplicitHydrogenCount(0);
                break;
        }
    }
    String smi = null;
    try {
        smi = smigen.create(mol, ordering);
    } finally {
        for (int i = 0; i < mol.getAtomCount(); i++) mol.getAtom(i).setImplicitHydrogenCount(hcntBackup[i]);
    }
    return smi;
}","/**
     * Internal - create a canonical SMILES string temporarily adjusting to default
     * hydrogen count. This method may be moved to the SMILESGenerator in future.
     *
     * @param mol molecule
     * @param ordering ordering output
     * @return SMILES
     * @throws CDKException SMILES could be generate
     */","('cansmi', {'INSTRUCTION': {'covered': 192, 'missed': 60}, 'BRANCH': {'covered': 18, 'missed': 15}, 'LINE': {'covered': 29, 'missed': 9}, 'COMPLEXITY': {'covered': 9, 'missed': 11}, 'METHOD': {'covered': 1, 'missed': 0}})",539.0,  Internal - create a canonical SMILES string temporarily adjusting to default  hydrogen count.,14.0,"['The SMILES string temporarily adjusts to the default hydrogen count.', 'The SMILES string temporarily adjusting to default hydrogen count is internal.', 'The SMILES string temporarily adjusting to the default hydrogen count is internal.']"
1079,cdk,org/openscience/cdk/fingerprint/ShortestPathFingerprinter.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/fingerprint/ShortestPathFingerprinter.java,findPaths,177-255,"/**
     * Get all paths of lengths 0 to the specified length.
     *
     * This method will find all paths upto length N starting from each atom in the molecule and return the unique set
     * of such paths.
     *
     * @param container The molecule to search
     * @return A map of path strings, keyed on themselves
     */
private Integer[] findPaths(IAtomContainer container){
    ShortestPathWalker walker = new ShortestPathWalker(container);
    List<Integer> paths = new ArrayList<Integer>();
    int patternIndex = 0;
    for (String s : walker.paths()) {
        int toHashCode = s.hashCode();
        paths.add(patternIndex, toHashCode);
        patternIndex++;
    }
    IRingSet sssr = Cycles.essential(container).toRingSet();
    RingSetManipulator.sort(sssr);
    for (Iterator<IAtomContainer> it = sssr.atomContainers().iterator(); it.hasNext(); ) {
        IAtomContainer ring = it.next();
        int toHashCode = String.valueOf(ring.getAtomCount()).hashCode();
        paths.add(patternIndex, toHashCode);
        patternIndex++;
    }
    List<String> l = new ArrayList<String>();
    for (Iterator<IAtom> it = container.atoms().iterator(); it.hasNext(); ) {
        IAtom atom = it.next();
        int charge = atom.getFormalCharge() == null ? 0 : atom.getFormalCharge();
        if (charge != 0) {
            l.add(atom.getSymbol().concat(String.valueOf(charge)));
        }
    }
    Collections.sort(l);
    int toHashCode = l.hashCode();
    paths.add(patternIndex, toHashCode);
    patternIndex++;
    l = new ArrayList<String>();
    for (Iterator<IAtom> it = container.atoms().iterator(); it.hasNext(); ) {
        IAtom atom = it.next();
        int st = atom.getStereoParity() == null ? 0 : atom.getStereoParity();
        if (st != 0) {
            l.add(atom.getSymbol().concat(String.valueOf(st)));
        }
    }
    Collections.sort(l);
    toHashCode = l.hashCode();
    paths.add(patternIndex, toHashCode);
    patternIndex++;
    if (container.getSingleElectronCount() > 0) {
        StringBuilder radicalInformation = new StringBuilder();
        radicalInformation.append(""RAD: "").append(String.valueOf(container.getSingleElectronCount()));
        paths.add(patternIndex, radicalInformation.toString().hashCode());
        patternIndex++;
    }
    if (container.getLonePairCount() > 0) {
        StringBuilder lpInformation = new StringBuilder();
        lpInformation.append(""LP: "").append(String.valueOf(container.getLonePairCount()));
        paths.add(patternIndex, lpInformation.toString().hashCode());
        patternIndex++;
    }
    return paths.toArray(new Integer[paths.size()]);
}","private Integer[] findPaths(IAtomContainer container){
    ShortestPathWalker walker = new ShortestPathWalker(container);
    List<Integer> paths = new ArrayList<Integer>();
    int patternIndex = 0;
    for (String s : walker.paths()) {
        int toHashCode = s.hashCode();
        paths.add(patternIndex, toHashCode);
        patternIndex++;
    }
    IRingSet sssr = Cycles.essential(container).toRingSet();
    RingSetManipulator.sort(sssr);
    for (Iterator<IAtomContainer> it = sssr.atomContainers().iterator(); it.hasNext(); ) {
        IAtomContainer ring = it.next();
        int toHashCode = String.valueOf(ring.getAtomCount()).hashCode();
        paths.add(patternIndex, toHashCode);
        patternIndex++;
    }
    List<String> l = new ArrayList<String>();
    for (Iterator<IAtom> it = container.atoms().iterator(); it.hasNext(); ) {
        IAtom atom = it.next();
        int charge = atom.getFormalCharge() == null ? 0 : atom.getFormalCharge();
        if (charge != 0) {
            l.add(atom.getSymbol().concat(String.valueOf(charge)));
        }
    }
    Collections.sort(l);
    int toHashCode = l.hashCode();
    paths.add(patternIndex, toHashCode);
    patternIndex++;
    l = new ArrayList<String>();
    for (Iterator<IAtom> it = container.atoms().iterator(); it.hasNext(); ) {
        IAtom atom = it.next();
        int st = atom.getStereoParity() == null ? 0 : atom.getStereoParity();
        if (st != 0) {
            l.add(atom.getSymbol().concat(String.valueOf(st)));
        }
    }
    Collections.sort(l);
    toHashCode = l.hashCode();
    paths.add(patternIndex, toHashCode);
    patternIndex++;
    if (container.getSingleElectronCount() > 0) {
        StringBuilder radicalInformation = new StringBuilder();
        radicalInformation.append(""RAD: "").append(String.valueOf(container.getSingleElectronCount()));
        paths.add(patternIndex, radicalInformation.toString().hashCode());
        patternIndex++;
    }
    if (container.getLonePairCount() > 0) {
        StringBuilder lpInformation = new StringBuilder();
        lpInformation.append(""LP: "").append(String.valueOf(container.getLonePairCount()));
        paths.add(patternIndex, lpInformation.toString().hashCode());
        patternIndex++;
    }
    return paths.toArray(new Integer[paths.size()]);
}","/**
     * Get all paths of lengths 0 to the specified length.
     *
     * This method will find all paths upto length N starting from each atom in the molecule and return the unique set
     * of such paths.
     *
     * @param container The molecule to search
     * @return A map of path strings, keyed on themselves
     */","('findPaths', {'INSTRUCTION': {'covered': 156, 'missed': 50}, 'BRANCH': {'covered': 16, 'missed': 4}, 'LINE': {'covered': 40, 'missed': 9}, 'COMPLEXITY': {'covered': 7, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",545.0,Get all paths of lengths 0 to the specified length.,11.0,"['Get all the paths of lengths.', 'All paths of lengths 0 to the specified length can be obtained.', 'All paths of lengths 0 to the specified length are obtained.']"
1080,cdk,org/openscience/cdk/smsd/algorithm/rgraph/CDKRMapHandler.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRMapHandler.java,makeAtomsMapOfBondsMap,327-396,"/**
     *  This makes sourceAtom map of matching atoms out of sourceAtom map of matching bonds as produced by the get(Subgraph|Ismorphism)Map methods.
     *
     * @param  rMapList   The list produced by the getMap method.
     * @param  graph1  first molecule. Must not be an IQueryAtomContainer.
     * @param  graph2  second molecule. May be an IQueryAtomContainer.
     * @return     The mapping found projected on graph1. This is sourceAtom List of CDKRMap objects containing Ids of matching atoms.
     */
private static List<List<CDKRMap>> makeAtomsMapOfBondsMap(List<CDKRMap> rMapList, IAtomContainer graph1, IAtomContainer graph2){
    if (rMapList == null) {
        return (null);
    }
    List<List<CDKRMap>> result = null;
    if (rMapList.size() == 1) {
        result = makeAtomsMapOfBondsMapSingleBond(rMapList, graph1, graph2);
    } else {
        List<CDKRMap> resultLocal = new ArrayList<CDKRMap>();
        for (int i = 0; i < rMapList.size(); i++) {
            IBond qBond = graph1.getBond(rMapList.get(i).getId1());
            IBond tBond = graph2.getBond(rMapList.get(i).getId2());
            IAtom[] qAtoms = BondManipulator.getAtomArray(qBond);
            IAtom[] tAtoms = BondManipulator.getAtomArray(tBond);
            for (int j = 0; j < 2; j++) {
                List<IBond> bondsConnectedToAtom1j = graph1.getConnectedBondsList(qAtoms[j]);
                for (int k = 0; k < bondsConnectedToAtom1j.size(); k++) {
                    if (!bondsConnectedToAtom1j.get(k).equals(qBond)) {
                        IBond testBond = bondsConnectedToAtom1j.get(k);
                        for (int m = 0; m < rMapList.size(); m++) {
                            IBond testBond2;
                            if ((rMapList.get(m)).getId1() == graph1.indexOf(testBond)) {
                                testBond2 = graph2.getBond((rMapList.get(m)).getId2());
                                for (int n = 0; n < 2; n++) {
                                    List<IBond> bondsToTest = graph2.getConnectedBondsList(tAtoms[n]);
                                    if (bondsToTest.contains(testBond2)) {
                                        CDKRMap map;
                                        if (j == n) {
                                            map = new CDKRMap(graph1.indexOf(qAtoms[0]), graph2.indexOf(tAtoms[0]));
                                        } else {
                                            map = new CDKRMap(graph1.indexOf(qAtoms[1]), graph2.indexOf(tAtoms[0]));
                                        }
                                        if (!resultLocal.contains(map)) {
                                            resultLocal.add(map);
                                        }
                                        CDKRMap map2;
                                        if (j == n) {
                                            map2 = new CDKRMap(graph1.indexOf(qAtoms[1]), graph2.indexOf(tAtoms[1]));
                                        } else {
                                            map2 = new CDKRMap(graph1.indexOf(qAtoms[0]), graph2.indexOf(tAtoms[1]));
                                        }
                                        if (!resultLocal.contains(map2)) {
                                            resultLocal.add(map2);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        result = new ArrayList<List<CDKRMap>>();
        result.add(resultLocal);
    }
    return result;
}","private static List<List<CDKRMap>> makeAtomsMapOfBondsMap(List<CDKRMap> rMapList, IAtomContainer graph1, IAtomContainer graph2){
    if (rMapList == null) {
        return (null);
    }
    List<List<CDKRMap>> result = null;
    if (rMapList.size() == 1) {
        result = makeAtomsMapOfBondsMapSingleBond(rMapList, graph1, graph2);
    } else {
        List<CDKRMap> resultLocal = new ArrayList<CDKRMap>();
        for (int i = 0; i < rMapList.size(); i++) {
            IBond qBond = graph1.getBond(rMapList.get(i).getId1());
            IBond tBond = graph2.getBond(rMapList.get(i).getId2());
            IAtom[] qAtoms = BondManipulator.getAtomArray(qBond);
            IAtom[] tAtoms = BondManipulator.getAtomArray(tBond);
            for (int j = 0; j < 2; j++) {
                List<IBond> bondsConnectedToAtom1j = graph1.getConnectedBondsList(qAtoms[j]);
                for (int k = 0; k < bondsConnectedToAtom1j.size(); k++) {
                    if (!bondsConnectedToAtom1j.get(k).equals(qBond)) {
                        IBond testBond = bondsConnectedToAtom1j.get(k);
                        for (int m = 0; m < rMapList.size(); m++) {
                            IBond testBond2;
                            if ((rMapList.get(m)).getId1() == graph1.indexOf(testBond)) {
                                testBond2 = graph2.getBond((rMapList.get(m)).getId2());
                                for (int n = 0; n < 2; n++) {
                                    List<IBond> bondsToTest = graph2.getConnectedBondsList(tAtoms[n]);
                                    if (bondsToTest.contains(testBond2)) {
                                        CDKRMap map;
                                        if (j == n) {
                                            map = new CDKRMap(graph1.indexOf(qAtoms[0]), graph2.indexOf(tAtoms[0]));
                                        } else {
                                            map = new CDKRMap(graph1.indexOf(qAtoms[1]), graph2.indexOf(tAtoms[0]));
                                        }
                                        if (!resultLocal.contains(map)) {
                                            resultLocal.add(map);
                                        }
                                        CDKRMap map2;
                                        if (j == n) {
                                            map2 = new CDKRMap(graph1.indexOf(qAtoms[1]), graph2.indexOf(tAtoms[1]));
                                        } else {
                                            map2 = new CDKRMap(graph1.indexOf(qAtoms[0]), graph2.indexOf(tAtoms[1]));
                                        }
                                        if (!resultLocal.contains(map2)) {
                                            resultLocal.add(map2);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        result = new ArrayList<List<CDKRMap>>();
        result.add(resultLocal);
    }
    return result;
}","/**
     *  This makes sourceAtom map of matching atoms out of sourceAtom map of matching bonds as produced by the get(Subgraph|Ismorphism)Map methods.
     *
     * @param  rMapList   The list produced by the getMap method.
     * @param  graph1  first molecule. Must not be an IQueryAtomContainer.
     * @param  graph2  second molecule. May be an IQueryAtomContainer.
     * @return     The mapping found projected on graph1. This is sourceAtom List of CDKRMap objects containing Ids of matching atoms.
     */","('makeAtomsMapOfBondsMap', {'INSTRUCTION': {'covered': 213, 'missed': 2}, 'BRANCH': {'covered': 27, 'missed': 1}, 'LINE': {'covered': 38, 'missed': 1}, 'COMPLEXITY': {'covered': 14, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",553.0,  This makes sourceAtom map of matching atoms out of sourceAtom map of matching bonds as produced by the get(Subgraph|Ismorphism)Map methods.,25.0,"['This makes sourceAtom map of matching atoms out of sourceAtom map of matching bonds.', 'This makes sourceAtom map of matching atoms out of sourceAtom map of matching bonds as produced by the get method.', 'This makes sourceAtom map of matching atoms out of sourceAtom map of matching bonds as produced by the get methods.']"
1081,cdk,org/openscience/cdk/charges/GasteigerMarsiliPartialCharges.java,/tool/charges/src/main/java/org/openscience/cdk/charges/GasteigerMarsiliPartialCharges.java,assignGasteigerMarsiliSigmaPartialCharges,117-197,"/**
     *  Main method which assigns Gasteiger Marisili partial sigma charges.
     *
     *@param  ac             AtomContainer
     *@param setCharge   	 The Charge
     *@return                AtomContainer with partial charges
     *@exception  Exception  Possible Exceptions
     */
public IAtomContainer assignGasteigerMarsiliSigmaPartialCharges(IAtomContainer ac, boolean setCharge) throws Exception{
    for (int i = 0; i < ac.getAtomCount(); i++) ac.getAtom(i).setCharge(0.0);
    double[] gasteigerFactors = assignGasteigerSigmaMarsiliFactors(ac);
    double alpha = 1.0;
    double q;
    double deoc;
    IAtom[] atoms = null;
    int atom1 = 0;
    int atom2 = 0;
    double[] q_old = new double[ac.getAtomCount()];
    for (int i = 0; i < q_old.length; i++) q_old[0] = 20.0;
    out: for (int i = 0; i < MX_ITERATIONS; i++) {
        alpha *= MX_DAMP;
        boolean isDifferent = false;
        for (int j = 0; j < ac.getAtomCount(); j++) {
            q = gasteigerFactors[STEP_SIZE * j + j + 5];
            double difference = Math.abs(q_old[j]) - Math.abs(q);
            if (Math.abs(difference) > 0.001)
                isDifferent = true;
            q_old[j] = q;
            gasteigerFactors[STEP_SIZE * j + j + 4] = gasteigerFactors[STEP_SIZE * j + j + 2] * q * q + gasteigerFactors[STEP_SIZE * j + j + 1] * q + gasteigerFactors[STEP_SIZE * j + j];
        }
        if (!isDifferent)
            break out;
        Iterator<IBond> bonds = ac.bonds().iterator();
        while (bonds.hasNext()) {
            IBond bond = (IBond) bonds.next();
            atom1 = ac.indexOf(bond.getBegin());
            atom2 = ac.indexOf(bond.getEnd());
            if (gasteigerFactors[STEP_SIZE * atom1 + atom1 + 4] >= gasteigerFactors[STEP_SIZE * atom2 + atom2 + 4]) {
                if (""H"".equals(ac.getAtom(atom2).getSymbol())) {
                    deoc = DEOC_HYDROGEN;
                } else {
                    deoc = gasteigerFactors[STEP_SIZE * atom2 + atom2 + 3];
                }
            } else {
                if (""H"".equals(ac.getAtom(atom1).getSymbol())) {
                    deoc = DEOC_HYDROGEN;
                } else {
                    deoc = gasteigerFactors[STEP_SIZE * atom1 + atom1 + 3];
                }
            }
            q = (gasteigerFactors[STEP_SIZE * atom1 + atom1 + 4] - gasteigerFactors[STEP_SIZE * atom2 + atom2 + 4]) / deoc;
            gasteigerFactors[STEP_SIZE * atom1 + atom1 + 5] -= (q * alpha);
            gasteigerFactors[STEP_SIZE * atom2 + atom2 + 5] += (q * alpha);
        }
    }
    for (int i = 0; i < ac.getAtomCount(); i++) {
        ac.getAtom(i).setCharge(gasteigerFactors[STEP_SIZE * i + i + 5]);
    }
    return ac;
}","public IAtomContainer assignGasteigerMarsiliSigmaPartialCharges(IAtomContainer ac, boolean setCharge) throws Exception{
    for (int i = 0; i < ac.getAtomCount(); i++) ac.getAtom(i).setCharge(0.0);
    double[] gasteigerFactors = assignGasteigerSigmaMarsiliFactors(ac);
    double alpha = 1.0;
    double q;
    double deoc;
    IAtom[] atoms = null;
    int atom1 = 0;
    int atom2 = 0;
    double[] q_old = new double[ac.getAtomCount()];
    for (int i = 0; i < q_old.length; i++) q_old[0] = 20.0;
    out: for (int i = 0; i < MX_ITERATIONS; i++) {
        alpha *= MX_DAMP;
        boolean isDifferent = false;
        for (int j = 0; j < ac.getAtomCount(); j++) {
            q = gasteigerFactors[STEP_SIZE * j + j + 5];
            double difference = Math.abs(q_old[j]) - Math.abs(q);
            if (Math.abs(difference) > 0.001)
                isDifferent = true;
            q_old[j] = q;
            gasteigerFactors[STEP_SIZE * j + j + 4] = gasteigerFactors[STEP_SIZE * j + j + 2] * q * q + gasteigerFactors[STEP_SIZE * j + j + 1] * q + gasteigerFactors[STEP_SIZE * j + j];
        }
        if (!isDifferent)
            break out;
        Iterator<IBond> bonds = ac.bonds().iterator();
        while (bonds.hasNext()) {
            IBond bond = (IBond) bonds.next();
            atom1 = ac.indexOf(bond.getBegin());
            atom2 = ac.indexOf(bond.getEnd());
            if (gasteigerFactors[STEP_SIZE * atom1 + atom1 + 4] >= gasteigerFactors[STEP_SIZE * atom2 + atom2 + 4]) {
                if (""H"".equals(ac.getAtom(atom2).getSymbol())) {
                    deoc = DEOC_HYDROGEN;
                } else {
                    deoc = gasteigerFactors[STEP_SIZE * atom2 + atom2 + 3];
                }
            } else {
                if (""H"".equals(ac.getAtom(atom1).getSymbol())) {
                    deoc = DEOC_HYDROGEN;
                } else {
                    deoc = gasteigerFactors[STEP_SIZE * atom1 + atom1 + 3];
                }
            }
            q = (gasteigerFactors[STEP_SIZE * atom1 + atom1 + 4] - gasteigerFactors[STEP_SIZE * atom2 + atom2 + 4]) / deoc;
            gasteigerFactors[STEP_SIZE * atom1 + atom1 + 5] -= (q * alpha);
            gasteigerFactors[STEP_SIZE * atom2 + atom2 + 5] += (q * alpha);
        }
    }
    for (int i = 0; i < ac.getAtomCount(); i++) {
        ac.getAtom(i).setCharge(gasteigerFactors[STEP_SIZE * i + i + 5]);
    }
    return ac;
}","/**
     *  Main method which assigns Gasteiger Marisili partial sigma charges.
     *
     *@param  ac             AtomContainer
     *@param setCharge   	 The Charge
     *@return                AtomContainer with partial charges
     *@exception  Exception  Possible Exceptions
     */","('assignGasteigerMarsiliSigmaPartialCharges', {'INSTRUCTION': {'covered': 312, 'missed': 4}, 'BRANCH': {'covered': 21, 'missed': 1}, 'LINE': {'covered': 39, 'missed': 1}, 'COMPLEXITY': {'covered': 11, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",557.0,  Main method which assigns Gasteiger Marisili partial sigma charges.,10.0,"['The main method assigns partial sigma charges.', 'The main method assigns partial sigma charges to Gasteiger Marisili.', 'The main method assigns Gasteiger Marisili partial sigma charges.']"
1082,matsim-libs,org/matsim/contrib/freight/jsprit/DistanceConstraint.java,/contribs/freight/src/main/java/org/matsim/contrib/freight/jsprit/DistanceConstraint.java,calculateRouteDistanceWithAssociatedPickup,130-183,"/**
	 * Calculates the distance based on the route-based distances between every tour
	 * activities. The method also integrates the associated pickup in the tour.
	 */
private double calculateRouteDistanceWithAssociatedPickup(JobInsertionContext context){
    double routeDistance = 0;
    int positionOfRelatedPickup = context.getRelatedActivityContext().getInsertionIndex();
    int nextRouteActivity = 0;
    // checks if the associated pickup is on first position
    if (positionOfRelatedPickup == 0 && context.getRoute().getActivities().isEmpty()) {
        context.getRoute().getStart().setLocation(context.getNewVehicle().getStartLocation());
        // This value is never used. it gets overwritten before usage. -- commenting it out. KMT, Jun'20
        // routeDistance = getDistance(context.getRoute().getStart(), context.getAssociatedActivities().get(0),
        // context.getNewVehicle(), context.getNewDepTime());
        context.getRoute().getEnd().setLocation(context.getNewVehicle().getEndLocation());
        routeDistance = getDistance(context.getAssociatedActivities().get(0), context.getRoute().getEnd(), context.getNewVehicle(), context.getNewDepTime());
        return routeDistance;
    } else if (positionOfRelatedPickup == 0 && !context.getRoute().getActivities().isEmpty()) {
        // This value is never used. it gets overwritten before usage. -- commenting it out. KMT, Jun'20
        // routeDistance = getDistance(context.getRoute().getStart(), context.getAssociatedActivities().get(0),
        // context.getNewVehicle(), context.getNewDepTime());
        routeDistance = getDistance(context.getAssociatedActivities().get(0), context.getRoute().getActivities().get(0), context.getNewVehicle(), context.getNewDepTime());
    } else {
        routeDistance = getDistance(context.getRoute().getStart(), context.getRoute().getActivities().get(0), context.getNewVehicle(), context.getNewDepTime());
    }
    // adds distances between every tour activity and adds the associated pickup on
    // the correct position of the tour
    while (context.getRoute().getTourActivities().getActivities().size() > (nextRouteActivity + 1)) {
        if (positionOfRelatedPickup == (nextRouteActivity + 1) && positionOfRelatedPickup != 0) {
            routeDistance = routeDistance + getDistance(context.getRoute().getActivities().get(nextRouteActivity), context.getAssociatedActivities().get(0), context.getNewVehicle());
            routeDistance = routeDistance + getDistance(context.getAssociatedActivities().get(0), context.getRoute().getActivities().get(nextRouteActivity), context.getNewVehicle());
        } else {
            routeDistance = routeDistance + getDistance(context.getRoute().getActivities().get(nextRouteActivity), context.getRoute().getActivities().get(nextRouteActivity + 1), context.getNewVehicle());
        }
        nextRouteActivity++;
    }
    if (positionOfRelatedPickup == context.getRoute().getActivities().size()) {
        routeDistance = routeDistance + getDistance(context.getRoute().getActivities().get(nextRouteActivity), context.getAssociatedActivities().get(0), context.getNewVehicle());
        routeDistance = routeDistance + getDistance(context.getAssociatedActivities().get(0), context.getRoute().getEnd(), context.getNewVehicle());
    } else
        routeDistance = routeDistance + getDistance(context.getRoute().getActivities().get(nextRouteActivity), context.getRoute().getEnd(), context.getNewVehicle());
    return routeDistance;
}","private double calculateRouteDistanceWithAssociatedPickup(JobInsertionContext context){
    double routeDistance = 0;
    int positionOfRelatedPickup = context.getRelatedActivityContext().getInsertionIndex();
    int nextRouteActivity = 0;
    // checks if the associated pickup is on first position
    if (positionOfRelatedPickup == 0 && context.getRoute().getActivities().isEmpty()) {
        context.getRoute().getStart().setLocation(context.getNewVehicle().getStartLocation());
        // This value is never used. it gets overwritten before usage. -- commenting it out. KMT, Jun'20
        // routeDistance = getDistance(context.getRoute().getStart(), context.getAssociatedActivities().get(0),
        // context.getNewVehicle(), context.getNewDepTime());
        context.getRoute().getEnd().setLocation(context.getNewVehicle().getEndLocation());
        routeDistance = getDistance(context.getAssociatedActivities().get(0), context.getRoute().getEnd(), context.getNewVehicle(), context.getNewDepTime());
        return routeDistance;
    } else if (positionOfRelatedPickup == 0 && !context.getRoute().getActivities().isEmpty()) {
        // This value is never used. it gets overwritten before usage. -- commenting it out. KMT, Jun'20
        // routeDistance = getDistance(context.getRoute().getStart(), context.getAssociatedActivities().get(0),
        // context.getNewVehicle(), context.getNewDepTime());
        routeDistance = getDistance(context.getAssociatedActivities().get(0), context.getRoute().getActivities().get(0), context.getNewVehicle(), context.getNewDepTime());
    } else {
        routeDistance = getDistance(context.getRoute().getStart(), context.getRoute().getActivities().get(0), context.getNewVehicle(), context.getNewDepTime());
    }
    // adds distances between every tour activity and adds the associated pickup on
    // the correct position of the tour
    while (context.getRoute().getTourActivities().getActivities().size() > (nextRouteActivity + 1)) {
        if (positionOfRelatedPickup == (nextRouteActivity + 1) && positionOfRelatedPickup != 0) {
            routeDistance = routeDistance + getDistance(context.getRoute().getActivities().get(nextRouteActivity), context.getAssociatedActivities().get(0), context.getNewVehicle());
            routeDistance = routeDistance + getDistance(context.getAssociatedActivities().get(0), context.getRoute().getActivities().get(nextRouteActivity), context.getNewVehicle());
        } else {
            routeDistance = routeDistance + getDistance(context.getRoute().getActivities().get(nextRouteActivity), context.getRoute().getActivities().get(nextRouteActivity + 1), context.getNewVehicle());
        }
        nextRouteActivity++;
    }
    if (positionOfRelatedPickup == context.getRoute().getActivities().size()) {
        routeDistance = routeDistance + getDistance(context.getRoute().getActivities().get(nextRouteActivity), context.getAssociatedActivities().get(0), context.getNewVehicle());
        routeDistance = routeDistance + getDistance(context.getAssociatedActivities().get(0), context.getRoute().getEnd(), context.getNewVehicle());
    } else
        routeDistance = routeDistance + getDistance(context.getRoute().getActivities().get(nextRouteActivity), context.getRoute().getEnd(), context.getNewVehicle());
    return routeDistance;
}","/**
	 * Calculates the distance based on the route-based distances between every tour
	 * activities. The method also integrates the associated pickup in the tour.
	 */","('calculateRouteDistanceWithAssociatedPickup', {'INSTRUCTION': {'covered': 222, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 2}, 'LINE': {'covered': 31, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",561.0,  Calculates the distance based on the route-based distances between every tour  activities.,13.0,"['The distance is calculated based on the route-based distances.', 'The distance is calculated based on the route-based distances between the activities.', 'The distance is calculated using the route-based distances between the activities.']"
1083,jooby,io/jooby/Router.java,/jooby/src/main/java/io/jooby/Router.java,expandOptionalVariables,1174-1270,"/**
   * Look for optional path parameter and expand the given pattern into multiple pattern.
   *
   * <pre>
   *   /path =&gt; [/path]
   *   /{id} =&gt; [/{id}]
   *   /path/{id} =&gt; [/path/{id}]
   *
   *   /{id}? =&gt; [/, /{id}]
   *   /path/{id}? =&gt; [/path, /path/{id}]
   *   /path/{id}/{start}?/{end}? =&gt; [/path/{id}, /path/{id}/{start}, /path/{id}/{start}/{end}]
   *   /path/{id}?/suffix =&gt; [/path, /path/{id}, /path/suffix]
   * </pre>
   *
   * @param pattern Pattern.
   * @return One or more patterns.
   */
 static List<String> expandOptionalVariables(@Nonnull String pattern){
    if (pattern == null || pattern.isEmpty() || pattern.equals(""/"")) {
        return Collections.singletonList(""/"");
    }
    int len = pattern.length();
    AtomicInteger key = new AtomicInteger();
    Map<Integer, StringBuilder> paths = new HashMap<>();
    BiConsumer<Integer, StringBuilder> pathAppender = (index, segment) -> {
        for (int i = index; i < index - 1; i++) {
            paths.get(i).append(segment);
        }
        paths.computeIfAbsent(index, current -> {
            StringBuilder value = new StringBuilder();
            if (current > 0) {
                StringBuilder previous = paths.get(current - 1);
                if (!previous.toString().equals(""/"")) {
                    value.append(previous);
                }
            }
            return value;
        }).append(segment);
    };
    StringBuilder segment = new StringBuilder();
    boolean isLastOptional = false;
    for (int i = 0; i < len; ) {
        char ch = pattern.charAt(i);
        if (ch == '/') {
            if (segment.length() > 0) {
                pathAppender.accept(key.get(), segment);
                segment.setLength(0);
            }
            segment.append(ch);
            i += 1;
        } else if (ch == '{') {
            segment.append(ch);
            int curly = 1;
            int j = i + 1;
            while (j < len) {
                char next = pattern.charAt(j++);
                segment.append(next);
                if (next == '{') {
                    curly += 1;
                } else if (next == '}') {
                    curly -= 1;
                    if (curly == 0) {
                        break;
                    }
                }
            }
            if (j < len && pattern.charAt(j) == '?') {
                j += 1;
                isLastOptional = true;
                if (paths.isEmpty()) {
                    paths.put(0, new StringBuilder(""/""));
                }
                pathAppender.accept(key.incrementAndGet(), segment);
            } else {
                isLastOptional = false;
                pathAppender.accept(key.get(), segment);
            }
            segment.setLength(0);
            i = j;
        } else {
            segment.append(ch);
            i += 1;
        }
    }
    if (paths.isEmpty()) {
        return Collections.singletonList(pattern);
    }
    if (segment.length() > 0) {
        pathAppender.accept(key.get(), segment);
        if (isLastOptional) {
            paths.put(key.incrementAndGet(), segment);
        }
    }
    return paths.values().stream().map(StringBuilder::toString).collect(Collectors.toList());
}","static List<String> expandOptionalVariables(@Nonnull String pattern){
    if (pattern == null || pattern.isEmpty() || pattern.equals(""/"")) {
        return Collections.singletonList(""/"");
    }
    int len = pattern.length();
    AtomicInteger key = new AtomicInteger();
    Map<Integer, StringBuilder> paths = new HashMap<>();
    BiConsumer<Integer, StringBuilder> pathAppender = (index, segment) -> {
        for (int i = index; i < index - 1; i++) {
            paths.get(i).append(segment);
        }
        paths.computeIfAbsent(index, current -> {
            StringBuilder value = new StringBuilder();
            if (current > 0) {
                StringBuilder previous = paths.get(current - 1);
                if (!previous.toString().equals(""/"")) {
                    value.append(previous);
                }
            }
            return value;
        }).append(segment);
    };
    StringBuilder segment = new StringBuilder();
    boolean isLastOptional = false;
    for (int i = 0; i < len; ) {
        char ch = pattern.charAt(i);
        if (ch == '/') {
            if (segment.length() > 0) {
                pathAppender.accept(key.get(), segment);
                segment.setLength(0);
            }
            segment.append(ch);
            i += 1;
        } else if (ch == '{') {
            segment.append(ch);
            int curly = 1;
            int j = i + 1;
            while (j < len) {
                char next = pattern.charAt(j++);
                segment.append(next);
                if (next == '{') {
                    curly += 1;
                } else if (next == '}') {
                    curly -= 1;
                    if (curly == 0) {
                        break;
                    }
                }
            }
            if (j < len && pattern.charAt(j) == '?') {
                j += 1;
                isLastOptional = true;
                if (paths.isEmpty()) {
                    paths.put(0, new StringBuilder(""/""));
                }
                pathAppender.accept(key.incrementAndGet(), segment);
            } else {
                isLastOptional = false;
                pathAppender.accept(key.get(), segment);
            }
            segment.setLength(0);
            i = j;
        } else {
            segment.append(ch);
            i += 1;
        }
    }
    if (paths.isEmpty()) {
        return Collections.singletonList(pattern);
    }
    if (segment.length() > 0) {
        pathAppender.accept(key.get(), segment);
        if (isLastOptional) {
            paths.put(key.incrementAndGet(), segment);
        }
    }
    return paths.values().stream().map(StringBuilder::toString).collect(Collectors.toList());
}","/**
   * Look for optional path parameter and expand the given pattern into multiple pattern.
   *
   * <pre>
   *   /path =&gt; [/path]
   *   /{id} =&gt; [/{id}]
   *   /path/{id} =&gt; [/path/{id}]
   *
   *   /{id}? =&gt; [/, /{id}]
   *   /path/{id}? =&gt; [/path, /path/{id}]
   *   /path/{id}/{start}?/{end}? =&gt; [/path/{id}, /path/{id}/{start}, /path/{id}/{start}/{end}]
   *   /path/{id}?/suffix =&gt; [/path, /path/{id}, /path/suffix]
   * </pre>
   *
   * @param pattern Pattern.
   * @return One or more patterns.
   */","('expandOptionalVariables', {'INSTRUCTION': {'covered': 183, 'missed': 0}, 'BRANCH': {'covered': 33, 'missed': 1}, 'LINE': {'covered': 53, 'missed': 0}, 'COMPLEXITY': {'covered': 17, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",565.0,  Look for optional path parameter and expand the given pattern into multiple pattern.,14.0,"['If you want to expand the pattern into multiple patterns, look for optional path parameters.', 'If you want to expand the pattern into multiple pattern, look for optional path parameters.', 'Look for optional path parameters to expand the pattern.']"
1084,cdk,org/openscience/cdk/smiles/SmilesParser.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/SmilesParser.java,handleFragmentGrouping,379-474,"/**
     * Handle fragment grouping of a reaction that specifies certain disconnected components
     * are actually considered a single molecule. Normally used for salts, [Na+].[OH-].
     *
     * @param rxn     reaction
     * @param cxstate state
     */
private void handleFragmentGrouping(IReaction rxn, CxSmilesState cxstate){
    if (cxstate.fragGroups == null && cxstate.racemicFrags == null)
        return;
    final int reactant = 1;
    final int agent = 2;
    final int product = 3;
    List<IAtomContainer> fragMap = new ArrayList<>();
    Map<IAtomContainer, Integer> roleMap = new HashMap<>();
    for (IAtomContainer mol : rxn.getReactants().atomContainers()) {
        fragMap.add(mol);
        roleMap.put(mol, reactant);
    }
    for (IAtomContainer mol : rxn.getAgents().atomContainers()) {
        fragMap.add(mol);
        roleMap.put(mol, agent);
    }
    for (IAtomContainer mol : rxn.getProducts().atomContainers()) {
        fragMap.add(mol);
        roleMap.put(mol, product);
    }
    if (cxstate.racemicFrags != null) {
        for (Integer grp : cxstate.racemicFrags) {
            if (grp >= fragMap.size())
                continue;
            IAtomContainer mol = fragMap.get(grp);
            if (mol == null)
                continue;
            for (IStereoElement<?, ?> e : mol.stereoElements()) {
                if (e.getConfigClass() == IStereoElement.TH) {
                    e.setGroupInfo(IStereoElement.GRP_RAC1);
                }
            }
        }
    }
    if (cxstate.fragGroups != null) {
        boolean invalid = false;
        Set<Integer> visit = new HashSet<>();
        for (List<Integer> grouping : cxstate.fragGroups) {
            if (grouping.get(0) >= fragMap.size())
                continue;
            IAtomContainer dest = fragMap.get(grouping.get(0));
            if (dest == null)
                continue;
            if (!visit.add(grouping.get(0)))
                invalid = true;
            for (int i = 1; i < grouping.size(); i++) {
                if (!visit.add(grouping.get(i)))
                    invalid = true;
                if (grouping.get(i) >= fragMap.size())
                    continue;
                IAtomContainer src = fragMap.get(grouping.get(i));
                if (src != null) {
                    dest.add(src);
                    roleMap.put(src, 0);
                }
            }
        }
        if (!invalid) {
            rxn.getReactants().removeAllAtomContainers();
            rxn.getAgents().removeAllAtomContainers();
            rxn.getProducts().removeAllAtomContainers();
            for (IAtomContainer mol : fragMap) {
                switch(roleMap.get(mol)) {
                    case reactant:
                        rxn.getReactants().addAtomContainer(mol);
                        break;
                    case product:
                        rxn.getProducts().addAtomContainer(mol);
                        break;
                    case agent:
                        rxn.getAgents().addAtomContainer(mol);
                        break;
                }
            }
        }
    }
}","private void handleFragmentGrouping(IReaction rxn, CxSmilesState cxstate){
    if (cxstate.fragGroups == null && cxstate.racemicFrags == null)
        return;
    final int reactant = 1;
    final int agent = 2;
    final int product = 3;
    List<IAtomContainer> fragMap = new ArrayList<>();
    Map<IAtomContainer, Integer> roleMap = new HashMap<>();
    for (IAtomContainer mol : rxn.getReactants().atomContainers()) {
        fragMap.add(mol);
        roleMap.put(mol, reactant);
    }
    for (IAtomContainer mol : rxn.getAgents().atomContainers()) {
        fragMap.add(mol);
        roleMap.put(mol, agent);
    }
    for (IAtomContainer mol : rxn.getProducts().atomContainers()) {
        fragMap.add(mol);
        roleMap.put(mol, product);
    }
    if (cxstate.racemicFrags != null) {
        for (Integer grp : cxstate.racemicFrags) {
            if (grp >= fragMap.size())
                continue;
            IAtomContainer mol = fragMap.get(grp);
            if (mol == null)
                continue;
            for (IStereoElement<?, ?> e : mol.stereoElements()) {
                if (e.getConfigClass() == IStereoElement.TH) {
                    e.setGroupInfo(IStereoElement.GRP_RAC1);
                }
            }
        }
    }
    if (cxstate.fragGroups != null) {
        boolean invalid = false;
        Set<Integer> visit = new HashSet<>();
        for (List<Integer> grouping : cxstate.fragGroups) {
            if (grouping.get(0) >= fragMap.size())
                continue;
            IAtomContainer dest = fragMap.get(grouping.get(0));
            if (dest == null)
                continue;
            if (!visit.add(grouping.get(0)))
                invalid = true;
            for (int i = 1; i < grouping.size(); i++) {
                if (!visit.add(grouping.get(i)))
                    invalid = true;
                if (grouping.get(i) >= fragMap.size())
                    continue;
                IAtomContainer src = fragMap.get(grouping.get(i));
                if (src != null) {
                    dest.add(src);
                    roleMap.put(src, 0);
                }
            }
        }
        if (!invalid) {
            rxn.getReactants().removeAllAtomContainers();
            rxn.getAgents().removeAllAtomContainers();
            rxn.getProducts().removeAllAtomContainers();
            for (IAtomContainer mol : fragMap) {
                switch(roleMap.get(mol)) {
                    case reactant:
                        rxn.getReactants().addAtomContainer(mol);
                        break;
                    case product:
                        rxn.getProducts().addAtomContainer(mol);
                        break;
                    case agent:
                        rxn.getAgents().addAtomContainer(mol);
                        break;
                }
            }
        }
    }
}","/**
     * Handle fragment grouping of a reaction that specifies certain disconnected components
     * are actually considered a single molecule. Normally used for salts, [Na+].[OH-].
     *
     * @param rxn     reaction
     * @param cxstate state
     */","('handleFragmentGrouping', {'INSTRUCTION': {'covered': 272, 'missed': 7}, 'BRANCH': {'covered': 40, 'missed': 8}, 'LINE': {'covered': 59, 'missed': 6}, 'COMPLEXITY': {'covered': 18, 'missed': 8}, 'METHOD': {'covered': 1, 'missed': 0}})",566.0,  Handle fragment grouping of a reaction that specifies certain disconnected components  are actually considered a single molecule.,18.0,"['A single molecule is a reaction that specifies certain disconnected components.', 'The fragment grouping of a reaction that specifies certain disconnected components is considered a single molecule.', 'The fragment grouping of a reaction that specifies certain disconnected components is actually a single molecule.']"
1085,cdk,org/openscience/cdk/smsd/algorithm/rgraph/CDKRMapHandler.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKRMapHandler.java,makeAtomsMapOfBondsMapSingleBond,398-467,"/**
     *  This makes atom map of matching atoms out of atom map of matching bonds as produced by the get(Subgraph|Ismorphism)Map methods.
     *  Added by Asad since CDK one doesn't pick up the correct changes
     * @param  list   The list produced by the getMap method.
     * @param  sourceGraph  first molecule. Must not be an IQueryAtomContainer.
     * @param  targetGraph  second molecule. May be an IQueryAtomContainer.
     * @return     The mapping found projected on sourceGraph. This is atom List of CDKRMap objects containing Ids of matching atoms.
     */
private static List<List<CDKRMap>> makeAtomsMapOfBondsMapSingleBond(List<CDKRMap> list, IAtomContainer sourceGraph, IAtomContainer targetGraph){
    if (list == null) {
        return null;
    }
    Map<IBond, IBond> bondMap = new HashMap<IBond, IBond>(list.size());
    for (CDKRMap solBondMap : list) {
        int id1 = solBondMap.getId1();
        int id2 = solBondMap.getId2();
        IBond qBond = sourceGraph.getBond(id1);
        IBond tBond = targetGraph.getBond(id2);
        bondMap.put(qBond, tBond);
    }
    List<CDKRMap> result1 = new ArrayList<CDKRMap>();
    List<CDKRMap> result2 = new ArrayList<CDKRMap>();
    for (IBond qbond : sourceGraph.bonds()) {
        if (bondMap.containsKey(qbond)) {
            IBond tbond = bondMap.get(qbond);
            CDKRMap map00 = null;
            CDKRMap map01 = null;
            CDKRMap map10 = null;
            CDKRMap map11 = null;
            if ((qbond.getBegin().getSymbol().equals(tbond.getBegin().getSymbol())) && (qbond.getEnd().getSymbol().equals(tbond.getEnd().getSymbol()))) {
                map00 = new CDKRMap(sourceGraph.indexOf(qbond.getBegin()), targetGraph.indexOf(tbond.getBegin()));
                map11 = new CDKRMap(sourceGraph.indexOf(qbond.getEnd()), targetGraph.indexOf(tbond.getEnd()));
                if (!result1.contains(map00)) {
                    result1.add(map00);
                }
                if (!result1.contains(map11)) {
                    result1.add(map11);
                }
            }
            if ((qbond.getBegin().getSymbol().equals(tbond.getEnd().getSymbol())) && (qbond.getEnd().getSymbol().equals(tbond.getBegin().getSymbol()))) {
                map01 = new CDKRMap(sourceGraph.indexOf(qbond.getBegin()), targetGraph.indexOf(tbond.getEnd()));
                map10 = new CDKRMap(sourceGraph.indexOf(qbond.getEnd()), targetGraph.indexOf(tbond.getBegin()));
                if (!result2.contains(map01)) {
                    result2.add(map01);
                }
                if (!result2.contains(map10)) {
                    result2.add(map10);
                }
            }
        }
    }
    List<List<CDKRMap>> result = new ArrayList<List<CDKRMap>>();
    if (result1.size() == result2.size()) {
        result.add(result1);
        result.add(result2);
    } else if (result1.size() > result2.size()) {
        result.add(result1);
    } else {
        result.add(result2);
    }
    return result;
}","private static List<List<CDKRMap>> makeAtomsMapOfBondsMapSingleBond(List<CDKRMap> list, IAtomContainer sourceGraph, IAtomContainer targetGraph){
    if (list == null) {
        return null;
    }
    Map<IBond, IBond> bondMap = new HashMap<IBond, IBond>(list.size());
    for (CDKRMap solBondMap : list) {
        int id1 = solBondMap.getId1();
        int id2 = solBondMap.getId2();
        IBond qBond = sourceGraph.getBond(id1);
        IBond tBond = targetGraph.getBond(id2);
        bondMap.put(qBond, tBond);
    }
    List<CDKRMap> result1 = new ArrayList<CDKRMap>();
    List<CDKRMap> result2 = new ArrayList<CDKRMap>();
    for (IBond qbond : sourceGraph.bonds()) {
        if (bondMap.containsKey(qbond)) {
            IBond tbond = bondMap.get(qbond);
            CDKRMap map00 = null;
            CDKRMap map01 = null;
            CDKRMap map10 = null;
            CDKRMap map11 = null;
            if ((qbond.getBegin().getSymbol().equals(tbond.getBegin().getSymbol())) && (qbond.getEnd().getSymbol().equals(tbond.getEnd().getSymbol()))) {
                map00 = new CDKRMap(sourceGraph.indexOf(qbond.getBegin()), targetGraph.indexOf(tbond.getBegin()));
                map11 = new CDKRMap(sourceGraph.indexOf(qbond.getEnd()), targetGraph.indexOf(tbond.getEnd()));
                if (!result1.contains(map00)) {
                    result1.add(map00);
                }
                if (!result1.contains(map11)) {
                    result1.add(map11);
                }
            }
            if ((qbond.getBegin().getSymbol().equals(tbond.getEnd().getSymbol())) && (qbond.getEnd().getSymbol().equals(tbond.getBegin().getSymbol()))) {
                map01 = new CDKRMap(sourceGraph.indexOf(qbond.getBegin()), targetGraph.indexOf(tbond.getEnd()));
                map10 = new CDKRMap(sourceGraph.indexOf(qbond.getEnd()), targetGraph.indexOf(tbond.getBegin()));
                if (!result2.contains(map01)) {
                    result2.add(map01);
                }
                if (!result2.contains(map10)) {
                    result2.add(map10);
                }
            }
        }
    }
    List<List<CDKRMap>> result = new ArrayList<List<CDKRMap>>();
    if (result1.size() == result2.size()) {
        result.add(result1);
        result.add(result2);
    } else if (result1.size() > result2.size()) {
        result.add(result1);
    } else {
        result.add(result2);
    }
    return result;
}","/**
     *  This makes atom map of matching atoms out of atom map of matching bonds as produced by the get(Subgraph|Ismorphism)Map methods.
     *  Added by Asad since CDK one doesn't pick up the correct changes
     * @param  list   The list produced by the getMap method.
     * @param  sourceGraph  first molecule. Must not be an IQueryAtomContainer.
     * @param  targetGraph  second molecule. May be an IQueryAtomContainer.
     * @return     The mapping found projected on sourceGraph. This is atom List of CDKRMap objects containing Ids of matching atoms.
     */","('makeAtomsMapOfBondsMapSingleBond', {'INSTRUCTION': {'covered': 207, 'missed': 16}, 'BRANCH': {'covered': 16, 'missed': 12}, 'LINE': {'covered': 44, 'missed': 4}, 'COMPLEXITY': {'covered': 4, 'missed': 11}, 'METHOD': {'covered': 1, 'missed': 0}})",580.0,  This makes atom map of matching atoms out of atom map of matching bonds as produced by the get(Subgraph|Ismorphism)Map methods.,25.0,"['The get(subgraph)(ismorphism)Map methods make atom map of matching atoms out of atom map of matching bonds.', 'The get(subgraph)(ismorphism)Map methods make atom map of matching atoms out of atom map of matching bonds', 'The get(subgraph)(ismorphism)Map methods make atom map of matching atoms out of matching bonds.']"
1086,cdk,org/openscience/cdk/qsar/descriptors/bond/BondPartialPiChargeDescriptor.java,/descriptor/qsarbond/src/main/java/org/openscience/cdk/qsar/descriptors/bond/BondPartialPiChargeDescriptor.java,calculate,145-213,"/**
     *  The method calculates the bond-pi Partial charge of a given bond
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *
     *@param  ac                AtomContainer
     *@return                   return the sigma electronegativity
     */
public DescriptorValue calculate(IBond bond, IAtomContainer ac){
    Double originalCharge1 = bond.getBegin().getCharge();
    String originalAtomtypeName1 = bond.getBegin().getAtomTypeName();
    Integer originalNeighborCount1 = bond.getBegin().getFormalNeighbourCount();
    IAtomType.Hybridization originalHybridization1 = bond.getBegin().getHybridization();
    Integer originalValency1 = bond.getBegin().getValency();
    Double originalCharge2 = bond.getEnd().getCharge();
    String originalAtomtypeName2 = bond.getEnd().getAtomTypeName();
    Integer originalNeighborCount2 = bond.getEnd().getFormalNeighbourCount();
    IAtomType.Hybridization originalHybridization2 = bond.getEnd().getHybridization();
    Integer originalValency2 = bond.getEnd().getValency();
    Double originalBondOrderSum1 = bond.getBegin().getBondOrderSum();
    Order originalMaxBondOrder1 = bond.getBegin().getMaxBondOrder();
    Double originalBondOrderSum2 = bond.getEnd().getBondOrderSum();
    Order originalMaxBondOrder2 = bond.getEnd().getMaxBondOrder();
    if (!isCachedAtomContainer(ac)) {
        try {
            AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(ac);
            if (lpeChecker) {
                LonePairElectronChecker lpcheck = new LonePairElectronChecker();
                lpcheck.saturate(ac);
            }
        } catch (CDKException e) {
            return getDummyDescriptorValue(e);
        }
        if (maxIterations != -1)
            pepe.setMaxGasteigerIters(maxIterations);
        if (maxResonStruc != -1)
            pepe.setMaxResoStruc(maxResonStruc);
        try {
            for (int i = 0; i < ac.getAtomCount(); i++) ac.getAtom(i).setCharge(0.0);
            pepe.assignGasteigerPiPartialCharges(ac, true);
            for (Iterator<IBond> it = ac.bonds().iterator(); it.hasNext(); ) {
                IBond bondi = it.next();
                double result = Math.abs(bondi.getBegin().getCharge() - bondi.getEnd().getCharge());
                cacheDescriptorValue(bondi, ac, new DoubleResult(result));
            }
        } catch (Exception ex1) {
            return getDummyDescriptorValue(ex1);
        }
    }
    bond.getBegin().setCharge(originalCharge1);
    bond.getBegin().setAtomTypeName(originalAtomtypeName1);
    bond.getBegin().setHybridization(originalHybridization1);
    bond.getBegin().setValency(originalValency1);
    bond.getBegin().setFormalNeighbourCount(originalNeighborCount1);
    bond.getEnd().setCharge(originalCharge2);
    bond.getEnd().setAtomTypeName(originalAtomtypeName2);
    bond.getEnd().setHybridization(originalHybridization2);
    bond.getEnd().setValency(originalValency2);
    bond.getEnd().setFormalNeighbourCount(originalNeighborCount2);
    bond.getBegin().setMaxBondOrder(originalMaxBondOrder1);
    bond.getBegin().setBondOrderSum(originalBondOrderSum1);
    bond.getEnd().setMaxBondOrder(originalMaxBondOrder2);
    bond.getEnd().setBondOrderSum(originalBondOrderSum2);
    return getCachedDescriptorValue(bond) != null ? new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), getCachedDescriptorValue(bond), NAMES) : null;
}","public DescriptorValue calculate(IBond bond, IAtomContainer ac){
    Double originalCharge1 = bond.getBegin().getCharge();
    String originalAtomtypeName1 = bond.getBegin().getAtomTypeName();
    Integer originalNeighborCount1 = bond.getBegin().getFormalNeighbourCount();
    IAtomType.Hybridization originalHybridization1 = bond.getBegin().getHybridization();
    Integer originalValency1 = bond.getBegin().getValency();
    Double originalCharge2 = bond.getEnd().getCharge();
    String originalAtomtypeName2 = bond.getEnd().getAtomTypeName();
    Integer originalNeighborCount2 = bond.getEnd().getFormalNeighbourCount();
    IAtomType.Hybridization originalHybridization2 = bond.getEnd().getHybridization();
    Integer originalValency2 = bond.getEnd().getValency();
    Double originalBondOrderSum1 = bond.getBegin().getBondOrderSum();
    Order originalMaxBondOrder1 = bond.getBegin().getMaxBondOrder();
    Double originalBondOrderSum2 = bond.getEnd().getBondOrderSum();
    Order originalMaxBondOrder2 = bond.getEnd().getMaxBondOrder();
    if (!isCachedAtomContainer(ac)) {
        try {
            AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(ac);
            if (lpeChecker) {
                LonePairElectronChecker lpcheck = new LonePairElectronChecker();
                lpcheck.saturate(ac);
            }
        } catch (CDKException e) {
            return getDummyDescriptorValue(e);
        }
        if (maxIterations != -1)
            pepe.setMaxGasteigerIters(maxIterations);
        if (maxResonStruc != -1)
            pepe.setMaxResoStruc(maxResonStruc);
        try {
            for (int i = 0; i < ac.getAtomCount(); i++) ac.getAtom(i).setCharge(0.0);
            pepe.assignGasteigerPiPartialCharges(ac, true);
            for (Iterator<IBond> it = ac.bonds().iterator(); it.hasNext(); ) {
                IBond bondi = it.next();
                double result = Math.abs(bondi.getBegin().getCharge() - bondi.getEnd().getCharge());
                cacheDescriptorValue(bondi, ac, new DoubleResult(result));
            }
        } catch (Exception ex1) {
            return getDummyDescriptorValue(ex1);
        }
    }
    bond.getBegin().setCharge(originalCharge1);
    bond.getBegin().setAtomTypeName(originalAtomtypeName1);
    bond.getBegin().setHybridization(originalHybridization1);
    bond.getBegin().setValency(originalValency1);
    bond.getBegin().setFormalNeighbourCount(originalNeighborCount1);
    bond.getEnd().setCharge(originalCharge2);
    bond.getEnd().setAtomTypeName(originalAtomtypeName2);
    bond.getEnd().setHybridization(originalHybridization2);
    bond.getEnd().setValency(originalValency2);
    bond.getEnd().setFormalNeighbourCount(originalNeighborCount2);
    bond.getBegin().setMaxBondOrder(originalMaxBondOrder1);
    bond.getBegin().setBondOrderSum(originalBondOrderSum1);
    bond.getEnd().setMaxBondOrder(originalMaxBondOrder2);
    bond.getEnd().setBondOrderSum(originalBondOrderSum2);
    return getCachedDescriptorValue(bond) != null ? new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), getCachedDescriptorValue(bond), NAMES) : null;
}","/**
     *  The method calculates the bond-pi Partial charge of a given bond
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *
     *@param  ac                AtomContainer
     *@return                   return the sigma electronegativity
     */","('calculate', {'INSTRUCTION': {'covered': 208, 'missed': 21}, 'BRANCH': {'covered': 10, 'missed': 4}, 'LINE': {'covered': 47, 'missed': 4}, 'COMPLEXITY': {'covered': 4, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",599.0,  The method calculates the bond-pi Partial charge of a given bond  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.,24.0,"['The addExplicitHydrogensToSatisfyValency method needs to be called from the class tools.', 'The addExplicitHydrogensToSatisfyValency method from the class tools is needed to calculate the partial charge of a bond.', 'The addExplicitHydrogensToSatisfyValency method from the class tools is needed to calculate the partial charge of a given bond.']"
1087,jeromq,org/zeromq/proto/ZPicture.java,/src/main/java/org/zeromq/proto/ZPicture.java,msgBinaryPicture,25-163,"/**
     * Creates a binary encoded 'picture' message to the socket (or actor), so it can be sent.
     * The arguments are encoded in a binary format that is compatible with zproto, and
     * is designed to reduce memory allocations.
     *
     * @param picture The picture argument is a string that defines the
     *                type of each argument. Supports these argument types:
     *                <table>
     *                <caption> </caption>
     *                <tr><th style=""text-align:left"">pattern</th><th style=""text-align:left"">java type</th><th style=""text-align:left"">zproto type</th></tr>
     *                <tr><td>1</td><td>int</td><td>type = ""number"" size = ""1""</td></tr>
     *                <tr><td>2</td><td>int</td><td>type = ""number"" size = ""2""</td></tr>
     *                <tr><td>4</td><td>long</td><td>type = ""number"" size = ""3""</td></tr>
     *                <tr><td>8</td><td>long</td><td>type = ""number"" size = ""4""</td></tr>
     *                <tr><td>s</td><td>String, 0-255 chars</td><td>type = ""string""</td></tr>
     *                <tr><td>S</td><td>String, 0-2^32-1 chars</td><td>type = ""longstr""</td></tr>
     *                <tr><td>b</td><td>byte[], 0-2^32-1 bytes</td><td>type = ""chunk""</td></tr>
     *                <tr><td>c</td><td>byte[], 0-2^32-1 bytes</td><td>type = ""chunk""</td></tr>
     *                <tr><td>f</td><td>ZFrame</td><td>type = ""frame""</td></tr>
     *                <tr><td>m</td><td>ZMsg</td><td>type = ""msg"" <b>Has to be the last element of the picture</b></td></tr>
     *                </table>
     * @param args    Arguments according to the picture
     * @return true when it has been queued on the socket and MQ has assumed responsibility for the message.
     * This does not indicate that the message has been transmitted to the network.
     * @apiNote Does not change or take ownership of any arguments.
     */
public ZMsg msgBinaryPicture(String picture, Object... args){
    if (!BINARY_FORMAT.matcher(picture).matches()) {
        throw new ZMQException(picture + "" is not in expected binary format "" + BINARY_FORMAT.pattern(), ZError.EPROTO);
    }
    ZMsg msg = new ZMsg();
    // Pass 1: calculate total size of data frame
    int frameSize = 0;
    for (int index = 0; index < picture.length(); index++) {
        char pattern = picture.charAt(index);
        switch(pattern) {
            case '1':
                {
                    frameSize += 1;
                    break;
                }
            case '2':
                {
                    frameSize += 2;
                    break;
                }
            case '4':
                {
                    frameSize += 4;
                    break;
                }
            case '8':
                {
                    frameSize += 8;
                    break;
                }
            case 's':
                {
                    String string = (String) args[index];
                    frameSize += 1 + (string != null ? string.getBytes(ZMQ.CHARSET).length : 0);
                    break;
                }
            case 'S':
                {
                    String string = (String) args[index];
                    frameSize += 4 + (string != null ? string.getBytes(ZMQ.CHARSET).length : 0);
                    break;
                }
            case 'b':
            case 'c':
                {
                    byte[] block = (byte[]) args[index];
                    frameSize += 4 + block.length;
                    break;
                }
            case 'f':
                {
                    ZFrame frame = (ZFrame) args[index];
                    msg.add(frame);
                    break;
                }
            case 'm':
                {
                    ZMsg other = (ZMsg) args[index];
                    if (other == null) {
                        msg.add(new ZFrame((byte[]) null));
                    } else {
                        msg.addAll(other);
                    }
                    break;
                }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    // Pass 2: encode data into data frame
    ZFrame frame = new ZFrame(new byte[frameSize]);
    ZNeedle needle = new ZNeedle(frame);
    for (int index = 0; index < picture.length(); index++) {
        char pattern = picture.charAt(index);
        switch(pattern) {
            case '1':
                {
                    needle.putNumber1((int) args[index]);
                    break;
                }
            case '2':
                {
                    needle.putNumber2((int) args[index]);
                    break;
                }
            case '4':
                {
                    needle.putNumber4((int) args[index]);
                    break;
                }
            case '8':
                {
                    needle.putNumber8((long) args[index]);
                    break;
                }
            case 's':
                {
                    needle.putString((String) args[index]);
                    break;
                }
            case 'S':
                {
                    needle.putLongString((String) args[index]);
                    break;
                }
            case 'b':
            case 'c':
                {
                    byte[] block = (byte[]) args[index];
                    needle.putNumber4(block.length);
                    needle.putBlock(block, block.length);
                    break;
                }
            case 'f':
            case 'm':
                break;
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    msg.addFirst(frame);
    return msg;
}","public ZMsg msgBinaryPicture(String picture, Object... args){
    if (!BINARY_FORMAT.matcher(picture).matches()) {
        throw new ZMQException(picture + "" is not in expected binary format "" + BINARY_FORMAT.pattern(), ZError.EPROTO);
    }
    ZMsg msg = new ZMsg();
    // Pass 1: calculate total size of data frame
    int frameSize = 0;
    for (int index = 0; index < picture.length(); index++) {
        char pattern = picture.charAt(index);
        switch(pattern) {
            case '1':
                {
                    frameSize += 1;
                    break;
                }
            case '2':
                {
                    frameSize += 2;
                    break;
                }
            case '4':
                {
                    frameSize += 4;
                    break;
                }
            case '8':
                {
                    frameSize += 8;
                    break;
                }
            case 's':
                {
                    String string = (String) args[index];
                    frameSize += 1 + (string != null ? string.getBytes(ZMQ.CHARSET).length : 0);
                    break;
                }
            case 'S':
                {
                    String string = (String) args[index];
                    frameSize += 4 + (string != null ? string.getBytes(ZMQ.CHARSET).length : 0);
                    break;
                }
            case 'b':
            case 'c':
                {
                    byte[] block = (byte[]) args[index];
                    frameSize += 4 + block.length;
                    break;
                }
            case 'f':
                {
                    ZFrame frame = (ZFrame) args[index];
                    msg.add(frame);
                    break;
                }
            case 'm':
                {
                    ZMsg other = (ZMsg) args[index];
                    if (other == null) {
                        msg.add(new ZFrame((byte[]) null));
                    } else {
                        msg.addAll(other);
                    }
                    break;
                }
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    // Pass 2: encode data into data frame
    ZFrame frame = new ZFrame(new byte[frameSize]);
    ZNeedle needle = new ZNeedle(frame);
    for (int index = 0; index < picture.length(); index++) {
        char pattern = picture.charAt(index);
        switch(pattern) {
            case '1':
                {
                    needle.putNumber1((int) args[index]);
                    break;
                }
            case '2':
                {
                    needle.putNumber2((int) args[index]);
                    break;
                }
            case '4':
                {
                    needle.putNumber4((int) args[index]);
                    break;
                }
            case '8':
                {
                    needle.putNumber8((long) args[index]);
                    break;
                }
            case 's':
                {
                    needle.putString((String) args[index]);
                    break;
                }
            case 'S':
                {
                    needle.putLongString((String) args[index]);
                    break;
                }
            case 'b':
            case 'c':
                {
                    byte[] block = (byte[]) args[index];
                    needle.putNumber4(block.length);
                    needle.putBlock(block, block.length);
                    break;
                }
            case 'f':
            case 'm':
                break;
            default:
                assert (false) : ""invalid picture element '"" + pattern + ""'"";
        }
    }
    msg.addFirst(frame);
    return msg;
}","/**
     * Creates a binary encoded 'picture' message to the socket (or actor), so it can be sent.
     * The arguments are encoded in a binary format that is compatible with zproto, and
     * is designed to reduce memory allocations.
     *
     * @param picture The picture argument is a string that defines the
     *                type of each argument. Supports these argument types:
     *                <table>
     *                <caption> </caption>
     *                <tr><th style=""text-align:left"">pattern</th><th style=""text-align:left"">java type</th><th style=""text-align:left"">zproto type</th></tr>
     *                <tr><td>1</td><td>int</td><td>type = ""number"" size = ""1""</td></tr>
     *                <tr><td>2</td><td>int</td><td>type = ""number"" size = ""2""</td></tr>
     *                <tr><td>4</td><td>long</td><td>type = ""number"" size = ""3""</td></tr>
     *                <tr><td>8</td><td>long</td><td>type = ""number"" size = ""4""</td></tr>
     *                <tr><td>s</td><td>String, 0-255 chars</td><td>type = ""string""</td></tr>
     *                <tr><td>S</td><td>String, 0-2^32-1 chars</td><td>type = ""longstr""</td></tr>
     *                <tr><td>b</td><td>byte[], 0-2^32-1 bytes</td><td>type = ""chunk""</td></tr>
     *                <tr><td>c</td><td>byte[], 0-2^32-1 bytes</td><td>type = ""chunk""</td></tr>
     *                <tr><td>f</td><td>ZFrame</td><td>type = ""frame""</td></tr>
     *                <tr><td>m</td><td>ZMsg</td><td>type = ""msg"" <b>Has to be the last element of the picture</b></td></tr>
     *                </table>
     * @param args    Arguments according to the picture
     * @return true when it has been queued on the socket and MQ has assumed responsibility for the message.
     * This does not indicate that the message has been transmitted to the network.
     * @apiNote Does not change or take ownership of any arguments.
     */","('msgBinaryPicture', {'INSTRUCTION': {'covered': 221, 'missed': 34}, 'BRANCH': {'covered': 27, 'missed': 8}, 'LINE': {'covered': 56, 'missed': 2}, 'COMPLEXITY': {'covered': 20, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",600.0,"  Creates a binary encoded 'picture' message to the socket (or actor), so it can be sent.",21.0,"['A picture message can be sent.', 'A picture message can be sent by the actor.', ""A picture message can be sent if it's created.""]"
1088,liquibase,liquibase/integration/cdi/SchemesTreeBuilder.java,/liquibase-cdi/src/main/java/liquibase/integration/cdi/SchemesTreeBuilder.java,build,74-184,"/**
     * Builds a collection of schemes sorted according dependencies
     *
     * @param schemes All found Liquibase Schema annotations in 'war' or 'ear' type file.
     * @return sorted collection of schemes
     */
public List<LiquibaseSchema> build(final String id, Collection<LiquibaseSchema> schemes){
    log.fine(String.format(""[id = %s] build(%s)"", id, schemes));
    log.info(String.format(""[id = %s] Sorting schemes according dependencies..."", id));
    if (schemes.isEmpty()) {
        return Collections.emptyList();
    }
    SchemaNode root = null;
    // first, copy schemes to no modify source collection
    schemes = new ArrayList<>(schemes);
    Collection<LiquibaseSchema> availableSchemes = new ArrayList<>(schemes);
    // then find not dependent schemes - this will the roots of hierarchy.
    List<LiquibaseSchema> notDependent = new ArrayList<>();
    for (LiquibaseSchema liquibaseSchema : schemes) {
        String depends = liquibaseSchema.depends();
        if (depends.trim().isEmpty()) {
            notDependent.add(liquibaseSchema);
        }
    }
    log.info(String.format(""[id = %s] Found [%s] not dependent schemes."", id, notDependent.size()));
    if (notDependent.isEmpty()) {
        // if there is no not-dependent schema, then there is a cyclic dependency.
        throw new CyclicDependencyException(String.format(""[id = %s] Not independent schemes, possible cyclic dependencies discovered."", id));
    } else {
        // take first of not-dependent and use it as root of hierarchy.
        root = new SchemaNode(notDependent.get(0));
        log.fine(String.format(""[id = %s] Selected dependencies tree root [%s]"", id, root.getItem()));
        // we won't to check not-dependent schemes.
        availableSchemes.removeAll(notDependent);
        // remove root from not-dependent schemes
        notDependent.remove(root.getItem());
        // remove not-dependent from all schemes
        schemes.retainAll(availableSchemes);
        // now make all not-dependent schemes children to selected root.
        for (LiquibaseSchema liquibaseSchema : notDependent) {
            root.addChild(liquibaseSchema);
        }
        log.fine(String.format(""[id = %s] Made other non-dependent schemes children of root. [%s] dependent schemes to resolve. Resolving..."", id, availableSchemes.size()));
        int cycles = 0;
        long start = System.currentTimeMillis();
        // until we resolve all dependencies
        while (!availableSchemes.isEmpty()) {
            cycles++;
            log.fine(String.format(""[id = %s] Resolution cycle [%s] started."", id, cycles));
            // we will count dependencies resolution for each resolution cycle.
            int additions = 0;
            for (LiquibaseSchema liquibaseSchema : schemes) {
                log.fine(String.format(""[id = %s] LiquibaseSchema [name=%s] depends on liquibaseSchema [name=%s]."", id, liquibaseSchema.name(), liquibaseSchema.depends()));
                SchemaNode parent = root.find(liquibaseSchema.depends());
                // we make the dependent liquibaseSchema as a child for it's dependency if found. If not, we just continue.
                if (parent == null) {
                    log.fine(String.format(""[id = %s] Dependency not found in resolved dependencies tree, skipping liquibaseSchema [name=%s] for a while."", id, liquibaseSchema.name()));
                    boolean isDependencyMissed = true;
                    for (LiquibaseSchema tmpLiquibaseSchema : availableSchemes) {
                        if (tmpLiquibaseSchema.name().equalsIgnoreCase(liquibaseSchema.depends())) {
                            isDependencyMissed = false;
                            break;
                        }
                    }
                    if (isDependencyMissed) {
                        throw new DependencyNotFoundException(String.format(""[id = %s][name=%s] depends on [name=%s], but it is not found!"", id, liquibaseSchema.name(), liquibaseSchema.depends()));
                    }
                } else {
                    log.fine(String.format(""[id = %s] Dependency found for liquibaseSchema [name=%s], moving it to resolved dependencies tree."", id, liquibaseSchema.name()));
                    parent.addChild(liquibaseSchema);
                    availableSchemes.remove(liquibaseSchema);
                    additions++;
                }
            }
            log.fine(String.format(""[id = %s] Resolution cycle [%s] completed"", id, cycles));
            // if not resolutions happened through resolution cycle, definitely there is a cyclic dependency.
            if (additions == 0) {
                throw new CyclicDependencyException(String.format(""[id = %s] Cyclic dependencies discovered!"", id));
            }
            schemes.retainAll(availableSchemes);
        }
        log.info(String.format(""[id = %s] Dependencies resolved in [cycles=%s, millis=%s]"", id, cycles, System.currentTimeMillis() - start));
    }
    return root.toList();
}","public List<LiquibaseSchema> build(final String id, Collection<LiquibaseSchema> schemes){
    log.fine(String.format(""[id = %s] build(%s)"", id, schemes));
    log.info(String.format(""[id = %s] Sorting schemes according dependencies..."", id));
    if (schemes.isEmpty()) {
        return Collections.emptyList();
    }
    SchemaNode root = null;
    // first, copy schemes to no modify source collection
    schemes = new ArrayList<>(schemes);
    Collection<LiquibaseSchema> availableSchemes = new ArrayList<>(schemes);
    // then find not dependent schemes - this will the roots of hierarchy.
    List<LiquibaseSchema> notDependent = new ArrayList<>();
    for (LiquibaseSchema liquibaseSchema : schemes) {
        String depends = liquibaseSchema.depends();
        if (depends.trim().isEmpty()) {
            notDependent.add(liquibaseSchema);
        }
    }
    log.info(String.format(""[id = %s] Found [%s] not dependent schemes."", id, notDependent.size()));
    if (notDependent.isEmpty()) {
        // if there is no not-dependent schema, then there is a cyclic dependency.
        throw new CyclicDependencyException(String.format(""[id = %s] Not independent schemes, possible cyclic dependencies discovered."", id));
    } else {
        // take first of not-dependent and use it as root of hierarchy.
        root = new SchemaNode(notDependent.get(0));
        log.fine(String.format(""[id = %s] Selected dependencies tree root [%s]"", id, root.getItem()));
        // we won't to check not-dependent schemes.
        availableSchemes.removeAll(notDependent);
        // remove root from not-dependent schemes
        notDependent.remove(root.getItem());
        // remove not-dependent from all schemes
        schemes.retainAll(availableSchemes);
        // now make all not-dependent schemes children to selected root.
        for (LiquibaseSchema liquibaseSchema : notDependent) {
            root.addChild(liquibaseSchema);
        }
        log.fine(String.format(""[id = %s] Made other non-dependent schemes children of root. [%s] dependent schemes to resolve. Resolving..."", id, availableSchemes.size()));
        int cycles = 0;
        long start = System.currentTimeMillis();
        // until we resolve all dependencies
        while (!availableSchemes.isEmpty()) {
            cycles++;
            log.fine(String.format(""[id = %s] Resolution cycle [%s] started."", id, cycles));
            // we will count dependencies resolution for each resolution cycle.
            int additions = 0;
            for (LiquibaseSchema liquibaseSchema : schemes) {
                log.fine(String.format(""[id = %s] LiquibaseSchema [name=%s] depends on liquibaseSchema [name=%s]."", id, liquibaseSchema.name(), liquibaseSchema.depends()));
                SchemaNode parent = root.find(liquibaseSchema.depends());
                // we make the dependent liquibaseSchema as a child for it's dependency if found. If not, we just continue.
                if (parent == null) {
                    log.fine(String.format(""[id = %s] Dependency not found in resolved dependencies tree, skipping liquibaseSchema [name=%s] for a while."", id, liquibaseSchema.name()));
                    boolean isDependencyMissed = true;
                    for (LiquibaseSchema tmpLiquibaseSchema : availableSchemes) {
                        if (tmpLiquibaseSchema.name().equalsIgnoreCase(liquibaseSchema.depends())) {
                            isDependencyMissed = false;
                            break;
                        }
                    }
                    if (isDependencyMissed) {
                        throw new DependencyNotFoundException(String.format(""[id = %s][name=%s] depends on [name=%s], but it is not found!"", id, liquibaseSchema.name(), liquibaseSchema.depends()));
                    }
                } else {
                    log.fine(String.format(""[id = %s] Dependency found for liquibaseSchema [name=%s], moving it to resolved dependencies tree."", id, liquibaseSchema.name()));
                    parent.addChild(liquibaseSchema);
                    availableSchemes.remove(liquibaseSchema);
                    additions++;
                }
            }
            log.fine(String.format(""[id = %s] Resolution cycle [%s] completed"", id, cycles));
            // if not resolutions happened through resolution cycle, definitely there is a cyclic dependency.
            if (additions == 0) {
                throw new CyclicDependencyException(String.format(""[id = %s] Cyclic dependencies discovered!"", id));
            }
            schemes.retainAll(availableSchemes);
        }
        log.info(String.format(""[id = %s] Dependencies resolved in [cycles=%s, millis=%s]"", id, cycles, System.currentTimeMillis() - start));
    }
    return root.toList();
}","/**
     * Builds a collection of schemes sorted according dependencies
     *
     * @param schemes All found Liquibase Schema annotations in 'war' or 'ear' type file.
     * @return sorted collection of schemes
     */","('build', {'INSTRUCTION': {'covered': 370, 'missed': 2}, 'BRANCH': {'covered': 23, 'missed': 1}, 'LINE': {'covered': 61, 'missed': 1}, 'COMPLEXITY': {'covered': 12, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",601.0,  Builds a collection of schemes sorted according dependencies   @param schemes All found Liquibase Schema annotations in 'war' or 'ear' type file.,25.0,"[""There were annotations in the 'war' or 'ear' type file."", ""There were annotations in the 'war' or 'ear' type file that were found."", 'All of the schemes were sorted according to their dependency.']"
1089,jooby,io/jooby/openapi/OpenAPIGenerator.java,/modules/jooby-openapi/src/main/java/io/jooby/openapi/OpenAPIGenerator.java,generate,165-247,"/**
   * Generate an {@link OpenAPI} model from Jooby class. This method parses class byte code and
   * generates an open api model from it. Compilation must be done with debug information and
   * parameters name available.
   *
   * Optionally, the <code>conf/openapi.yaml</code> is used as template and get merged into the
   * final model.
   *
   * @param classname Application class name.
   * @return Model.
   */
public OpenAPI generate(@Nonnull String classname){
    ClassLoader classLoader = Optional.ofNullable(this.classLoader).orElseGet(getClass()::getClassLoader);
    ClassSource source = new ClassSource(classLoader);
    RouteParser routes = new RouteParser(metaInf);
    ParserContext ctx = new ParserContext(source, TypeFactory.fromJavaName(classname), debug);
    List<OperationExt> operations = routes.parse(ctx);
    String contextPath = ContextPathParser.parse(ctx);
    OpenAPIExt openapi = new OpenAPIExt();
    openapi.setSource(Optional.ofNullable(ctx.getMainClass()).orElse(classname));
    OpenAPIParser.parse(ctx, openapi);
    OpenAPIExt.fromTemplate(basedir, classLoader, templateName).ifPresent(template -> merge(openapi, template));
    defaults(classname, contextPath, openapi);
    ctx.schemas().forEach(schema -> openapi.schema(schema.getName(), schema));
    Map<String, Tag> globalTags = new LinkedHashMap<>();
    Paths paths = new Paths();
    for (OperationExt operation : operations) {
        String pattern = operation.getPattern();
        if (!includes(pattern) || excludes(pattern)) {
            log.debug(""skipping {}"", pattern);
            continue;
        }
        Map<String, String> regexMap = new HashMap<>();
        Router.pathKeys(pattern, (key, value) -> Optional.ofNullable(value).ifPresent(v -> regexMap.put(key, v)));
        if (regexMap.size() > 0) {
            for (Map.Entry<String, String> e : regexMap.entrySet()) {
                String name = e.getKey();
                String regex = e.getValue();
                operation.getParameter(name).ifPresent(parameter -> parameter.getSchema().setPattern(regex));
                if (regex.equals(""\\.*"")) {
                    if (name.equals(""*"")) {
                        pattern = pattern.substring(0, pattern.length() - 1) + ""{*}"";
                    } else {
                        pattern = pattern.replace(""*"" + name, ""{"" + name + ""}"");
                    }
                } else {
                    pattern = pattern.replace(name + "":"" + regex, name);
                }
            }
        }
        PathItem pathItem = paths.computeIfAbsent(pattern, k -> new PathItem());
        pathItem.operation(PathItem.HttpMethod.valueOf(operation.getMethod()), operation);
        Optional.ofNullable(operation.getPathSummary()).ifPresent(pathItem::setSummary);
        Optional.ofNullable(operation.getPathDescription()).ifPresent(pathItem::setDescription);
        operation.getGlobalTags().forEach(tag -> globalTags.put(tag.getName(), tag));
    }
    globalTags.values().forEach(tag -> {
        if (tag.getDescription() != null || tag.getExtensions() != null) {
            openapi.addTagsItem(tag);
        }
    });
    openapi.setOperations(operations);
    openapi.setPaths(paths);
    return openapi;
}","public OpenAPI generate(@Nonnull String classname){
    ClassLoader classLoader = Optional.ofNullable(this.classLoader).orElseGet(getClass()::getClassLoader);
    ClassSource source = new ClassSource(classLoader);
    RouteParser routes = new RouteParser(metaInf);
    ParserContext ctx = new ParserContext(source, TypeFactory.fromJavaName(classname), debug);
    List<OperationExt> operations = routes.parse(ctx);
    String contextPath = ContextPathParser.parse(ctx);
    OpenAPIExt openapi = new OpenAPIExt();
    openapi.setSource(Optional.ofNullable(ctx.getMainClass()).orElse(classname));
    OpenAPIParser.parse(ctx, openapi);
    OpenAPIExt.fromTemplate(basedir, classLoader, templateName).ifPresent(template -> merge(openapi, template));
    defaults(classname, contextPath, openapi);
    ctx.schemas().forEach(schema -> openapi.schema(schema.getName(), schema));
    Map<String, Tag> globalTags = new LinkedHashMap<>();
    Paths paths = new Paths();
    for (OperationExt operation : operations) {
        String pattern = operation.getPattern();
        if (!includes(pattern) || excludes(pattern)) {
            log.debug(""skipping {}"", pattern);
            continue;
        }
        Map<String, String> regexMap = new HashMap<>();
        Router.pathKeys(pattern, (key, value) -> Optional.ofNullable(value).ifPresent(v -> regexMap.put(key, v)));
        if (regexMap.size() > 0) {
            for (Map.Entry<String, String> e : regexMap.entrySet()) {
                String name = e.getKey();
                String regex = e.getValue();
                operation.getParameter(name).ifPresent(parameter -> parameter.getSchema().setPattern(regex));
                if (regex.equals(""\\.*"")) {
                    if (name.equals(""*"")) {
                        pattern = pattern.substring(0, pattern.length() - 1) + ""{*}"";
                    } else {
                        pattern = pattern.replace(""*"" + name, ""{"" + name + ""}"");
                    }
                } else {
                    pattern = pattern.replace(name + "":"" + regex, name);
                }
            }
        }
        PathItem pathItem = paths.computeIfAbsent(pattern, k -> new PathItem());
        pathItem.operation(PathItem.HttpMethod.valueOf(operation.getMethod()), operation);
        Optional.ofNullable(operation.getPathSummary()).ifPresent(pathItem::setSummary);
        Optional.ofNullable(operation.getPathDescription()).ifPresent(pathItem::setDescription);
        operation.getGlobalTags().forEach(tag -> globalTags.put(tag.getName(), tag));
    }
    globalTags.values().forEach(tag -> {
        if (tag.getDescription() != null || tag.getExtensions() != null) {
            openapi.addTagsItem(tag);
        }
    });
    openapi.setOperations(operations);
    openapi.setPaths(paths);
    return openapi;
}","/**
   * Generate an {@link OpenAPI} model from Jooby class. This method parses class byte code and
   * generates an open api model from it. Compilation must be done with debug information and
   * parameters name available.
   *
   * Optionally, the <code>conf/openapi.yaml</code> is used as template and get merged into the
   * final model.
   *
   * @param classname Application class name.
   * @return Model.
   */","('generate', {'INSTRUCTION': {'covered': 256, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 44, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",608.0,  Generate an {@link OpenAPI} model from Jooby class.,12.0,"['Generate a model from the class.', 'A model from the class.', 'The model is from the class.']"
1093,dcache,org/dcache/resilience/handlers/FileOperationHandler.java,/modules/dcache-resilience/src/main/java/org/dcache/resilience/handlers/FileOperationHandler.java,determineTypeFromConstraints,1125-1286,"/**
     * <p>Checks the readable locations against the requirements.
     * If previous operations on this pnfsId have already satisfied them, the operation should be
     * voided.</p>
     *
     * @param operation -- on the given pnfsid
     * @param excluded  -- number of member pools manually excluded by admins
     * @param occupied  -- group member pools with a replica in any state
     * @param sticky    -- group member replicas that are sticky
     * @param nonSticky -- group member replicas that are not sticky
     * @param verified  -- the messages returned by the pools
     * @return the type of operation which should take place, if any.
     */
private Type determineTypeFromConstraints(FileOperation operation, int excluded, Set<String> occupied, Set<String> sticky, Set<String> nonSticky, Collection verified){
    PnfsId pnfsId = operation.getPnfsId();
    Integer gindex = operation.getPoolGroup();
    Integer sindex = operation.getStorageUnit();
    LOGGER.trace(""determineTypeFromConstraints {}, group {}, unit {}."", pnfsId, gindex, sindex);
    StorageUnitConstraints constraints = poolInfoMap.getStorageUnitConstraints(sindex);
    int required = constraints.getRequired();
    int missing = required - sticky.size();
    if (missing > 0) {
        missing -= excluded;
        if (missing < 0) {
            missing = 0;
        }
    }
    Collection<String> tags = constraints.getOneCopyPer();
    LOGGER.trace(""{}, required {}, excluded {}, missing {}."", pnfsId, required, excluded, missing);
    Type type;
    String source = null;
    String target = null;
    try {
        if (missing < 0) {
            Integer index = operation.getTarget();
            if (index == null || !poolInfoMap.isPoolViable(index, true) || !verifier.isRemovable(poolInfoMap.getPool(index), verified)) {
                Set<String> removable = verifier.areRemovable(sticky, verified);
                target = locationSelector.selectRemoveTarget(operation, sticky, removable, tags);
            }
            LOGGER.trace(""target to remove: {}"", target);
            type = Type.REMOVE;
        } else if (missing > 0) {
            Integer viableSource = operation.getSource();
            if (viableSource != null && !poolInfoMap.isPoolViable(viableSource, false)) {
                viableSource = null;
            }
            Integer targetIndex = operation.getTarget();
            if (targetIndex == null) {
                if (viableSource != null) {
                    source = poolInfoMap.getPool(viableSource);
                    if (nonSticky.contains(source)) {
                        fileOpMap.updateOperation(pnfsId, null, source);
                        LOGGER.trace(""promoting source to sticky: {}"", source);
                        return Type.SET_STICKY;
                    }
                }
                target = locationSelector.selectPromotionTarget(operation, sticky, nonSticky, tags);
                if (target != null) {
                    fileOpMap.updateOperation(pnfsId, null, target);
                    LOGGER.trace(""target to promote to sticky: {}"", target);
                    return Type.SET_STICKY;
                }
                target = locationSelector.selectCopyTarget(operation, gindex, occupied, tags);
            } else if (!poolInfoMap.isPoolViable(targetIndex, true)) {
                target = locationSelector.selectCopyTarget(operation, gindex, occupied, tags);
            }
            LOGGER.trace(""target to copy: {}"", target);
            Set<String> strictlyReadable = verifier.areReadable(sticky, verified);
            if (viableSource == null) {
                source = locationSelector.selectCopySource(operation, strictlyReadable.isEmpty() ? sticky : strictlyReadable);
            }
            LOGGER.trace(""source: {}"", source);
            type = Type.COPY;
        } else {
            LOGGER.trace(""Nothing to do, VOID operation for {}"", pnfsId);
            fileOpMap.voidOperation(pnfsId);
            return Type.VOID;
        }
    } catch (LocationSelectionException e) {
        CacheException exception = CacheExceptionUtils.getCacheException(CacheException.DEFAULT_ERROR_CODE, FileTaskCompletionHandler.VERIFY_FAILURE_MESSAGE, pnfsId, Type.VOID, null, e);
        completionHandler.taskFailed(pnfsId, exception);
        return Type.VOID;
    }
    fileOpMap.updateOperation(pnfsId, source, target);
    return type;
}","private Type determineTypeFromConstraints(FileOperation operation, int excluded, Set<String> occupied, Set<String> sticky, Set<String> nonSticky, Collection verified){
    PnfsId pnfsId = operation.getPnfsId();
    Integer gindex = operation.getPoolGroup();
    Integer sindex = operation.getStorageUnit();
    LOGGER.trace(""determineTypeFromConstraints {}, group {}, unit {}."", pnfsId, gindex, sindex);
    StorageUnitConstraints constraints = poolInfoMap.getStorageUnitConstraints(sindex);
    int required = constraints.getRequired();
    int missing = required - sticky.size();
    if (missing > 0) {
        missing -= excluded;
        if (missing < 0) {
            missing = 0;
        }
    }
    Collection<String> tags = constraints.getOneCopyPer();
    LOGGER.trace(""{}, required {}, excluded {}, missing {}."", pnfsId, required, excluded, missing);
    Type type;
    String source = null;
    String target = null;
    try {
        if (missing < 0) {
            Integer index = operation.getTarget();
            if (index == null || !poolInfoMap.isPoolViable(index, true) || !verifier.isRemovable(poolInfoMap.getPool(index), verified)) {
                Set<String> removable = verifier.areRemovable(sticky, verified);
                target = locationSelector.selectRemoveTarget(operation, sticky, removable, tags);
            }
            LOGGER.trace(""target to remove: {}"", target);
            type = Type.REMOVE;
        } else if (missing > 0) {
            Integer viableSource = operation.getSource();
            if (viableSource != null && !poolInfoMap.isPoolViable(viableSource, false)) {
                viableSource = null;
            }
            Integer targetIndex = operation.getTarget();
            if (targetIndex == null) {
                if (viableSource != null) {
                    source = poolInfoMap.getPool(viableSource);
                    if (nonSticky.contains(source)) {
                        fileOpMap.updateOperation(pnfsId, null, source);
                        LOGGER.trace(""promoting source to sticky: {}"", source);
                        return Type.SET_STICKY;
                    }
                }
                target = locationSelector.selectPromotionTarget(operation, sticky, nonSticky, tags);
                if (target != null) {
                    fileOpMap.updateOperation(pnfsId, null, target);
                    LOGGER.trace(""target to promote to sticky: {}"", target);
                    return Type.SET_STICKY;
                }
                target = locationSelector.selectCopyTarget(operation, gindex, occupied, tags);
            } else if (!poolInfoMap.isPoolViable(targetIndex, true)) {
                target = locationSelector.selectCopyTarget(operation, gindex, occupied, tags);
            }
            LOGGER.trace(""target to copy: {}"", target);
            Set<String> strictlyReadable = verifier.areReadable(sticky, verified);
            if (viableSource == null) {
                source = locationSelector.selectCopySource(operation, strictlyReadable.isEmpty() ? sticky : strictlyReadable);
            }
            LOGGER.trace(""source: {}"", source);
            type = Type.COPY;
        } else {
            LOGGER.trace(""Nothing to do, VOID operation for {}"", pnfsId);
            fileOpMap.voidOperation(pnfsId);
            return Type.VOID;
        }
    } catch (LocationSelectionException e) {
        CacheException exception = CacheExceptionUtils.getCacheException(CacheException.DEFAULT_ERROR_CODE, FileTaskCompletionHandler.VERIFY_FAILURE_MESSAGE, pnfsId, Type.VOID, null, e);
        completionHandler.taskFailed(pnfsId, exception);
        return Type.VOID;
    }
    fileOpMap.updateOperation(pnfsId, source, target);
    return type;
}","/**
     * <p>Checks the readable locations against the requirements.
     * If previous operations on this pnfsId have already satisfied them, the operation should be
     * voided.</p>
     *
     * @param operation -- on the given pnfsid
     * @param excluded  -- number of member pools manually excluded by admins
     * @param occupied  -- group member pools with a replica in any state
     * @param sticky    -- group member replicas that are sticky
     * @param nonSticky -- group member replicas that are not sticky
     * @param verified  -- the messages returned by the pools
     * @return the type of operation which should take place, if any.
     */","('determineTypeFromConstraints', {'INSTRUCTION': {'covered': 238, 'missed': 39}, 'BRANCH': {'covered': 23, 'missed': 9}, 'LINE': {'covered': 60, 'missed': 7}, 'COMPLEXITY': {'covered': 10, 'missed': 7}, 'METHOD': {'covered': 1, 'missed': 0}})",619.0,  <p>Checks the readable locations against the requirements.,11.0,"['The locations are checked against the requirements.', 'Checks the readable locations against the requirements.', 'The locations are checked against requirements.']"
1094,matsim-libs,org/matsim/lanes/LanesUtils.java,/matsim/src/main/java/org/matsim/lanes/LanesUtils.java,createLanes,107-200,"/**
	 * Creates a sorted list of lanes for a link. 
	 * @param link
	 * @param lanesToLinkAssignment
	 * @return sorted list with the most upstream lane at the first position. 
	 */
public static List<ModelLane> createLanes(Link link, LanesToLinkAssignment lanesToLinkAssignment){
    List<ModelLane> queueLanes = new ArrayList<>();
    List<Lane> sortedLanes = new ArrayList<>(lanesToLinkAssignment.getLanes().values());
    sortedLanes.sort(Comparator.comparingDouble(Lane::getStartsAtMeterFromLinkEnd).thenComparing((l1, l2) -> {
        boolean l1Outgoing = l1.getToLinkIds() != null && !l1.getToLinkIds().isEmpty();
        boolean l2Outgoing = l2.getToLinkIds() != null && !l2.getToLinkIds().isEmpty();
        if (l1Outgoing && !l2Outgoing)
            return -1;
        else if (l2Outgoing && !l1Outgoing)
            return 1;
        else
            return 0;
    }));
    Collections.reverse(sortedLanes);
    List<ModelLane> laneList = new LinkedList<>();
    Lane firstLane = sortedLanes.remove(0);
    if (firstLane.getStartsAtMeterFromLinkEnd() != link.getLength()) {
        throw new IllegalStateException(""First Lane Id "" + firstLane.getId() + "" on Link Id "" + link.getId() + ""isn't starting at the beginning of the link!"");
    }
    ModelLane firstQLane = new ModelLane(firstLane);
    laneList.add(firstQLane);
    Stack<ModelLane> laneStack = new Stack<>();
    while (!laneList.isEmpty()) {
        ModelLane lastQLane = laneList.remove(0);
        laneStack.push(lastQLane);
        queueLanes.add(lastQLane);
        List<Id<Lane>> toLaneIds = lastQLane.getLaneData().getToLaneIds();
        double nextMetersFromLinkEnd = 0.0;
        double laneLength = 0.0;
        if (toLaneIds != null && (!toLaneIds.isEmpty())) {
            for (Id<Lane> toLaneId : toLaneIds) {
                Lane currentLane = lanesToLinkAssignment.getLanes().get(toLaneId);
                nextMetersFromLinkEnd = currentLane.getStartsAtMeterFromLinkEnd();
                ModelLane currentQLane = new ModelLane(currentLane);
                laneList.add(currentQLane);
                lastQLane.addAToLane(currentQLane);
            }
            laneLength = lastQLane.getLaneData().getStartsAtMeterFromLinkEnd() - nextMetersFromLinkEnd;
            lastQLane.setEndsAtMetersFromLinkEnd(nextMetersFromLinkEnd);
        } else {
            laneLength = lastQLane.getLaneData().getStartsAtMeterFromLinkEnd();
            lastQLane.setEndsAtMetersFromLinkEnd(0.0);
        }
        lastQLane.setLength(laneLength);
    }
    while (!laneStack.isEmpty()) {
        ModelLane qLane = laneStack.pop();
        if (qLane.getToLanes() == null || (qLane.getToLanes().isEmpty())) {
            for (Id<Link> toLinkId : qLane.getLaneData().getToLinkIds()) {
                qLane.addDestinationLink(toLinkId);
            }
        } else {
            for (ModelLane subsequentLane : qLane.getToLanes()) {
                for (Id<Link> toLinkId : subsequentLane.getDestinationLinkIds()) {
                    qLane.addDestinationLink(toLinkId);
                }
            }
        }
    }
    Collections.sort(queueLanes, new Comparator<ModelLane>() {

        @Override
        public int compare(ModelLane o1, ModelLane o2) {
            if (o1.getEndsAtMeterFromLinkEnd() < o2.getEndsAtMeterFromLinkEnd()) {
                return -1;
            } else if (o1.getEndsAtMeterFromLinkEnd() > o2.getEndsAtMeterFromLinkEnd()) {
                return 1;
            } else {
                return 0;
            }
        }
    });
    return queueLanes;
}","public static List<ModelLane> createLanes(Link link, LanesToLinkAssignment lanesToLinkAssignment){
    List<ModelLane> queueLanes = new ArrayList<>();
    List<Lane> sortedLanes = new ArrayList<>(lanesToLinkAssignment.getLanes().values());
    sortedLanes.sort(Comparator.comparingDouble(Lane::getStartsAtMeterFromLinkEnd).thenComparing((l1, l2) -> {
        boolean l1Outgoing = l1.getToLinkIds() != null && !l1.getToLinkIds().isEmpty();
        boolean l2Outgoing = l2.getToLinkIds() != null && !l2.getToLinkIds().isEmpty();
        if (l1Outgoing && !l2Outgoing)
            return -1;
        else if (l2Outgoing && !l1Outgoing)
            return 1;
        else
            return 0;
    }));
    Collections.reverse(sortedLanes);
    List<ModelLane> laneList = new LinkedList<>();
    Lane firstLane = sortedLanes.remove(0);
    if (firstLane.getStartsAtMeterFromLinkEnd() != link.getLength()) {
        throw new IllegalStateException(""First Lane Id "" + firstLane.getId() + "" on Link Id "" + link.getId() + ""isn't starting at the beginning of the link!"");
    }
    ModelLane firstQLane = new ModelLane(firstLane);
    laneList.add(firstQLane);
    Stack<ModelLane> laneStack = new Stack<>();
    while (!laneList.isEmpty()) {
        ModelLane lastQLane = laneList.remove(0);
        laneStack.push(lastQLane);
        queueLanes.add(lastQLane);
        List<Id<Lane>> toLaneIds = lastQLane.getLaneData().getToLaneIds();
        double nextMetersFromLinkEnd = 0.0;
        double laneLength = 0.0;
        if (toLaneIds != null && (!toLaneIds.isEmpty())) {
            for (Id<Lane> toLaneId : toLaneIds) {
                Lane currentLane = lanesToLinkAssignment.getLanes().get(toLaneId);
                nextMetersFromLinkEnd = currentLane.getStartsAtMeterFromLinkEnd();
                ModelLane currentQLane = new ModelLane(currentLane);
                laneList.add(currentQLane);
                lastQLane.addAToLane(currentQLane);
            }
            laneLength = lastQLane.getLaneData().getStartsAtMeterFromLinkEnd() - nextMetersFromLinkEnd;
            lastQLane.setEndsAtMetersFromLinkEnd(nextMetersFromLinkEnd);
        } else {
            laneLength = lastQLane.getLaneData().getStartsAtMeterFromLinkEnd();
            lastQLane.setEndsAtMetersFromLinkEnd(0.0);
        }
        lastQLane.setLength(laneLength);
    }
    while (!laneStack.isEmpty()) {
        ModelLane qLane = laneStack.pop();
        if (qLane.getToLanes() == null || (qLane.getToLanes().isEmpty())) {
            for (Id<Link> toLinkId : qLane.getLaneData().getToLinkIds()) {
                qLane.addDestinationLink(toLinkId);
            }
        } else {
            for (ModelLane subsequentLane : qLane.getToLanes()) {
                for (Id<Link> toLinkId : subsequentLane.getDestinationLinkIds()) {
                    qLane.addDestinationLink(toLinkId);
                }
            }
        }
    }
    Collections.sort(queueLanes, new Comparator<ModelLane>() {

        @Override
        public int compare(ModelLane o1, ModelLane o2) {
            if (o1.getEndsAtMeterFromLinkEnd() < o2.getEndsAtMeterFromLinkEnd()) {
                return -1;
            } else if (o1.getEndsAtMeterFromLinkEnd() > o2.getEndsAtMeterFromLinkEnd()) {
                return 1;
            } else {
                return 0;
            }
        }
    });
    return queueLanes;
}","/**
	 * Creates a sorted list of lanes for a link. 
	 * @param link
	 * @param lanesToLinkAssignment
	 * @return sorted list with the most upstream lane at the first position. 
	 */","('createLanes', {'INSTRUCTION': {'covered': 195, 'missed': 9}, 'BRANCH': {'covered': 19, 'missed': 3}, 'LINE': {'covered': 45, 'missed': 1}, 'COMPLEXITY': {'covered': 9, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",623.0,  Creates a sorted list of lanes for a link.,10.0,"['A sorted list of lanes is created.', 'A sorted list of lanes.', 'A sorted list of lanes for a link is created.']"
1096,cdk,org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/AtomPlacer3D.java,placeAliphaticHeavyChain,116-200,"/**
     *  Method assigns 3D coordinates to the heavy atoms in an aliphatic chain.
     *
     * @param molecule        the reference molecule for the chain
     * @param  chain          the atoms to be assigned, must be connected
     * @throws CDKException the 'chain' was not a chain
     */
public void placeAliphaticHeavyChain(IAtomContainer molecule, IAtomContainer chain) throws CDKException{
    int[] first = new int[2];
    int counter = 1;
    int nextAtomNr = 0;
    String id1 = """";
    String id2 = """";
    String id3 = """";
    first = findHeavyAtomsInChain(molecule, chain);
    distances = new double[first[1]];
    firstAtoms = new int[first[1]];
    angles = new double[first[1]];
    secondAtoms = new int[first[1]];
    dihedrals = new double[first[1]];
    thirdAtoms = new int[first[1]];
    firstAtoms[0] = first[0];
    molecule.getAtom(firstAtoms[0]).setFlag(CDKConstants.VISITED, true);
    int hybridisation = 0;
    for (int i = 0; i < chain.getAtomCount(); i++) {
        if (isHeavyAtom(chain.getAtom(i))) {
            if (!chain.getAtom(i).getFlag(CDKConstants.VISITED)) {
                nextAtomNr = molecule.indexOf(chain.getAtom(i));
                id2 = molecule.getAtom(firstAtoms[counter - 1]).getAtomTypeName();
                id1 = molecule.getAtom(nextAtomNr).getAtomTypeName();
                if (molecule.getBond(molecule.getAtom(firstAtoms[counter - 1]), molecule.getAtom(nextAtomNr)) == null)
                    throw new CDKException(""atoms do not form a chain, please use ModelBuilder3D"");
                distances[counter] = getBondLengthValue(id1, id2);
                firstAtoms[counter] = nextAtomNr;
                secondAtoms[counter] = firstAtoms[counter - 1];
                if (counter > 1) {
                    id3 = molecule.getAtom(firstAtoms[counter - 2]).getAtomTypeName();
                    hybridisation = getHybridisationState(molecule.getAtom(firstAtoms[counter - 1]));
                    angles[counter] = getAngleValue(id1, id2, id3);
                    if (angles[counter] == -1) {
                        if (hybridisation == 3) {
                            angles[counter] = DEFAULT_SP3_ANGLE;
                        } else if (hybridisation == 2) {
                            angles[counter] = DEFAULT_SP2_ANGLE;
                        } else if (hybridisation == 1) {
                            angles[counter] = DEFAULT_SP_ANGLE;
                        }
                    }
                    thirdAtoms[counter] = firstAtoms[counter - 2];
                } else {
                    angles[counter] = -1;
                    thirdAtoms[counter] = -1;
                }
                if (counter > 2) {
                    try {
                        if (getDoubleBondConfiguration2D(molecule.getBond(molecule.getAtom(firstAtoms[counter - 1]), molecule.getAtom(firstAtoms[counter - 2])), (molecule.getAtom(firstAtoms[counter])).getPoint2d(), (molecule.getAtom(firstAtoms[counter - 1])).getPoint2d(), (molecule.getAtom(firstAtoms[counter - 2])).getPoint2d(), (molecule.getAtom(firstAtoms[counter - 3])).getPoint2d()) == 5) {
                            dihedrals[counter] = DIHEDRAL_BRANCHED_CHAIN;
                        } else {
                            dihedrals[counter] = DIHEDRAL_EXTENDED_CHAIN;
                        }
                    } catch (CDKException ex1) {
                        dihedrals[counter] = DIHEDRAL_EXTENDED_CHAIN;
                    }
                } else {
                    dihedrals[counter] = -1;
                }
                counter++;
            }
        }
    }
}","public void placeAliphaticHeavyChain(IAtomContainer molecule, IAtomContainer chain) throws CDKException{
    int[] first = new int[2];
    int counter = 1;
    int nextAtomNr = 0;
    String id1 = """";
    String id2 = """";
    String id3 = """";
    first = findHeavyAtomsInChain(molecule, chain);
    distances = new double[first[1]];
    firstAtoms = new int[first[1]];
    angles = new double[first[1]];
    secondAtoms = new int[first[1]];
    dihedrals = new double[first[1]];
    thirdAtoms = new int[first[1]];
    firstAtoms[0] = first[0];
    molecule.getAtom(firstAtoms[0]).setFlag(CDKConstants.VISITED, true);
    int hybridisation = 0;
    for (int i = 0; i < chain.getAtomCount(); i++) {
        if (isHeavyAtom(chain.getAtom(i))) {
            if (!chain.getAtom(i).getFlag(CDKConstants.VISITED)) {
                nextAtomNr = molecule.indexOf(chain.getAtom(i));
                id2 = molecule.getAtom(firstAtoms[counter - 1]).getAtomTypeName();
                id1 = molecule.getAtom(nextAtomNr).getAtomTypeName();
                if (molecule.getBond(molecule.getAtom(firstAtoms[counter - 1]), molecule.getAtom(nextAtomNr)) == null)
                    throw new CDKException(""atoms do not form a chain, please use ModelBuilder3D"");
                distances[counter] = getBondLengthValue(id1, id2);
                firstAtoms[counter] = nextAtomNr;
                secondAtoms[counter] = firstAtoms[counter - 1];
                if (counter > 1) {
                    id3 = molecule.getAtom(firstAtoms[counter - 2]).getAtomTypeName();
                    hybridisation = getHybridisationState(molecule.getAtom(firstAtoms[counter - 1]));
                    angles[counter] = getAngleValue(id1, id2, id3);
                    if (angles[counter] == -1) {
                        if (hybridisation == 3) {
                            angles[counter] = DEFAULT_SP3_ANGLE;
                        } else if (hybridisation == 2) {
                            angles[counter] = DEFAULT_SP2_ANGLE;
                        } else if (hybridisation == 1) {
                            angles[counter] = DEFAULT_SP_ANGLE;
                        }
                    }
                    thirdAtoms[counter] = firstAtoms[counter - 2];
                } else {
                    angles[counter] = -1;
                    thirdAtoms[counter] = -1;
                }
                if (counter > 2) {
                    try {
                        if (getDoubleBondConfiguration2D(molecule.getBond(molecule.getAtom(firstAtoms[counter - 1]), molecule.getAtom(firstAtoms[counter - 2])), (molecule.getAtom(firstAtoms[counter])).getPoint2d(), (molecule.getAtom(firstAtoms[counter - 1])).getPoint2d(), (molecule.getAtom(firstAtoms[counter - 2])).getPoint2d(), (molecule.getAtom(firstAtoms[counter - 3])).getPoint2d()) == 5) {
                            dihedrals[counter] = DIHEDRAL_BRANCHED_CHAIN;
                        } else {
                            dihedrals[counter] = DIHEDRAL_EXTENDED_CHAIN;
                        }
                    } catch (CDKException ex1) {
                        dihedrals[counter] = DIHEDRAL_EXTENDED_CHAIN;
                    }
                } else {
                    dihedrals[counter] = -1;
                }
                counter++;
            }
        }
    }
}","/**
     *  Method assigns 3D coordinates to the heavy atoms in an aliphatic chain.
     *
     * @param molecule        the reference molecule for the chain
     * @param  chain          the atoms to be assigned, must be connected
     * @throws CDKException the 'chain' was not a chain
     */","('placeAliphaticHeavyChain', {'INSTRUCTION': {'covered': 297, 'missed': 30}, 'BRANCH': {'covered': 16, 'missed': 6}, 'LINE': {'covered': 50, 'missed': 7}, 'COMPLEXITY': {'covered': 8, 'missed': 4}, 'METHOD': {'covered': 1, 'missed': 0}})",634.0,Method assigns 3D coordinates to the heavy atoms in an aliphatic chain.,13.0,"['The method assigns coordinates to the heavy atoms.', '3D coordinates are assigned to the heavy atoms.', '3D coordinates are given to the heavy atoms.']"
1097,matsim-libs,org/matsim/core/config/Config.java,/matsim/src/main/java/org/matsim/core/config/Config.java,addCoreModules,112-200,"/**
	 * Adds all the commonly used config-groups, also known as ""core modules"",
	 * to this config-instance. This should be called before reading any
	 * configuration from file.
	 */
public void addCoreModules(){
    this.global = new GlobalConfigGroup();
    this.modules.put(GlobalConfigGroup.GROUP_NAME, this.global);
    this.controler = new ControlerConfigGroup();
    this.modules.put(ControlerConfigGroup.GROUP_NAME, this.controler);
    this.qSimConfigGroup = new QSimConfigGroup();
    this.modules.put(QSimConfigGroup.GROUP_NAME, this.qSimConfigGroup);
    this.counts = new CountsConfigGroup();
    this.modules.put(CountsConfigGroup.GROUP_NAME, this.counts);
    this.charyparNagelScoring = new PlanCalcScoreConfigGroup();
    this.modules.put(PlanCalcScoreConfigGroup.GROUP_NAME, this.charyparNagelScoring);
    this.network = new NetworkConfigGroup();
    this.modules.put(NetworkConfigGroup.GROUP_NAME, this.network);
    this.plans = new PlansConfigGroup();
    this.modules.put(PlansConfigGroup.GROUP_NAME, this.plans);
    this.households = new HouseholdsConfigGroup();
    this.modules.put(HouseholdsConfigGroup.GROUP_NAME, this.households);
    this.parallelEventHandling = new ParallelEventHandlingConfigGroup();
    this.modules.put(ParallelEventHandlingConfigGroup.GROUP_NAME, this.parallelEventHandling);
    this.facilities = new FacilitiesConfigGroup();
    this.modules.put(FacilitiesConfigGroup.GROUP_NAME, this.facilities);
    this.strategy = new StrategyConfigGroup();
    this.modules.put(StrategyConfigGroup.GROUP_NAME, this.strategy);
    this.travelTimeCalculatorConfigGroup = new TravelTimeCalculatorConfigGroup();
    this.modules.put(TravelTimeCalculatorConfigGroup.GROUPNAME, this.travelTimeCalculatorConfigGroup);
    this.scenarioConfigGroup = new ScenarioConfigGroup();
    this.modules.put(ScenarioConfigGroup.GROUP_NAME, this.scenarioConfigGroup);
    this.plansCalcRoute = new PlansCalcRouteConfigGroup();
    this.modules.put(PlansCalcRouteConfigGroup.GROUP_NAME, this.plansCalcRoute);
    this.timeAllocationMutator = new TimeAllocationMutatorConfigGroup();
    this.modules.put(TimeAllocationMutatorConfigGroup.GROUP_NAME, this.timeAllocationMutator);
    this.vspExperimentalGroup = new VspExperimentalConfigGroup();
    this.modules.put(VspExperimentalConfigGroup.GROUP_NAME, this.vspExperimentalGroup);
    this.ptCounts = new PtCountsConfigGroup();
    this.modules.put(PtCountsConfigGroup.GROUP_NAME, this.ptCounts);
    this.transit = new TransitConfigGroup();
    this.modules.put(TransitConfigGroup.GROUP_NAME, this.transit);
    this.linkStats = new LinkStatsConfigGroup();
    this.modules.put(LinkStatsConfigGroup.GROUP_NAME, this.linkStats);
    this.transitRouter = new TransitRouterConfigGroup();
    this.modules.put(TransitRouterConfigGroup.GROUP_NAME, this.transitRouter);
    this.subtourModeChoice = new SubtourModeChoiceConfigGroup();
    this.modules.put(SubtourModeChoiceConfigGroup.GROUP_NAME, this.subtourModeChoice);
    this.vehicles = new VehiclesConfigGroup();
    this.modules.put(VehiclesConfigGroup.GROUP_NAME, this.vehicles);
    this.changeMode = new ChangeModeConfigGroup();
    this.modules.put(ChangeModeConfigGroup.CONFIG_MODULE, this.changeMode);
    this.modules.put(ChangeLegModeConfigGroup.CONFIG_MODULE, new ChangeLegModeConfigGroup());
    // only to provide error messages. kai, may'16
    this.jdeqSim = new JDEQSimConfigGroup();
    this.modules.put(JDEQSimConfigGroup.NAME, this.jdeqSim);
    this.hermes = new HermesConfigGroup();
    this.modules.put(HermesConfigGroup.NAME, this.hermes);
    this.addConfigConsistencyChecker(new VspConfigConsistencyCheckerImpl());
    this.addConfigConsistencyChecker(new UnmaterializedConfigGroupChecker());
    this.addConfigConsistencyChecker(new BeanValidationConfigConsistencyChecker());
}","public void addCoreModules(){
    this.global = new GlobalConfigGroup();
    this.modules.put(GlobalConfigGroup.GROUP_NAME, this.global);
    this.controler = new ControlerConfigGroup();
    this.modules.put(ControlerConfigGroup.GROUP_NAME, this.controler);
    this.qSimConfigGroup = new QSimConfigGroup();
    this.modules.put(QSimConfigGroup.GROUP_NAME, this.qSimConfigGroup);
    this.counts = new CountsConfigGroup();
    this.modules.put(CountsConfigGroup.GROUP_NAME, this.counts);
    this.charyparNagelScoring = new PlanCalcScoreConfigGroup();
    this.modules.put(PlanCalcScoreConfigGroup.GROUP_NAME, this.charyparNagelScoring);
    this.network = new NetworkConfigGroup();
    this.modules.put(NetworkConfigGroup.GROUP_NAME, this.network);
    this.plans = new PlansConfigGroup();
    this.modules.put(PlansConfigGroup.GROUP_NAME, this.plans);
    this.households = new HouseholdsConfigGroup();
    this.modules.put(HouseholdsConfigGroup.GROUP_NAME, this.households);
    this.parallelEventHandling = new ParallelEventHandlingConfigGroup();
    this.modules.put(ParallelEventHandlingConfigGroup.GROUP_NAME, this.parallelEventHandling);
    this.facilities = new FacilitiesConfigGroup();
    this.modules.put(FacilitiesConfigGroup.GROUP_NAME, this.facilities);
    this.strategy = new StrategyConfigGroup();
    this.modules.put(StrategyConfigGroup.GROUP_NAME, this.strategy);
    this.travelTimeCalculatorConfigGroup = new TravelTimeCalculatorConfigGroup();
    this.modules.put(TravelTimeCalculatorConfigGroup.GROUPNAME, this.travelTimeCalculatorConfigGroup);
    this.scenarioConfigGroup = new ScenarioConfigGroup();
    this.modules.put(ScenarioConfigGroup.GROUP_NAME, this.scenarioConfigGroup);
    this.plansCalcRoute = new PlansCalcRouteConfigGroup();
    this.modules.put(PlansCalcRouteConfigGroup.GROUP_NAME, this.plansCalcRoute);
    this.timeAllocationMutator = new TimeAllocationMutatorConfigGroup();
    this.modules.put(TimeAllocationMutatorConfigGroup.GROUP_NAME, this.timeAllocationMutator);
    this.vspExperimentalGroup = new VspExperimentalConfigGroup();
    this.modules.put(VspExperimentalConfigGroup.GROUP_NAME, this.vspExperimentalGroup);
    this.ptCounts = new PtCountsConfigGroup();
    this.modules.put(PtCountsConfigGroup.GROUP_NAME, this.ptCounts);
    this.transit = new TransitConfigGroup();
    this.modules.put(TransitConfigGroup.GROUP_NAME, this.transit);
    this.linkStats = new LinkStatsConfigGroup();
    this.modules.put(LinkStatsConfigGroup.GROUP_NAME, this.linkStats);
    this.transitRouter = new TransitRouterConfigGroup();
    this.modules.put(TransitRouterConfigGroup.GROUP_NAME, this.transitRouter);
    this.subtourModeChoice = new SubtourModeChoiceConfigGroup();
    this.modules.put(SubtourModeChoiceConfigGroup.GROUP_NAME, this.subtourModeChoice);
    this.vehicles = new VehiclesConfigGroup();
    this.modules.put(VehiclesConfigGroup.GROUP_NAME, this.vehicles);
    this.changeMode = new ChangeModeConfigGroup();
    this.modules.put(ChangeModeConfigGroup.CONFIG_MODULE, this.changeMode);
    this.modules.put(ChangeLegModeConfigGroup.CONFIG_MODULE, new ChangeLegModeConfigGroup());
    // only to provide error messages. kai, may'16
    this.jdeqSim = new JDEQSimConfigGroup();
    this.modules.put(JDEQSimConfigGroup.NAME, this.jdeqSim);
    this.hermes = new HermesConfigGroup();
    this.modules.put(HermesConfigGroup.NAME, this.hermes);
    this.addConfigConsistencyChecker(new VspConfigConsistencyCheckerImpl());
    this.addConfigConsistencyChecker(new UnmaterializedConfigGroupChecker());
    this.addConfigConsistencyChecker(new BeanValidationConfigConsistencyChecker());
}","/**
	 * Adds all the commonly used config-groups, also known as ""core modules"",
	 * to this config-instance. This should be called before reading any
	 * configuration from file.
	 */","('addCoreModules', {'INSTRUCTION': {'covered': 324, 'missed': 0}, 'LINE': {'covered': 55, 'missed': 0}, 'COMPLEXITY': {'covered': 1, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",653.0,"  Adds all the commonly used config-groups, also known as ""core modules"",  to this config-instance.",19.0,"['This config-instance adds all the commonly used config-groups.', 'Adds all the commonly used modules to this config-instance.', 'This config-instance adds all the commonly used config-group.']"
1098,cdk,org/openscience/cdk/io/PDBReader.java,/storage/pdb/src/main/java/org/openscience/cdk/io/PDBReader.java,readAtom,610-723,"/**
     * Creates an <code>Atom</code> and sets properties to their values from
     * the ATOM or HETATM record. If the line is shorter than 80 characters, the
     * information past 59 characters is treated as optional. If the line is
     * shorter than 59 characters, a <code>RuntimeException</code> is thrown.
     *
     * @param cLine  the PDB ATOM or HEATATM record.
     * @return the <code>Atom</code> created from the record.
     * @throws RuntimeException if the line is too short (less than 59 characters).
     */
private PDBAtom readAtom(String cLine, int lineLength) throws CDKException{
    if (lineLength < 59) {
        throw new RuntimeException(""PDBReader error during readAtom(): line too short"");
    }
    boolean isHetatm = cLine.startsWith(""HETATM"");
    String atomName = cLine.substring(12, 16).trim();
    String resName = cLine.substring(17, 20).trim();
    String symbol = parseAtomSymbol(cLine);
    if (symbol == null)
        handleError(""Cannot parse symbol from "" + atomName);
    PDBAtom oAtom = new PDBAtom(symbol, new Point3d(Double.parseDouble(cLine.substring(30, 38)), Double.parseDouble(cLine.substring(38, 46)), Double.parseDouble(cLine.substring(46, 54))));
    if (useHetDictionary.isSet() && isHetatm) {
        String cdkType = typeHetatm(resName, atomName);
        oAtom.setAtomTypeName(cdkType);
        if (cdkType != null) {
            try {
                cdkAtomTypeFactory.configure(oAtom);
            } catch (CDKException cdke) {
                logger.warn(""Could not configure"", resName, "" "", atomName);
            }
        }
    }
    oAtom.setRecord(cLine);
    oAtom.setSerial(Integer.parseInt(cLine.substring(6, 11).trim()));
    oAtom.setName(atomName.trim());
    oAtom.setAltLoc(cLine.substring(16, 17).trim());
    oAtom.setResName(resName);
    oAtom.setChainID(cLine.substring(21, 22).trim());
    oAtom.setResSeq(cLine.substring(22, 26).trim());
    oAtom.setICode(cLine.substring(26, 27).trim());
    if (useHetDictionary.isSet() && isHetatm) {
        oAtom.setID(oAtom.getResName() + ""."" + atomName);
    } else {
        oAtom.setAtomTypeName(oAtom.getResName() + ""."" + atomName);
    }
    if (lineLength >= 59) {
        String frag = cLine.substring(54, Math.min(lineLength, 60)).trim();
        if (frag.length() > 0) {
            oAtom.setOccupancy(Double.parseDouble(frag));
        }
    }
    if (lineLength >= 65) {
        String frag = cLine.substring(60, Math.min(lineLength, 66)).trim();
        if (frag.length() > 0) {
            oAtom.setTempFactor(Double.parseDouble(frag));
        }
    }
    if (lineLength >= 75) {
        oAtom.setSegID(cLine.substring(72, Math.min(lineLength, 76)).trim());
    }
    if (lineLength >= 79) {
        String frag;
        if (lineLength >= 80) {
            frag = cLine.substring(78, 80).trim();
        } else {
            frag = cLine.substring(78);
        }
        if (frag.length() > 0) {
            if (frag.endsWith(""-"") || frag.endsWith(""+"")) {
                oAtom.setCharge(Double.parseDouble(new StringBuilder(frag).reverse().toString()));
            } else {
                oAtom.setCharge(Double.parseDouble(frag));
            }
        }
    }
    String oxt = cLine.substring(13, 16).trim();
    if (oxt.equals(""OXT"")) {
        oAtom.setOxt(true);
    } else {
        oAtom.setOxt(false);
    }
    return oAtom;
}","private PDBAtom readAtom(String cLine, int lineLength) throws CDKException{
    if (lineLength < 59) {
        throw new RuntimeException(""PDBReader error during readAtom(): line too short"");
    }
    boolean isHetatm = cLine.startsWith(""HETATM"");
    String atomName = cLine.substring(12, 16).trim();
    String resName = cLine.substring(17, 20).trim();
    String symbol = parseAtomSymbol(cLine);
    if (symbol == null)
        handleError(""Cannot parse symbol from "" + atomName);
    PDBAtom oAtom = new PDBAtom(symbol, new Point3d(Double.parseDouble(cLine.substring(30, 38)), Double.parseDouble(cLine.substring(38, 46)), Double.parseDouble(cLine.substring(46, 54))));
    if (useHetDictionary.isSet() && isHetatm) {
        String cdkType = typeHetatm(resName, atomName);
        oAtom.setAtomTypeName(cdkType);
        if (cdkType != null) {
            try {
                cdkAtomTypeFactory.configure(oAtom);
            } catch (CDKException cdke) {
                logger.warn(""Could not configure"", resName, "" "", atomName);
            }
        }
    }
    oAtom.setRecord(cLine);
    oAtom.setSerial(Integer.parseInt(cLine.substring(6, 11).trim()));
    oAtom.setName(atomName.trim());
    oAtom.setAltLoc(cLine.substring(16, 17).trim());
    oAtom.setResName(resName);
    oAtom.setChainID(cLine.substring(21, 22).trim());
    oAtom.setResSeq(cLine.substring(22, 26).trim());
    oAtom.setICode(cLine.substring(26, 27).trim());
    if (useHetDictionary.isSet() && isHetatm) {
        oAtom.setID(oAtom.getResName() + ""."" + atomName);
    } else {
        oAtom.setAtomTypeName(oAtom.getResName() + ""."" + atomName);
    }
    if (lineLength >= 59) {
        String frag = cLine.substring(54, Math.min(lineLength, 60)).trim();
        if (frag.length() > 0) {
            oAtom.setOccupancy(Double.parseDouble(frag));
        }
    }
    if (lineLength >= 65) {
        String frag = cLine.substring(60, Math.min(lineLength, 66)).trim();
        if (frag.length() > 0) {
            oAtom.setTempFactor(Double.parseDouble(frag));
        }
    }
    if (lineLength >= 75) {
        oAtom.setSegID(cLine.substring(72, Math.min(lineLength, 76)).trim());
    }
    if (lineLength >= 79) {
        String frag;
        if (lineLength >= 80) {
            frag = cLine.substring(78, 80).trim();
        } else {
            frag = cLine.substring(78);
        }
        if (frag.length() > 0) {
            if (frag.endsWith(""-"") || frag.endsWith(""+"")) {
                oAtom.setCharge(Double.parseDouble(new StringBuilder(frag).reverse().toString()));
            } else {
                oAtom.setCharge(Double.parseDouble(frag));
            }
        }
    }
    String oxt = cLine.substring(13, 16).trim();
    if (oxt.equals(""OXT"")) {
        oAtom.setOxt(true);
    } else {
        oAtom.setOxt(false);
    }
    return oAtom;
}","/**
     * Creates an <code>Atom</code> and sets properties to their values from
     * the ATOM or HETATM record. If the line is shorter than 80 characters, the
     * information past 59 characters is treated as optional. If the line is
     * shorter than 59 characters, a <code>RuntimeException</code> is thrown.
     *
     * @param cLine  the PDB ATOM or HEATATM record.
     * @return the <code>Atom</code> created from the record.
     * @throws RuntimeException if the line is too short (less than 59 characters).
     */","('readAtom', {'INSTRUCTION': {'covered': 250, 'missed': 48}, 'BRANCH': {'covered': 27, 'missed': 9}, 'LINE': {'covered': 46, 'missed': 6}, 'COMPLEXITY': {'covered': 10, 'missed': 9}, 'METHOD': {'covered': 1, 'missed': 0}})",684.0,  Creates an <code>Atom</code> and sets properties to their values from  the ATOM or HETATM record.,22.0,"['The Atom record has properties set to their values by the code>Atom/code>.', 'The Atom record has properties that are set to their values by the code>Atom/code>.', 'The Atom record has properties set to their values.']"
1100,cdk,org/openscience/cdk/structgen/VicinitySampler.java,/tool/structgen/src/main/java/org/openscience/cdk/structgen/VicinitySampler.java,sample,53-163,"/**
     * Choose any possible quadruple of the set of atoms
     * in ac and establish all of the possible bonding schemes according to
     * Faulon's equations.
     */
public static List<IAtomContainer> sample(IAtomContainer ac){
    LOGGER.debug(""RandomGenerator->mutate() Start"");
    List<IAtomContainer> structures = new ArrayList<IAtomContainer>();
    int nrOfAtoms = ac.getAtomCount();
    double a11 = 0, a12 = 0, a22 = 0, a21 = 0;
    double b11 = 0, lowerborder = 0, upperborder = 0;
    double b12 = 0;
    double b21 = 0;
    double b22 = 0;
    double[] cmax = new double[4];
    double[] cmin = new double[4];
    IAtomContainer newAc = null;
    IAtom ax1 = null, ax2 = null, ay1 = null, ay2 = null;
    IBond b1 = null, b2 = null, b3 = null, b4 = null;
    // int[] choices = new int[3];
    /* We need at least two non-zero bonds in order to be successful */
    int nonZeroBondsCounter = 0;
    for (int x1 = 0; x1 < nrOfAtoms; x1++) {
        for (int x2 = x1 + 1; x2 < nrOfAtoms; x2++) {
            for (int y1 = x2 + 1; y1 < nrOfAtoms; y1++) {
                for (int y2 = y1 + 1; y2 < nrOfAtoms; y2++) {
                    nonZeroBondsCounter = 0;
                    ax1 = ac.getAtom(x1);
                    ay1 = ac.getAtom(y1);
                    ax2 = ac.getAtom(x2);
                    ay2 = ac.getAtom(y2);
                    /* Get four bonds for these four atoms */
                    b1 = ac.getBond(ax1, ay1);
                    if (b1 != null) {
                        a11 = BondManipulator.destroyBondOrder(b1.getOrder());
                        nonZeroBondsCounter++;
                    } else {
                        a11 = 0;
                    }
                    b2 = ac.getBond(ax1, ay2);
                    if (b2 != null) {
                        a12 = BondManipulator.destroyBondOrder(b2.getOrder());
                        nonZeroBondsCounter++;
                    } else {
                        a12 = 0;
                    }
                    b3 = ac.getBond(ax2, ay1);
                    if (b3 != null) {
                        a21 = BondManipulator.destroyBondOrder(b3.getOrder());
                        nonZeroBondsCounter++;
                    } else {
                        a21 = 0;
                    }
                    b4 = ac.getBond(ax2, ay2);
                    if (b4 != null) {
                        a22 = BondManipulator.destroyBondOrder(b4.getOrder());
                        nonZeroBondsCounter++;
                    } else {
                        a22 = 0;
                    }
                    if (nonZeroBondsCounter > 1) {
                        /*
                             * Compute the range for b11 (see Faulons formulae
                             * for details)
                             */
                        cmax[0] = 0;
                        cmax[1] = a11 - a22;
                        cmax[2] = a11 + a12 - 3;
                        cmax[3] = a11 + a21 - 3;
                        cmin[0] = 3;
                        cmin[1] = a11 + a12;
                        cmin[2] = a11 + a21;
                        cmin[3] = a11 - a22 + 3;
                        lowerborder = MathTools.max(cmax);
                        upperborder = MathTools.min(cmin);
                        for (b11 = lowerborder; b11 <= upperborder; b11++) {
                            if (b11 != a11) {
                                b12 = a11 + a12 - b11;
                                b21 = a11 + a21 - b11;
                                b22 = a22 - a11 + b11;
                                LOGGER.debug(""Trying atom combination : "" + x1 + "":"" + x2 + "":"" + y1 + "":"" + y2);
                                try {
                                    newAc = (IAtomContainer) ac.clone();
                                    change(newAc, x1, y1, x2, y2, b11, b12, b21, b22);
                                    if (ConnectivityChecker.isConnected(newAc)) {
                                        structures.add(newAc);
                                    } else {
                                        LOGGER.debug(""not connected"");
                                    }
                                } catch (CloneNotSupportedException e) {
                                    LOGGER.error(""Cloning exception: "" + e.getMessage());
                                    LOGGER.debug(e);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return structures;
}","public static List<IAtomContainer> sample(IAtomContainer ac){
    LOGGER.debug(""RandomGenerator->mutate() Start"");
    List<IAtomContainer> structures = new ArrayList<IAtomContainer>();
    int nrOfAtoms = ac.getAtomCount();
    double a11 = 0, a12 = 0, a22 = 0, a21 = 0;
    double b11 = 0, lowerborder = 0, upperborder = 0;
    double b12 = 0;
    double b21 = 0;
    double b22 = 0;
    double[] cmax = new double[4];
    double[] cmin = new double[4];
    IAtomContainer newAc = null;
    IAtom ax1 = null, ax2 = null, ay1 = null, ay2 = null;
    IBond b1 = null, b2 = null, b3 = null, b4 = null;
    // int[] choices = new int[3];
    /* We need at least two non-zero bonds in order to be successful */
    int nonZeroBondsCounter = 0;
    for (int x1 = 0; x1 < nrOfAtoms; x1++) {
        for (int x2 = x1 + 1; x2 < nrOfAtoms; x2++) {
            for (int y1 = x2 + 1; y1 < nrOfAtoms; y1++) {
                for (int y2 = y1 + 1; y2 < nrOfAtoms; y2++) {
                    nonZeroBondsCounter = 0;
                    ax1 = ac.getAtom(x1);
                    ay1 = ac.getAtom(y1);
                    ax2 = ac.getAtom(x2);
                    ay2 = ac.getAtom(y2);
                    /* Get four bonds for these four atoms */
                    b1 = ac.getBond(ax1, ay1);
                    if (b1 != null) {
                        a11 = BondManipulator.destroyBondOrder(b1.getOrder());
                        nonZeroBondsCounter++;
                    } else {
                        a11 = 0;
                    }
                    b2 = ac.getBond(ax1, ay2);
                    if (b2 != null) {
                        a12 = BondManipulator.destroyBondOrder(b2.getOrder());
                        nonZeroBondsCounter++;
                    } else {
                        a12 = 0;
                    }
                    b3 = ac.getBond(ax2, ay1);
                    if (b3 != null) {
                        a21 = BondManipulator.destroyBondOrder(b3.getOrder());
                        nonZeroBondsCounter++;
                    } else {
                        a21 = 0;
                    }
                    b4 = ac.getBond(ax2, ay2);
                    if (b4 != null) {
                        a22 = BondManipulator.destroyBondOrder(b4.getOrder());
                        nonZeroBondsCounter++;
                    } else {
                        a22 = 0;
                    }
                    if (nonZeroBondsCounter > 1) {
                        /*
                             * Compute the range for b11 (see Faulons formulae
                             * for details)
                             */
                        cmax[0] = 0;
                        cmax[1] = a11 - a22;
                        cmax[2] = a11 + a12 - 3;
                        cmax[3] = a11 + a21 - 3;
                        cmin[0] = 3;
                        cmin[1] = a11 + a12;
                        cmin[2] = a11 + a21;
                        cmin[3] = a11 - a22 + 3;
                        lowerborder = MathTools.max(cmax);
                        upperborder = MathTools.min(cmin);
                        for (b11 = lowerborder; b11 <= upperborder; b11++) {
                            if (b11 != a11) {
                                b12 = a11 + a12 - b11;
                                b21 = a11 + a21 - b11;
                                b22 = a22 - a11 + b11;
                                LOGGER.debug(""Trying atom combination : "" + x1 + "":"" + x2 + "":"" + y1 + "":"" + y2);
                                try {
                                    newAc = (IAtomContainer) ac.clone();
                                    change(newAc, x1, y1, x2, y2, b11, b12, b21, b22);
                                    if (ConnectivityChecker.isConnected(newAc)) {
                                        structures.add(newAc);
                                    } else {
                                        LOGGER.debug(""not connected"");
                                    }
                                } catch (CloneNotSupportedException e) {
                                    LOGGER.error(""Cloning exception: "" + e.getMessage());
                                    LOGGER.debug(e);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return structures;
}","/**
     * Choose any possible quadruple of the set of atoms
     * in ac and establish all of the possible bonding schemes according to
     * Faulon's equations.
     */","('sample', {'INSTRUCTION': {'covered': 307, 'missed': 18}, 'BRANCH': {'covered': 23, 'missed': 1}, 'LINE': {'covered': 66, 'missed': 4}, 'COMPLEXITY': {'covered': 12, 'missed': 1}, 'METHOD': {'covered': 1, 'missed': 0}})",693.0,  Choose any possible quadruple of the set of atoms  in ac and establish all of the possible bonding schemes according to  Faulon's equations.,25.0,"[""Establish all of the possible bonding schemes according to Faulon's equations if you choose any possible quadruple of the set of atoms."", ""Establish all of the possible bonding schemes according to Faulon's equations by choosing any possible quadruple of the set of atoms."", ""Establish all of the possible bonding schemes according to Faulon's equations by choosing any possible quadruple of the set of atoms in ac.""]"
1101,cdk,org/openscience/cdk/smiles/CxSmilesParser.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/CxSmilesParser.java,processCx,425-569,"/**
     * Parse an string possibly containing CXSMILES into an intermediate state
     * ({@link CxSmilesState}) representation.
     *
     * @param str input character string (SMILES title field)
     * @param state output CXSMILES state
     * @return position where CXSMILES ends (below 0 means no CXSMILES)
     */
 static int processCx(final String str, final CxSmilesState state){
    final CharIter iter = new CharIter(str);
    if (!iter.nextIf('|'))
        return -1;
    while (iter.hasNext()) {
        switch(iter.next()) {
            case '$':
                Map<Integer, String> dest;
                if (iter.nextIf(""_AV:""))
                    dest = state.atomValues = new TreeMap<>();
                else
                    dest = state.atomLabels = new TreeMap<>();
                if (!processAtomLabels(iter, dest))
                    return -1;
                break;
            case '(':
                if (!processCoords(iter, state))
                    return -1;
                break;
            case 'c':
            case 't':
                if (iter.nextIf(':')) {
                    if (!skipIntList(iter, COMMA_SEPARATOR))
                        return -1;
                } else if (iter.nextIf(""tu:"")) {
                    if (!skipIntList(iter, COMMA_SEPARATOR))
                        return -1;
                }
                break;
            case '&':
                if (!processStereoGrps(state, iter, IStereoElement.GRP_RAC))
                    return -1;
                break;
            case 'o':
                if (!processStereoGrps(state, iter, IStereoElement.GRP_REL))
                    return -1;
                break;
            case 'a':
                if (!processStereoGrps(state, iter, IStereoElement.GRP_ABS))
                    return -1;
                break;
            case 'r':
                if (iter.nextIf(':')) {
                    state.racemicFrags = new ArrayList<>();
                    if (!processIntList(iter, ',', state.racemicFrags))
                        return -1;
                } else {
                    state.racemic = true;
                    if (!iter.nextIf(',') && iter.curr() != '|')
                        return -1;
                }
                break;
            case 'l':
                if (!iter.nextIf(""p:""))
                    return -1;
                if (!skipIntMap(iter))
                    return -1;
                break;
            case 'f':
                if (!iter.nextIf(':'))
                    return -1;
                if (!processFragmentGrouping(iter, state))
                    return -1;
                break;
            case 'S':
                if (iter.nextIf(""g:"")) {
                    if (!processPolymerSgroups(iter, state))
                        return -1;
                } else if (iter.nextIf(""gD:"")) {
                    if (!processDataSgroups(iter, state))
                        return -1;
                    if (iter.nextIf(','))
                        break;
                } else if (iter.nextIf(""gH:"")) {
                    if (!processSgroupsHierarchy(iter, state))
                        return -1;
                } else {
                    return -1;
                }
                break;
            case 'm':
                if (!iter.nextIf(':'))
                    return -1;
                if (!processPositionalVariation(iter, state))
                    return -1;
                break;
            case '^':
                if (!processRadicals(iter, state))
                    return -1;
                break;
            case 'C':
            case 'H':
                if (!iter.nextIf(':'))
                    return -1;
                while (iter.hasNext() && isDigit(iter.curr())) {
                    if (!skipIntList(iter, DOT_SEPARATOR))
                        return -1;
                    iter.nextIf(',');
                }
                break;
            case '|':
                if (!iter.nextIf(' '))
                    iter.nextIf('\t');
                return iter.pos;
            case 'L':
                if (iter.nextIf('O')) {
                    if (!iter.nextIf(':'))
                        return -1;
                    if (!processLigandOrdering(iter, state))
                        return -1;
                } else {
                    return -1;
                }
                break;
            default:
                return -1;
        }
    }
    return -1;
}","static int processCx(final String str, final CxSmilesState state){
    final CharIter iter = new CharIter(str);
    if (!iter.nextIf('|'))
        return -1;
    while (iter.hasNext()) {
        switch(iter.next()) {
            case '$':
                Map<Integer, String> dest;
                if (iter.nextIf(""_AV:""))
                    dest = state.atomValues = new TreeMap<>();
                else
                    dest = state.atomLabels = new TreeMap<>();
                if (!processAtomLabels(iter, dest))
                    return -1;
                break;
            case '(':
                if (!processCoords(iter, state))
                    return -1;
                break;
            case 'c':
            case 't':
                if (iter.nextIf(':')) {
                    if (!skipIntList(iter, COMMA_SEPARATOR))
                        return -1;
                } else if (iter.nextIf(""tu:"")) {
                    if (!skipIntList(iter, COMMA_SEPARATOR))
                        return -1;
                }
                break;
            case '&':
                if (!processStereoGrps(state, iter, IStereoElement.GRP_RAC))
                    return -1;
                break;
            case 'o':
                if (!processStereoGrps(state, iter, IStereoElement.GRP_REL))
                    return -1;
                break;
            case 'a':
                if (!processStereoGrps(state, iter, IStereoElement.GRP_ABS))
                    return -1;
                break;
            case 'r':
                if (iter.nextIf(':')) {
                    state.racemicFrags = new ArrayList<>();
                    if (!processIntList(iter, ',', state.racemicFrags))
                        return -1;
                } else {
                    state.racemic = true;
                    if (!iter.nextIf(',') && iter.curr() != '|')
                        return -1;
                }
                break;
            case 'l':
                if (!iter.nextIf(""p:""))
                    return -1;
                if (!skipIntMap(iter))
                    return -1;
                break;
            case 'f':
                if (!iter.nextIf(':'))
                    return -1;
                if (!processFragmentGrouping(iter, state))
                    return -1;
                break;
            case 'S':
                if (iter.nextIf(""g:"")) {
                    if (!processPolymerSgroups(iter, state))
                        return -1;
                } else if (iter.nextIf(""gD:"")) {
                    if (!processDataSgroups(iter, state))
                        return -1;
                    if (iter.nextIf(','))
                        break;
                } else if (iter.nextIf(""gH:"")) {
                    if (!processSgroupsHierarchy(iter, state))
                        return -1;
                } else {
                    return -1;
                }
                break;
            case 'm':
                if (!iter.nextIf(':'))
                    return -1;
                if (!processPositionalVariation(iter, state))
                    return -1;
                break;
            case '^':
                if (!processRadicals(iter, state))
                    return -1;
                break;
            case 'C':
            case 'H':
                if (!iter.nextIf(':'))
                    return -1;
                while (iter.hasNext() && isDigit(iter.curr())) {
                    if (!skipIntList(iter, DOT_SEPARATOR))
                        return -1;
                    iter.nextIf(',');
                }
                break;
            case '|':
                if (!iter.nextIf(' '))
                    iter.nextIf('\t');
                return iter.pos;
            case 'L':
                if (iter.nextIf('O')) {
                    if (!iter.nextIf(':'))
                        return -1;
                    if (!processLigandOrdering(iter, state))
                        return -1;
                } else {
                    return -1;
                }
                break;
            default:
                return -1;
        }
    }
    return -1;
}","/**
     * Parse an string possibly containing CXSMILES into an intermediate state
     * ({@link CxSmilesState}) representation.
     *
     * @param str input character string (SMILES title field)
     * @param state output CXSMILES state
     * @return position where CXSMILES ends (below 0 means no CXSMILES)
     */","('processCx', {'INSTRUCTION': {'covered': 206, 'missed': 48}, 'BRANCH': {'covered': 66, 'missed': 26}, 'LINE': {'covered': 49, 'missed': 24}, 'COMPLEXITY': {'covered': 28, 'missed': 26}, 'METHOD': {'covered': 1, 'missed': 0}})",708.0,  Parse an string possibly containing CXSMILES into an intermediate state  ({@link CxSmilesState}) representation.,19.0,"['Parse a string into a representation of an intermediate state.', 'Parse a string into an intermediate state representation.', 'Parse a string into an intermediate state.']"
1102,cdk,org/openscience/cdk/similarity/DistanceMoment.java,/descriptor/fingerprint/src/main/java/org/openscience/cdk/similarity/DistanceMoment.java,generateMoments,81-199,"/**
     * Evaluate the 12 descriptors used to characterize the 3D shape of a molecule.
     *
     * @param atomContainer The molecule to consider, should have 3D coordinates
     * @return A 12 element array containing the descriptors.
     * @throws CDKException if there are no 3D coordinates
     */
public static float[] generateMoments(IAtomContainer atomContainer) throws CDKException{
    // lets check if we have 3D coordinates
    Iterator<IAtom> atoms;
    int natom = atomContainer.getAtomCount();
    Point3d ctd = getGeometricCenter(atomContainer);
    Point3d cst = new Point3d();
    Point3d fct = new Point3d();
    Point3d ftf = new Point3d();
    double[] distCtd = new double[natom];
    double[] distCst = new double[natom];
    double[] distFct = new double[natom];
    double[] distFtf = new double[natom];
    atoms = atomContainer.atoms().iterator();
    int counter = 0;
    double min = Double.MAX_VALUE;
    double max = Double.MIN_VALUE;
    // eval dist to centroid
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        Point3d p = atom.getPoint3d();
        double d = p.distance(ctd);
        distCtd[counter++] = d;
        if (d < min) {
            cst.x = p.x;
            cst.y = p.y;
            cst.z = p.z;
            min = d;
        }
        if (d > max) {
            fct.x = p.x;
            fct.y = p.y;
            fct.z = p.z;
            max = d;
        }
    }
    // eval dist to cst
    atoms = atomContainer.atoms().iterator();
    counter = 0;
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        Point3d p = atom.getPoint3d();
        double d = p.distance(cst);
        distCst[counter++] = d;
    }
    // eval dist to fct
    atoms = atomContainer.atoms().iterator();
    counter = 0;
    max = Double.MIN_VALUE;
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        Point3d p = atom.getPoint3d();
        double d = p.distance(fct);
        distFct[counter++] = d;
        if (d > max) {
            ftf.x = p.x;
            ftf.y = p.y;
            ftf.z = p.z;
            max = d;
        }
    }
    // eval dist to ftf
    atoms = atomContainer.atoms().iterator();
    counter = 0;
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        Point3d p = atom.getPoint3d();
        double d = p.distance(ftf);
        distFtf[counter++] = d;
    }
    float[] moments = new float[12];
    float mean = mu1(distCtd);
    float sigma2 = mu2(distCtd, mean);
    float skewness = mu3(distCtd, mean, Math.sqrt(sigma2));
    moments[0] = mean;
    moments[1] = sigma2;
    moments[2] = skewness;
    mean = mu1(distCst);
    sigma2 = mu2(distCst, mean);
    skewness = mu3(distCst, mean, Math.sqrt(sigma2));
    moments[3] = mean;
    moments[4] = sigma2;
    moments[5] = skewness;
    mean = mu1(distFct);
    sigma2 = mu2(distFct, mean);
    skewness = mu3(distFct, mean, Math.sqrt(sigma2));
    moments[6] = mean;
    moments[7] = sigma2;
    moments[8] = skewness;
    mean = mu1(distFtf);
    sigma2 = mu2(distFtf, mean);
    skewness = mu3(distFtf, mean, Math.sqrt(sigma2));
    moments[9] = mean;
    moments[10] = sigma2;
    moments[11] = skewness;
    return moments;
}","public static float[] generateMoments(IAtomContainer atomContainer) throws CDKException{
    // lets check if we have 3D coordinates
    Iterator<IAtom> atoms;
    int natom = atomContainer.getAtomCount();
    Point3d ctd = getGeometricCenter(atomContainer);
    Point3d cst = new Point3d();
    Point3d fct = new Point3d();
    Point3d ftf = new Point3d();
    double[] distCtd = new double[natom];
    double[] distCst = new double[natom];
    double[] distFct = new double[natom];
    double[] distFtf = new double[natom];
    atoms = atomContainer.atoms().iterator();
    int counter = 0;
    double min = Double.MAX_VALUE;
    double max = Double.MIN_VALUE;
    // eval dist to centroid
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        Point3d p = atom.getPoint3d();
        double d = p.distance(ctd);
        distCtd[counter++] = d;
        if (d < min) {
            cst.x = p.x;
            cst.y = p.y;
            cst.z = p.z;
            min = d;
        }
        if (d > max) {
            fct.x = p.x;
            fct.y = p.y;
            fct.z = p.z;
            max = d;
        }
    }
    // eval dist to cst
    atoms = atomContainer.atoms().iterator();
    counter = 0;
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        Point3d p = atom.getPoint3d();
        double d = p.distance(cst);
        distCst[counter++] = d;
    }
    // eval dist to fct
    atoms = atomContainer.atoms().iterator();
    counter = 0;
    max = Double.MIN_VALUE;
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        Point3d p = atom.getPoint3d();
        double d = p.distance(fct);
        distFct[counter++] = d;
        if (d > max) {
            ftf.x = p.x;
            ftf.y = p.y;
            ftf.z = p.z;
            max = d;
        }
    }
    // eval dist to ftf
    atoms = atomContainer.atoms().iterator();
    counter = 0;
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        Point3d p = atom.getPoint3d();
        double d = p.distance(ftf);
        distFtf[counter++] = d;
    }
    float[] moments = new float[12];
    float mean = mu1(distCtd);
    float sigma2 = mu2(distCtd, mean);
    float skewness = mu3(distCtd, mean, Math.sqrt(sigma2));
    moments[0] = mean;
    moments[1] = sigma2;
    moments[2] = skewness;
    mean = mu1(distCst);
    sigma2 = mu2(distCst, mean);
    skewness = mu3(distCst, mean, Math.sqrt(sigma2));
    moments[3] = mean;
    moments[4] = sigma2;
    moments[5] = skewness;
    mean = mu1(distFct);
    sigma2 = mu2(distFct, mean);
    skewness = mu3(distFct, mean, Math.sqrt(sigma2));
    moments[6] = mean;
    moments[7] = sigma2;
    moments[8] = skewness;
    mean = mu1(distFtf);
    sigma2 = mu2(distFtf, mean);
    skewness = mu3(distFtf, mean, Math.sqrt(sigma2));
    moments[9] = mean;
    moments[10] = sigma2;
    moments[11] = skewness;
    return moments;
}","/**
     * Evaluate the 12 descriptors used to characterize the 3D shape of a molecule.
     *
     * @param atomContainer The molecule to consider, should have 3D coordinates
     * @return A 12 element array containing the descriptors.
     * @throws CDKException if there are no 3D coordinates
     */","('generateMoments', {'INSTRUCTION': {'covered': 311, 'missed': 0}, 'BRANCH': {'covered': 14, 'missed': 0}, 'LINE': {'covered': 85, 'missed': 0}, 'COMPLEXITY': {'covered': 8, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",711.0,Evaluate the 12 descriptors used to characterize the 3D shape of a molecule.,14.0,"['Evaluate the shape of the molecule using the 12 descriptors.', 'Evaluate the shape of a molecule using 12 descriptors.', 'Evaluate the shape of the molecule using 12 descriptors.']"
1103,cdk,org/openscience/cdk/qsar/descriptors/bond/BondPartialTChargeDescriptor.java,/descriptor/qsarbond/src/main/java/org/openscience/cdk/qsar/descriptors/bond/BondPartialTChargeDescriptor.java,calculate,152-230,"/**
     *  The method calculates the bond total Partial charge of a given bond
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *
     *@param  ac                AtomContainer
     *@return return the sigma electronegativity
     */
public DescriptorValue calculate(IBond bond, IAtomContainer ac){
    Double originalCharge1 = bond.getBegin().getCharge();
    String originalAtomtypeName1 = bond.getBegin().getAtomTypeName();
    Integer originalNeighborCount1 = bond.getBegin().getFormalNeighbourCount();
    IAtomType.Hybridization originalHybridization1 = bond.getBegin().getHybridization();
    Integer originalValency1 = bond.getBegin().getValency();
    Double originalCharge2 = bond.getEnd().getCharge();
    String originalAtomtypeName2 = bond.getEnd().getAtomTypeName();
    Integer originalNeighborCount2 = bond.getEnd().getFormalNeighbourCount();
    IAtomType.Hybridization originalHybridization2 = bond.getEnd().getHybridization();
    Integer originalValency2 = bond.getEnd().getValency();
    Double originalBondOrderSum1 = bond.getBegin().getBondOrderSum();
    Order originalMaxBondOrder1 = bond.getBegin().getMaxBondOrder();
    Double originalBondOrderSum2 = bond.getEnd().getBondOrderSum();
    Order originalMaxBondOrder2 = bond.getEnd().getMaxBondOrder();
    if (!isCachedAtomContainer(ac)) {
        try {
            AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(ac);
            if (lpeChecker) {
                LonePairElectronChecker lpcheck = new LonePairElectronChecker();
                lpcheck.saturate(ac);
            }
        } catch (CDKException e) {
            return getDummyDescriptorValue(e);
        }
        if (maxIterations != -1)
            peoe.setMaxGasteigerIters(maxIterations);
        if (maxIterations != -1)
            pepe.setMaxGasteigerIters(maxIterations);
        if (maxResonStruc != -1)
            pepe.setMaxResoStruc(maxResonStruc);
        try {
            peoe.assignGasteigerMarsiliSigmaPartialCharges(ac, true);
            List<Double> peoeBond = new ArrayList<Double>();
            for (Iterator<IBond> it = ac.bonds().iterator(); it.hasNext(); ) {
                IBond bondi = it.next();
                double result = Math.abs(bondi.getBegin().getCharge() - bondi.getEnd().getCharge());
                peoeBond.add(result);
            }
            for (Iterator<IAtom> it = ac.atoms().iterator(); it.hasNext(); ) it.next().setCharge(0.0);
            pepe.assignGasteigerPiPartialCharges(ac, true);
            for (int i = 0; i < ac.getBondCount(); i++) {
                IBond bondi = ac.getBond(i);
                double result = Math.abs(bondi.getBegin().getCharge() - bondi.getEnd().getCharge());
                cacheDescriptorValue(bondi, ac, new DoubleResult(peoeBond.get(i) + result));
            }
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }
    bond.getBegin().setCharge(originalCharge1);
    bond.getBegin().setAtomTypeName(originalAtomtypeName1);
    bond.getBegin().setHybridization(originalHybridization1);
    bond.getBegin().setValency(originalValency1);
    bond.getBegin().setFormalNeighbourCount(originalNeighborCount1);
    bond.getEnd().setCharge(originalCharge2);
    bond.getEnd().setAtomTypeName(originalAtomtypeName2);
    bond.getEnd().setHybridization(originalHybridization2);
    bond.getEnd().setValency(originalValency2);
    bond.getEnd().setFormalNeighbourCount(originalNeighborCount2);
    bond.getBegin().setMaxBondOrder(originalMaxBondOrder1);
    bond.getBegin().setBondOrderSum(originalBondOrderSum1);
    bond.getEnd().setMaxBondOrder(originalMaxBondOrder2);
    bond.getEnd().setBondOrderSum(originalBondOrderSum2);
    return getCachedDescriptorValue(bond) != null ? new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), getCachedDescriptorValue(bond), NAMES) : null;
}","public DescriptorValue calculate(IBond bond, IAtomContainer ac){
    Double originalCharge1 = bond.getBegin().getCharge();
    String originalAtomtypeName1 = bond.getBegin().getAtomTypeName();
    Integer originalNeighborCount1 = bond.getBegin().getFormalNeighbourCount();
    IAtomType.Hybridization originalHybridization1 = bond.getBegin().getHybridization();
    Integer originalValency1 = bond.getBegin().getValency();
    Double originalCharge2 = bond.getEnd().getCharge();
    String originalAtomtypeName2 = bond.getEnd().getAtomTypeName();
    Integer originalNeighborCount2 = bond.getEnd().getFormalNeighbourCount();
    IAtomType.Hybridization originalHybridization2 = bond.getEnd().getHybridization();
    Integer originalValency2 = bond.getEnd().getValency();
    Double originalBondOrderSum1 = bond.getBegin().getBondOrderSum();
    Order originalMaxBondOrder1 = bond.getBegin().getMaxBondOrder();
    Double originalBondOrderSum2 = bond.getEnd().getBondOrderSum();
    Order originalMaxBondOrder2 = bond.getEnd().getMaxBondOrder();
    if (!isCachedAtomContainer(ac)) {
        try {
            AtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(ac);
            if (lpeChecker) {
                LonePairElectronChecker lpcheck = new LonePairElectronChecker();
                lpcheck.saturate(ac);
            }
        } catch (CDKException e) {
            return getDummyDescriptorValue(e);
        }
        if (maxIterations != -1)
            peoe.setMaxGasteigerIters(maxIterations);
        if (maxIterations != -1)
            pepe.setMaxGasteigerIters(maxIterations);
        if (maxResonStruc != -1)
            pepe.setMaxResoStruc(maxResonStruc);
        try {
            peoe.assignGasteigerMarsiliSigmaPartialCharges(ac, true);
            List<Double> peoeBond = new ArrayList<Double>();
            for (Iterator<IBond> it = ac.bonds().iterator(); it.hasNext(); ) {
                IBond bondi = it.next();
                double result = Math.abs(bondi.getBegin().getCharge() - bondi.getEnd().getCharge());
                peoeBond.add(result);
            }
            for (Iterator<IAtom> it = ac.atoms().iterator(); it.hasNext(); ) it.next().setCharge(0.0);
            pepe.assignGasteigerPiPartialCharges(ac, true);
            for (int i = 0; i < ac.getBondCount(); i++) {
                IBond bondi = ac.getBond(i);
                double result = Math.abs(bondi.getBegin().getCharge() - bondi.getEnd().getCharge());
                cacheDescriptorValue(bondi, ac, new DoubleResult(peoeBond.get(i) + result));
            }
        } catch (Exception e) {
            return getDummyDescriptorValue(e);
        }
    }
    bond.getBegin().setCharge(originalCharge1);
    bond.getBegin().setAtomTypeName(originalAtomtypeName1);
    bond.getBegin().setHybridization(originalHybridization1);
    bond.getBegin().setValency(originalValency1);
    bond.getBegin().setFormalNeighbourCount(originalNeighborCount1);
    bond.getEnd().setCharge(originalCharge2);
    bond.getEnd().setAtomTypeName(originalAtomtypeName2);
    bond.getEnd().setHybridization(originalHybridization2);
    bond.getEnd().setValency(originalValency2);
    bond.getEnd().setFormalNeighbourCount(originalNeighborCount2);
    bond.getBegin().setMaxBondOrder(originalMaxBondOrder1);
    bond.getBegin().setBondOrderSum(originalBondOrderSum1);
    bond.getEnd().setMaxBondOrder(originalMaxBondOrder2);
    bond.getEnd().setBondOrderSum(originalBondOrderSum2);
    return getCachedDescriptorValue(bond) != null ? new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), getCachedDescriptorValue(bond), NAMES) : null;
}","/**
     *  The method calculates the bond total Partial charge of a given bond
     *  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.HydrogenAdder.
     *
     *@param  ac                AtomContainer
     *@return return the sigma electronegativity
     */","('calculate', {'INSTRUCTION': {'covered': 256, 'missed': 27}, 'BRANCH': {'covered': 13, 'missed': 5}, 'LINE': {'covered': 54, 'missed': 4}, 'COMPLEXITY': {'covered': 5, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",714.0,  The method calculates the bond total Partial charge of a given bond  It is needed to call the addExplicitHydrogensToSatisfyValency method from the class tools.,25.0,"['The addExplicitHydrogensToSatisfyValency method needs to be called from the class tools.', 'The addExplicitHydrogensToSatisfyValency method from the class tools is needed to calculate the bond total partial charge.', 'The addExplicitHydrogensToSatisfyValency method from the class tools is needed to call the method.']"
1104,cdk,org/openscience/cdk/io/MDLRXNV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLRXNV2000Reader.java,readReaction,186-305,"/**
     * Read a Reaction from a file in MDL RXN format
     *
     * @return  The Reaction that was read from the MDL file.
     */
private IReaction readReaction(IChemObjectBuilder builder) throws CDKException{
    IReaction reaction = builder.newInstance(IReaction.class);
    try {
        input.readLine();
        input.readLine();
        input.readLine();
        input.readLine();
    } catch (IOException exception) {
        logger.debug(exception);
        throw new CDKException(""Error while reading header of RXN file"", exception);
    }
    int numReactans = 0;
    int numProducts = 0;
    int agentCount = 0;
    try {
        String countsLine = input.readLine();
        StringTokenizer tokenizer = new StringTokenizer(countsLine);
        numReactans = Integer.valueOf(tokenizer.nextToken());
        logger.info(""Expecting "" + numReactans + "" reactants in file"");
        numProducts = Integer.valueOf(tokenizer.nextToken());
        if (tokenizer.hasMoreTokens()) {
            agentCount = Integer.valueOf(tokenizer.nextToken());
            if (mode == Mode.STRICT && agentCount > 0)
                throw new CDKException(""RXN files uses agent count extension"");
        }
        logger.info(""Expecting "" + numProducts + "" products in file"");
    } catch (IOException | NumberFormatException exception) {
        logger.debug(exception);
        throw new CDKException(""Error while counts line of RXN file"", exception);
    }
    try {
        String line = input.readLine();
        if (line == null || !line.startsWith(""$MOL"")) {
            throw new CDKException(""Expected $MOL to start, was"" + line);
        }
        List<IAtomContainer> components = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        while ((line = input.readLine()) != null) {
            if (line.startsWith(""$MOL"")) {
                processMol(builder.newAtomContainer(), components, sb);
                sb.setLength(0);
            } else {
                sb.append(line).append('\n');
            }
        }
        if (sb.length() > 0)
            processMol(builder.newAtomContainer(), components, sb);
        for (IAtomContainer component : components.subList(0, numReactans)) {
            reaction.addReactant(component);
        }
        for (IAtomContainer component : components.subList(numReactans, numReactans + numProducts)) {
            reaction.addProduct(component);
        }
        for (IAtomContainer component : components.subList(numReactans + numProducts, components.size())) {
            reaction.addAgent(component);
        }
    } catch (CDKException exception) {
        throw exception;
    } catch (IOException | IllegalArgumentException exception) {
        logger.debug(exception);
        throw new CDKException(""Error while reading reactant"", exception);
    }
    logger.info(""Reading atom-atom mapping from file"");
    IAtomContainer reactingSide = builder.newInstance(IAtomContainer.class);
    Iterator<IAtomContainer> molecules = reaction.getReactants().atomContainers().iterator();
    while (molecules.hasNext()) {
        reactingSide.add(molecules.next());
    }
    IAtomContainer producedSide = builder.newInstance(IAtomContainer.class);
    molecules = reaction.getProducts().atomContainers().iterator();
    while (molecules.hasNext()) {
        producedSide.add(molecules.next());
    }
    int mappingCount = 0;
    for (int i = 0; i < reactingSide.getAtomCount(); i++) {
        for (int j = 0; j < producedSide.getAtomCount(); j++) {
            IAtom eductAtom = reactingSide.getAtom(i);
            IAtom productAtom = producedSide.getAtom(j);
            if (eductAtom.getProperty(CDKConstants.ATOM_ATOM_MAPPING) != null && eductAtom.getProperty(CDKConstants.ATOM_ATOM_MAPPING).equals(productAtom.getProperty(CDKConstants.ATOM_ATOM_MAPPING))) {
                reaction.addMapping(builder.newInstance(IMapping.class, eductAtom, productAtom));
                mappingCount++;
                break;
            }
        }
    }
    logger.info(""Mapped atom pairs: "" + mappingCount);
    return reaction;
}","private IReaction readReaction(IChemObjectBuilder builder) throws CDKException{
    IReaction reaction = builder.newInstance(IReaction.class);
    try {
        input.readLine();
        input.readLine();
        input.readLine();
        input.readLine();
    } catch (IOException exception) {
        logger.debug(exception);
        throw new CDKException(""Error while reading header of RXN file"", exception);
    }
    int numReactans = 0;
    int numProducts = 0;
    int agentCount = 0;
    try {
        String countsLine = input.readLine();
        StringTokenizer tokenizer = new StringTokenizer(countsLine);
        numReactans = Integer.valueOf(tokenizer.nextToken());
        logger.info(""Expecting "" + numReactans + "" reactants in file"");
        numProducts = Integer.valueOf(tokenizer.nextToken());
        if (tokenizer.hasMoreTokens()) {
            agentCount = Integer.valueOf(tokenizer.nextToken());
            if (mode == Mode.STRICT && agentCount > 0)
                throw new CDKException(""RXN files uses agent count extension"");
        }
        logger.info(""Expecting "" + numProducts + "" products in file"");
    } catch (IOException | NumberFormatException exception) {
        logger.debug(exception);
        throw new CDKException(""Error while counts line of RXN file"", exception);
    }
    try {
        String line = input.readLine();
        if (line == null || !line.startsWith(""$MOL"")) {
            throw new CDKException(""Expected $MOL to start, was"" + line);
        }
        List<IAtomContainer> components = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        while ((line = input.readLine()) != null) {
            if (line.startsWith(""$MOL"")) {
                processMol(builder.newAtomContainer(), components, sb);
                sb.setLength(0);
            } else {
                sb.append(line).append('\n');
            }
        }
        if (sb.length() > 0)
            processMol(builder.newAtomContainer(), components, sb);
        for (IAtomContainer component : components.subList(0, numReactans)) {
            reaction.addReactant(component);
        }
        for (IAtomContainer component : components.subList(numReactans, numReactans + numProducts)) {
            reaction.addProduct(component);
        }
        for (IAtomContainer component : components.subList(numReactans + numProducts, components.size())) {
            reaction.addAgent(component);
        }
    } catch (CDKException exception) {
        throw exception;
    } catch (IOException | IllegalArgumentException exception) {
        logger.debug(exception);
        throw new CDKException(""Error while reading reactant"", exception);
    }
    logger.info(""Reading atom-atom mapping from file"");
    IAtomContainer reactingSide = builder.newInstance(IAtomContainer.class);
    Iterator<IAtomContainer> molecules = reaction.getReactants().atomContainers().iterator();
    while (molecules.hasNext()) {
        reactingSide.add(molecules.next());
    }
    IAtomContainer producedSide = builder.newInstance(IAtomContainer.class);
    molecules = reaction.getProducts().atomContainers().iterator();
    while (molecules.hasNext()) {
        producedSide.add(molecules.next());
    }
    int mappingCount = 0;
    for (int i = 0; i < reactingSide.getAtomCount(); i++) {
        for (int j = 0; j < producedSide.getAtomCount(); j++) {
            IAtom eductAtom = reactingSide.getAtom(i);
            IAtom productAtom = producedSide.getAtom(j);
            if (eductAtom.getProperty(CDKConstants.ATOM_ATOM_MAPPING) != null && eductAtom.getProperty(CDKConstants.ATOM_ATOM_MAPPING).equals(productAtom.getProperty(CDKConstants.ATOM_ATOM_MAPPING))) {
                reaction.addMapping(builder.newInstance(IMapping.class, eductAtom, productAtom));
                mappingCount++;
                break;
            }
        }
    }
    logger.info(""Mapped atom pairs: "" + mappingCount);
    return reaction;
}","/**
     * Read a Reaction from a file in MDL RXN format
     *
     * @return  The Reaction that was read from the MDL file.
     */","('readReaction', {'INSTRUCTION': {'covered': 310, 'missed': 52}, 'BRANCH': {'covered': 28, 'missed': 6}, 'LINE': {'covered': 63, 'missed': 13}, 'COMPLEXITY': {'covered': 13, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",724.0,  Read a Reaction from a file in MDL RXN format   @return The Reaction that was read from the MDL file.,22.0,"['Return the Reaction that was read from the MDL file.', 'The Reaction that was read from the MDL file should be returned.', 'The Reaction that was read from the MDL file is called a Reaction.']"
1105,cdk,org/openscience/cdk/io/PDBWriter.java,/storage/pdb/src/main/java/org/openscience/cdk/io/PDBWriter.java,writeMolecule,173-281,"/**
     * Writes a single frame in PDB format to the Writer.
     *
     * @param molecule the Molecule to write
     */
public void writeMolecule(IAtomContainer molecule) throws CDKException{
    try {
        writeHeader();
        int atomNumber = 1;
        String hetatmRecordName = (writeAsHET.isSet()) ? ""HETATM"" : ""ATOM  "";
        String id = molecule.getID();
        String residueName = (id == null || id.equals("""")) ? ""MOL"" : id;
        String terRecordName = ""TER"";
        // Loop through the atoms and write them out:
        StringBuffer buffer = new StringBuffer();
        Iterator<IAtom> atoms = molecule.atoms().iterator();
        FormatStringBuffer fsb = new FormatStringBuffer("""");
        String[] connectRecords = null;
        if (writeCONECTRecords.isSet()) {
            connectRecords = new String[molecule.getAtomCount()];
        }
        while (atoms.hasNext()) {
            buffer.setLength(0);
            buffer.append(hetatmRecordName);
            fsb.reset(SERIAL_FORMAT).format(atomNumber);
            buffer.append(fsb.toString());
            buffer.append(' ');
            IAtom atom = atoms.next();
            String name;
            if (useElementSymbolAsAtomName.isSet()) {
                name = atom.getSymbol();
            } else {
                if (atom.getID() == null || atom.getID().equals("""")) {
                    name = atom.getSymbol();
                } else {
                    name = atom.getID();
                }
            }
            fsb.reset(ATOM_NAME_FORMAT).format(name);
            buffer.append(fsb.toString());
            fsb.reset(RESIDUE_FORMAT).format(residueName);
            buffer.append(fsb).append(""     0    "");
            Point3d position = atom.getPoint3d();
            fsb.reset(POSITION_FORMAT).format(position.x);
            buffer.append(fsb.toString());
            fsb.reset(POSITION_FORMAT).format(position.y);
            buffer.append(fsb.toString());
            fsb.reset(POSITION_FORMAT).format(position.z);
            buffer.append(fsb.toString());
            // occupancy + temperature factor
            buffer.append(""  1.00  0.00           "").append(atom.getSymbol());
            Integer formalCharge = atom.getFormalCharge();
            if (formalCharge == CDKConstants.UNSET) {
                buffer.append(""+0"");
            } else {
                if (formalCharge < 0) {
                    buffer.append(formalCharge);
                } else {
                    buffer.append('+').append(formalCharge);
                }
            }
            if (connectRecords != null && writeCONECTRecords.isSet()) {
                List<IAtom> neighbours = molecule.getConnectedAtomsList(atom);
                if (neighbours.size() != 0) {
                    StringBuffer connectBuffer = new StringBuffer(""CONECT"");
                    connectBuffer.append(String.format(""%5d"", atomNumber));
                    for (IAtom neighbour : neighbours) {
                        int neighbourNumber = molecule.indexOf(neighbour) + 1;
                        connectBuffer.append(String.format(""%5d"", neighbourNumber));
                    }
                    connectRecords[atomNumber - 1] = connectBuffer.toString();
                } else {
                    connectRecords[atomNumber - 1] = null;
                }
            }
            writer.write(buffer.toString(), 0, buffer.length());
            writer.write('\n');
            ++atomNumber;
        }
        if (writeTERRecord.isSet()) {
            writer.write(terRecordName, 0, terRecordName.length());
            writer.write('\n');
        }
        if (connectRecords != null && writeCONECTRecords.isSet()) {
            for (String connectRecord : connectRecords) {
                if (connectRecord != null) {
                    writer.write(connectRecord);
                    writer.write('\n');
                }
            }
        }
        if (writeENDRecord.isSet()) {
            writer.write(""END   "");
            writer.write('\n');
        }
    } catch (IOException exception) {
        throw new CDKException(""Error while writing file: "" + exception.getMessage(), exception);
    }
}","public void writeMolecule(IAtomContainer molecule) throws CDKException{
    try {
        writeHeader();
        int atomNumber = 1;
        String hetatmRecordName = (writeAsHET.isSet()) ? ""HETATM"" : ""ATOM  "";
        String id = molecule.getID();
        String residueName = (id == null || id.equals("""")) ? ""MOL"" : id;
        String terRecordName = ""TER"";
        // Loop through the atoms and write them out:
        StringBuffer buffer = new StringBuffer();
        Iterator<IAtom> atoms = molecule.atoms().iterator();
        FormatStringBuffer fsb = new FormatStringBuffer("""");
        String[] connectRecords = null;
        if (writeCONECTRecords.isSet()) {
            connectRecords = new String[molecule.getAtomCount()];
        }
        while (atoms.hasNext()) {
            buffer.setLength(0);
            buffer.append(hetatmRecordName);
            fsb.reset(SERIAL_FORMAT).format(atomNumber);
            buffer.append(fsb.toString());
            buffer.append(' ');
            IAtom atom = atoms.next();
            String name;
            if (useElementSymbolAsAtomName.isSet()) {
                name = atom.getSymbol();
            } else {
                if (atom.getID() == null || atom.getID().equals("""")) {
                    name = atom.getSymbol();
                } else {
                    name = atom.getID();
                }
            }
            fsb.reset(ATOM_NAME_FORMAT).format(name);
            buffer.append(fsb.toString());
            fsb.reset(RESIDUE_FORMAT).format(residueName);
            buffer.append(fsb).append(""     0    "");
            Point3d position = atom.getPoint3d();
            fsb.reset(POSITION_FORMAT).format(position.x);
            buffer.append(fsb.toString());
            fsb.reset(POSITION_FORMAT).format(position.y);
            buffer.append(fsb.toString());
            fsb.reset(POSITION_FORMAT).format(position.z);
            buffer.append(fsb.toString());
            // occupancy + temperature factor
            buffer.append(""  1.00  0.00           "").append(atom.getSymbol());
            Integer formalCharge = atom.getFormalCharge();
            if (formalCharge == CDKConstants.UNSET) {
                buffer.append(""+0"");
            } else {
                if (formalCharge < 0) {
                    buffer.append(formalCharge);
                } else {
                    buffer.append('+').append(formalCharge);
                }
            }
            if (connectRecords != null && writeCONECTRecords.isSet()) {
                List<IAtom> neighbours = molecule.getConnectedAtomsList(atom);
                if (neighbours.size() != 0) {
                    StringBuffer connectBuffer = new StringBuffer(""CONECT"");
                    connectBuffer.append(String.format(""%5d"", atomNumber));
                    for (IAtom neighbour : neighbours) {
                        int neighbourNumber = molecule.indexOf(neighbour) + 1;
                        connectBuffer.append(String.format(""%5d"", neighbourNumber));
                    }
                    connectRecords[atomNumber - 1] = connectBuffer.toString();
                } else {
                    connectRecords[atomNumber - 1] = null;
                }
            }
            writer.write(buffer.toString(), 0, buffer.length());
            writer.write('\n');
            ++atomNumber;
        }
        if (writeTERRecord.isSet()) {
            writer.write(terRecordName, 0, terRecordName.length());
            writer.write('\n');
        }
        if (connectRecords != null && writeCONECTRecords.isSet()) {
            for (String connectRecord : connectRecords) {
                if (connectRecord != null) {
                    writer.write(connectRecord);
                    writer.write('\n');
                }
            }
        }
        if (writeENDRecord.isSet()) {
            writer.write(""END   "");
            writer.write('\n');
        }
    } catch (IOException exception) {
        throw new CDKException(""Error while writing file: "" + exception.getMessage(), exception);
    }
}","/**
     * Writes a single frame in PDB format to the Writer.
     *
     * @param molecule the Molecule to write
     */","('writeMolecule', {'INSTRUCTION': {'covered': 311, 'missed': 48}, 'BRANCH': {'covered': 27, 'missed': 13}, 'LINE': {'covered': 66, 'missed': 8}, 'COMPLEXITY': {'covered': 9, 'missed': 12}, 'METHOD': {'covered': 1, 'missed': 0}})",743.0,  Writes a single frame in PDB format to the Writer.,11.0,"['A single frame is written in PDB format.', 'A single frame is written in the PDB format.', 'A single frame is written to the writer.']"
1106,cdk,org/openscience/cdk/graph/invariant/InChINumbersTools.java,/storage/inchi/src/main/java/org/openscience/cdk/graph/invariant/InChINumbersTools.java,parseUSmilesNumbers,86-191,"/**
     * Parse the InChI canonical atom numbers (from the AuxInfo) to use in
     * Universal SMILES.
     *
     * The parsing follows: ""Rule A: The correspondence between the input atom
     * order and the InChI canonical labels should be obtained from the
     * reconnected metal layer (/R:) in preference to the initial layer, and
     * then from the fixed hydrogen labels (/F:) in preference to the standard
     * labels (/N:)."" 
     *
     * The labels are also adjust for ""Rule E: If the start atom is a negatively
     * charged oxygen atom, start instead at any carbonyl oxygen attached to the
     * same neighbour."" 
     *
     * All unlabelled atoms (e.g. hydrogens) are assigned the same label which
     * is different but larger then all other labels. The hydrogen
     * labelling then needs to be adjusted externally as universal SMILES
     * suggests hydrogens should be visited first.
     *
     * @param aux       inchi AuxInfo
     * @param container the structure to obtain the numbering of
     * @return the numbers string to use
     */
 static long[] parseUSmilesNumbers(String aux, IAtomContainer container){
    int index;
    long[] numbers = new long[container.getAtomCount()];
    int[] first = null;
    int label = 1;
    if ((index = aux.indexOf(""/R:"")) >= 0) {
        int endIndex = aux.indexOf('/', index + 8);
        if (endIndex < 0)
            endIndex = aux.length();
        String[] baseNumbers = aux.substring(index + 8, endIndex).split("";"");
        first = new int[baseNumbers.length];
        Arrays.fill(first, -1);
        for (int i = 0; i < baseNumbers.length; i++) {
            String[] numbering = baseNumbers[i].split("","");
            first[i] = Integer.parseInt(numbering[0]) - 1;
            for (String number : numbering) {
                numbers[Integer.parseInt(number) - 1] = label++;
            }
        }
    } else if ((index = aux.indexOf(""/N:"")) >= 0) {
        String[] baseNumbers = aux.substring(index + 3, aux.indexOf('/', index + 3)).split("";"");
        first = new int[baseNumbers.length];
        Arrays.fill(first, -1);
        if ((index = aux.indexOf(""/F:"")) >= 0) {
            String[] fixedHNumbers = aux.substring(index + 3, aux.indexOf('/', index + 3)).split("";"");
            for (int i = 0; i < fixedHNumbers.length; i++) {
                String component = fixedHNumbers[i];
                if (component.charAt(component.length() - 1) == 'm') {
                    int n = component.length() > 1 ? Integer.parseInt(component.substring(0, component.length() - 1)) : 1;
                    for (int j = 0; j < n; j++) {
                        String[] numbering = baseNumbers[i + j].split("","");
                        first[i + j] = Integer.parseInt(numbering[0]) - 1;
                        for (String number : numbering) numbers[Integer.parseInt(number) - 1] = label++;
                    }
                } else {
                    String[] numbering = component.split("","");
                    for (String number : numbering) numbers[Integer.parseInt(number) - 1] = label++;
                }
            }
        } else {
            for (int i = 0; i < baseNumbers.length; i++) {
                String[] numbering = baseNumbers[i].split("","");
                first[i] = Integer.parseInt(numbering[0]) - 1;
                for (String number : numbering) numbers[Integer.parseInt(number) - 1] = label++;
            }
        }
    } else {
        throw new IllegalArgumentException(""AuxInfo did not contain extractable base numbers (/N: or /R:)."");
    }
    for (int v : first) {
        if (v >= 0) {
            IAtom atom = container.getAtom(v);
            if (atom.getFormalCharge() == null)
                continue;
            if (atom.getAtomicNumber() == 8 && atom.getFormalCharge() == -1) {
                List<IAtom> neighbors = container.getConnectedAtomsList(atom);
                if (neighbors.size() == 1) {
                    IAtom correctedStart = findPiBondedOxygen(container, neighbors.get(0));
                    if (correctedStart != null)
                        exch(numbers, v, container.indexOf(correctedStart));
                }
            }
        }
    }
    for (int i = 0; i < numbers.length; i++) if (numbers[i] == 0)
        numbers[i] = label++;
    return numbers;
}","static long[] parseUSmilesNumbers(String aux, IAtomContainer container){
    int index;
    long[] numbers = new long[container.getAtomCount()];
    int[] first = null;
    int label = 1;
    if ((index = aux.indexOf(""/R:"")) >= 0) {
        int endIndex = aux.indexOf('/', index + 8);
        if (endIndex < 0)
            endIndex = aux.length();
        String[] baseNumbers = aux.substring(index + 8, endIndex).split("";"");
        first = new int[baseNumbers.length];
        Arrays.fill(first, -1);
        for (int i = 0; i < baseNumbers.length; i++) {
            String[] numbering = baseNumbers[i].split("","");
            first[i] = Integer.parseInt(numbering[0]) - 1;
            for (String number : numbering) {
                numbers[Integer.parseInt(number) - 1] = label++;
            }
        }
    } else if ((index = aux.indexOf(""/N:"")) >= 0) {
        String[] baseNumbers = aux.substring(index + 3, aux.indexOf('/', index + 3)).split("";"");
        first = new int[baseNumbers.length];
        Arrays.fill(first, -1);
        if ((index = aux.indexOf(""/F:"")) >= 0) {
            String[] fixedHNumbers = aux.substring(index + 3, aux.indexOf('/', index + 3)).split("";"");
            for (int i = 0; i < fixedHNumbers.length; i++) {
                String component = fixedHNumbers[i];
                if (component.charAt(component.length() - 1) == 'm') {
                    int n = component.length() > 1 ? Integer.parseInt(component.substring(0, component.length() - 1)) : 1;
                    for (int j = 0; j < n; j++) {
                        String[] numbering = baseNumbers[i + j].split("","");
                        first[i + j] = Integer.parseInt(numbering[0]) - 1;
                        for (String number : numbering) numbers[Integer.parseInt(number) - 1] = label++;
                    }
                } else {
                    String[] numbering = component.split("","");
                    for (String number : numbering) numbers[Integer.parseInt(number) - 1] = label++;
                }
            }
        } else {
            for (int i = 0; i < baseNumbers.length; i++) {
                String[] numbering = baseNumbers[i].split("","");
                first[i] = Integer.parseInt(numbering[0]) - 1;
                for (String number : numbering) numbers[Integer.parseInt(number) - 1] = label++;
            }
        }
    } else {
        throw new IllegalArgumentException(""AuxInfo did not contain extractable base numbers (/N: or /R:)."");
    }
    for (int v : first) {
        if (v >= 0) {
            IAtom atom = container.getAtom(v);
            if (atom.getFormalCharge() == null)
                continue;
            if (atom.getAtomicNumber() == 8 && atom.getFormalCharge() == -1) {
                List<IAtom> neighbors = container.getConnectedAtomsList(atom);
                if (neighbors.size() == 1) {
                    IAtom correctedStart = findPiBondedOxygen(container, neighbors.get(0));
                    if (correctedStart != null)
                        exch(numbers, v, container.indexOf(correctedStart));
                }
            }
        }
    }
    for (int i = 0; i < numbers.length; i++) if (numbers[i] == 0)
        numbers[i] = label++;
    return numbers;
}","/**
     * Parse the InChI canonical atom numbers (from the AuxInfo) to use in
     * Universal SMILES.
     *
     * The parsing follows: ""Rule A: The correspondence between the input atom
     * order and the InChI canonical labels should be obtained from the
     * reconnected metal layer (/R:) in preference to the initial layer, and
     * then from the fixed hydrogen labels (/F:) in preference to the standard
     * labels (/N:)."" 
     *
     * The labels are also adjust for ""Rule E: If the start atom is a negatively
     * charged oxygen atom, start instead at any carbonyl oxygen attached to the
     * same neighbour."" 
     *
     * All unlabelled atoms (e.g. hydrogens) are assigned the same label which
     * is different but larger then all other labels. The hydrogen
     * labelling then needs to be adjusted externally as universal SMILES
     * suggests hydrogens should be visited first.
     *
     * @param aux       inchi AuxInfo
     * @param container the structure to obtain the numbering of
     * @return the numbers string to use
     */","('parseUSmilesNumbers', {'INSTRUCTION': {'covered': 384, 'missed': 6}, 'BRANCH': {'covered': 41, 'missed': 5}, 'LINE': {'covered': 54, 'missed': 1}, 'COMPLEXITY': {'covered': 19, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",749.0,  Parse the InChI canonical atom numbers (from the AuxInfo) to use in  Universal SMILES.,17.0,"['Universal SMILES can be used with the InChI canonical atom numbers.', 'Universal SMILES can be used toParse the InChI canonical atom numbers.', 'Universal SMILES can be used toParse the In chI canonical atom numbers.']"
1107,dcache,org/dcache/resilience/handlers/FileOperationHandler.java,/modules/dcache-resilience/src/main/java/org/dcache/resilience/handlers/FileOperationHandler.java,handleVerification,668-1064,"/**
     * <p>Called when a pnfsid has been selected from the operation map for
     * possible processing. Refreshes locations from namespace, and checks which of those are
     * currently readable.  Sends an alarm if no operation can occur but should.</p>
     *
     * <p>Note:  because of the possibility of data loss due to a lag between
     * the pools and namespace, the namespace locations are now verified by sending a message to the
     * pool.</p>
     *
     * <p>The following table illustrates the progress of this routine
     * by positing a file with one type of replica location each reported initially by the
     * namespace:</p>
     *
     * <table>
     *   <thead>
     *     <th>
     *         <td style=""text-align: center;"">Cached+Sticky</td>
     *         <td style=""text-align: center;"">Precious+Sticky</td>
     *         <td style=""text-align: center;"">Precious</td>
     *         <td style=""text-align: center;"">Cached</td>
     *         <td style=""text-align: center;"">Broken</td>
     *         <td style=""text-align: center;"">Removed</td>
     *         <td style=""text-align: center;"">OFFLINE</td>
     *         <td style=""text-align: center;"">EXCLUDED</td>
     *     </th>
     *   </thead>
     *   <tbody>
     *     <tr>
     *             <td style=""text-align: left;"">LOCATIONS</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;"">B2</td>
     *             <td style=""text-align: center;"">C</td>
     *             <td style=""text-align: center;"">D</td>
     *             <td style=""text-align: center;"">[E]</td>
     *             <td style=""text-align: center;"">F</td>
     *             <td style=""text-align: center;"">G</td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;"">VERIFIED</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;"">B2</td>
     *             <td style=""text-align: center;"">C</td>
     *             <td style=""text-align: center;"">D</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">G</td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;"">BROKEN</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">D</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;""><i>(remove broken, return)</i></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *     </tr>
     *     <tr/>
     *     <tr>
     *             <td style=""text-align: left;"">LOCATIONS</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;"">B2</td>
     *             <td style=""text-align: center;"">C</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">[E]</td>
     *             <td style=""text-align: center;"">F</td>
     *             <td style=""text-align: center;"">G</td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;"">VERIFIED</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;"">B2</td>
     *             <td style=""text-align: center;"">C</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">G</td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;"">READABLE</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;"">B2</td>
     *             <td style=""text-align: center;"">C</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">[E]</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">G</td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;"">VERIFIED READABLE</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;"">B2</td>
     *             <td style=""text-align: center;"">C</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">G</td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;""><i>(alarm, continue)</i></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *     </tr>
     *     <tr/>
     *     <tr>
     *             <td style=""text-align: left;"">OCCUPIED</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;"">B2</td>
     *             <td style=""text-align: center;"">C</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">F</td>
     *             <td style=""text-align: center;"">G</td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;"">STICKY READABLE</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">G</td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;"">W/O EXCLUDED</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;"">REMOVABLE</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @return COPY, REMOVE, SET_STICKY, WAIT_FOR_STAGE, or VOID if no operation is necessary.
     */
public Type handleVerification(FileAttributes attributes){
    PnfsId pnfsId = attributes.getPnfsId();
    FileOperation operation = fileOpMap.getOperation(pnfsId);
    int gindex = operation.getPoolGroup();
    try {
        namespace.refreshAttributes(attributes);
    } catch (CacheException e) {
        CacheException exception = CacheExceptionUtils.getCacheException(e.getRc(), FileTaskCompletionHandler.VERIFY_FAILURE_MESSAGE, pnfsId, Type.VOID, null, e.getCause());
        completionHandler.taskFailed(pnfsId, exception);
        return Type.VOID;
    }
    Collection<String> locations = attributes.getLocations();
    LOGGER.trace(""handleVerification {}, refreshed access latency {}, "" + ""retention policy {}; "" + ""locations from namespace {}"", pnfsId, attributes.getAccessLatency(), attributes.getRetentionPolicy(), locations);
    if (locations.isEmpty()) {
        LOGGER.trace(""handleVerification {}, no namespace locations found, "" + ""checking to see if file can be staged."", pnfsId);
        if (shouldTryToStage(attributes, operation)) {
            return Type.WAIT_FOR_STAGE;
        }
        return inaccessibleFileHandler.handleNoLocationsForFile(operation);
    }
    Set<String> members = poolInfoMap.getMemberLocations(gindex, locations);
    LOGGER.trace(""handleVerification {}, valid group member locations {}"", pnfsId, members);
    if (members.isEmpty()) {
        fileOpMap.voidOperation(pnfsId);
        return Type.VOID;
    }
    Collection responsesFromPools;
    try {
        responsesFromPools = verifier.verifyLocations(pnfsId, members, pools);
    } catch (InterruptedException e) {
        LOGGER.warn(""handleVerification, replica verification "" + ""for {} was interrupted; "" + ""cancelling operation."", pnfsId);
        completionHandler.taskCancelled(pnfsId);
        return Type.VOID;
    }
    LOGGER.trace(""handleVerification {}, verified replicas: {}"", pnfsId, responsesFromPools);
    Set<String> broken = verifier.getBroken(responsesFromPools);
    if (!broken.isEmpty()) {
        String target = broken.iterator().next();
        if (verifier.isSticky(target, responsesFromPools) && verifier.getSticky(responsesFromPools).size() > 1) {
            fileOpMap.updateOperation(pnfsId, null, target);
            operation.incrementCount();
            return Type.REMOVE;
        }
    }
    Set<String> namespaceReadable = poolInfoMap.getReadableLocations(members);
    Set<String> exist = verifier.exist(namespaceReadable, responsesFromPools);
    LOGGER.trace(""handleVerification, {}, namespace readable locations {},"" + ""verified locations {}"", pnfsId, namespaceReadable, exist);
    if (namespaceReadable.size() != exist.size()) {
        ACTIVITY_LOGGER.info(""The namespace is not in sync with the pool "" + ""repositories for {}: "" + ""namespace locations "" + ""that are readable: {}; "" + ""actually found: {}."", pnfsId, namespaceReadable, exist);
        sendOutOfSyncAlarm();
    }
    if (inaccessibleFileHandler.isInaccessible(exist, operation)) {
        LOGGER.trace(""handleVerification {}, "" + ""no valid readable locations found, "" + ""checking to see if "" + ""file can be staged."", pnfsId);
        if (shouldTryToStage(attributes, operation)) {
            return Type.WAIT_FOR_STAGE;
        }
        return inaccessibleFileHandler.handleInaccessibleFile(operation);
    }
    Set<String> sticky = verifier.areSticky(exist, responsesFromPools);
    if (AccessLatency.NEARLINE.equals(attributes.getAccessLatency())) {
        if (sticky.size() > 0) {
            String target = sticky.iterator().next();
            LOGGER.trace(""handleVerification, {}, access latency is NEARLINE, "" + ""updating operation with first "" + ""sticky target to cache: {}"", pnfsId, target);
            fileOpMap.updateOperation(pnfsId, null, target);
            return Type.REMOVE;
        }
        LOGGER.trace(""handleVerification, {}, access latency is NEARLINE, "" + ""but no sticky replicas:  responses {}"", pnfsId, responsesFromPools);
        completionHandler.taskCompleted(pnfsId);
        return Type.VOID;
    }
    if (shouldEvictALocation(operation, sticky, responsesFromPools)) {
        LOGGER.trace(""handleVerification, a replica should be evicted from {}"", sticky);
        return Type.REMOVE;
    }
    LOGGER.trace(""handleVerification after eviction check, {}, "" + ""valid replicas {}"", pnfsId, sticky);
    Set<String> occupied = Sets.union(exist, Sets.difference(members, namespaceReadable));
    Set<String> nonSticky = Sets.difference(Sets.difference(exist, sticky), broken);
    Set<String> excluded = verifier.areSticky(poolInfoMap.getExcludedLocationNames(members), responsesFromPools);
    sticky = Sets.difference(sticky, excluded);
    LOGGER.trace(""handleVerification {}: member pools with a sticky replica  "" + "" but which have been manually excluded: {}."", pnfsId, excluded);
    return determineTypeFromConstraints(operation, excluded.size(), occupied, sticky, nonSticky, responsesFromPools);
}","public Type handleVerification(FileAttributes attributes){
    PnfsId pnfsId = attributes.getPnfsId();
    FileOperation operation = fileOpMap.getOperation(pnfsId);
    int gindex = operation.getPoolGroup();
    try {
        namespace.refreshAttributes(attributes);
    } catch (CacheException e) {
        CacheException exception = CacheExceptionUtils.getCacheException(e.getRc(), FileTaskCompletionHandler.VERIFY_FAILURE_MESSAGE, pnfsId, Type.VOID, null, e.getCause());
        completionHandler.taskFailed(pnfsId, exception);
        return Type.VOID;
    }
    Collection<String> locations = attributes.getLocations();
    LOGGER.trace(""handleVerification {}, refreshed access latency {}, "" + ""retention policy {}; "" + ""locations from namespace {}"", pnfsId, attributes.getAccessLatency(), attributes.getRetentionPolicy(), locations);
    if (locations.isEmpty()) {
        LOGGER.trace(""handleVerification {}, no namespace locations found, "" + ""checking to see if file can be staged."", pnfsId);
        if (shouldTryToStage(attributes, operation)) {
            return Type.WAIT_FOR_STAGE;
        }
        return inaccessibleFileHandler.handleNoLocationsForFile(operation);
    }
    Set<String> members = poolInfoMap.getMemberLocations(gindex, locations);
    LOGGER.trace(""handleVerification {}, valid group member locations {}"", pnfsId, members);
    if (members.isEmpty()) {
        fileOpMap.voidOperation(pnfsId);
        return Type.VOID;
    }
    Collection responsesFromPools;
    try {
        responsesFromPools = verifier.verifyLocations(pnfsId, members, pools);
    } catch (InterruptedException e) {
        LOGGER.warn(""handleVerification, replica verification "" + ""for {} was interrupted; "" + ""cancelling operation."", pnfsId);
        completionHandler.taskCancelled(pnfsId);
        return Type.VOID;
    }
    LOGGER.trace(""handleVerification {}, verified replicas: {}"", pnfsId, responsesFromPools);
    Set<String> broken = verifier.getBroken(responsesFromPools);
    if (!broken.isEmpty()) {
        String target = broken.iterator().next();
        if (verifier.isSticky(target, responsesFromPools) && verifier.getSticky(responsesFromPools).size() > 1) {
            fileOpMap.updateOperation(pnfsId, null, target);
            operation.incrementCount();
            return Type.REMOVE;
        }
    }
    Set<String> namespaceReadable = poolInfoMap.getReadableLocations(members);
    Set<String> exist = verifier.exist(namespaceReadable, responsesFromPools);
    LOGGER.trace(""handleVerification, {}, namespace readable locations {},"" + ""verified locations {}"", pnfsId, namespaceReadable, exist);
    if (namespaceReadable.size() != exist.size()) {
        ACTIVITY_LOGGER.info(""The namespace is not in sync with the pool "" + ""repositories for {}: "" + ""namespace locations "" + ""that are readable: {}; "" + ""actually found: {}."", pnfsId, namespaceReadable, exist);
        sendOutOfSyncAlarm();
    }
    if (inaccessibleFileHandler.isInaccessible(exist, operation)) {
        LOGGER.trace(""handleVerification {}, "" + ""no valid readable locations found, "" + ""checking to see if "" + ""file can be staged."", pnfsId);
        if (shouldTryToStage(attributes, operation)) {
            return Type.WAIT_FOR_STAGE;
        }
        return inaccessibleFileHandler.handleInaccessibleFile(operation);
    }
    Set<String> sticky = verifier.areSticky(exist, responsesFromPools);
    if (AccessLatency.NEARLINE.equals(attributes.getAccessLatency())) {
        if (sticky.size() > 0) {
            String target = sticky.iterator().next();
            LOGGER.trace(""handleVerification, {}, access latency is NEARLINE, "" + ""updating operation with first "" + ""sticky target to cache: {}"", pnfsId, target);
            fileOpMap.updateOperation(pnfsId, null, target);
            return Type.REMOVE;
        }
        LOGGER.trace(""handleVerification, {}, access latency is NEARLINE, "" + ""but no sticky replicas:  responses {}"", pnfsId, responsesFromPools);
        completionHandler.taskCompleted(pnfsId);
        return Type.VOID;
    }
    if (shouldEvictALocation(operation, sticky, responsesFromPools)) {
        LOGGER.trace(""handleVerification, a replica should be evicted from {}"", sticky);
        return Type.REMOVE;
    }
    LOGGER.trace(""handleVerification after eviction check, {}, "" + ""valid replicas {}"", pnfsId, sticky);
    Set<String> occupied = Sets.union(exist, Sets.difference(members, namespaceReadable));
    Set<String> nonSticky = Sets.difference(Sets.difference(exist, sticky), broken);
    Set<String> excluded = verifier.areSticky(poolInfoMap.getExcludedLocationNames(members), responsesFromPools);
    sticky = Sets.difference(sticky, excluded);
    LOGGER.trace(""handleVerification {}: member pools with a sticky replica  "" + "" but which have been manually excluded: {}."", pnfsId, excluded);
    return determineTypeFromConstraints(operation, excluded.size(), occupied, sticky, nonSticky, responsesFromPools);
}","/**
     * <p>Called when a pnfsid has been selected from the operation map for
     * possible processing. Refreshes locations from namespace, and checks which of those are
     * currently readable.  Sends an alarm if no operation can occur but should.</p>
     *
     * <p>Note:  because of the possibility of data loss due to a lag between
     * the pools and namespace, the namespace locations are now verified by sending a message to the
     * pool.</p>
     *
     * <p>The following table illustrates the progress of this routine
     * by positing a file with one type of replica location each reported initially by the
     * namespace:</p>
     *
     * <table>
     *   <thead>
     *     <th>
     *         <td style=""text-align: center;"">Cached+Sticky</td>
     *         <td style=""text-align: center;"">Precious+Sticky</td>
     *         <td style=""text-align: center;"">Precious</td>
     *         <td style=""text-align: center;"">Cached</td>
     *         <td style=""text-align: center;"">Broken</td>
     *         <td style=""text-align: center;"">Removed</td>
     *         <td style=""text-align: center;"">OFFLINE</td>
     *         <td style=""text-align: center;"">EXCLUDED</td>
     *     </th>
     *   </thead>
     *   <tbody>
     *     <tr>
     *             <td style=""text-align: left;"">LOCATIONS</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;"">B2</td>
     *             <td style=""text-align: center;"">C</td>
     *             <td style=""text-align: center;"">D</td>
     *             <td style=""text-align: center;"">[E]</td>
     *             <td style=""text-align: center;"">F</td>
     *             <td style=""text-align: center;"">G</td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;"">VERIFIED</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;"">B2</td>
     *             <td style=""text-align: center;"">C</td>
     *             <td style=""text-align: center;"">D</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">G</td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;"">BROKEN</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">D</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;""><i>(remove broken, return)</i></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *     </tr>
     *     <tr/>
     *     <tr>
     *             <td style=""text-align: left;"">LOCATIONS</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;"">B2</td>
     *             <td style=""text-align: center;"">C</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">[E]</td>
     *             <td style=""text-align: center;"">F</td>
     *             <td style=""text-align: center;"">G</td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;"">VERIFIED</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;"">B2</td>
     *             <td style=""text-align: center;"">C</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">G</td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;"">READABLE</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;"">B2</td>
     *             <td style=""text-align: center;"">C</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">[E]</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">G</td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;"">VERIFIED READABLE</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;"">B2</td>
     *             <td style=""text-align: center;"">C</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">G</td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;""><i>(alarm, continue)</i></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *     </tr>
     *     <tr/>
     *     <tr>
     *             <td style=""text-align: left;"">OCCUPIED</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;"">B2</td>
     *             <td style=""text-align: center;"">C</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">F</td>
     *             <td style=""text-align: center;"">G</td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;"">STICKY READABLE</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;"">G</td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;"">W/O EXCLUDED</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;"">B1</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *     </tr>
     *     <tr>
     *             <td style=""text-align: left;"">REMOVABLE</td>
     *             <td style=""text-align: center;"">A</td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *             <td style=""text-align: center;""></td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @return COPY, REMOVE, SET_STICKY, WAIT_FOR_STAGE, or VOID if no operation is necessary.
     */","('handleVerification', {'INSTRUCTION': {'covered': 285, 'missed': 49}, 'BRANCH': {'covered': 18, 'missed': 6}, 'LINE': {'covered': 60, 'missed': 14}, 'COMPLEXITY': {'covered': 8, 'missed': 5}, 'METHOD': {'covered': 1, 'missed': 0}})",776.0,  <p>Called when a pnfsid has been selected from the operation map for  possible processing.,18.0,"['When a pnfsid has been selected from the operation map for possible processing.', 'When a pnfsid has been selected from the operation map for possible processing', 'When a pnfsid has been selected from the operation map for processing.']"
1108,cdk,org/openscience/cdk/io/Mol2Writer.java,/storage/io/src/main/java/org/openscience/cdk/io/Mol2Writer.java,writeMolecule,133-259,"/**
     * Writes a single frame in XYZ format to the Writer.
     *
     * @param mol the Molecule to write
     * @throws java.io.IOException if there is an error during writing
     */
public void writeMolecule(IAtomContainer mol) throws IOException{
    matcher = SybylAtomTypeMatcher.getInstance(mol.getBuilder());
    try {
        logger.debug(""Writing header..."");
        if (mol.getTitle() != null) {
            writer.write(""#        Name: "" + mol.getTitle());
            writer.write('\n');
        }
        writer.write('\n');
        logger.debug(""Writing molecule block..."");
        writer.write(""@<TRIPOS>MOLECULE"");
        writer.write('\n');
        if (mol.getID() == null) {
            writer.write(""CDKMolecule"");
        } else {
            writer.write(mol.getID());
        }
        writer.write('\n');
        writer.write(mol.getAtomCount() + "" "" + mol.getBondCount());
        writer.write('\n');
        writer.write(""SMALL"");
        writer.write('\n');
        writer.write(""NO CHARGES"");
        writer.write('\n');
        logger.debug(""Writing atom block..."");
        writer.write(""@<TRIPOS>ATOM"");
        writer.write('\n');
        for (int i = 0; i < mol.getAtomCount(); i++) {
            IAtom atom = mol.getAtom(i);
            writer.write((i + 1) + "" "" + atom.getSymbol() + (mol.indexOf(atom) + 1) + "" "");
            if (atom.getPoint3d() != null) {
                writer.write(atom.getPoint3d().x + "" "");
                writer.write(atom.getPoint3d().y + "" "");
                writer.write(atom.getPoint3d().z + "" "");
            } else if (atom.getPoint2d() != null) {
                writer.write(atom.getPoint2d().x + "" "");
                writer.write(atom.getPoint2d().y + "" "");
                writer.write("" 0.000 "");
            } else {
                writer.write(""0.000 0.000 0.000 "");
            }
            IAtomType sybylType = null;
            try {
                sybylType = matcher.findMatchingAtomType(mol, atom);
            } catch (CDKException e) {
                e.printStackTrace();
            }
            if (sybylType != null) {
                writer.write(sybylType.getAtomTypeName());
            } else {
                writer.write(atom.getSymbol());
            }
            writer.write('\n');
        }
        logger.debug(""Writing bond block..."");
        writer.write(""@<TRIPOS>BOND"");
        writer.write('\n');
        int counter = 0;
        for (IBond bond : mol.bonds()) {
            String sybylBondOrder = ""-1"";
            if (bond.getOrder().equals(IBond.Order.SINGLE))
                sybylBondOrder = ""1"";
            else if (bond.getOrder().equals(IBond.Order.DOUBLE))
                sybylBondOrder = ""2"";
            else if (bond.getOrder().equals(IBond.Order.TRIPLE))
                sybylBondOrder = ""3"";
            if (bond.getFlag(CDKConstants.ISAROMATIC))
                sybylBondOrder = ""ar"";
            final IAtom bondAtom1 = bond.getBegin();
            final IAtom bondAtom2 = bond.getEnd();
            try {
                final IAtomType bondAtom1Type = matcher.findMatchingAtomType(mol, bondAtom1);
                final IAtomType bondAtom2Type = matcher.findMatchingAtomType(mol, bondAtom2);
                if (bondAtom1Type != null && bondAtom2Type != null && ((bondAtom1Type.getAtomTypeName().equals(""N.am"") && bondAtom2Type.getAtomTypeName().equals(""C.2"")) || (bondAtom2Type.getAtomTypeName().equals(""N.am"") && bondAtom1Type.getAtomTypeName().equals(""C.2"")))) {
                    sybylBondOrder = ""am"";
                }
            } catch (CDKException e) {
                e.printStackTrace();
            }
            writer.write((counter + 1) + "" "" + (mol.indexOf(bond.getBegin()) + 1) + "" "" + (mol.indexOf(bond.getEnd()) + 1) + "" "" + sybylBondOrder);
            writer.write('\n');
            counter++;
        }
    } catch (IOException e) {
        throw e;
    }
}","public void writeMolecule(IAtomContainer mol) throws IOException{
    matcher = SybylAtomTypeMatcher.getInstance(mol.getBuilder());
    try {
        logger.debug(""Writing header..."");
        if (mol.getTitle() != null) {
            writer.write(""#        Name: "" + mol.getTitle());
            writer.write('\n');
        }
        writer.write('\n');
        logger.debug(""Writing molecule block..."");
        writer.write(""@<TRIPOS>MOLECULE"");
        writer.write('\n');
        if (mol.getID() == null) {
            writer.write(""CDKMolecule"");
        } else {
            writer.write(mol.getID());
        }
        writer.write('\n');
        writer.write(mol.getAtomCount() + "" "" + mol.getBondCount());
        writer.write('\n');
        writer.write(""SMALL"");
        writer.write('\n');
        writer.write(""NO CHARGES"");
        writer.write('\n');
        logger.debug(""Writing atom block..."");
        writer.write(""@<TRIPOS>ATOM"");
        writer.write('\n');
        for (int i = 0; i < mol.getAtomCount(); i++) {
            IAtom atom = mol.getAtom(i);
            writer.write((i + 1) + "" "" + atom.getSymbol() + (mol.indexOf(atom) + 1) + "" "");
            if (atom.getPoint3d() != null) {
                writer.write(atom.getPoint3d().x + "" "");
                writer.write(atom.getPoint3d().y + "" "");
                writer.write(atom.getPoint3d().z + "" "");
            } else if (atom.getPoint2d() != null) {
                writer.write(atom.getPoint2d().x + "" "");
                writer.write(atom.getPoint2d().y + "" "");
                writer.write("" 0.000 "");
            } else {
                writer.write(""0.000 0.000 0.000 "");
            }
            IAtomType sybylType = null;
            try {
                sybylType = matcher.findMatchingAtomType(mol, atom);
            } catch (CDKException e) {
                e.printStackTrace();
            }
            if (sybylType != null) {
                writer.write(sybylType.getAtomTypeName());
            } else {
                writer.write(atom.getSymbol());
            }
            writer.write('\n');
        }
        logger.debug(""Writing bond block..."");
        writer.write(""@<TRIPOS>BOND"");
        writer.write('\n');
        int counter = 0;
        for (IBond bond : mol.bonds()) {
            String sybylBondOrder = ""-1"";
            if (bond.getOrder().equals(IBond.Order.SINGLE))
                sybylBondOrder = ""1"";
            else if (bond.getOrder().equals(IBond.Order.DOUBLE))
                sybylBondOrder = ""2"";
            else if (bond.getOrder().equals(IBond.Order.TRIPLE))
                sybylBondOrder = ""3"";
            if (bond.getFlag(CDKConstants.ISAROMATIC))
                sybylBondOrder = ""ar"";
            final IAtom bondAtom1 = bond.getBegin();
            final IAtom bondAtom2 = bond.getEnd();
            try {
                final IAtomType bondAtom1Type = matcher.findMatchingAtomType(mol, bondAtom1);
                final IAtomType bondAtom2Type = matcher.findMatchingAtomType(mol, bondAtom2);
                if (bondAtom1Type != null && bondAtom2Type != null && ((bondAtom1Type.getAtomTypeName().equals(""N.am"") && bondAtom2Type.getAtomTypeName().equals(""C.2"")) || (bondAtom2Type.getAtomTypeName().equals(""N.am"") && bondAtom1Type.getAtomTypeName().equals(""C.2"")))) {
                    sybylBondOrder = ""am"";
                }
            } catch (CDKException e) {
                e.printStackTrace();
            }
            writer.write((counter + 1) + "" "" + (mol.indexOf(bond.getBegin()) + 1) + "" "" + (mol.indexOf(bond.getEnd()) + 1) + "" "" + sybylBondOrder);
            writer.write('\n');
            counter++;
        }
    } catch (IOException e) {
        throw e;
    }
}","/**
     * Writes a single frame in XYZ format to the Writer.
     *
     * @param mol the Molecule to write
     * @throws java.io.IOException if there is an error during writing
     */","('writeMolecule', {'INSTRUCTION': {'covered': 320, 'missed': 78}, 'BRANCH': {'covered': 16, 'missed': 18}, 'LINE': {'covered': 60, 'missed': 15}, 'COMPLEXITY': {'covered': 4, 'missed': 14}, 'METHOD': {'covered': 1, 'missed': 0}})",781.0,  Writes a single frame in XYZ format to the Writer.,11.0,"['A single frame is written to the writer.', 'Writes a single frame in a different format to the writer.', 'Writes a single frame in a different format.']"
1109,cdk,org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,/tool/builder3d/src/main/java/org/openscience/cdk/modeling/builder3d/ModelBuilder3D.java,layoutRingSystem,314-390,"/**
     * Layout the ring system, rotate and translate the template.
     *
     *@param  originalCoord         coordinates of the placedRingAtom from the template
     *@param  placedRingAtom        placedRingAtom
     *@param  ringSet               ring system which placedRingAtom is part of
     *@param  centerPlacedMolecule  the geometric center of the already placed molecule
     *@param  atomB                 placed neighbour atom of  placedRingAtom
     */
private void layoutRingSystem(Point3d originalCoord, IAtom placedRingAtom, IRingSet ringSet, Point3d centerPlacedMolecule, IAtom atomB, AtomPlacer3D ap3d){
    IAtomContainer ac = RingSetManipulator.getAllInOneContainer(ringSet);
    Point3d newCoord = placedRingAtom.getPoint3d();
    Vector3d axis = new Vector3d(atomB.getPoint3d().x - newCoord.x, atomB.getPoint3d().y - newCoord.y, atomB.getPoint3d().z - newCoord.z);
    translateStructure(originalCoord, newCoord, ac);
    Vector3d startAtomVector = new Vector3d(newCoord.x - atomB.getPoint3d().x, newCoord.y - atomB.getPoint3d().y, newCoord.z - atomB.getPoint3d().z);
    IAtom farthestAtom = ap3d.getFarthestAtom(placedRingAtom.getPoint3d(), ac);
    Vector3d farthestAtomVector = new Vector3d(farthestAtom.getPoint3d().x - newCoord.x, farthestAtom.getPoint3d().y - newCoord.y, farthestAtom.getPoint3d().z - newCoord.z);
    Vector3d n1 = new Vector3d();
    n1.cross(axis, farthestAtomVector);
    n1.normalize();
    double lengthFarthestAtomVector = farthestAtomVector.length();
    Vector3d farthestVector = new Vector3d(startAtomVector);
    farthestVector.normalize();
    farthestVector.scale((startAtomVector.length() + lengthFarthestAtomVector));
    double dotProduct = farthestAtomVector.dot(farthestVector);
    double angle = Math.acos(dotProduct / (farthestAtomVector.length() * farthestVector.length()));
    Vector3d ringCenter = new Vector3d();
    for (int i = 0; i < ac.getAtomCount(); i++) {
        if (!(ac.getAtom(i).getFlag(CDKConstants.ISPLACED))) {
            ringCenter.x = (ac.getAtom(i).getPoint3d()).x - newCoord.x;
            ringCenter.y = (ac.getAtom(i).getPoint3d()).y - newCoord.y;
            ringCenter.z = (ac.getAtom(i).getPoint3d()).z - newCoord.z;
            ringCenter = AtomTetrahedralLigandPlacer3D.rotate(ringCenter, n1, angle);
            ac.getAtom(i).setPoint3d(new Point3d(ringCenter.x + newCoord.x, ringCenter.y + newCoord.y, ringCenter.z + newCoord.z));
        }
    }
    Point3d pointRingCenter = GeometryUtil.get3DCenter(ac);
    double distance = 0;
    double rotAngleMax = 0;
    angle = 1 / 180 * Math.PI;
    ringCenter = new Vector3d(pointRingCenter.x, pointRingCenter.y, pointRingCenter.z);
    ringCenter.x = ringCenter.x - newCoord.x;
    ringCenter.y = ringCenter.y - newCoord.y;
    ringCenter.z = ringCenter.z - newCoord.z;
    for (int i = 1; i < 360; i++) {
        ringCenter = AtomTetrahedralLigandPlacer3D.rotate(ringCenter, axis, angle);
        if (centerPlacedMolecule.distance(new Point3d(ringCenter.x, ringCenter.y, ringCenter.z)) > distance) {
            rotAngleMax = i;
            distance = centerPlacedMolecule.distance(new Point3d(ringCenter.x, ringCenter.y, ringCenter.z));
        }
    }
    rotAngleMax = (rotAngleMax / 180) * Math.PI;
    for (int i = 0; i < ac.getAtomCount(); i++) {
        if (!(ac.getAtom(i).getFlag(CDKConstants.ISPLACED))) {
            ringCenter.x = (ac.getAtom(i).getPoint3d()).x;
            ringCenter.y = (ac.getAtom(i).getPoint3d()).y;
            ringCenter.z = (ac.getAtom(i).getPoint3d()).z;
            ringCenter = AtomTetrahedralLigandPlacer3D.rotate(ringCenter, axis, rotAngleMax);
            ac.getAtom(i).setPoint3d(new Point3d(ringCenter.x, ringCenter.y, ringCenter.z));
            ac.getAtom(i).setFlag(CDKConstants.ISPLACED, true);
        }
    }
}","private void layoutRingSystem(Point3d originalCoord, IAtom placedRingAtom, IRingSet ringSet, Point3d centerPlacedMolecule, IAtom atomB, AtomPlacer3D ap3d){
    IAtomContainer ac = RingSetManipulator.getAllInOneContainer(ringSet);
    Point3d newCoord = placedRingAtom.getPoint3d();
    Vector3d axis = new Vector3d(atomB.getPoint3d().x - newCoord.x, atomB.getPoint3d().y - newCoord.y, atomB.getPoint3d().z - newCoord.z);
    translateStructure(originalCoord, newCoord, ac);
    Vector3d startAtomVector = new Vector3d(newCoord.x - atomB.getPoint3d().x, newCoord.y - atomB.getPoint3d().y, newCoord.z - atomB.getPoint3d().z);
    IAtom farthestAtom = ap3d.getFarthestAtom(placedRingAtom.getPoint3d(), ac);
    Vector3d farthestAtomVector = new Vector3d(farthestAtom.getPoint3d().x - newCoord.x, farthestAtom.getPoint3d().y - newCoord.y, farthestAtom.getPoint3d().z - newCoord.z);
    Vector3d n1 = new Vector3d();
    n1.cross(axis, farthestAtomVector);
    n1.normalize();
    double lengthFarthestAtomVector = farthestAtomVector.length();
    Vector3d farthestVector = new Vector3d(startAtomVector);
    farthestVector.normalize();
    farthestVector.scale((startAtomVector.length() + lengthFarthestAtomVector));
    double dotProduct = farthestAtomVector.dot(farthestVector);
    double angle = Math.acos(dotProduct / (farthestAtomVector.length() * farthestVector.length()));
    Vector3d ringCenter = new Vector3d();
    for (int i = 0; i < ac.getAtomCount(); i++) {
        if (!(ac.getAtom(i).getFlag(CDKConstants.ISPLACED))) {
            ringCenter.x = (ac.getAtom(i).getPoint3d()).x - newCoord.x;
            ringCenter.y = (ac.getAtom(i).getPoint3d()).y - newCoord.y;
            ringCenter.z = (ac.getAtom(i).getPoint3d()).z - newCoord.z;
            ringCenter = AtomTetrahedralLigandPlacer3D.rotate(ringCenter, n1, angle);
            ac.getAtom(i).setPoint3d(new Point3d(ringCenter.x + newCoord.x, ringCenter.y + newCoord.y, ringCenter.z + newCoord.z));
        }
    }
    Point3d pointRingCenter = GeometryUtil.get3DCenter(ac);
    double distance = 0;
    double rotAngleMax = 0;
    angle = 1 / 180 * Math.PI;
    ringCenter = new Vector3d(pointRingCenter.x, pointRingCenter.y, pointRingCenter.z);
    ringCenter.x = ringCenter.x - newCoord.x;
    ringCenter.y = ringCenter.y - newCoord.y;
    ringCenter.z = ringCenter.z - newCoord.z;
    for (int i = 1; i < 360; i++) {
        ringCenter = AtomTetrahedralLigandPlacer3D.rotate(ringCenter, axis, angle);
        if (centerPlacedMolecule.distance(new Point3d(ringCenter.x, ringCenter.y, ringCenter.z)) > distance) {
            rotAngleMax = i;
            distance = centerPlacedMolecule.distance(new Point3d(ringCenter.x, ringCenter.y, ringCenter.z));
        }
    }
    rotAngleMax = (rotAngleMax / 180) * Math.PI;
    for (int i = 0; i < ac.getAtomCount(); i++) {
        if (!(ac.getAtom(i).getFlag(CDKConstants.ISPLACED))) {
            ringCenter.x = (ac.getAtom(i).getPoint3d()).x;
            ringCenter.y = (ac.getAtom(i).getPoint3d()).y;
            ringCenter.z = (ac.getAtom(i).getPoint3d()).z;
            ringCenter = AtomTetrahedralLigandPlacer3D.rotate(ringCenter, axis, rotAngleMax);
            ac.getAtom(i).setPoint3d(new Point3d(ringCenter.x, ringCenter.y, ringCenter.z));
            ac.getAtom(i).setFlag(CDKConstants.ISPLACED, true);
        }
    }
}","/**
     * Layout the ring system, rotate and translate the template.
     *
     *@param  originalCoord         coordinates of the placedRingAtom from the template
     *@param  placedRingAtom        placedRingAtom
     *@param  ringSet               ring system which placedRingAtom is part of
     *@param  centerPlacedMolecule  the geometric center of the already placed molecule
     *@param  atomB                 placed neighbour atom of  placedRingAtom
     */","('layoutRingSystem', {'INSTRUCTION': {'covered': 344, 'missed': 0}, 'BRANCH': {'covered': 12, 'missed': 0}, 'LINE': {'covered': 50, 'missed': 0}, 'COMPLEXITY': {'covered': 7, 'missed': 0}, 'METHOD': {'covered': 1, 'missed': 0}})",794.0,"  Layout the ring system, rotate and translate the template.",11.0,"['Take the template and translate it.', 'The ring system should be layout, rotate and translated.', 'The ring system should be layout, rotating and translated.']"
1110,jackson-databind,com/fasterxml/jackson/databind/ObjectMapper.java,/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,registerModule,809-1019,"/**
     * Method for registering a module that can extend functionality
     * provided by this mapper; for example, by adding providers for
     * custom serializers and deserializers.
     * 
     * @param module Module to register
     */
public ObjectMapper registerModule(Module module){
    _assertNotNull(""module"", module);
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    for (Module dep : module.getDependencies()) {
        registerModule(dep);
    }
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    module.setupModule(new Module.SetupContext() {

        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            return (C) ObjectMapper.this;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public MutableConfigOverride configOverride(Class<?> type) {
            return ObjectMapper.this.configOverride(type);
        }

        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = _deserializationContext._factory.withAdditionalDeserializers(d);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = _deserializationContext._factory.withAdditionalKeyDeserializers(d);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = _deserializationContext._factory.withDeserializerModifier(modifier);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void addSerializers(Serializers s) {
            _serializerFactory = _serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            _serializerFactory = _serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            _serializerFactory = _serializerFactory.withSerializerModifier(modifier);
        }

        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = _deserializationContext._factory.withAbstractTypeResolver(resolver);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = _typeFactory;
            f = f.withModifier(modifier);
            setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = _deserializationContext._factory.withValueInstantiators(instantiators);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            _deserializationConfig = _deserializationConfig.with(ci);
            _serializationConfig = _serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            _deserializationConfig = _deserializationConfig.withInsertedAnnotationIntrospector(ai);
            _serializationConfig = _serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            _deserializationConfig = _deserializationConfig.withAppendedAnnotationIntrospector(ai);
            _serializationConfig = _serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            ObjectMapper.this.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            ObjectMapper.this.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(Collection<Class<?>> subtypes) {
            ObjectMapper.this.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","public ObjectMapper registerModule(Module module){
    _assertNotNull(""module"", module);
    String name = module.getModuleName();
    if (name == null) {
        throw new IllegalArgumentException(""Module without defined name"");
    }
    Version version = module.version();
    if (version == null) {
        throw new IllegalArgumentException(""Module without defined version"");
    }
    for (Module dep : module.getDependencies()) {
        registerModule(dep);
    }
    if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {
        Object typeId = module.getTypeId();
        if (typeId != null) {
            if (_registeredModuleTypes == null) {
                _registeredModuleTypes = new LinkedHashSet<Object>();
            }
            if (!_registeredModuleTypes.add(typeId)) {
                return this;
            }
        }
    }
    module.setupModule(new Module.SetupContext() {

        @Override
        public Version getMapperVersion() {
            return version();
        }

        @SuppressWarnings(""unchecked"")
        @Override
        public <C extends ObjectCodec> C getOwner() {
            return (C) ObjectMapper.this;
        }

        @Override
        public TypeFactory getTypeFactory() {
            return _typeFactory;
        }

        @Override
        public boolean isEnabled(MapperFeature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(DeserializationFeature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(SerializationFeature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonFactory.Feature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonParser.Feature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public boolean isEnabled(JsonGenerator.Feature f) {
            return ObjectMapper.this.isEnabled(f);
        }

        @Override
        public MutableConfigOverride configOverride(Class<?> type) {
            return ObjectMapper.this.configOverride(type);
        }

        @Override
        public void addDeserializers(Deserializers d) {
            DeserializerFactory df = _deserializationContext._factory.withAdditionalDeserializers(d);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void addKeyDeserializers(KeyDeserializers d) {
            DeserializerFactory df = _deserializationContext._factory.withAdditionalKeyDeserializers(d);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {
            DeserializerFactory df = _deserializationContext._factory.withDeserializerModifier(modifier);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void addSerializers(Serializers s) {
            _serializerFactory = _serializerFactory.withAdditionalSerializers(s);
        }

        @Override
        public void addKeySerializers(Serializers s) {
            _serializerFactory = _serializerFactory.withAdditionalKeySerializers(s);
        }

        @Override
        public void addBeanSerializerModifier(BeanSerializerModifier modifier) {
            _serializerFactory = _serializerFactory.withSerializerModifier(modifier);
        }

        @Override
        public void addAbstractTypeResolver(AbstractTypeResolver resolver) {
            DeserializerFactory df = _deserializationContext._factory.withAbstractTypeResolver(resolver);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void addTypeModifier(TypeModifier modifier) {
            TypeFactory f = _typeFactory;
            f = f.withModifier(modifier);
            setTypeFactory(f);
        }

        @Override
        public void addValueInstantiators(ValueInstantiators instantiators) {
            DeserializerFactory df = _deserializationContext._factory.withValueInstantiators(instantiators);
            _deserializationContext = _deserializationContext.with(df);
        }

        @Override
        public void setClassIntrospector(ClassIntrospector ci) {
            _deserializationConfig = _deserializationConfig.with(ci);
            _serializationConfig = _serializationConfig.with(ci);
        }

        @Override
        public void insertAnnotationIntrospector(AnnotationIntrospector ai) {
            _deserializationConfig = _deserializationConfig.withInsertedAnnotationIntrospector(ai);
            _serializationConfig = _serializationConfig.withInsertedAnnotationIntrospector(ai);
        }

        @Override
        public void appendAnnotationIntrospector(AnnotationIntrospector ai) {
            _deserializationConfig = _deserializationConfig.withAppendedAnnotationIntrospector(ai);
            _serializationConfig = _serializationConfig.withAppendedAnnotationIntrospector(ai);
        }

        @Override
        public void registerSubtypes(Class<?>... subtypes) {
            ObjectMapper.this.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(NamedType... subtypes) {
            ObjectMapper.this.registerSubtypes(subtypes);
        }

        @Override
        public void registerSubtypes(Collection<Class<?>> subtypes) {
            ObjectMapper.this.registerSubtypes(subtypes);
        }

        @Override
        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {
            addMixIn(target, mixinSource);
        }

        @Override
        public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {
            addHandler(handler);
        }

        @Override
        public void setNamingStrategy(PropertyNamingStrategy naming) {
            setPropertyNamingStrategy(naming);
        }
    });
    return this;
}","/**
     * Method for registering a module that can extend functionality
     * provided by this mapper; for example, by adding providers for
     * custom serializers and deserializers.
     * 
     * @param module Module to register
     */","('registerModule', {'INSTRUCTION': {'covered': 62, 'missed': 10}, 'BRANCH': {'covered': 11, 'missed': 3}, 'LINE': {'covered': 17, 'missed': 2}, 'COMPLEXITY': {'covered': 5, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",836.0,"  Method for registering a module that can extend functionality  provided by this mapper; for example, by adding providers for  custom serializers and deserializers.",26.0,"['Adding providers for custom serializers and deserializers is a method of registration that can be used.', 'Adding providers for custom serializers and deserializers is a method for registration a module that can extend the function of this mapper.', 'Adding providers for custom serializers and deserializers is a method for registration a module that can extend its function.']"
1112,cdk,org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,/legacy/src/main/java/org/openscience/cdk/smsd/algorithm/rgraph/CDKMCS.java,testSubgraphHeuristics,1010-1163,"/**
     *  Checks some simple heuristics for whether the subgraph query can
     *  realistically be atom subgraph of the supergraph. If, for example, the
     *  number of nitrogen atoms in the query is larger than that of the supergraph
     *  it cannot be part of it.
     *
     * @param  ac1  the supergraph to be checked. Must not be an IQueryAtomContainer.
     * @param  ac2  the subgraph to be tested for. May be an IQueryAtomContainer.
     * @return    true if the subgraph ac2 has atom chance to be atom subgraph of ac1
     * @throws org.openscience.cdk.exception.CDKException if the first molecule is an instance
     * of IQueryAtomContainer
     */
private static boolean testSubgraphHeuristics(IAtomContainer ac1, IAtomContainer ac2) throws CDKException{
    if (ac1 instanceof IQueryAtomContainer) {
        throw new CDKException(""The first IAtomContainer must not be an IQueryAtomContainer"");
    }
    int ac1SingleBondCount = 0;
    int ac1DoubleBondCount = 0;
    int ac1TripleBondCount = 0;
    int ac1AromaticBondCount = 0;
    int ac2SingleBondCount = 0;
    int ac2DoubleBondCount = 0;
    int ac2TripleBondCount = 0;
    int ac2AromaticBondCount = 0;
    int ac1SCount = 0;
    int ac1OCount = 0;
    int ac1NCount = 0;
    int ac1FCount = 0;
    int ac1ClCount = 0;
    int ac1BrCount = 0;
    int ac1ICount = 0;
    int ac1CCount = 0;
    int ac2SCount = 0;
    int ac2OCount = 0;
    int ac2NCount = 0;
    int ac2FCount = 0;
    int ac2ClCount = 0;
    int ac2BrCount = 0;
    int ac2ICount = 0;
    int ac2CCount = 0;
    IBond bond;
    IAtom atom;
    for (int i = 0; i < ac1.getBondCount(); i++) {
        bond = ac1.getBond(i);
        if (bond.getFlag(CDKConstants.ISAROMATIC)) {
            ac1AromaticBondCount++;
        } else if (bond.getOrder() == IBond.Order.SINGLE) {
            ac1SingleBondCount++;
        } else if (bond.getOrder() == IBond.Order.DOUBLE) {
            ac1DoubleBondCount++;
        } else if (bond.getOrder() == IBond.Order.TRIPLE) {
            ac1TripleBondCount++;
        }
    }
    for (int i = 0; i < ac2.getBondCount(); i++) {
        bond = ac2.getBond(i);
        if (bond instanceof IQueryBond) {
            continue;
        }
        if (bond.getFlag(CDKConstants.ISAROMATIC)) {
            ac2AromaticBondCount++;
        } else if (bond.getOrder() == IBond.Order.SINGLE) {
            ac2SingleBondCount++;
        } else if (bond.getOrder() == IBond.Order.DOUBLE) {
            ac2DoubleBondCount++;
        } else if (bond.getOrder() == IBond.Order.TRIPLE) {
            ac2TripleBondCount++;
        }
    }
    if (ac2SingleBondCount > ac1SingleBondCount) {
        return false;
    }
    if (ac2AromaticBondCount > ac1AromaticBondCount) {
        return false;
    }
    if (ac2DoubleBondCount > ac1DoubleBondCount) {
        return false;
    }
    if (ac2TripleBondCount > ac1TripleBondCount) {
        return false;
    }
    for (int i = 0; i < ac1.getAtomCount(); i++) {
        atom = ac1.getAtom(i);
        if (atom.getSymbol().equals(""S"")) {
            ac1SCount++;
        } else if (atom.getSymbol().equals(""N"")) {
            ac1NCount++;
        } else if (atom.getSymbol().equals(""O"")) {
            ac1OCount++;
        } else if (atom.getSymbol().equals(""F"")) {
            ac1FCount++;
        } else if (atom.getSymbol().equals(""Cl"")) {
            ac1ClCount++;
        } else if (atom.getSymbol().equals(""Br"")) {
            ac1BrCount++;
        } else if (atom.getSymbol().equals(""I"")) {
            ac1ICount++;
        } else if (atom.getSymbol().equals(""C"")) {
            ac1CCount++;
        }
    }
    for (int i = 0; i < ac2.getAtomCount(); i++) {
        atom = ac2.getAtom(i);
        if (atom instanceof IQueryAtom) {
            continue;
        }
        if (atom.getSymbol().equals(""S"")) {
            ac2SCount++;
        } else if (atom.getSymbol().equals(""N"")) {
            ac2NCount++;
        } else if (atom.getSymbol().equals(""O"")) {
            ac2OCount++;
        } else if (atom.getSymbol().equals(""F"")) {
            ac2FCount++;
        } else if (atom.getSymbol().equals(""Cl"")) {
            ac2ClCount++;
        } else if (atom.getSymbol().equals(""Br"")) {
            ac2BrCount++;
        } else if (atom.getSymbol().equals(""I"")) {
            ac2ICount++;
        } else if (atom.getSymbol().equals(""C"")) {
            ac2CCount++;
        }
    }
    if (ac1SCount < ac2SCount) {
        return false;
    }
    if (ac1NCount < ac2NCount) {
        return false;
    }
    if (ac1OCount < ac2OCount) {
        return false;
    }
    if (ac1FCount < ac2FCount) {
        return false;
    }
    if (ac1ClCount < ac2ClCount) {
        return false;
    }
    if (ac1BrCount < ac2BrCount) {
        return false;
    }
    if (ac1ICount < ac2ICount) {
        return false;
    }
    return ac1CCount >= ac2CCount;
}","private static boolean testSubgraphHeuristics(IAtomContainer ac1, IAtomContainer ac2) throws CDKException{
    if (ac1 instanceof IQueryAtomContainer) {
        throw new CDKException(""The first IAtomContainer must not be an IQueryAtomContainer"");
    }
    int ac1SingleBondCount = 0;
    int ac1DoubleBondCount = 0;
    int ac1TripleBondCount = 0;
    int ac1AromaticBondCount = 0;
    int ac2SingleBondCount = 0;
    int ac2DoubleBondCount = 0;
    int ac2TripleBondCount = 0;
    int ac2AromaticBondCount = 0;
    int ac1SCount = 0;
    int ac1OCount = 0;
    int ac1NCount = 0;
    int ac1FCount = 0;
    int ac1ClCount = 0;
    int ac1BrCount = 0;
    int ac1ICount = 0;
    int ac1CCount = 0;
    int ac2SCount = 0;
    int ac2OCount = 0;
    int ac2NCount = 0;
    int ac2FCount = 0;
    int ac2ClCount = 0;
    int ac2BrCount = 0;
    int ac2ICount = 0;
    int ac2CCount = 0;
    IBond bond;
    IAtom atom;
    for (int i = 0; i < ac1.getBondCount(); i++) {
        bond = ac1.getBond(i);
        if (bond.getFlag(CDKConstants.ISAROMATIC)) {
            ac1AromaticBondCount++;
        } else if (bond.getOrder() == IBond.Order.SINGLE) {
            ac1SingleBondCount++;
        } else if (bond.getOrder() == IBond.Order.DOUBLE) {
            ac1DoubleBondCount++;
        } else if (bond.getOrder() == IBond.Order.TRIPLE) {
            ac1TripleBondCount++;
        }
    }
    for (int i = 0; i < ac2.getBondCount(); i++) {
        bond = ac2.getBond(i);
        if (bond instanceof IQueryBond) {
            continue;
        }
        if (bond.getFlag(CDKConstants.ISAROMATIC)) {
            ac2AromaticBondCount++;
        } else if (bond.getOrder() == IBond.Order.SINGLE) {
            ac2SingleBondCount++;
        } else if (bond.getOrder() == IBond.Order.DOUBLE) {
            ac2DoubleBondCount++;
        } else if (bond.getOrder() == IBond.Order.TRIPLE) {
            ac2TripleBondCount++;
        }
    }
    if (ac2SingleBondCount > ac1SingleBondCount) {
        return false;
    }
    if (ac2AromaticBondCount > ac1AromaticBondCount) {
        return false;
    }
    if (ac2DoubleBondCount > ac1DoubleBondCount) {
        return false;
    }
    if (ac2TripleBondCount > ac1TripleBondCount) {
        return false;
    }
    for (int i = 0; i < ac1.getAtomCount(); i++) {
        atom = ac1.getAtom(i);
        if (atom.getSymbol().equals(""S"")) {
            ac1SCount++;
        } else if (atom.getSymbol().equals(""N"")) {
            ac1NCount++;
        } else if (atom.getSymbol().equals(""O"")) {
            ac1OCount++;
        } else if (atom.getSymbol().equals(""F"")) {
            ac1FCount++;
        } else if (atom.getSymbol().equals(""Cl"")) {
            ac1ClCount++;
        } else if (atom.getSymbol().equals(""Br"")) {
            ac1BrCount++;
        } else if (atom.getSymbol().equals(""I"")) {
            ac1ICount++;
        } else if (atom.getSymbol().equals(""C"")) {
            ac1CCount++;
        }
    }
    for (int i = 0; i < ac2.getAtomCount(); i++) {
        atom = ac2.getAtom(i);
        if (atom instanceof IQueryAtom) {
            continue;
        }
        if (atom.getSymbol().equals(""S"")) {
            ac2SCount++;
        } else if (atom.getSymbol().equals(""N"")) {
            ac2NCount++;
        } else if (atom.getSymbol().equals(""O"")) {
            ac2OCount++;
        } else if (atom.getSymbol().equals(""F"")) {
            ac2FCount++;
        } else if (atom.getSymbol().equals(""Cl"")) {
            ac2ClCount++;
        } else if (atom.getSymbol().equals(""Br"")) {
            ac2BrCount++;
        } else if (atom.getSymbol().equals(""I"")) {
            ac2ICount++;
        } else if (atom.getSymbol().equals(""C"")) {
            ac2CCount++;
        }
    }
    if (ac1SCount < ac2SCount) {
        return false;
    }
    if (ac1NCount < ac2NCount) {
        return false;
    }
    if (ac1OCount < ac2OCount) {
        return false;
    }
    if (ac1FCount < ac2FCount) {
        return false;
    }
    if (ac1ClCount < ac2ClCount) {
        return false;
    }
    if (ac1BrCount < ac2BrCount) {
        return false;
    }
    if (ac1ICount < ac2ICount) {
        return false;
    }
    return ac1CCount >= ac2CCount;
}","/**
     *  Checks some simple heuristics for whether the subgraph query can
     *  realistically be atom subgraph of the supergraph. If, for example, the
     *  number of nitrogen atoms in the query is larger than that of the supergraph
     *  it cannot be part of it.
     *
     * @param  ac1  the supergraph to be checked. Must not be an IQueryAtomContainer.
     * @param  ac2  the subgraph to be tested for. May be an IQueryAtomContainer.
     * @return    true if the subgraph ac2 has atom chance to be atom subgraph of ac1
     * @throws org.openscience.cdk.exception.CDKException if the first molecule is an instance
     * of IQueryAtomContainer
     */","('testSubgraphHeuristics', {'INSTRUCTION': {'covered': 270, 'missed': 60}, 'BRANCH': {'covered': 56, 'missed': 30}, 'LINE': {'covered': 82, 'missed': 27}, 'COMPLEXITY': {'covered': 16, 'missed': 28}, 'METHOD': {'covered': 1, 'missed': 0}})",872.0,  Checks some simple heuristics for whether the subgraph query can  realistically be atom subgraph of the supergraph.,18.0,"['Checks to see if the subgraph query can be a subgraph of the supergraph.', 'Checks if the subgraph query can be an atom subgraph of the supergraph.', 'Checks to see if the subgraph query can be an atom subgraph of the supergraph.']"
1113,cdk,org/openscience/cdk/formula/MassToFormulaTool.java,/legacy/src/main/java/org/openscience/cdk/formula/MassToFormulaTool.java,generate,242-415,"/**
     * Method that actually does the work of extracting the molecular formula.
     *
     * @param  mass            molecular formula to create from the mass
     * @return                 the filled molecular formulas as IMolecularFormulaSet
     */
public IMolecularFormulaSet generate(double mass){
    if (mass <= 0.0) {
        logger.error(""Proposed mass is not valid: "", mass);
        return null;
    }
    IMolecularFormula minimalMF = MolecularFormulaRangeManipulator.getMinimalFormula(mfRange, builder);
    IMolecularFormula maximalMF = MolecularFormulaRangeManipulator.getMaximalFormula(mfRange, builder);
    double massMim = MolecularFormulaManipulator.getTotalExactMass(minimalMF) - tolerance;
    double massMap = MolecularFormulaManipulator.getTotalExactMass(maximalMF) + tolerance;
    if (massMim > mass || massMap < mass) {
        logger.error(""Proposed mass is out of the range: "", mass);
        return null;
    }
    IMolecularFormulaSet molecularFormulaSet = builder.newInstance(IMolecularFormulaSet.class);
    int[][] matrix = this.matrix_Base;
    int numberElements = mfRange.getIsotopeCount();
    List<IIsotope> isotopes_TO = new ArrayList<IIsotope>();
    Iterator<IIsotope> isIt = mfRange.isotopes().iterator();
    while (isIt.hasNext()) isotopes_TO.add(isIt.next());
    isotopes_TO = orderList(isotopes_TO);
    for (int i = 0; i < matrix.length; i++) {
        int[] value_In = new int[numberElements];
        for (int j = 0; j < numberElements; j++) {
            if (matrix[i][j] == 0)
                value_In[j] = 0;
            else
                value_In[j] = 1;
        }
        int count_E = 0;
        ArrayList<Integer> elem_Pos = new ArrayList<Integer>();
        for (int j = 0; j < matrix[1].length; j++) if (value_In[j] != 0) {
            count_E++;
            elem_Pos.add(j);
        }
        boolean flag = true;
        int possChan = 0;
        String lastMFString = """";
        while (flag) {
            boolean flagBreak = false;
            for (int j = 0; j < matrix[1].length; j++) {
                int min = mfRange.getIsotopeCountMin(isotopes_TO.get(j));
                if (value_In[j] == 0)
                    if (min != 0)
                        flagBreak = true;
            }
            if (flagBreak)
                break;
            int occurence = getMaxOccurence(mass, elem_Pos.get(possChan).intValue(), value_In, isotopes_TO);
            if (occurence == 0)
                break;
            int maxx = mfRange.getIsotopeCountMax(isotopes_TO.get(elem_Pos.get(possChan).intValue()));
            int minn = mfRange.getIsotopeCountMin(isotopes_TO.get(elem_Pos.get(possChan).intValue()));
            if (occurence < minn | maxx < occurence) {
                if (possChan < elem_Pos.size() - 1) {
                    if (maxx < occurence)
                        value_In[elem_Pos.get(possChan).intValue()] = maxx;
                    possChan++;
                } else {
                    boolean foundZ = false;
                    for (int z = possChan - 1; z >= 0; z--) {
                        if (value_In[elem_Pos.get(z).intValue()] != 1) {
                            possChan = z;
                            foundZ = true;
                            int newValue = value_In[elem_Pos.get(possChan).intValue()] - 1;
                            value_In[elem_Pos.get(possChan).intValue()] = newValue;
                            for (int j = possChan + 1; j < elem_Pos.size(); j++) {
                                int p = elem_Pos.get(j).intValue();
                                value_In[p] = 1;
                            }
                            possChan++;
                            break;
                        }
                    }
                    if (!foundZ)
                        break;
                }
                continue;
            }
            value_In[elem_Pos.get(possChan).intValue()] = occurence;
            double massT = calculateMassT(isotopes_TO, value_In);
            double diff_new = Math.abs(mass - (massT));
            if (diff_new < tolerance) {
                IMolecularFormula myMF = getFormula(isotopes_TO, value_In);
                String newMFString = MolecularFormulaManipulator.getString(myMF);
                if (!newMFString.equals(lastMFString)) {
                    molecularFormulaSet.addMolecularFormula(myMF);
                    lastMFString = newMFString;
                }
            }
            if (count_E == 1)
                break;
            if (possChan < elem_Pos.size() - 1) {
                possChan++;
            } else {
                boolean foundZ = false;
                for (int z = possChan - 1; z >= 0; z--) {
                    if (value_In[elem_Pos.get(z).intValue()] != 1) {
                        possChan = z;
                        foundZ = true;
                        int newValue = value_In[elem_Pos.get(possChan).intValue()] - 1;
                        value_In[elem_Pos.get(possChan).intValue()] = newValue;
                        for (int j = possChan + 1; j < elem_Pos.size(); j++) {
                            int p = elem_Pos.get(j).intValue();
                            value_In[p] = 1;
                        }
                        possChan++;
                        break;
                    }
                }
                if (!foundZ)
                    break;
            }
        }
    }
    return returnOrdered(mass, molecularFormulaSet);
}","public IMolecularFormulaSet generate(double mass){
    if (mass <= 0.0) {
        logger.error(""Proposed mass is not valid: "", mass);
        return null;
    }
    IMolecularFormula minimalMF = MolecularFormulaRangeManipulator.getMinimalFormula(mfRange, builder);
    IMolecularFormula maximalMF = MolecularFormulaRangeManipulator.getMaximalFormula(mfRange, builder);
    double massMim = MolecularFormulaManipulator.getTotalExactMass(minimalMF) - tolerance;
    double massMap = MolecularFormulaManipulator.getTotalExactMass(maximalMF) + tolerance;
    if (massMim > mass || massMap < mass) {
        logger.error(""Proposed mass is out of the range: "", mass);
        return null;
    }
    IMolecularFormulaSet molecularFormulaSet = builder.newInstance(IMolecularFormulaSet.class);
    int[][] matrix = this.matrix_Base;
    int numberElements = mfRange.getIsotopeCount();
    List<IIsotope> isotopes_TO = new ArrayList<IIsotope>();
    Iterator<IIsotope> isIt = mfRange.isotopes().iterator();
    while (isIt.hasNext()) isotopes_TO.add(isIt.next());
    isotopes_TO = orderList(isotopes_TO);
    for (int i = 0; i < matrix.length; i++) {
        int[] value_In = new int[numberElements];
        for (int j = 0; j < numberElements; j++) {
            if (matrix[i][j] == 0)
                value_In[j] = 0;
            else
                value_In[j] = 1;
        }
        int count_E = 0;
        ArrayList<Integer> elem_Pos = new ArrayList<Integer>();
        for (int j = 0; j < matrix[1].length; j++) if (value_In[j] != 0) {
            count_E++;
            elem_Pos.add(j);
        }
        boolean flag = true;
        int possChan = 0;
        String lastMFString = """";
        while (flag) {
            boolean flagBreak = false;
            for (int j = 0; j < matrix[1].length; j++) {
                int min = mfRange.getIsotopeCountMin(isotopes_TO.get(j));
                if (value_In[j] == 0)
                    if (min != 0)
                        flagBreak = true;
            }
            if (flagBreak)
                break;
            int occurence = getMaxOccurence(mass, elem_Pos.get(possChan).intValue(), value_In, isotopes_TO);
            if (occurence == 0)
                break;
            int maxx = mfRange.getIsotopeCountMax(isotopes_TO.get(elem_Pos.get(possChan).intValue()));
            int minn = mfRange.getIsotopeCountMin(isotopes_TO.get(elem_Pos.get(possChan).intValue()));
            if (occurence < minn | maxx < occurence) {
                if (possChan < elem_Pos.size() - 1) {
                    if (maxx < occurence)
                        value_In[elem_Pos.get(possChan).intValue()] = maxx;
                    possChan++;
                } else {
                    boolean foundZ = false;
                    for (int z = possChan - 1; z >= 0; z--) {
                        if (value_In[elem_Pos.get(z).intValue()] != 1) {
                            possChan = z;
                            foundZ = true;
                            int newValue = value_In[elem_Pos.get(possChan).intValue()] - 1;
                            value_In[elem_Pos.get(possChan).intValue()] = newValue;
                            for (int j = possChan + 1; j < elem_Pos.size(); j++) {
                                int p = elem_Pos.get(j).intValue();
                                value_In[p] = 1;
                            }
                            possChan++;
                            break;
                        }
                    }
                    if (!foundZ)
                        break;
                }
                continue;
            }
            value_In[elem_Pos.get(possChan).intValue()] = occurence;
            double massT = calculateMassT(isotopes_TO, value_In);
            double diff_new = Math.abs(mass - (massT));
            if (diff_new < tolerance) {
                IMolecularFormula myMF = getFormula(isotopes_TO, value_In);
                String newMFString = MolecularFormulaManipulator.getString(myMF);
                if (!newMFString.equals(lastMFString)) {
                    molecularFormulaSet.addMolecularFormula(myMF);
                    lastMFString = newMFString;
                }
            }
            if (count_E == 1)
                break;
            if (possChan < elem_Pos.size() - 1) {
                possChan++;
            } else {
                boolean foundZ = false;
                for (int z = possChan - 1; z >= 0; z--) {
                    if (value_In[elem_Pos.get(z).intValue()] != 1) {
                        possChan = z;
                        foundZ = true;
                        int newValue = value_In[elem_Pos.get(possChan).intValue()] - 1;
                        value_In[elem_Pos.get(possChan).intValue()] = newValue;
                        for (int j = possChan + 1; j < elem_Pos.size(); j++) {
                            int p = elem_Pos.get(j).intValue();
                            value_In[p] = 1;
                        }
                        possChan++;
                        break;
                    }
                }
                if (!foundZ)
                    break;
            }
        }
    }
    return returnOrdered(mass, molecularFormulaSet);
}","/**
     * Method that actually does the work of extracting the molecular formula.
     *
     * @param  mass            molecular formula to create from the mass
     * @return                 the filled molecular formulas as IMolecularFormulaSet
     */","('generate', {'INSTRUCTION': {'covered': 462, 'missed': 1}, 'BRANCH': {'covered': 61, 'missed': 3}, 'LINE': {'covered': 89, 'missed': 0}, 'COMPLEXITY': {'covered': 30, 'missed': 3}, 'METHOD': {'covered': 1, 'missed': 0}})",951.0,  Method that actually does the work of extracting the molecular formula.,12.0,"['The method actually does the work.', 'The method is used to extract the formula.', 'The method actually does the work of getting the formula.']"
1115,cdk,org/openscience/cdk/qsar/descriptors/molecular/WHIMDescriptor.java,/descriptor/qsarmolecular/src/main/java/org/openscience/cdk/qsar/descriptors/molecular/WHIMDescriptor.java,calculate,301-450,"/**
     * Calculates 11 directional and 6 non-directional WHIM descriptors for.
     * the specified weighting scheme
     *
     * @param container Parameter is the atom container.
     * @return An ArrayList containing the descriptors in the order described above.
     */
public DescriptorValue calculate(IAtomContainer container){
    if (!GeometryUtil.has3DCoordinates(container))
        return getDummyDescriptorValue(new CDKException(""Molecule must have 3D coordinates""));
    double sum = 0.0;
    IAtomContainer ac;
    try {
        ac = (IAtomContainer) container.clone();
    } catch (CloneNotSupportedException e) {
        return getDummyDescriptorValue(e);
    }
    double[][] cmat = new double[ac.getAtomCount()][3];
    for (int i = 0; i < ac.getAtomCount(); i++) {
        Point3d coords = ac.getAtom(i).getPoint3d();
        cmat[i][0] = coords.x;
        cmat[i][1] = coords.y;
        cmat[i][2] = coords.z;
    }
    Map<String, Double> hash = null;
    double[] wt = new double[ac.getAtomCount()];
    if (this.type.equals(""unity"")) {
        for (int i = 0; i < ac.getAtomCount(); i++) wt[i] = 1.0;
    } else {
        if (this.type.equals(""mass"")) {
            hash = this.hashatwt;
        } else if (this.type.equals(""volume"")) {
            hash = this.hashvdw;
        } else if (this.type.equals(""eneg"")) {
            hash = this.hasheneg;
        } else if (this.type.equals(""polar"")) {
            hash = this.hashpol;
        }
        for (int i = 0; i < ac.getAtomCount(); i++) {
            String sym = ac.getAtom(i).getSymbol();
            wt[i] = (Double) hash.get(sym);
        }
    }
    PCA pcaobject = null;
    try {
        pcaobject = new PCA(cmat, wt);
    } catch (CDKException cdke) {
        logger.debug(cdke);
    }
    double[] lambda = pcaobject.getEigenvalues();
    double[] gamma = new double[3];
    double[] nu = new double[3];
    double[] eta = new double[3];
    for (int i = 0; i < 3; i++) sum += lambda[i];
    for (int i = 0; i < 3; i++) nu[i] = lambda[i] / sum;
    double[][] scores = pcaobject.getScores();
    for (int i = 0; i < 3; i++) {
        sum = 0.0;
        for (int j = 0; j < ac.getAtomCount(); j++) sum += scores[j][i] * scores[j][i] * scores[j][i] * scores[j][i];
        sum = sum / (lambda[i] * lambda[i] * ac.getAtomCount());
        eta[i] = 1.0 / sum;
    }
    for (int i = 0; i < 3; i++) {
        double ns = 0.0;
        double na = 0.0;
        for (int j = 0; j < ac.getAtomCount(); j++) {
            boolean foundmatch = false;
            for (int k = 0; k < ac.getAtomCount(); k++) {
                if (k == j)
                    continue;
                if (scores[j][i] == -1 * scores[k][i]) {
                    ns++;
                    foundmatch = true;
                    break;
                }
            }
            if (!foundmatch)
                na++;
        }
        double n = (double) ac.getAtomCount();
        gamma[i] = -1.0 * ((ns / n) * Math.log(ns / n) / Math.log(2.0) + (na / n) * Math.log(1.0 / n) / Math.log(2.0));
        gamma[i] = 1.0 / (1.0 + gamma[i]);
    }
    double t = lambda[0] + lambda[1] + lambda[2];
    double a = lambda[0] * lambda[1] + lambda[0] * lambda[2] + lambda[1] * lambda[2];
    double v = t + a + lambda[0] * lambda[1] * lambda[2];
    double k = 0.0;
    sum = 0.0;
    for (int i = 0; i < 3; i++) sum += lambda[i];
    for (int i = 0; i < 3; i++) k = (lambda[i] / sum) - (1.0 / 3.0);
    k = k / (4.0 / 3.0);
    double g = Math.pow(gamma[0] * gamma[1] * gamma[2], 1.0 / 3.0);
    double d = eta[0] + eta[1] + eta[2];
    DoubleArrayResult retval = new DoubleArrayResult(11 + 6);
    retval.add(lambda[0]);
    retval.add(lambda[1]);
    retval.add(lambda[2]);
    retval.add(nu[0]);
    retval.add(nu[1]);
    retval.add(gamma[0]);
    retval.add(gamma[1]);
    retval.add(gamma[2]);
    retval.add(eta[0]);
    retval.add(eta[1]);
    retval.add(eta[2]);
    retval.add(t);
    retval.add(a);
    retval.add(v);
    retval.add(k);
    retval.add(g);
    retval.add(d);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), retval, getDescriptorNames());
}","public DescriptorValue calculate(IAtomContainer container){
    if (!GeometryUtil.has3DCoordinates(container))
        return getDummyDescriptorValue(new CDKException(""Molecule must have 3D coordinates""));
    double sum = 0.0;
    IAtomContainer ac;
    try {
        ac = (IAtomContainer) container.clone();
    } catch (CloneNotSupportedException e) {
        return getDummyDescriptorValue(e);
    }
    double[][] cmat = new double[ac.getAtomCount()][3];
    for (int i = 0; i < ac.getAtomCount(); i++) {
        Point3d coords = ac.getAtom(i).getPoint3d();
        cmat[i][0] = coords.x;
        cmat[i][1] = coords.y;
        cmat[i][2] = coords.z;
    }
    Map<String, Double> hash = null;
    double[] wt = new double[ac.getAtomCount()];
    if (this.type.equals(""unity"")) {
        for (int i = 0; i < ac.getAtomCount(); i++) wt[i] = 1.0;
    } else {
        if (this.type.equals(""mass"")) {
            hash = this.hashatwt;
        } else if (this.type.equals(""volume"")) {
            hash = this.hashvdw;
        } else if (this.type.equals(""eneg"")) {
            hash = this.hasheneg;
        } else if (this.type.equals(""polar"")) {
            hash = this.hashpol;
        }
        for (int i = 0; i < ac.getAtomCount(); i++) {
            String sym = ac.getAtom(i).getSymbol();
            wt[i] = (Double) hash.get(sym);
        }
    }
    PCA pcaobject = null;
    try {
        pcaobject = new PCA(cmat, wt);
    } catch (CDKException cdke) {
        logger.debug(cdke);
    }
    double[] lambda = pcaobject.getEigenvalues();
    double[] gamma = new double[3];
    double[] nu = new double[3];
    double[] eta = new double[3];
    for (int i = 0; i < 3; i++) sum += lambda[i];
    for (int i = 0; i < 3; i++) nu[i] = lambda[i] / sum;
    double[][] scores = pcaobject.getScores();
    for (int i = 0; i < 3; i++) {
        sum = 0.0;
        for (int j = 0; j < ac.getAtomCount(); j++) sum += scores[j][i] * scores[j][i] * scores[j][i] * scores[j][i];
        sum = sum / (lambda[i] * lambda[i] * ac.getAtomCount());
        eta[i] = 1.0 / sum;
    }
    for (int i = 0; i < 3; i++) {
        double ns = 0.0;
        double na = 0.0;
        for (int j = 0; j < ac.getAtomCount(); j++) {
            boolean foundmatch = false;
            for (int k = 0; k < ac.getAtomCount(); k++) {
                if (k == j)
                    continue;
                if (scores[j][i] == -1 * scores[k][i]) {
                    ns++;
                    foundmatch = true;
                    break;
                }
            }
            if (!foundmatch)
                na++;
        }
        double n = (double) ac.getAtomCount();
        gamma[i] = -1.0 * ((ns / n) * Math.log(ns / n) / Math.log(2.0) + (na / n) * Math.log(1.0 / n) / Math.log(2.0));
        gamma[i] = 1.0 / (1.0 + gamma[i]);
    }
    double t = lambda[0] + lambda[1] + lambda[2];
    double a = lambda[0] * lambda[1] + lambda[0] * lambda[2] + lambda[1] * lambda[2];
    double v = t + a + lambda[0] * lambda[1] * lambda[2];
    double k = 0.0;
    sum = 0.0;
    for (int i = 0; i < 3; i++) sum += lambda[i];
    for (int i = 0; i < 3; i++) k = (lambda[i] / sum) - (1.0 / 3.0);
    k = k / (4.0 / 3.0);
    double g = Math.pow(gamma[0] * gamma[1] * gamma[2], 1.0 / 3.0);
    double d = eta[0] + eta[1] + eta[2];
    DoubleArrayResult retval = new DoubleArrayResult(11 + 6);
    retval.add(lambda[0]);
    retval.add(lambda[1]);
    retval.add(lambda[2]);
    retval.add(nu[0]);
    retval.add(nu[1]);
    retval.add(gamma[0]);
    retval.add(gamma[1]);
    retval.add(gamma[2]);
    retval.add(eta[0]);
    retval.add(eta[1]);
    retval.add(eta[2]);
    retval.add(t);
    retval.add(a);
    retval.add(v);
    retval.add(k);
    retval.add(g);
    retval.add(d);
    return new DescriptorValue(getSpecification(), getParameterNames(), getParameters(), retval, getDescriptorNames());
}","/**
     * Calculates 11 directional and 6 non-directional WHIM descriptors for.
     * the specified weighting scheme
     *
     * @param container Parameter is the atom container.
     * @return An ArrayList containing the descriptors in the order described above.
     */","('calculate', {'INSTRUCTION': {'covered': 502, 'missed': 65}, 'BRANCH': {'covered': 31, 'missed': 11}, 'LINE': {'covered': 82, 'missed': 15}, 'COMPLEXITY': {'covered': 16, 'missed': 6}, 'METHOD': {'covered': 1, 'missed': 0}})",1163.0,Calculates 11 directional and 6 non-directional WHIM descriptors for.,10.0,"['Determines 11 and 6 WHIM descriptors.', '11 and 6 WHIM descriptors were calculated.', '11 and 6 WHIM descriptors are calculated.']"
1116,cdk,org/openscience/cdk/smiles/BeamToCDK.java,/storage/smiles/src/main/java/org/openscience/cdk/smiles/BeamToCDK.java,addDoubleBondStereochemistry,258-417,"/**
     * Adds double-bond conformations ({@link DoubleBondStereochemistry}) to the
     * atom-container.
     *
     * @param g  Beam graph object (for directional bonds)
     * @param ac The atom-container built from the Beam graph
     */
private void addDoubleBondStereochemistry(Graph g, IAtomContainer ac){
    for (final Edge e : g.edges()) {
        if (e.bond() != Bond.DOUBLE)
            continue;
        int u = e.either();
        int v = e.other(u);
        Edge first = null;
        Edge second = null;
        if ((first = findDirectionalEdge(g, u)) != null) {
            if ((second = findDirectionalEdge(g, v)) != null) {
                Conformation conformation = first.bond(u) == second.bond(v) ? Conformation.TOGETHER : Conformation.OPPOSITE;
                IBond db = ac.getBond(ac.getAtom(u), ac.getAtom(v));
                IBond[] ligands = new IBond[] { ac.getBond(ac.getAtom(u), ac.getAtom(first.other(u))), ac.getBond(ac.getAtom(v), ac.getAtom(second.other(v))) };
                ac.addStereoElement(new DoubleBondStereochemistry(db, ligands, conformation));
            } else if (g.degree(v) == 2) {
                List<Edge> edges = new ArrayList<>();
                edges.add(e);
                Edge f = findCumulatedEdge(g, v, e);
                int beg = v;
                while (f != null) {
                    edges.add(f);
                    v = f.other(v);
                    f = findCumulatedEdge(g, v, f);
                    if (beg == v) {
                        beg = -1;
                        break;
                    }
                }
                if (beg < 0)
                    continue;
                if ((edges.size() & 0x1) == 0)
                    continue;
                second = findDirectionalEdge(g, v);
                if (second != null) {
                    int cfg = first.bond(u) == second.bond(v) ? IStereoElement.TOGETHER : IStereoElement.OPPOSITE;
                    Edge middleEdge = edges.get(edges.size() / 2);
                    IBond middleBond = ac.getBond(ac.getAtom(middleEdge.either()), ac.getAtom(middleEdge.other(middleEdge.either())));
                    IBond[] ligands = new IBond[] { ac.getBond(ac.getAtom(u), ac.getAtom(first.other(u))), ac.getBond(ac.getAtom(v), ac.getAtom(second.other(v))) };
                    ac.addStereoElement(new ExtendedCisTrans(middleBond, ligands, cfg));
                }
            }
        } else {
            Configuration uConf = g.configurationOf(u);
            Configuration vConf = g.configurationOf(v);
            if (uConf.type() == Configuration.Type.DoubleBond && vConf.type() == Configuration.Type.DoubleBond) {
                int[] nbrs = new int[6];
                int[] uNbrs = g.neighbors(u);
                int[] vNbrs = g.neighbors(v);
                if (uNbrs.length < 2 || uNbrs.length > 3)
                    continue;
                if (vNbrs.length < 2 || vNbrs.length > 3)
                    continue;
                int idx = 0;
                System.arraycopy(uNbrs, 0, nbrs, idx, uNbrs.length);
                idx += uNbrs.length;
                if (uNbrs.length == 2)
                    nbrs[idx++] = u;
                System.arraycopy(vNbrs, 0, nbrs, idx, vNbrs.length);
                idx += vNbrs.length;
                if (vNbrs.length == 2)
                    nbrs[idx] = v;
                Arrays.sort(nbrs, 0, 3);
                Arrays.sort(nbrs, 3, 6);
                int vPos = Arrays.binarySearch(nbrs, 0, 3, v);
                int uPos = Arrays.binarySearch(nbrs, 3, 6, u);
                int uhi = 0, ulo = 0;
                int vhi = 0, vlo = 0;
                uhi = nbrs[(vPos + 1) % 3];
                ulo = nbrs[(vPos + 2) % 3];
                vhi = nbrs[3 + ((uPos + 1) % 3)];
                vlo = nbrs[3 + ((uPos + 2) % 3)];
                if (uConf.shorthand() == Configuration.CLOCKWISE) {
                    int tmp = uhi;
                    uhi = ulo;
                    ulo = tmp;
                }
                if (vConf.shorthand() == Configuration.ANTI_CLOCKWISE) {
                    int tmp = vhi;
                    vhi = vlo;
                    vlo = tmp;
                }
                DoubleBondStereochemistry.Conformation conf = null;
                IBond[] bonds = new IBond[2];
                if (uhi != u) {
                    bonds[0] = ac.getBond(ac.getAtom(u), ac.getAtom(uhi));
                    if (vhi != v) {
                        conf = Conformation.TOGETHER;
                        bonds[1] = ac.getBond(ac.getAtom(v), ac.getAtom(vhi));
                    } else if (vlo != v) {
                        conf = Conformation.OPPOSITE;
                        bonds[1] = ac.getBond(ac.getAtom(v), ac.getAtom(vlo));
                    }
                } else if (ulo != u) {
                    bonds[0] = ac.getBond(ac.getAtom(u), ac.getAtom(ulo));
                    if (vhi != v) {
                        conf = Conformation.OPPOSITE;
                        bonds[1] = ac.getBond(ac.getAtom(v), ac.getAtom(vhi));
                    } else if (vlo != v) {
                        conf = Conformation.TOGETHER;
                        bonds[1] = ac.getBond(ac.getAtom(v), ac.getAtom(vlo));
                    }
                }
                ac.addStereoElement(new DoubleBondStereochemistry(ac.getBond(ac.getAtom(u), ac.getAtom(v)), bonds, conf));
            }
        }
    }
}","private void addDoubleBondStereochemistry(Graph g, IAtomContainer ac){
    for (final Edge e : g.edges()) {
        if (e.bond() != Bond.DOUBLE)
            continue;
        int u = e.either();
        int v = e.other(u);
        Edge first = null;
        Edge second = null;
        if ((first = findDirectionalEdge(g, u)) != null) {
            if ((second = findDirectionalEdge(g, v)) != null) {
                Conformation conformation = first.bond(u) == second.bond(v) ? Conformation.TOGETHER : Conformation.OPPOSITE;
                IBond db = ac.getBond(ac.getAtom(u), ac.getAtom(v));
                IBond[] ligands = new IBond[] { ac.getBond(ac.getAtom(u), ac.getAtom(first.other(u))), ac.getBond(ac.getAtom(v), ac.getAtom(second.other(v))) };
                ac.addStereoElement(new DoubleBondStereochemistry(db, ligands, conformation));
            } else if (g.degree(v) == 2) {
                List<Edge> edges = new ArrayList<>();
                edges.add(e);
                Edge f = findCumulatedEdge(g, v, e);
                int beg = v;
                while (f != null) {
                    edges.add(f);
                    v = f.other(v);
                    f = findCumulatedEdge(g, v, f);
                    if (beg == v) {
                        beg = -1;
                        break;
                    }
                }
                if (beg < 0)
                    continue;
                if ((edges.size() & 0x1) == 0)
                    continue;
                second = findDirectionalEdge(g, v);
                if (second != null) {
                    int cfg = first.bond(u) == second.bond(v) ? IStereoElement.TOGETHER : IStereoElement.OPPOSITE;
                    Edge middleEdge = edges.get(edges.size() / 2);
                    IBond middleBond = ac.getBond(ac.getAtom(middleEdge.either()), ac.getAtom(middleEdge.other(middleEdge.either())));
                    IBond[] ligands = new IBond[] { ac.getBond(ac.getAtom(u), ac.getAtom(first.other(u))), ac.getBond(ac.getAtom(v), ac.getAtom(second.other(v))) };
                    ac.addStereoElement(new ExtendedCisTrans(middleBond, ligands, cfg));
                }
            }
        } else {
            Configuration uConf = g.configurationOf(u);
            Configuration vConf = g.configurationOf(v);
            if (uConf.type() == Configuration.Type.DoubleBond && vConf.type() == Configuration.Type.DoubleBond) {
                int[] nbrs = new int[6];
                int[] uNbrs = g.neighbors(u);
                int[] vNbrs = g.neighbors(v);
                if (uNbrs.length < 2 || uNbrs.length > 3)
                    continue;
                if (vNbrs.length < 2 || vNbrs.length > 3)
                    continue;
                int idx = 0;
                System.arraycopy(uNbrs, 0, nbrs, idx, uNbrs.length);
                idx += uNbrs.length;
                if (uNbrs.length == 2)
                    nbrs[idx++] = u;
                System.arraycopy(vNbrs, 0, nbrs, idx, vNbrs.length);
                idx += vNbrs.length;
                if (vNbrs.length == 2)
                    nbrs[idx] = v;
                Arrays.sort(nbrs, 0, 3);
                Arrays.sort(nbrs, 3, 6);
                int vPos = Arrays.binarySearch(nbrs, 0, 3, v);
                int uPos = Arrays.binarySearch(nbrs, 3, 6, u);
                int uhi = 0, ulo = 0;
                int vhi = 0, vlo = 0;
                uhi = nbrs[(vPos + 1) % 3];
                ulo = nbrs[(vPos + 2) % 3];
                vhi = nbrs[3 + ((uPos + 1) % 3)];
                vlo = nbrs[3 + ((uPos + 2) % 3)];
                if (uConf.shorthand() == Configuration.CLOCKWISE) {
                    int tmp = uhi;
                    uhi = ulo;
                    ulo = tmp;
                }
                if (vConf.shorthand() == Configuration.ANTI_CLOCKWISE) {
                    int tmp = vhi;
                    vhi = vlo;
                    vlo = tmp;
                }
                DoubleBondStereochemistry.Conformation conf = null;
                IBond[] bonds = new IBond[2];
                if (uhi != u) {
                    bonds[0] = ac.getBond(ac.getAtom(u), ac.getAtom(uhi));
                    if (vhi != v) {
                        conf = Conformation.TOGETHER;
                        bonds[1] = ac.getBond(ac.getAtom(v), ac.getAtom(vhi));
                    } else if (vlo != v) {
                        conf = Conformation.OPPOSITE;
                        bonds[1] = ac.getBond(ac.getAtom(v), ac.getAtom(vlo));
                    }
                } else if (ulo != u) {
                    bonds[0] = ac.getBond(ac.getAtom(u), ac.getAtom(ulo));
                    if (vhi != v) {
                        conf = Conformation.OPPOSITE;
                        bonds[1] = ac.getBond(ac.getAtom(v), ac.getAtom(vhi));
                    } else if (vlo != v) {
                        conf = Conformation.TOGETHER;
                        bonds[1] = ac.getBond(ac.getAtom(v), ac.getAtom(vlo));
                    }
                }
                ac.addStereoElement(new DoubleBondStereochemistry(ac.getBond(ac.getAtom(u), ac.getAtom(v)), bonds, conf));
            }
        }
    }
}","/**
     * Adds double-bond conformations ({@link DoubleBondStereochemistry}) to the
     * atom-container.
     *
     * @param g  Beam graph object (for directional bonds)
     * @param ac The atom-container built from the Beam graph
     */","('addDoubleBondStereochemistry', {'INSTRUCTION': {'covered': 515, 'missed': 2}, 'BRANCH': {'covered': 46, 'missed': 10}, 'LINE': {'covered': 99, 'missed': 2}, 'COMPLEXITY': {'covered': 19, 'missed': 10}, 'METHOD': {'covered': 1, 'missed': 0}})",1171.0,  Adds double-bond conformations ({@link DoubleBondStereochemistry}) to the  atom-container.,14.0,"['Adds double-bonds to the atom-container.', 'Adds double-bonds to the atom container.', 'Adds double-bond conformations to the atom-container.']"
1120,cdk,org/openscience/cdk/inchi/InChIToStructure.java,/storage/inchi/src/main/java/org/openscience/cdk/inchi/InChIToStructure.java,generateAtomContainerFromInchi,158-384,"/**
     * Gets structure from InChI, and converts InChI library data structure
     * into an IAtomContainer.
     *
     * @throws CDKException
     */
protected void generateAtomContainerFromInchi(IChemObjectBuilder builder) throws CDKException{
    InchiInput input = output.getInchiInput();
    molecule = builder.newInstance(IAtomContainer.class);
    Map<InchiAtom, IAtom> inchiCdkAtomMap = new HashMap<InchiAtom, IAtom>();
    List<InchiAtom> atoms = input.getAtoms();
    for (int i = 0; i < atoms.size(); i++) {
        InchiAtom iAt = atoms.get(i);
        IAtom cAt = builder.newInstance(IAtom.class);
        inchiCdkAtomMap.put(iAt, cAt);
        cAt.setID(""a"" + i);
        cAt.setAtomicNumber(Elements.ofString(iAt.getElName()).number());
        cAt.setFormalCharge(iAt.getCharge());
        cAt.setImplicitHydrogenCount(iAt.getImplicitHydrogen());
        int isotopicMass = iAt.getIsotopicMass();
        if (isotopicMass != 0) {
            if (isotopicMass > ISOTOPIC_SHIFT_THRESHOLD) {
                try {
                    int massNumber = Isotopes.getInstance().getMajorIsotope(cAt.getAtomicNumber()).getMassNumber();
                    cAt.setMassNumber(massNumber + (isotopicMass - ISOTOPIC_SHIFT_FLAG));
                } catch (IOException e) {
                    throw new CDKException(""Could not load Isotopes data"", e);
                }
            } else {
                cAt.setMassNumber(isotopicMass);
            }
        }
        molecule.addAtom(cAt);
        cAt = molecule.getAtom(molecule.getAtomCount() - 1);
        addHydrogenIsotopes(builder, cAt, 2, iAt.getImplicitDeuterium());
        addHydrogenIsotopes(builder, cAt, 3, iAt.getImplicitTritium());
    }
    List<InchiBond> bonds = input.getBonds();
    for (int i = 0; i < bonds.size(); i++) {
        InchiBond iBo = bonds.get(i);
        IBond cBo = builder.newInstance(IBond.class);
        IAtom atO = inchiCdkAtomMap.get(iBo.getStart());
        IAtom atT = inchiCdkAtomMap.get(iBo.getEnd());
        cBo.setAtoms(new IAtom[] { atO, atT });
        InchiBondType type = iBo.getType();
        switch(type) {
            case SINGLE:
                cBo.setOrder(IBond.Order.SINGLE);
                break;
            case DOUBLE:
                cBo.setOrder(IBond.Order.DOUBLE);
                break;
            case TRIPLE:
                cBo.setOrder(IBond.Order.TRIPLE);
                break;
            case ALTERN:
                cBo.setIsInRing(true);
                break;
            default:
                throw new CDKException(""Unknown bond type: "" + type);
        }
        InchiBondStereo stereo = iBo.getStereo();
        switch(stereo) {
            case NONE:
                cBo.setStereo(IBond.Stereo.NONE);
                break;
            case SINGLE_1DOWN:
                cBo.setStereo(IBond.Stereo.DOWN);
                break;
            case SINGLE_1UP:
                cBo.setStereo(IBond.Stereo.UP);
                break;
            case SINGLE_2DOWN:
                cBo.setStereo(IBond.Stereo.DOWN_INVERTED);
                break;
            case SINGLE_2UP:
                cBo.setStereo(IBond.Stereo.UP_INVERTED);
                break;
            case SINGLE_1EITHER:
                cBo.setStereo(IBond.Stereo.UP_OR_DOWN);
                break;
            case SINGLE_2EITHER:
                cBo.setStereo(IBond.Stereo.UP_OR_DOWN_INVERTED);
                break;
        }
        molecule.addBond(cBo);
    }
    List<InchiStereo> stereos = input.getStereos();
    for (int i = 0; i < stereos.size(); i++) {
        InchiStereo stereo0d = stereos.get(i);
        if (stereo0d.getType() == InchiStereoType.Tetrahedral || stereo0d.getType() == InchiStereoType.Allene) {
            InchiAtom central = stereo0d.getCentralAtom();
            InchiAtom[] neighbours = stereo0d.getAtoms();
            IAtom focus = inchiCdkAtomMap.get(central);
            IAtom[] neighbors = new IAtom[] { inchiCdkAtomMap.get(neighbours[0]), inchiCdkAtomMap.get(neighbours[1]), inchiCdkAtomMap.get(neighbours[2]), inchiCdkAtomMap.get(neighbours[3]) };
            ITetrahedralChirality.Stereo stereo;
            if (stereo0d.getParity() == InchiStereoParity.ODD) {
                stereo = ITetrahedralChirality.Stereo.ANTI_CLOCKWISE;
            } else if (stereo0d.getParity() == InchiStereoParity.EVEN) {
                stereo = ITetrahedralChirality.Stereo.CLOCKWISE;
            } else {
                continue;
            }
            IStereoElement stereoElement = null;
            if (stereo0d.getType() == InchiStereoType.Tetrahedral) {
                stereoElement = builder.newInstance(ITetrahedralChirality.class, focus, neighbors, stereo);
            } else if (stereo0d.getType() == InchiStereoType.Allene) {
                IAtom[] peripherals = neighbors;
                IAtom[] terminals = ExtendedTetrahedral.findTerminalAtoms(molecule, focus);
                for (IAtom terminal : terminals) {
                    if (peripherals[1].equals(terminal)) {
                        peripherals[1] = findOtherSinglyBonded(molecule, terminal, peripherals[0]);
                    } else if (peripherals[2].equals(terminal)) {
                        peripherals[2] = findOtherSinglyBonded(molecule, terminal, peripherals[3]);
                    } else if (peripherals[0].equals(terminal)) {
                        peripherals[0] = findOtherSinglyBonded(molecule, terminal, peripherals[1]);
                    } else if (peripherals[3].equals(terminal)) {
                        peripherals[3] = findOtherSinglyBonded(molecule, terminal, peripherals[2]);
                    }
                }
                stereoElement = new ExtendedTetrahedral(focus, peripherals, stereo);
            }
            assert stereoElement != null;
            molecule.addStereoElement(stereoElement);
        } else if (stereo0d.getType() == InchiStereoType.DoubleBond) {
            boolean extended = false;
            InchiAtom[] neighbors = stereo0d.getAtoms();
            IAtom x = inchiCdkAtomMap.get(neighbors[0]);
            IAtom a = inchiCdkAtomMap.get(neighbors[1]);
            IAtom b = inchiCdkAtomMap.get(neighbors[2]);
            IAtom y = inchiCdkAtomMap.get(neighbors[3]);
            IBond stereoBond = molecule.getBond(a, b);
            if (stereoBond == null) {
                extended = true;
                IBond tmp = null;
                stereoBond = ExtendedCisTrans.findCentralBond(molecule, a);
                if (stereoBond == null)
                    continue;
                IAtom[] ends = ExtendedCisTrans.findTerminalAtoms(molecule, stereoBond);
                assert ends != null;
                if (ends[0] != a)
                    flip(stereoBond);
            } else {
                if (!stereoBond.getBegin().equals(a))
                    flip(stereoBond);
            }
            int config = IStereoElement.TOGETHER;
            if (stereo0d.getParity() == InchiStereoParity.EVEN)
                config = IStereoElement.OPPOSITE;
            if (extended) {
                molecule.addStereoElement(new ExtendedCisTrans(stereoBond, new IBond[] { molecule.getBond(x, a), molecule.getBond(b, y) }, config));
            } else {
                molecule.addStereoElement(new DoubleBondStereochemistry(stereoBond, new IBond[] { molecule.getBond(x, a), molecule.getBond(b, y) }, config));
            }
        }
    }
}","protected void generateAtomContainerFromInchi(IChemObjectBuilder builder) throws CDKException{
    InchiInput input = output.getInchiInput();
    molecule = builder.newInstance(IAtomContainer.class);
    Map<InchiAtom, IAtom> inchiCdkAtomMap = new HashMap<InchiAtom, IAtom>();
    List<InchiAtom> atoms = input.getAtoms();
    for (int i = 0; i < atoms.size(); i++) {
        InchiAtom iAt = atoms.get(i);
        IAtom cAt = builder.newInstance(IAtom.class);
        inchiCdkAtomMap.put(iAt, cAt);
        cAt.setID(""a"" + i);
        cAt.setAtomicNumber(Elements.ofString(iAt.getElName()).number());
        cAt.setFormalCharge(iAt.getCharge());
        cAt.setImplicitHydrogenCount(iAt.getImplicitHydrogen());
        int isotopicMass = iAt.getIsotopicMass();
        if (isotopicMass != 0) {
            if (isotopicMass > ISOTOPIC_SHIFT_THRESHOLD) {
                try {
                    int massNumber = Isotopes.getInstance().getMajorIsotope(cAt.getAtomicNumber()).getMassNumber();
                    cAt.setMassNumber(massNumber + (isotopicMass - ISOTOPIC_SHIFT_FLAG));
                } catch (IOException e) {
                    throw new CDKException(""Could not load Isotopes data"", e);
                }
            } else {
                cAt.setMassNumber(isotopicMass);
            }
        }
        molecule.addAtom(cAt);
        cAt = molecule.getAtom(molecule.getAtomCount() - 1);
        addHydrogenIsotopes(builder, cAt, 2, iAt.getImplicitDeuterium());
        addHydrogenIsotopes(builder, cAt, 3, iAt.getImplicitTritium());
    }
    List<InchiBond> bonds = input.getBonds();
    for (int i = 0; i < bonds.size(); i++) {
        InchiBond iBo = bonds.get(i);
        IBond cBo = builder.newInstance(IBond.class);
        IAtom atO = inchiCdkAtomMap.get(iBo.getStart());
        IAtom atT = inchiCdkAtomMap.get(iBo.getEnd());
        cBo.setAtoms(new IAtom[] { atO, atT });
        InchiBondType type = iBo.getType();
        switch(type) {
            case SINGLE:
                cBo.setOrder(IBond.Order.SINGLE);
                break;
            case DOUBLE:
                cBo.setOrder(IBond.Order.DOUBLE);
                break;
            case TRIPLE:
                cBo.setOrder(IBond.Order.TRIPLE);
                break;
            case ALTERN:
                cBo.setIsInRing(true);
                break;
            default:
                throw new CDKException(""Unknown bond type: "" + type);
        }
        InchiBondStereo stereo = iBo.getStereo();
        switch(stereo) {
            case NONE:
                cBo.setStereo(IBond.Stereo.NONE);
                break;
            case SINGLE_1DOWN:
                cBo.setStereo(IBond.Stereo.DOWN);
                break;
            case SINGLE_1UP:
                cBo.setStereo(IBond.Stereo.UP);
                break;
            case SINGLE_2DOWN:
                cBo.setStereo(IBond.Stereo.DOWN_INVERTED);
                break;
            case SINGLE_2UP:
                cBo.setStereo(IBond.Stereo.UP_INVERTED);
                break;
            case SINGLE_1EITHER:
                cBo.setStereo(IBond.Stereo.UP_OR_DOWN);
                break;
            case SINGLE_2EITHER:
                cBo.setStereo(IBond.Stereo.UP_OR_DOWN_INVERTED);
                break;
        }
        molecule.addBond(cBo);
    }
    List<InchiStereo> stereos = input.getStereos();
    for (int i = 0; i < stereos.size(); i++) {
        InchiStereo stereo0d = stereos.get(i);
        if (stereo0d.getType() == InchiStereoType.Tetrahedral || stereo0d.getType() == InchiStereoType.Allene) {
            InchiAtom central = stereo0d.getCentralAtom();
            InchiAtom[] neighbours = stereo0d.getAtoms();
            IAtom focus = inchiCdkAtomMap.get(central);
            IAtom[] neighbors = new IAtom[] { inchiCdkAtomMap.get(neighbours[0]), inchiCdkAtomMap.get(neighbours[1]), inchiCdkAtomMap.get(neighbours[2]), inchiCdkAtomMap.get(neighbours[3]) };
            ITetrahedralChirality.Stereo stereo;
            if (stereo0d.getParity() == InchiStereoParity.ODD) {
                stereo = ITetrahedralChirality.Stereo.ANTI_CLOCKWISE;
            } else if (stereo0d.getParity() == InchiStereoParity.EVEN) {
                stereo = ITetrahedralChirality.Stereo.CLOCKWISE;
            } else {
                continue;
            }
            IStereoElement stereoElement = null;
            if (stereo0d.getType() == InchiStereoType.Tetrahedral) {
                stereoElement = builder.newInstance(ITetrahedralChirality.class, focus, neighbors, stereo);
            } else if (stereo0d.getType() == InchiStereoType.Allene) {
                IAtom[] peripherals = neighbors;
                IAtom[] terminals = ExtendedTetrahedral.findTerminalAtoms(molecule, focus);
                for (IAtom terminal : terminals) {
                    if (peripherals[1].equals(terminal)) {
                        peripherals[1] = findOtherSinglyBonded(molecule, terminal, peripherals[0]);
                    } else if (peripherals[2].equals(terminal)) {
                        peripherals[2] = findOtherSinglyBonded(molecule, terminal, peripherals[3]);
                    } else if (peripherals[0].equals(terminal)) {
                        peripherals[0] = findOtherSinglyBonded(molecule, terminal, peripherals[1]);
                    } else if (peripherals[3].equals(terminal)) {
                        peripherals[3] = findOtherSinglyBonded(molecule, terminal, peripherals[2]);
                    }
                }
                stereoElement = new ExtendedTetrahedral(focus, peripherals, stereo);
            }
            assert stereoElement != null;
            molecule.addStereoElement(stereoElement);
        } else if (stereo0d.getType() == InchiStereoType.DoubleBond) {
            boolean extended = false;
            InchiAtom[] neighbors = stereo0d.getAtoms();
            IAtom x = inchiCdkAtomMap.get(neighbors[0]);
            IAtom a = inchiCdkAtomMap.get(neighbors[1]);
            IAtom b = inchiCdkAtomMap.get(neighbors[2]);
            IAtom y = inchiCdkAtomMap.get(neighbors[3]);
            IBond stereoBond = molecule.getBond(a, b);
            if (stereoBond == null) {
                extended = true;
                IBond tmp = null;
                stereoBond = ExtendedCisTrans.findCentralBond(molecule, a);
                if (stereoBond == null)
                    continue;
                IAtom[] ends = ExtendedCisTrans.findTerminalAtoms(molecule, stereoBond);
                assert ends != null;
                if (ends[0] != a)
                    flip(stereoBond);
            } else {
                if (!stereoBond.getBegin().equals(a))
                    flip(stereoBond);
            }
            int config = IStereoElement.TOGETHER;
            if (stereo0d.getParity() == InchiStereoParity.EVEN)
                config = IStereoElement.OPPOSITE;
            if (extended) {
                molecule.addStereoElement(new ExtendedCisTrans(stereoBond, new IBond[] { molecule.getBond(x, a), molecule.getBond(b, y) }, config));
            } else {
                molecule.addStereoElement(new DoubleBondStereochemistry(stereoBond, new IBond[] { molecule.getBond(x, a), molecule.getBond(b, y) }, config));
            }
        }
    }
}","/**
     * Gets structure from InChI, and converts InChI library data structure
     * into an IAtomContainer.
     *
     * @throws CDKException
     */","('generateAtomContainerFromInchi', {'INSTRUCTION': {'covered': 515, 'missed': 119}, 'BRANCH': {'covered': 39, 'missed': 28}, 'LINE': {'covered': 97, 'missed': 26}, 'COMPLEXITY': {'covered': 13, 'missed': 26}, 'METHOD': {'covered': 1, 'missed': 0}})",1349.0,"  Gets structure from InChI, and converts InChI library data structure  into an IAtomContainer.",15.0,"['Gets structure from InChI and converts it into an IAtomContainer.', 'Gets structure and converts it into an IAtomContainer.', 'Gets structure from InChI and converts it into IAtomContainer.']"
1121,cdk,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,readAtomContainer,303-560,"/**
     * Read an IAtomContainer from a file in MDL sd format
     *
     * @return The Molecule that was read from the MDL file.
     */
private IAtomContainer readAtomContainer(IAtomContainer molecule) throws CDKException{
    boolean isQuery = molecule instanceof IQueryAtomContainer;
    IAtomContainer outputContainer = null;
    Map<IAtom, Integer> parities = new HashMap<>();
    int linecount = 0;
    String title = null;
    String program = null;
    String remark = null;
    String line = """";
    try {
        line = input.readLine();
        linecount++;
        if (line == null) {
            return null;
        }
        if (line.startsWith(""$$$$"")) {
            return molecule;
        }
        if (line.length() > 0) {
            title = line;
        }
        line = input.readLine();
        linecount++;
        program = line;
        line = input.readLine();
        linecount++;
        if (line.length() > 0) {
            remark = line;
        }
        line = input.readLine();
        linecount++;
        if (line.length() == 0) {
            handleError(""Unexpected empty line"", linecount, 0, 0);
            while (true) {
                line = input.readLine();
                linecount++;
                if (line == null) {
                    return null;
                }
                if (line.startsWith(""$$$$"")) {
                    return molecule;
                }
            }
        }
        final CTabVersion version = CTabVersion.ofHeader(line);
        if (version == CTabVersion.V3000) {
            handleError(""This file must be read with the MDLV3000Reader."");
            throw new CDKException(""This file must be read with the MDLV3000Reader."");
        } else if (version == CTabVersion.UNSPECIFIED) {
            handleError(""This file must be read with the MDLReader."");
        }
        int nAtoms = readMolfileInt(line, 0);
        int nBonds = readMolfileInt(line, 3);
        int chiral = readMolfileInt(line, 13);
        final IAtom[] atoms = new IAtom[nAtoms];
        final IBond[] bonds = new IBond[nBonds];
        int[] explicitValence = new int[nAtoms];
        boolean hasX = false, hasY = false, hasZ = false;
        for (int i = 0; i < nAtoms; i++) {
            line = input.readLine();
            linecount++;
            final IAtom atom = readAtomFast(line, molecule.getBuilder(), parities, linecount, isQuery);
            atoms[i] = atom;
            Point3d p = atom.getPoint3d();
            hasX = hasX || p.x != 0d;
            hasY = hasY || p.y != 0d;
            hasZ = hasZ || p.z != 0d;
        }
        if (!hasX && !hasY && !hasZ) {
            if (nAtoms == 1) {
                atoms[0].setPoint2d(new Point2d(0, 0));
            } else {
                for (IAtom atomToUpdate : atoms) {
                    atomToUpdate.setPoint3d(null);
                }
            }
        } else if (!hasZ) {
            if (is3Dfile(program)) {
                hasZ = true;
            } else if (!forceReadAs3DCoords.isSet()) {
                for (IAtom atomToUpdate : atoms) {
                    Point3d p3d = atomToUpdate.getPoint3d();
                    if (p3d != null) {
                        atomToUpdate.setPoint2d(new Point2d(p3d.x, p3d.y));
                        atomToUpdate.setPoint3d(null);
                    }
                }
            }
        }
        for (int i = 0; i < nBonds; i++) {
            line = input.readLine();
            linecount++;
            bonds[i] = readBondFast(line, molecule.getBuilder(), atoms, explicitValence, linecount, isQuery);
            isQuery = isQuery || bonds[i] instanceof IQueryBond || (bonds[i].getOrder() == IBond.Order.UNSET && !bonds[i].isAromatic());
        }
        if (!isQuery)
            outputContainer = molecule;
        else
            outputContainer = new QueryAtomContainer(molecule.getBuilder());
        if (title != null)
            outputContainer.setTitle(title);
        if (remark != null)
            outputContainer.setProperty(CDKConstants.REMARK, remark);
        if (outputContainer.isEmpty()) {
            outputContainer.setAtoms(atoms);
            outputContainer.setBonds(bonds);
        } else {
            for (IAtom atom : atoms) outputContainer.addAtom(atom);
            for (IBond bond : bonds) outputContainer.addBond(bond);
        }
        if (addStereoElements.isSet()) {
            Parities: for (Map.Entry<IAtom, Integer> e : parities.entrySet()) {
                int parity = e.getValue();
                if (parity != 1 && parity != 2)
                    continue;
                int idx = 0;
                IAtom focus = e.getKey();
                IAtom[] carriers = new IAtom[4];
                int hidx = -1;
                for (IAtom nbr : outputContainer.getConnectedAtomsList(focus)) {
                    if (idx == 4)
                        continue Parities;
                    if (nbr.getAtomicNumber() == 1) {
                        if (hidx >= 0)
                            continue Parities;
                        hidx = idx;
                    }
                    carriers[idx++] = nbr;
                }
                if (idx < 3 || idx < 4 && hidx >= 0)
                    continue;
                if (idx == 3)
                    carriers[idx++] = focus;
                if (idx == 4) {
                    Stereo winding = parity == 1 ? Stereo.CLOCKWISE : Stereo.ANTI_CLOCKWISE;
                    if (hidx == 0 || hidx == 2)
                        winding = winding.invert();
                    outputContainer.addStereoElement(new TetrahedralChirality(focus, carriers, winding));
                }
            }
        }
        readPropertiesFast(input, outputContainer, nAtoms);
        readNonStructuralData(input, outputContainer);
        int offset = outputContainer.getAtomCount() - nAtoms;
        for (int i = offset; i < outputContainer.getAtomCount(); i++) {
            int valence = explicitValence[i - offset];
            if (valence < 0) {
                isQuery = true;
            } else {
                int unpaired = outputContainer.getConnectedSingleElectronsCount(outputContainer.getAtom(i));
                applyMDLValenceModel(outputContainer.getAtom(i), valence + unpaired, unpaired);
            }
        }
        if (!(outputContainer instanceof IQueryAtomContainer) && !isQuery && addStereoElements.isSet() && hasX && hasY) {
            for (IAtom atom : outputContainer.atoms()) {
                if (AtomRef.deref(atom) instanceof QueryAtom) {
                    isQuery = true;
                    break;
                }
            }
            if (!isQuery) {
                if (hasZ) {
                    outputContainer.setStereoElements(StereoElementFactory.using3DCoordinates(outputContainer).createAll());
                } else if (!forceReadAs3DCoords.isSet()) {
                    outputContainer.setStereoElements(StereoElementFactory.using2DCoordinates(outputContainer).createAll());
                }
            }
        }
        if (chiral == 0) {
            for (IStereoElement<?, ?> se : outputContainer.stereoElements()) {
                if (se.getConfigClass() == IStereoElement.TH) {
                    se.setGroupInfo(IStereoElement.GRP_RAC1);
                }
            }
        }
    } catch (CDKException exception) {
        String error = ""Error while parsing line "" + linecount + "": "" + line + "" -> "" + exception.getMessage();
        logger.error(error);
        throw exception;
    } catch (IOException exception) {
        exception.printStackTrace();
        String error = ""Error while parsing line "" + linecount + "": "" + line + "" -> "" + exception.getMessage();
        logger.error(error);
        handleError(""Error while parsing line: "" + line, linecount, 0, 0, exception);
    }
    return outputContainer;
}","private IAtomContainer readAtomContainer(IAtomContainer molecule) throws CDKException{
    boolean isQuery = molecule instanceof IQueryAtomContainer;
    IAtomContainer outputContainer = null;
    Map<IAtom, Integer> parities = new HashMap<>();
    int linecount = 0;
    String title = null;
    String program = null;
    String remark = null;
    String line = """";
    try {
        line = input.readLine();
        linecount++;
        if (line == null) {
            return null;
        }
        if (line.startsWith(""$$$$"")) {
            return molecule;
        }
        if (line.length() > 0) {
            title = line;
        }
        line = input.readLine();
        linecount++;
        program = line;
        line = input.readLine();
        linecount++;
        if (line.length() > 0) {
            remark = line;
        }
        line = input.readLine();
        linecount++;
        if (line.length() == 0) {
            handleError(""Unexpected empty line"", linecount, 0, 0);
            while (true) {
                line = input.readLine();
                linecount++;
                if (line == null) {
                    return null;
                }
                if (line.startsWith(""$$$$"")) {
                    return molecule;
                }
            }
        }
        final CTabVersion version = CTabVersion.ofHeader(line);
        if (version == CTabVersion.V3000) {
            handleError(""This file must be read with the MDLV3000Reader."");
            throw new CDKException(""This file must be read with the MDLV3000Reader."");
        } else if (version == CTabVersion.UNSPECIFIED) {
            handleError(""This file must be read with the MDLReader."");
        }
        int nAtoms = readMolfileInt(line, 0);
        int nBonds = readMolfileInt(line, 3);
        int chiral = readMolfileInt(line, 13);
        final IAtom[] atoms = new IAtom[nAtoms];
        final IBond[] bonds = new IBond[nBonds];
        int[] explicitValence = new int[nAtoms];
        boolean hasX = false, hasY = false, hasZ = false;
        for (int i = 0; i < nAtoms; i++) {
            line = input.readLine();
            linecount++;
            final IAtom atom = readAtomFast(line, molecule.getBuilder(), parities, linecount, isQuery);
            atoms[i] = atom;
            Point3d p = atom.getPoint3d();
            hasX = hasX || p.x != 0d;
            hasY = hasY || p.y != 0d;
            hasZ = hasZ || p.z != 0d;
        }
        if (!hasX && !hasY && !hasZ) {
            if (nAtoms == 1) {
                atoms[0].setPoint2d(new Point2d(0, 0));
            } else {
                for (IAtom atomToUpdate : atoms) {
                    atomToUpdate.setPoint3d(null);
                }
            }
        } else if (!hasZ) {
            if (is3Dfile(program)) {
                hasZ = true;
            } else if (!forceReadAs3DCoords.isSet()) {
                for (IAtom atomToUpdate : atoms) {
                    Point3d p3d = atomToUpdate.getPoint3d();
                    if (p3d != null) {
                        atomToUpdate.setPoint2d(new Point2d(p3d.x, p3d.y));
                        atomToUpdate.setPoint3d(null);
                    }
                }
            }
        }
        for (int i = 0; i < nBonds; i++) {
            line = input.readLine();
            linecount++;
            bonds[i] = readBondFast(line, molecule.getBuilder(), atoms, explicitValence, linecount, isQuery);
            isQuery = isQuery || bonds[i] instanceof IQueryBond || (bonds[i].getOrder() == IBond.Order.UNSET && !bonds[i].isAromatic());
        }
        if (!isQuery)
            outputContainer = molecule;
        else
            outputContainer = new QueryAtomContainer(molecule.getBuilder());
        if (title != null)
            outputContainer.setTitle(title);
        if (remark != null)
            outputContainer.setProperty(CDKConstants.REMARK, remark);
        if (outputContainer.isEmpty()) {
            outputContainer.setAtoms(atoms);
            outputContainer.setBonds(bonds);
        } else {
            for (IAtom atom : atoms) outputContainer.addAtom(atom);
            for (IBond bond : bonds) outputContainer.addBond(bond);
        }
        if (addStereoElements.isSet()) {
            Parities: for (Map.Entry<IAtom, Integer> e : parities.entrySet()) {
                int parity = e.getValue();
                if (parity != 1 && parity != 2)
                    continue;
                int idx = 0;
                IAtom focus = e.getKey();
                IAtom[] carriers = new IAtom[4];
                int hidx = -1;
                for (IAtom nbr : outputContainer.getConnectedAtomsList(focus)) {
                    if (idx == 4)
                        continue Parities;
                    if (nbr.getAtomicNumber() == 1) {
                        if (hidx >= 0)
                            continue Parities;
                        hidx = idx;
                    }
                    carriers[idx++] = nbr;
                }
                if (idx < 3 || idx < 4 && hidx >= 0)
                    continue;
                if (idx == 3)
                    carriers[idx++] = focus;
                if (idx == 4) {
                    Stereo winding = parity == 1 ? Stereo.CLOCKWISE : Stereo.ANTI_CLOCKWISE;
                    if (hidx == 0 || hidx == 2)
                        winding = winding.invert();
                    outputContainer.addStereoElement(new TetrahedralChirality(focus, carriers, winding));
                }
            }
        }
        readPropertiesFast(input, outputContainer, nAtoms);
        readNonStructuralData(input, outputContainer);
        int offset = outputContainer.getAtomCount() - nAtoms;
        for (int i = offset; i < outputContainer.getAtomCount(); i++) {
            int valence = explicitValence[i - offset];
            if (valence < 0) {
                isQuery = true;
            } else {
                int unpaired = outputContainer.getConnectedSingleElectronsCount(outputContainer.getAtom(i));
                applyMDLValenceModel(outputContainer.getAtom(i), valence + unpaired, unpaired);
            }
        }
        if (!(outputContainer instanceof IQueryAtomContainer) && !isQuery && addStereoElements.isSet() && hasX && hasY) {
            for (IAtom atom : outputContainer.atoms()) {
                if (AtomRef.deref(atom) instanceof QueryAtom) {
                    isQuery = true;
                    break;
                }
            }
            if (!isQuery) {
                if (hasZ) {
                    outputContainer.setStereoElements(StereoElementFactory.using3DCoordinates(outputContainer).createAll());
                } else if (!forceReadAs3DCoords.isSet()) {
                    outputContainer.setStereoElements(StereoElementFactory.using2DCoordinates(outputContainer).createAll());
                }
            }
        }
        if (chiral == 0) {
            for (IStereoElement<?, ?> se : outputContainer.stereoElements()) {
                if (se.getConfigClass() == IStereoElement.TH) {
                    se.setGroupInfo(IStereoElement.GRP_RAC1);
                }
            }
        }
    } catch (CDKException exception) {
        String error = ""Error while parsing line "" + linecount + "": "" + line + "" -> "" + exception.getMessage();
        logger.error(error);
        throw exception;
    } catch (IOException exception) {
        exception.printStackTrace();
        String error = ""Error while parsing line "" + linecount + "": "" + line + "" -> "" + exception.getMessage();
        logger.error(error);
        handleError(""Error while parsing line: "" + line, linecount, 0, 0, exception);
    }
    return outputContainer;
}","/**
     * Read an IAtomContainer from a file in MDL sd format
     *
     * @return The Molecule that was read from the MDL file.
     */","('readAtomContainer', {'INSTRUCTION': {'covered': 596, 'missed': 98}, 'BRANCH': {'covered': 116, 'missed': 20}, 'LINE': {'covered': 138, 'missed': 18}, 'COMPLEXITY': {'covered': 52, 'missed': 17}, 'METHOD': {'covered': 1, 'missed': 0}})",1376.0,  Read an IAtomContainer from a file in MDL sd format   @return The Molecule that was read from the MDL file.,22.0,"['The Molecule was read from the MDL file when you read an IAtomContainer from it.', 'The Molecule was read from the MDL file when you read an IAtomContainer from there.', 'The Molecule was read from the MDL file when you read an IAtomContainer.']"
1122,cdk,org/openscience/cdk/layout/AtomPlacer.java,/tool/sdg/src/main/java/org/openscience/cdk/layout/AtomPlacer.java,distributePartners,97-306,"/**
     *  Distribute the bonded atoms (neighbours) of an atom such that they fill the
     *  remaining space around an atom in a geometrically nice way.
     *  IMPORTANT: This method is not supposed to handle the
     *  case of one or no place neighbor. In the case of
     *  one placed neigbor, the chain placement methods
     *  should be used.
     *
     *@param  atom                The atom whose partners are to be placed
     *@param  placedNeighbours    The atoms which are already placed
     *@param  unplacedNeighbours  The partners to be placed
     *@param  bondLength          The standared bond length for the newly placed
     *      Atoms
     *@param  sharedAtomsCenter   The 2D centre of the placed Atoms
     */
public void distributePartners(IAtom atom, IAtomContainer placedNeighbours, Point2d sharedAtomsCenter, IAtomContainer unplacedNeighbours, double bondLength){
    double occupiedAngle = 0;
    IAtom[] sortedAtoms = null;
    double startAngle = 0.0;
    double addAngle = 0.0;
    double radius = 0.0;
    double remainingAngle = 0.0;
    Vector2d sharedAtomsCenterVector = new Vector2d(sharedAtomsCenter);
    Vector2d newDirection = new Vector2d(atom.getPoint2d());
    Vector2d occupiedDirection = new Vector2d(sharedAtomsCenter);
    occupiedDirection.sub(newDirection);
    if (Math.abs(occupiedDirection.length()) < 0.001)
        occupiedDirection = new Vector2d(0, 1);
    logger.debug(""distributePartners->occupiedDirection.lenght(): "" + occupiedDirection.length());
    List<IAtom> atomsToDraw = new ArrayList<IAtom>();
    logger.debug(""Number of shared atoms: "", placedNeighbours.getAtomCount());
    if (placedNeighbours.getAtomCount() == 1) {
        logger.debug(""Only one neighbour..."");
        for (int f = 0; f < unplacedNeighbours.getAtomCount(); f++) {
            atomsToDraw.add(unplacedNeighbours.getAtom(f));
        }
        addAngle = Math.PI * 2 / (unplacedNeighbours.getAtomCount() + placedNeighbours.getAtomCount());
        IAtom placedAtom = placedNeighbours.getAtom(0);
        double xDiff = placedAtom.getPoint2d().x - atom.getPoint2d().x;
        double yDiff = placedAtom.getPoint2d().y - atom.getPoint2d().y;
        logger.debug(""distributePartners->xdiff: "" + Math.toDegrees(xDiff));
        logger.debug(""distributePartners->ydiff: "" + Math.toDegrees(yDiff));
        startAngle = GeometryUtil.getAngle(xDiff, yDiff);
        logger.debug(""distributePartners->angle: "" + Math.toDegrees(startAngle));
        populatePolygonCorners(atomsToDraw, new Point2d(atom.getPoint2d()), startAngle, addAngle, bondLength);
        return;
    } else if (placedNeighbours.getAtomCount() == 0) {
        logger.debug(""First atom..."");
        for (int f = 0; f < unplacedNeighbours.getAtomCount(); f++) {
            atomsToDraw.add(unplacedNeighbours.getAtom(f));
        }
        addAngle = Math.PI * 2.0 / unplacedNeighbours.getAtomCount();
        startAngle = 0.0;
        populatePolygonCorners(atomsToDraw, new Point2d(atom.getPoint2d()), startAngle, addAngle, bondLength);
        return;
    }
    if (doAngleSnap(atom, placedNeighbours)) {
        int numTerminal = 0;
        for (IAtom unplaced : unplacedNeighbours.atoms()) if (molecule.getConnectedBondsCount(unplaced) == 1)
            numTerminal++;
        if (numTerminal == unplacedNeighbours.getAtomCount()) {
            final Vector2d a = newVector(placedNeighbours.getAtom(0).getPoint2d(), atom.getPoint2d());
            final Vector2d b = newVector(placedNeighbours.getAtom(1).getPoint2d(), atom.getPoint2d());
            final double d1 = GeometryUtil.getAngle(a.x, a.y);
            final double d2 = GeometryUtil.getAngle(b.x, b.y);
            double sweep = a.angle(b);
            if (sweep < Math.PI) {
                sweep = 2 * Math.PI - sweep;
            }
            startAngle = d2;
            if (d1 > d2 && d1 - d2 < Math.PI || d2 - d1 >= Math.PI) {
                startAngle = d1;
            }
            sweep /= (1 + unplacedNeighbours.getAtomCount());
            populatePolygonCorners(StreamSupport.stream(unplacedNeighbours.atoms().spliterator(), false).collect(Collectors.toList()), atom.getPoint2d(), startAngle, sweep, bondLength);
            markPlaced(unplacedNeighbours);
            return;
        } else {
            atom.removeProperty(MacroCycleLayout.MACROCYCLE_ATOM_HINT);
        }
    }
    sharedAtomsCenterVector.sub(newDirection);
    newDirection = sharedAtomsCenterVector;
    newDirection.normalize();
    newDirection.scale(bondLength);
    newDirection.negate();
    logger.debug(""distributePartners->newDirection.lenght(): "" + newDirection.length());
    Point2d distanceMeasure = new Point2d(atom.getPoint2d());
    distanceMeasure.add(newDirection);
    sortedAtoms = AtomContainerManipulator.getAtomArray(placedNeighbours);
    GeometryUtil.sortBy2DDistance(sortedAtoms, distanceMeasure);
    Vector2d closestPoint1 = new Vector2d(sortedAtoms[0].getPoint2d());
    Vector2d closestPoint2 = new Vector2d(sortedAtoms[1].getPoint2d());
    closestPoint1.sub(new Vector2d(atom.getPoint2d()));
    closestPoint2.sub(new Vector2d(atom.getPoint2d()));
    occupiedAngle = closestPoint1.angle(occupiedDirection);
    occupiedAngle += closestPoint2.angle(occupiedDirection);
    double angle1 = GeometryUtil.getAngle(sortedAtoms[0].getPoint2d().x - atom.getPoint2d().x, sortedAtoms[0].getPoint2d().y - atom.getPoint2d().y);
    double angle2 = GeometryUtil.getAngle(sortedAtoms[1].getPoint2d().x - atom.getPoint2d().x, sortedAtoms[1].getPoint2d().y - atom.getPoint2d().y);
    double angle3 = GeometryUtil.getAngle(distanceMeasure.x - atom.getPoint2d().x, distanceMeasure.y - atom.getPoint2d().y);
    if (debug) {
        try {
            logger.debug(""distributePartners->sortedAtoms[0]: "", (molecule.indexOf(sortedAtoms[0]) + 1));
            logger.debug(""distributePartners->sortedAtoms[1]: "", (molecule.indexOf(sortedAtoms[1]) + 1));
            logger.debug(""distributePartners->angle1: "", Math.toDegrees(angle1));
            logger.debug(""distributePartners->angle2: "", Math.toDegrees(angle2));
        } catch (Exception exc) {
            logger.debug(exc);
        }
    }
    IAtom startAtom = null;
    if (angle1 > angle3) {
        if (angle1 - angle3 < Math.PI) {
            startAtom = sortedAtoms[1];
        } else {
            startAtom = sortedAtoms[0];
        }
    } else {
        if (angle3 - angle1 < Math.PI) {
            startAtom = sortedAtoms[0];
        } else {
            startAtom = sortedAtoms[1];
        }
    }
    remainingAngle = (2 * Math.PI) - occupiedAngle;
    addAngle = remainingAngle / (unplacedNeighbours.getAtomCount() + 1);
    if (debug) {
        try {
            logger.debug(""distributePartners->startAtom: "" + (molecule.indexOf(startAtom) + 1));
            logger.debug(""distributePartners->remainingAngle: "" + Math.toDegrees(remainingAngle));
            logger.debug(""distributePartners->addAngle: "" + Math.toDegrees(addAngle));
            logger.debug(""distributePartners-> partners.getAtomCount(): "" + unplacedNeighbours.getAtomCount());
        } catch (Exception exc) {
            logger.debug(exc);
        }
    }
    for (int f = 0; f < unplacedNeighbours.getAtomCount(); f++) {
        atomsToDraw.add(unplacedNeighbours.getAtom(f));
    }
    radius = bondLength;
    startAngle = GeometryUtil.getAngle(startAtom.getPoint2d().x - atom.getPoint2d().x, startAtom.getPoint2d().y - atom.getPoint2d().y);
    logger.debug(""Before check: distributePartners->startAngle: "" + startAngle);
    logger.debug(""After check: distributePartners->startAngle: "" + startAngle);
    populatePolygonCorners(atomsToDraw, new Point2d(atom.getPoint2d()), startAngle, addAngle, radius);
}","public void distributePartners(IAtom atom, IAtomContainer placedNeighbours, Point2d sharedAtomsCenter, IAtomContainer unplacedNeighbours, double bondLength){
    double occupiedAngle = 0;
    IAtom[] sortedAtoms = null;
    double startAngle = 0.0;
    double addAngle = 0.0;
    double radius = 0.0;
    double remainingAngle = 0.0;
    Vector2d sharedAtomsCenterVector = new Vector2d(sharedAtomsCenter);
    Vector2d newDirection = new Vector2d(atom.getPoint2d());
    Vector2d occupiedDirection = new Vector2d(sharedAtomsCenter);
    occupiedDirection.sub(newDirection);
    if (Math.abs(occupiedDirection.length()) < 0.001)
        occupiedDirection = new Vector2d(0, 1);
    logger.debug(""distributePartners->occupiedDirection.lenght(): "" + occupiedDirection.length());
    List<IAtom> atomsToDraw = new ArrayList<IAtom>();
    logger.debug(""Number of shared atoms: "", placedNeighbours.getAtomCount());
    if (placedNeighbours.getAtomCount() == 1) {
        logger.debug(""Only one neighbour..."");
        for (int f = 0; f < unplacedNeighbours.getAtomCount(); f++) {
            atomsToDraw.add(unplacedNeighbours.getAtom(f));
        }
        addAngle = Math.PI * 2 / (unplacedNeighbours.getAtomCount() + placedNeighbours.getAtomCount());
        IAtom placedAtom = placedNeighbours.getAtom(0);
        double xDiff = placedAtom.getPoint2d().x - atom.getPoint2d().x;
        double yDiff = placedAtom.getPoint2d().y - atom.getPoint2d().y;
        logger.debug(""distributePartners->xdiff: "" + Math.toDegrees(xDiff));
        logger.debug(""distributePartners->ydiff: "" + Math.toDegrees(yDiff));
        startAngle = GeometryUtil.getAngle(xDiff, yDiff);
        logger.debug(""distributePartners->angle: "" + Math.toDegrees(startAngle));
        populatePolygonCorners(atomsToDraw, new Point2d(atom.getPoint2d()), startAngle, addAngle, bondLength);
        return;
    } else if (placedNeighbours.getAtomCount() == 0) {
        logger.debug(""First atom..."");
        for (int f = 0; f < unplacedNeighbours.getAtomCount(); f++) {
            atomsToDraw.add(unplacedNeighbours.getAtom(f));
        }
        addAngle = Math.PI * 2.0 / unplacedNeighbours.getAtomCount();
        startAngle = 0.0;
        populatePolygonCorners(atomsToDraw, new Point2d(atom.getPoint2d()), startAngle, addAngle, bondLength);
        return;
    }
    if (doAngleSnap(atom, placedNeighbours)) {
        int numTerminal = 0;
        for (IAtom unplaced : unplacedNeighbours.atoms()) if (molecule.getConnectedBondsCount(unplaced) == 1)
            numTerminal++;
        if (numTerminal == unplacedNeighbours.getAtomCount()) {
            final Vector2d a = newVector(placedNeighbours.getAtom(0).getPoint2d(), atom.getPoint2d());
            final Vector2d b = newVector(placedNeighbours.getAtom(1).getPoint2d(), atom.getPoint2d());
            final double d1 = GeometryUtil.getAngle(a.x, a.y);
            final double d2 = GeometryUtil.getAngle(b.x, b.y);
            double sweep = a.angle(b);
            if (sweep < Math.PI) {
                sweep = 2 * Math.PI - sweep;
            }
            startAngle = d2;
            if (d1 > d2 && d1 - d2 < Math.PI || d2 - d1 >= Math.PI) {
                startAngle = d1;
            }
            sweep /= (1 + unplacedNeighbours.getAtomCount());
            populatePolygonCorners(StreamSupport.stream(unplacedNeighbours.atoms().spliterator(), false).collect(Collectors.toList()), atom.getPoint2d(), startAngle, sweep, bondLength);
            markPlaced(unplacedNeighbours);
            return;
        } else {
            atom.removeProperty(MacroCycleLayout.MACROCYCLE_ATOM_HINT);
        }
    }
    sharedAtomsCenterVector.sub(newDirection);
    newDirection = sharedAtomsCenterVector;
    newDirection.normalize();
    newDirection.scale(bondLength);
    newDirection.negate();
    logger.debug(""distributePartners->newDirection.lenght(): "" + newDirection.length());
    Point2d distanceMeasure = new Point2d(atom.getPoint2d());
    distanceMeasure.add(newDirection);
    sortedAtoms = AtomContainerManipulator.getAtomArray(placedNeighbours);
    GeometryUtil.sortBy2DDistance(sortedAtoms, distanceMeasure);
    Vector2d closestPoint1 = new Vector2d(sortedAtoms[0].getPoint2d());
    Vector2d closestPoint2 = new Vector2d(sortedAtoms[1].getPoint2d());
    closestPoint1.sub(new Vector2d(atom.getPoint2d()));
    closestPoint2.sub(new Vector2d(atom.getPoint2d()));
    occupiedAngle = closestPoint1.angle(occupiedDirection);
    occupiedAngle += closestPoint2.angle(occupiedDirection);
    double angle1 = GeometryUtil.getAngle(sortedAtoms[0].getPoint2d().x - atom.getPoint2d().x, sortedAtoms[0].getPoint2d().y - atom.getPoint2d().y);
    double angle2 = GeometryUtil.getAngle(sortedAtoms[1].getPoint2d().x - atom.getPoint2d().x, sortedAtoms[1].getPoint2d().y - atom.getPoint2d().y);
    double angle3 = GeometryUtil.getAngle(distanceMeasure.x - atom.getPoint2d().x, distanceMeasure.y - atom.getPoint2d().y);
    if (debug) {
        try {
            logger.debug(""distributePartners->sortedAtoms[0]: "", (molecule.indexOf(sortedAtoms[0]) + 1));
            logger.debug(""distributePartners->sortedAtoms[1]: "", (molecule.indexOf(sortedAtoms[1]) + 1));
            logger.debug(""distributePartners->angle1: "", Math.toDegrees(angle1));
            logger.debug(""distributePartners->angle2: "", Math.toDegrees(angle2));
        } catch (Exception exc) {
            logger.debug(exc);
        }
    }
    IAtom startAtom = null;
    if (angle1 > angle3) {
        if (angle1 - angle3 < Math.PI) {
            startAtom = sortedAtoms[1];
        } else {
            startAtom = sortedAtoms[0];
        }
    } else {
        if (angle3 - angle1 < Math.PI) {
            startAtom = sortedAtoms[0];
        } else {
            startAtom = sortedAtoms[1];
        }
    }
    remainingAngle = (2 * Math.PI) - occupiedAngle;
    addAngle = remainingAngle / (unplacedNeighbours.getAtomCount() + 1);
    if (debug) {
        try {
            logger.debug(""distributePartners->startAtom: "" + (molecule.indexOf(startAtom) + 1));
            logger.debug(""distributePartners->remainingAngle: "" + Math.toDegrees(remainingAngle));
            logger.debug(""distributePartners->addAngle: "" + Math.toDegrees(addAngle));
            logger.debug(""distributePartners-> partners.getAtomCount(): "" + unplacedNeighbours.getAtomCount());
        } catch (Exception exc) {
            logger.debug(exc);
        }
    }
    for (int f = 0; f < unplacedNeighbours.getAtomCount(); f++) {
        atomsToDraw.add(unplacedNeighbours.getAtom(f));
    }
    radius = bondLength;
    startAngle = GeometryUtil.getAngle(startAtom.getPoint2d().x - atom.getPoint2d().x, startAtom.getPoint2d().y - atom.getPoint2d().y);
    logger.debug(""Before check: distributePartners->startAngle: "" + startAngle);
    logger.debug(""After check: distributePartners->startAngle: "" + startAngle);
    populatePolygonCorners(atomsToDraw, new Point2d(atom.getPoint2d()), startAngle, addAngle, radius);
}","/**
     *  Distribute the bonded atoms (neighbours) of an atom such that they fill the
     *  remaining space around an atom in a geometrically nice way.
     *  IMPORTANT: This method is not supposed to handle the
     *  case of one or no place neighbor. In the case of
     *  one placed neigbor, the chain placement methods
     *  should be used.
     *
     *@param  atom                The atom whose partners are to be placed
     *@param  placedNeighbours    The atoms which are already placed
     *@param  unplacedNeighbours  The partners to be placed
     *@param  bondLength          The standared bond length for the newly placed
     *      Atoms
     *@param  sharedAtomsCenter   The 2D centre of the placed Atoms
     */","('distributePartners', {'INSTRUCTION': {'covered': 670, 'missed': 16}, 'BRANCH': {'covered': 32, 'missed': 2}, 'LINE': {'covered': 110, 'missed': 5}, 'COMPLEXITY': {'covered': 16, 'missed': 2}, 'METHOD': {'covered': 1, 'missed': 0}})",1389.0,  Distribute the bonded atoms (neighbours) of an atom such that they fill the  remaining space around an atom in a geometrically nice way.,26.0,"['Distribute the atoms in a way that they fill the remaining space around the atom in a nice way.', 'Distribute the atoms so that they fill the remaining space around the atom in a nice way.', 'If you distribute the atoms in a way that they fill the remaining space around the atom, it will look nice.']"
1123,cdk,org/openscience/cdk/io/PMPReader.java,/storage/io/src/main/java/org/openscience/cdk/io/PMPReader.java,readChemFile,181-383,"/**
     *  Private method that actually parses the input to read a ChemFile
     *  object.
     *
     *  Each PMP frame is stored as a Crystal in a ChemModel. The PMP
     *  file is stored as a ChemSequence of ChemModels.
     *
     * @return A ChemFile containing the data parsed from input.
     */
private IChemFile readChemFile(IChemFile chemFile){
    IChemSequence chemSequence;
    IChemModel chemModel;
    ICrystal crystal;
    try {
        String line = readLine();
        while (input.ready() && line != null) {
            if (line.startsWith(""%%Header Start"")) {
                while (input.ready() && line != null && !(line.startsWith(""%%Header End""))) {
                    if (line.startsWith(""%%Version Number"")) {
                        String version = readLine().trim();
                        if (!version.equals(""3.00"")) {
                            logger.error(""The PMPReader only supports PMP files with version 3.00"");
                            return null;
                        }
                    }
                    line = readLine();
                }
            } else if (line.startsWith(""%%Model Start"")) {
                modelStructure = chemFile.getBuilder().newInstance(IAtomContainer.class);
                while (input.ready() && line != null && !(line.startsWith(""%%Model End""))) {
                    Matcher objHeaderMatcher = objHeader.matcher(line);
                    if (objHeaderMatcher.matches()) {
                        String object = objHeaderMatcher.group(2);
                        constructObject(chemFile.getBuilder(), object);
                        int id = Integer.parseInt(objHeaderMatcher.group(1));
                        line = readLine();
                        while (input.ready() && line != null && !(line.trim().equals("")""))) {
                            Matcher objCommandMatcher = objCommand.matcher(line);
                            objHeaderMatcher = objHeader.matcher(line);
                            if (objHeaderMatcher.matches()) {
                                object = objHeaderMatcher.group(2);
                                id = Integer.parseInt(objHeaderMatcher.group(1));
                                constructObject(chemFile.getBuilder(), object);
                            } else if (objCommandMatcher.matches()) {
                                String format = objCommandMatcher.group(1);
                                String command = objCommandMatcher.group(2);
                                String field = objCommandMatcher.group(3);
                                processModelCommand(object, command, format, field);
                            } else {
                                logger.warn(""Skipping line: "" + line);
                            }
                            line = readLine();
                        }
                        if (chemObject instanceof IAtom) {
                            atomids.put(id, modelStructure.getAtomCount());
                            atomGivenIds.put(Integer.valueOf((String) chemObject.getProperty(PMP_ID)), id);
                            modelStructure.addAtom((IAtom) chemObject);
                        } else if (chemObject instanceof IBond) {
                        } else {
                            logger.error(""chemObject is not initialized or of bad class type"");
                        }
                    }
                    line = readLine();
                }
                assert line != null;
                if (line.startsWith(""%%Model End"")) {
                    int bondsFound = bondids.size();
                    logger.debug(""Found #bonds: "", bondsFound);
                    logger.debug(""#atom ones: "", bondAtomOnes.size());
                    logger.debug(""#atom twos: "", bondAtomTwos.size());
                    logger.debug(""#orders: "", bondOrders.size());
                    for (Integer index : bondids.keySet()) {
                        double order = (bondOrders.get(index) != null ? bondOrders.get(index) : 1.0);
                        logger.debug(""index: "", index);
                        logger.debug(""ones: "", bondAtomOnes.get(index));
                        IAtom atom1 = modelStructure.getAtom(atomids.get(bondAtomOnes.get(index)));
                        IAtom atom2 = modelStructure.getAtom(atomids.get(bondAtomTwos.get(index)));
                        IBond bond = modelStructure.getBuilder().newInstance(IBond.class, atom1, atom2);
                        if (order == 1.0) {
                            bond.setOrder(IBond.Order.SINGLE);
                        } else if (order == 2.0) {
                            bond.setOrder(IBond.Order.DOUBLE);
                        } else if (order == 3.0) {
                            bond.setOrder(IBond.Order.TRIPLE);
                        } else if (order == 4.0) {
                            bond.setOrder(IBond.Order.QUADRUPLE);
                        }
                        modelStructure.addBond(bond);
                    }
                }
            } else if (line.startsWith(""%%Traj Start"")) {
                chemSequence = chemFile.getBuilder().newInstance(IChemSequence.class);
                double energyFragment = 0.0;
                double energyTotal = 0.0;
                int Z = 1;
                while (input.ready() && line != null && !(line.startsWith(""%%Traj End""))) {
                    if (line.startsWith(""%%Start Frame"")) {
                        chemModel = chemFile.getBuilder().newInstance(IChemModel.class);
                        crystal = chemFile.getBuilder().newInstance(ICrystal.class);
                        while (input.ready() && line != null && !(line.startsWith(""%%End Frame""))) {
                            if (line.startsWith(""%%Atom Coords"")) {
                                if (energyFragment != 0.0 && energyTotal != 0.0) {
                                    Z = (int) Math.round(energyTotal / energyFragment);
                                    logger.debug(""Z derived from energies: "", Z);
                                }
                                int expatoms = modelStructure.getAtomCount();
                                for (int molCount = 1; molCount <= Z; molCount++) {
                                    IAtomContainer clone = modelStructure.getBuilder().newInstance(IAtomContainer.class);
                                    for (int i = 0; i < expatoms; i++) {
                                        line = readLine();
                                        IAtom a = clone.getBuilder().newInstance(IAtom.class);
                                        StringTokenizer st = new StringTokenizer(line, "" "");
                                        a.setPoint3d(new Point3d(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken())));
                                        a.setCovalentRadius(0.6);
                                        IAtom modelAtom = modelStructure.getAtom(atomids.get(atomGivenIds.get(i + 1)));
                                        a.setSymbol(modelAtom.getSymbol());
                                        clone.addAtom(a);
                                    }
                                    rebonder.rebond(clone);
                                    crystal.add(clone);
                                }
                            } else if (line.startsWith(""%%E/Frag"")) {
                                line = readLine().trim();
                                energyFragment = Double.parseDouble(line);
                            } else if (line.startsWith(""%%Tot E"")) {
                                line = readLine().trim();
                                energyTotal = Double.parseDouble(line);
                            } else if (line.startsWith(""%%Lat Vects"")) {
                                StringTokenizer st;
                                line = readLine();
                                st = new StringTokenizer(line, "" "");
                                crystal.setA(new Vector3d(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken())));
                                line = readLine();
                                st = new StringTokenizer(line, "" "");
                                crystal.setB(new Vector3d(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken())));
                                line = readLine();
                                st = new StringTokenizer(line, "" "");
                                crystal.setC(new Vector3d(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken())));
                            } else if (line.startsWith(""%%Space Group"")) {
                                line = readLine().trim();
                                if (""P 21 21 21 (1)"".equals(line)) {
                                    crystal.setSpaceGroup(""P 2_1 2_1 2_1"");
                                } else {
                                    crystal.setSpaceGroup(""P1"");
                                }
                            }
                            line = readLine();
                        }
                        chemModel.setCrystal(crystal);
                        chemSequence.addChemModel(chemModel);
                    }
                    line = readLine();
                }
                chemFile.addChemSequence(chemSequence);
            }
            line = readLine();
        }
    } catch (IOException e) {
        logger.error(""An IOException happened: "", e.getMessage());
        logger.debug(e);
        chemFile = null;
    } catch (CDKException e) {
        logger.error(""An CDKException happened: "", e.getMessage());
        logger.debug(e);
        chemFile = null;
    }
    return chemFile;
}","private IChemFile readChemFile(IChemFile chemFile){
    IChemSequence chemSequence;
    IChemModel chemModel;
    ICrystal crystal;
    try {
        String line = readLine();
        while (input.ready() && line != null) {
            if (line.startsWith(""%%Header Start"")) {
                while (input.ready() && line != null && !(line.startsWith(""%%Header End""))) {
                    if (line.startsWith(""%%Version Number"")) {
                        String version = readLine().trim();
                        if (!version.equals(""3.00"")) {
                            logger.error(""The PMPReader only supports PMP files with version 3.00"");
                            return null;
                        }
                    }
                    line = readLine();
                }
            } else if (line.startsWith(""%%Model Start"")) {
                modelStructure = chemFile.getBuilder().newInstance(IAtomContainer.class);
                while (input.ready() && line != null && !(line.startsWith(""%%Model End""))) {
                    Matcher objHeaderMatcher = objHeader.matcher(line);
                    if (objHeaderMatcher.matches()) {
                        String object = objHeaderMatcher.group(2);
                        constructObject(chemFile.getBuilder(), object);
                        int id = Integer.parseInt(objHeaderMatcher.group(1));
                        line = readLine();
                        while (input.ready() && line != null && !(line.trim().equals("")""))) {
                            Matcher objCommandMatcher = objCommand.matcher(line);
                            objHeaderMatcher = objHeader.matcher(line);
                            if (objHeaderMatcher.matches()) {
                                object = objHeaderMatcher.group(2);
                                id = Integer.parseInt(objHeaderMatcher.group(1));
                                constructObject(chemFile.getBuilder(), object);
                            } else if (objCommandMatcher.matches()) {
                                String format = objCommandMatcher.group(1);
                                String command = objCommandMatcher.group(2);
                                String field = objCommandMatcher.group(3);
                                processModelCommand(object, command, format, field);
                            } else {
                                logger.warn(""Skipping line: "" + line);
                            }
                            line = readLine();
                        }
                        if (chemObject instanceof IAtom) {
                            atomids.put(id, modelStructure.getAtomCount());
                            atomGivenIds.put(Integer.valueOf((String) chemObject.getProperty(PMP_ID)), id);
                            modelStructure.addAtom((IAtom) chemObject);
                        } else if (chemObject instanceof IBond) {
                        } else {
                            logger.error(""chemObject is not initialized or of bad class type"");
                        }
                    }
                    line = readLine();
                }
                assert line != null;
                if (line.startsWith(""%%Model End"")) {
                    int bondsFound = bondids.size();
                    logger.debug(""Found #bonds: "", bondsFound);
                    logger.debug(""#atom ones: "", bondAtomOnes.size());
                    logger.debug(""#atom twos: "", bondAtomTwos.size());
                    logger.debug(""#orders: "", bondOrders.size());
                    for (Integer index : bondids.keySet()) {
                        double order = (bondOrders.get(index) != null ? bondOrders.get(index) : 1.0);
                        logger.debug(""index: "", index);
                        logger.debug(""ones: "", bondAtomOnes.get(index));
                        IAtom atom1 = modelStructure.getAtom(atomids.get(bondAtomOnes.get(index)));
                        IAtom atom2 = modelStructure.getAtom(atomids.get(bondAtomTwos.get(index)));
                        IBond bond = modelStructure.getBuilder().newInstance(IBond.class, atom1, atom2);
                        if (order == 1.0) {
                            bond.setOrder(IBond.Order.SINGLE);
                        } else if (order == 2.0) {
                            bond.setOrder(IBond.Order.DOUBLE);
                        } else if (order == 3.0) {
                            bond.setOrder(IBond.Order.TRIPLE);
                        } else if (order == 4.0) {
                            bond.setOrder(IBond.Order.QUADRUPLE);
                        }
                        modelStructure.addBond(bond);
                    }
                }
            } else if (line.startsWith(""%%Traj Start"")) {
                chemSequence = chemFile.getBuilder().newInstance(IChemSequence.class);
                double energyFragment = 0.0;
                double energyTotal = 0.0;
                int Z = 1;
                while (input.ready() && line != null && !(line.startsWith(""%%Traj End""))) {
                    if (line.startsWith(""%%Start Frame"")) {
                        chemModel = chemFile.getBuilder().newInstance(IChemModel.class);
                        crystal = chemFile.getBuilder().newInstance(ICrystal.class);
                        while (input.ready() && line != null && !(line.startsWith(""%%End Frame""))) {
                            if (line.startsWith(""%%Atom Coords"")) {
                                if (energyFragment != 0.0 && energyTotal != 0.0) {
                                    Z = (int) Math.round(energyTotal / energyFragment);
                                    logger.debug(""Z derived from energies: "", Z);
                                }
                                int expatoms = modelStructure.getAtomCount();
                                for (int molCount = 1; molCount <= Z; molCount++) {
                                    IAtomContainer clone = modelStructure.getBuilder().newInstance(IAtomContainer.class);
                                    for (int i = 0; i < expatoms; i++) {
                                        line = readLine();
                                        IAtom a = clone.getBuilder().newInstance(IAtom.class);
                                        StringTokenizer st = new StringTokenizer(line, "" "");
                                        a.setPoint3d(new Point3d(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken())));
                                        a.setCovalentRadius(0.6);
                                        IAtom modelAtom = modelStructure.getAtom(atomids.get(atomGivenIds.get(i + 1)));
                                        a.setSymbol(modelAtom.getSymbol());
                                        clone.addAtom(a);
                                    }
                                    rebonder.rebond(clone);
                                    crystal.add(clone);
                                }
                            } else if (line.startsWith(""%%E/Frag"")) {
                                line = readLine().trim();
                                energyFragment = Double.parseDouble(line);
                            } else if (line.startsWith(""%%Tot E"")) {
                                line = readLine().trim();
                                energyTotal = Double.parseDouble(line);
                            } else if (line.startsWith(""%%Lat Vects"")) {
                                StringTokenizer st;
                                line = readLine();
                                st = new StringTokenizer(line, "" "");
                                crystal.setA(new Vector3d(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken())));
                                line = readLine();
                                st = new StringTokenizer(line, "" "");
                                crystal.setB(new Vector3d(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken())));
                                line = readLine();
                                st = new StringTokenizer(line, "" "");
                                crystal.setC(new Vector3d(Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken()), Double.parseDouble(st.nextToken())));
                            } else if (line.startsWith(""%%Space Group"")) {
                                line = readLine().trim();
                                if (""P 21 21 21 (1)"".equals(line)) {
                                    crystal.setSpaceGroup(""P 2_1 2_1 2_1"");
                                } else {
                                    crystal.setSpaceGroup(""P1"");
                                }
                            }
                            line = readLine();
                        }
                        chemModel.setCrystal(crystal);
                        chemSequence.addChemModel(chemModel);
                    }
                    line = readLine();
                }
                chemFile.addChemSequence(chemSequence);
            }
            line = readLine();
        }
    } catch (IOException e) {
        logger.error(""An IOException happened: "", e.getMessage());
        logger.debug(e);
        chemFile = null;
    } catch (CDKException e) {
        logger.error(""An CDKException happened: "", e.getMessage());
        logger.debug(e);
        chemFile = null;
    }
    return chemFile;
}","/**
     *  Private method that actually parses the input to read a ChemFile
     *  object.
     *
     *  Each PMP frame is stored as a Crystal in a ChemModel. The PMP
     *  file is stored as a ChemSequence of ChemModels.
     *
     * @return A ChemFile containing the data parsed from input.
     */","('readChemFile', {'INSTRUCTION': {'covered': 690, 'missed': 64}, 'BRANCH': {'covered': 69, 'missed': 25}, 'LINE': {'covered': 123, 'missed': 16}, 'COMPLEXITY': {'covered': 25, 'missed': 23}, 'METHOD': {'covered': 1, 'missed': 0}})",1532.0,  Private method that actually parses the input to read a ChemFile  object.,13.0,"['Private method that reads the ChemFile object from the input.', 'Private method that reads ChemFile object from input.', 'Private method that reads the ChemFile object.']"
1124,matsim-libs,org/matsim/core/network/algorithms/intersectionSimplifier/DensityCluster.java,/matsim/src/main/java/org/matsim/core/network/algorithms/intersectionSimplifier/DensityCluster.java,clusterInput,97-341,"/**
	 * Building an <code>ArrayList</code> of <code>DigicoreCluster</code>s. The DJ-Clustering
	 * procedure of Zhou <i>et al</i> (2004) is followed. If there are no points to cluster, a
	 * warning message is logged, and the procedure bypassed.
	 */
public void clusterInput(double radius, int minimumPoints){
    if (this.inputPoints.size() == 0) {
        log.warn(""DJCluster.clusterInput() called, but no points to cluster."");
    } else {
        if (!silent) {
            log.info(""Clustering input points. This may take a while."");
        }
        int clusterIndex = 0;
        int pointMultiplier = 1;
        int uPointCounter = 0;
        int cPointCounter = 0;
        /*
			 * Determine the extent of the QuadTree. 
			 */
        double xMin = Double.POSITIVE_INFINITY;
        double yMin = Double.POSITIVE_INFINITY;
        double xMax = Double.NEGATIVE_INFINITY;
        double yMax = Double.NEGATIVE_INFINITY;
        for (Node node : this.inputPoints) {
            Coord c = node.getCoord();
            /* TODO Remove if no NullPointerExceptions are thrown. */
            if (c == null) {
                log.warn(""Coord is null. Number of points in list: "" + inputPoints.size());
            } else {
                xMin = Math.min(xMin, c.getX());
                yMin = Math.min(yMin, c.getY());
                xMax = Math.max(xMax, c.getX());
                yMax = Math.max(yMax, c.getY());
            }
        }
        /*
			 * Build a new QuadTree, and place each point in the QuadTree as a ClusterActivity.
			 * The geographic coordinates of each point is used as the keys in the QuadTree.
			 * Initially all ClusterPoints will have a NULL reference to its DigicoreCluster. An 
			 * ArrayList of Points is also kept as iterator for unclustered points.
			 */
        if (!silent) {
            log.info(""Place points in QuadTree."");
        }
        quadTree = new QuadTree<ClusterActivity>(xMin - 1, yMin - 1, xMax + 1, yMax + 1);
        List<ClusterActivity> listOfPoints = new ArrayList<ClusterActivity>();
        for (int i = 0; i < this.inputPoints.size(); i++) {
            double x = inputPoints.get(i).getCoord().getX();
            double y = inputPoints.get(i).getCoord().getY();
            ClusterActivity cp = new ClusterActivity(Id.create(i, Coord.class), inputPoints.get(i), null);
            quadTree.put(x, y, cp);
            listOfPoints.add(cp);
        }
        if (!silent) {
            log.info(""Done placing activities."");
        }
        int pointCounter = 0;
        while (pointCounter < listOfPoints.size()) {
            // Get next point.
            ClusterActivity p = listOfPoints.get(pointCounter);
            if (p.getCluster() == null) {
                // Compute the density-based neighbourhood, N(p), of the point p
                Collection<ClusterActivity> neighbourhood = quadTree.getDisk(p.getCoord().getX(), p.getCoord().getY(), radius);
                List<ClusterActivity> uN = new ArrayList<ClusterActivity>(neighbourhood.size());
                List<ClusterActivity> cN = new ArrayList<ClusterActivity>(neighbourhood.size());
                for (ClusterActivity cp : neighbourhood) {
                    if (cp.getCluster() == null) {
                        uN.add(cp);
                    } else {
                        cN.add(cp);
                    }
                }
                if (neighbourhood.size() < minimumPoints) {
                    /* Point is considered to be noise.
						 * FIXME Not quite true... it may be incorporated into
						 * another cluster later! (JWJ - Mar '14)
						 */
                    lostPoints.put(p.getId(), p);
                    uPointCounter++;
                } else if (cN.size() > 0) {
                    /* 
						 * Merge all the clusters. Use the DigicoreCluster with the smallest clusterId
						 * value as the remaining DigicoreCluster.
						 */
                    List<Cluster> localClusters = new ArrayList<Cluster>();
                    Cluster smallestCluster = cN.get(0).getCluster();
                    for (int i = 1; i < cN.size(); i++) {
                        if (Integer.parseInt(cN.get(i).getCluster().getId().toString()) < Integer.parseInt(smallestCluster.getId().toString())) {
                            smallestCluster = cN.get(i).getCluster();
                        }
                        if (!localClusters.contains(cN.get(i).getCluster())) {
                            localClusters.add(cN.get(i).getCluster());
                        }
                    }
                    for (Cluster DigicoreCluster : localClusters) {
                        if (!DigicoreCluster.equals(smallestCluster)) {
                            List<ClusterActivity> thisClusterList = DigicoreCluster.getPoints();
                            for (int j = 0; j < thisClusterList.size(); j++) {
                                // Change the DigicoreCluster reference of the ClusterActivity.
                                thisClusterList.get(j).setCluster(smallestCluster);
                                // Add the ClusterActivity to the new DigicoreCluster.
                                smallestCluster.getPoints().add(thisClusterList.get(j));
                                // Remove the ClusterActivity from old DigicoreCluster.
                                /* 
									 * 20091009 - I've commented this out... this seems
									 * both dangerous and unnecessary. 
									 */
                                // DigicoreCluster.getPoints().remove(thisClusterList.get(j));
                            }
                        }
                    }
                    // Add unclustered points in the neighborhood.
                    for (ClusterActivity cp : uN) {
                        smallestCluster.getPoints().add(cp);
                        cp.setCluster(smallestCluster);
                        cPointCounter++;
                        if (lostPoints.containsKey(cp.getId())) {
                            lostPoints.remove(cp.getId());
                            uPointCounter--;
                        }
                    }
                } else {
                    // Create new DigicoreCluster and add all the points.
                    Cluster newCluster = new Cluster(Id.create(clusterIndex, Cluster.class));
                    clusterIndex++;
                    for (ClusterActivity cp : uN) {
                        cp.setCluster(newCluster);
                        newCluster.getPoints().add(cp);
                        cPointCounter++;
                        if (lostPoints.containsKey(cp.getId())) {
                            lostPoints.remove(cp.getId());
                            uPointCounter--;
                        }
                    }
                }
            }
            pointCounter++;
            // Report progress
            if (!silent) {
                if (pointCounter == pointMultiplier) {
                    log.info(""   Points clustered: "" + pointCounter);
                    pointMultiplier = (int) Math.max(pointCounter, pointMultiplier) * 2;
                }
            }
        }
        if (!silent) {
            log.info(""   Points clustered: "" + pointCounter + "" (Done)"");
            int sum = cPointCounter + uPointCounter;
            log.info(""Sum should add up: "" + cPointCounter + "" (clustered) + "" + uPointCounter + "" (unclustered) = "" + sum);
            /* Code added for Joubert & Meintjes paper (2014). */
            log.info(""Unclustered points: "");
            for (ClusterActivity ca : lostPoints.values()) {
                log.info(String.format(""   %.6f,%.6f"", ca.getCoord().getX(), ca.getCoord().getY()));
            }
            log.info(""New way of unclustered points:"");
            log.info(""   Number: "" + lostPoints.size());
        }
        /* 
			 * Build the DigicoreCluster list. Once built, I rename the clusterId field so as to
			 * start at '0', and increment accordingly. This allows me to directly use
			 * the clusterId field as 'row' and 'column' reference in the 2D matrices
			 * when determining adjacency in Social Network Analysis.
			 */
        if (!silent) {
            log.info(""Building the DigicoreCluster list (2 steps)"");
        }
        Map<Cluster, List<ClusterActivity>> clusterMap = new HashMap<Cluster, List<ClusterActivity>>();
        if (!silent) {
            log.info(""Step 1 of 2:"");
            log.info(""Number of ClusterPoints to process: "" + listOfPoints.size());
        }
        int cpCounter = 0;
        int cpMultiplier = 1;
        for (ClusterActivity ca : listOfPoints) {
            Cluster theCluster = ca.getCluster();
            if (theCluster != null) {
                // Removed 7/12/2011 (JWJ): Seems unnecessary computation.
                // theCluster.setCenterOfGravity();
                if (!clusterMap.containsKey(theCluster)) {
                    List<ClusterActivity> newList = new ArrayList<ClusterActivity>();
                    clusterMap.put(theCluster, newList);
                }
                clusterMap.get(theCluster).add(ca);
            }
            if (!silent) {
                if (++cpCounter == cpMultiplier) {
                    log.info(""   ClusterPoints processed: "" + cpCounter + "" ("" + String.format(""%3.2f"", ((double) cpCounter / (double) listOfPoints.size()) * 100) + ""%)"");
                    cpMultiplier *= 2;
                }
            }
        }
        if (!silent) {
            log.info(""   ClusterPoints processed: "" + cpCounter + "" (Done)"");
        }
        if (!silent) {
            log.info(""Step 2 of 2:"");
            log.info(""Number of clusters to process: "" + clusterMap.keySet().size());
        }
        int clusterCounter = 0;
        int clusterMultiplier = 1;
        int clusterNumber = 0;
        for (Map.Entry<Cluster, List<ClusterActivity>> e : clusterMap.entrySet()) {
            Cluster digicoreCluster = e.getKey();
            List<ClusterActivity> listOfClusterPoints = e.getValue();
            if (listOfClusterPoints.size() >= minimumPoints) {
                digicoreCluster.setClusterId(Id.create(clusterNumber++, Cluster.class));
                clusterNumber++;
                digicoreCluster.setCenterOfGravity();
                clusterList.add(digicoreCluster);
            } else if (!silent) {
                log.warn("" ... why do we HAVE a cluster with too few points?..."");
            }
            if (!silent) {
                if (++clusterCounter == clusterMultiplier) {
                    log.info(""   Clusters processed: "" + clusterCounter + "" ("" + String.format(""%3.2f"", ((double) clusterCounter / (double) clusterMap.keySet().size()) * 100) + ""%)"");
                    clusterMultiplier *= 2;
                }
            }
        }
        if (!silent) {
            log.info(""   Clusters processed: "" + clusterCounter + "" (Done)"");
            log.info(""DigicoreCluster list built."");
        }
    }
    // lost list must be made up of clusters without Id.
}","public void clusterInput(double radius, int minimumPoints){
    if (this.inputPoints.size() == 0) {
        log.warn(""DJCluster.clusterInput() called, but no points to cluster."");
    } else {
        if (!silent) {
            log.info(""Clustering input points. This may take a while."");
        }
        int clusterIndex = 0;
        int pointMultiplier = 1;
        int uPointCounter = 0;
        int cPointCounter = 0;
        /*
			 * Determine the extent of the QuadTree. 
			 */
        double xMin = Double.POSITIVE_INFINITY;
        double yMin = Double.POSITIVE_INFINITY;
        double xMax = Double.NEGATIVE_INFINITY;
        double yMax = Double.NEGATIVE_INFINITY;
        for (Node node : this.inputPoints) {
            Coord c = node.getCoord();
            /* TODO Remove if no NullPointerExceptions are thrown. */
            if (c == null) {
                log.warn(""Coord is null. Number of points in list: "" + inputPoints.size());
            } else {
                xMin = Math.min(xMin, c.getX());
                yMin = Math.min(yMin, c.getY());
                xMax = Math.max(xMax, c.getX());
                yMax = Math.max(yMax, c.getY());
            }
        }
        /*
			 * Build a new QuadTree, and place each point in the QuadTree as a ClusterActivity.
			 * The geographic coordinates of each point is used as the keys in the QuadTree.
			 * Initially all ClusterPoints will have a NULL reference to its DigicoreCluster. An 
			 * ArrayList of Points is also kept as iterator for unclustered points.
			 */
        if (!silent) {
            log.info(""Place points in QuadTree."");
        }
        quadTree = new QuadTree<ClusterActivity>(xMin - 1, yMin - 1, xMax + 1, yMax + 1);
        List<ClusterActivity> listOfPoints = new ArrayList<ClusterActivity>();
        for (int i = 0; i < this.inputPoints.size(); i++) {
            double x = inputPoints.get(i).getCoord().getX();
            double y = inputPoints.get(i).getCoord().getY();
            ClusterActivity cp = new ClusterActivity(Id.create(i, Coord.class), inputPoints.get(i), null);
            quadTree.put(x, y, cp);
            listOfPoints.add(cp);
        }
        if (!silent) {
            log.info(""Done placing activities."");
        }
        int pointCounter = 0;
        while (pointCounter < listOfPoints.size()) {
            // Get next point.
            ClusterActivity p = listOfPoints.get(pointCounter);
            if (p.getCluster() == null) {
                // Compute the density-based neighbourhood, N(p), of the point p
                Collection<ClusterActivity> neighbourhood = quadTree.getDisk(p.getCoord().getX(), p.getCoord().getY(), radius);
                List<ClusterActivity> uN = new ArrayList<ClusterActivity>(neighbourhood.size());
                List<ClusterActivity> cN = new ArrayList<ClusterActivity>(neighbourhood.size());
                for (ClusterActivity cp : neighbourhood) {
                    if (cp.getCluster() == null) {
                        uN.add(cp);
                    } else {
                        cN.add(cp);
                    }
                }
                if (neighbourhood.size() < minimumPoints) {
                    /* Point is considered to be noise.
						 * FIXME Not quite true... it may be incorporated into
						 * another cluster later! (JWJ - Mar '14)
						 */
                    lostPoints.put(p.getId(), p);
                    uPointCounter++;
                } else if (cN.size() > 0) {
                    /* 
						 * Merge all the clusters. Use the DigicoreCluster with the smallest clusterId
						 * value as the remaining DigicoreCluster.
						 */
                    List<Cluster> localClusters = new ArrayList<Cluster>();
                    Cluster smallestCluster = cN.get(0).getCluster();
                    for (int i = 1; i < cN.size(); i++) {
                        if (Integer.parseInt(cN.get(i).getCluster().getId().toString()) < Integer.parseInt(smallestCluster.getId().toString())) {
                            smallestCluster = cN.get(i).getCluster();
                        }
                        if (!localClusters.contains(cN.get(i).getCluster())) {
                            localClusters.add(cN.get(i).getCluster());
                        }
                    }
                    for (Cluster DigicoreCluster : localClusters) {
                        if (!DigicoreCluster.equals(smallestCluster)) {
                            List<ClusterActivity> thisClusterList = DigicoreCluster.getPoints();
                            for (int j = 0; j < thisClusterList.size(); j++) {
                                // Change the DigicoreCluster reference of the ClusterActivity.
                                thisClusterList.get(j).setCluster(smallestCluster);
                                // Add the ClusterActivity to the new DigicoreCluster.
                                smallestCluster.getPoints().add(thisClusterList.get(j));
                                // Remove the ClusterActivity from old DigicoreCluster.
                                /* 
									 * 20091009 - I've commented this out... this seems
									 * both dangerous and unnecessary. 
									 */
                                // DigicoreCluster.getPoints().remove(thisClusterList.get(j));
                            }
                        }
                    }
                    // Add unclustered points in the neighborhood.
                    for (ClusterActivity cp : uN) {
                        smallestCluster.getPoints().add(cp);
                        cp.setCluster(smallestCluster);
                        cPointCounter++;
                        if (lostPoints.containsKey(cp.getId())) {
                            lostPoints.remove(cp.getId());
                            uPointCounter--;
                        }
                    }
                } else {
                    // Create new DigicoreCluster and add all the points.
                    Cluster newCluster = new Cluster(Id.create(clusterIndex, Cluster.class));
                    clusterIndex++;
                    for (ClusterActivity cp : uN) {
                        cp.setCluster(newCluster);
                        newCluster.getPoints().add(cp);
                        cPointCounter++;
                        if (lostPoints.containsKey(cp.getId())) {
                            lostPoints.remove(cp.getId());
                            uPointCounter--;
                        }
                    }
                }
            }
            pointCounter++;
            // Report progress
            if (!silent) {
                if (pointCounter == pointMultiplier) {
                    log.info(""   Points clustered: "" + pointCounter);
                    pointMultiplier = (int) Math.max(pointCounter, pointMultiplier) * 2;
                }
            }
        }
        if (!silent) {
            log.info(""   Points clustered: "" + pointCounter + "" (Done)"");
            int sum = cPointCounter + uPointCounter;
            log.info(""Sum should add up: "" + cPointCounter + "" (clustered) + "" + uPointCounter + "" (unclustered) = "" + sum);
            /* Code added for Joubert & Meintjes paper (2014). */
            log.info(""Unclustered points: "");
            for (ClusterActivity ca : lostPoints.values()) {
                log.info(String.format(""   %.6f,%.6f"", ca.getCoord().getX(), ca.getCoord().getY()));
            }
            log.info(""New way of unclustered points:"");
            log.info(""   Number: "" + lostPoints.size());
        }
        /* 
			 * Build the DigicoreCluster list. Once built, I rename the clusterId field so as to
			 * start at '0', and increment accordingly. This allows me to directly use
			 * the clusterId field as 'row' and 'column' reference in the 2D matrices
			 * when determining adjacency in Social Network Analysis.
			 */
        if (!silent) {
            log.info(""Building the DigicoreCluster list (2 steps)"");
        }
        Map<Cluster, List<ClusterActivity>> clusterMap = new HashMap<Cluster, List<ClusterActivity>>();
        if (!silent) {
            log.info(""Step 1 of 2:"");
            log.info(""Number of ClusterPoints to process: "" + listOfPoints.size());
        }
        int cpCounter = 0;
        int cpMultiplier = 1;
        for (ClusterActivity ca : listOfPoints) {
            Cluster theCluster = ca.getCluster();
            if (theCluster != null) {
                // Removed 7/12/2011 (JWJ): Seems unnecessary computation.
                // theCluster.setCenterOfGravity();
                if (!clusterMap.containsKey(theCluster)) {
                    List<ClusterActivity> newList = new ArrayList<ClusterActivity>();
                    clusterMap.put(theCluster, newList);
                }
                clusterMap.get(theCluster).add(ca);
            }
            if (!silent) {
                if (++cpCounter == cpMultiplier) {
                    log.info(""   ClusterPoints processed: "" + cpCounter + "" ("" + String.format(""%3.2f"", ((double) cpCounter / (double) listOfPoints.size()) * 100) + ""%)"");
                    cpMultiplier *= 2;
                }
            }
        }
        if (!silent) {
            log.info(""   ClusterPoints processed: "" + cpCounter + "" (Done)"");
        }
        if (!silent) {
            log.info(""Step 2 of 2:"");
            log.info(""Number of clusters to process: "" + clusterMap.keySet().size());
        }
        int clusterCounter = 0;
        int clusterMultiplier = 1;
        int clusterNumber = 0;
        for (Map.Entry<Cluster, List<ClusterActivity>> e : clusterMap.entrySet()) {
            Cluster digicoreCluster = e.getKey();
            List<ClusterActivity> listOfClusterPoints = e.getValue();
            if (listOfClusterPoints.size() >= minimumPoints) {
                digicoreCluster.setClusterId(Id.create(clusterNumber++, Cluster.class));
                clusterNumber++;
                digicoreCluster.setCenterOfGravity();
                clusterList.add(digicoreCluster);
            } else if (!silent) {
                log.warn("" ... why do we HAVE a cluster with too few points?..."");
            }
            if (!silent) {
                if (++clusterCounter == clusterMultiplier) {
                    log.info(""   Clusters processed: "" + clusterCounter + "" ("" + String.format(""%3.2f"", ((double) clusterCounter / (double) clusterMap.keySet().size()) * 100) + ""%)"");
                    clusterMultiplier *= 2;
                }
            }
        }
        if (!silent) {
            log.info(""   Clusters processed: "" + clusterCounter + "" (Done)"");
            log.info(""DigicoreCluster list built."");
        }
    }
    // lost list must be made up of clusters without Id.
}","/**
	 * Building an <code>ArrayList</code> of <code>DigicoreCluster</code>s. The DJ-Clustering
	 * procedure of Zhou <i>et al</i> (2004) is followed. If there are no points to cluster, a
	 * warning message is logged, and the procedure bypassed.
	 */","('clusterInput', {'INSTRUCTION': {'covered': 626, 'missed': 62}, 'BRANCH': {'covered': 72, 'missed': 12}, 'LINE': {'covered': 133, 'missed': 13}, 'COMPLEXITY': {'covered': 33, 'missed': 10}, 'METHOD': {'covered': 1, 'missed': 0}})",1543.0,  Building an <code>ArrayList</code> of <code>DigicoreCluster</code>s.,19.0,"['Building an code>DigicoreCluster/code>s.', 'Building an code>DigicoreCluster/code>.', 'Building a code>ArrayList/code> of theDigicoreCluster.']"
1125,cdk,org/openscience/cdk/inchi/InChIGenerator.java,/storage/inchi/src/main/java/org/openscience/cdk/inchi/InChIGenerator.java,generateInchiFromCDKAtomContainer,193-489,"/**
     * <p>Reads atoms, bonds etc from atom container and converts to format
     * InChI library requires, then places call for the library to generate
     * the InChI.
     *
     * @param atomContainer AtomContainer to generate InChI for.
     * @param ignore Ignore aromatic bonds
     * @throws CDKException
     */
private void generateInchiFromCDKAtomContainer(IAtomContainer atomContainer, boolean ignore) throws CDKException{
    this.atomContainer = atomContainer;
    Iterator<IAtom> atoms = atomContainer.atoms().iterator();
    // Check for 3d coordinates
    boolean all3d = true;
    boolean all2d = true;
    while (atoms.hasNext()) {
        IAtom atom = (IAtom) atoms.next();
        if (atom.getPoint3d() == null) {
            all3d = false;
        }
        if (atom.getPoint2d() == null) {
            all2d = false;
        }
    }
    Map<IAtom, InchiAtom> atomMap = new HashMap<IAtom, InchiAtom>();
    atoms = atomContainer.atoms().iterator();
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        // Get coordinates
        // Use 3d if possible, otherwise 2d or none
        double x, y, z;
        if (all3d) {
            Point3d p = atom.getPoint3d();
            x = p.x;
            y = p.y;
            z = p.z;
        } else if (all2d) {
            Point2d p = atom.getPoint2d();
            x = p.x;
            y = p.y;
            z = 0.0;
        } else {
            x = 0.0;
            y = 0.0;
            z = 0.0;
        }
        // Chemical element symbol
        String el = atom.getSymbol();
        // Generate InChI atom
        InchiAtom iatom = new InchiAtom(el, x, y, z);
        input.addAtom(iatom);
        atomMap.put(atom, iatom);
        // Check if charged
        int charge = atom.getFormalCharge();
        if (charge != 0) {
            iatom.setCharge(charge);
        }
        // Check whether isotopic
        Integer isotopeNumber = atom.getMassNumber();
        if (isotopeNumber != null) {
            iatom.setIsotopicMass(isotopeNumber);
        }
        // Check for implicit hydrogens
        // atom.getHydrogenCount() returns number of implict hydrogens, not
        // total number
        // Ref: Posting to cdk-devel list by Egon Willighagen 2005-09-17
        Integer implicitH = atom.getImplicitHydrogenCount();
        // set implicit hydrogen count, -1 tells the inchi to determine it
        iatom.setImplicitHydrogen(implicitH != null ? implicitH : -1);
        // Check if radical
        int count = atomContainer.getConnectedSingleElectronsCount(atom);
        if (count == 1) {
            iatom.setRadical(InchiRadical.DOUBLET);
        } else if (count == 2) {
            Enum spin = atom.getProperty(CDKConstants.SPIN_MULTIPLICITY);
            if (spin != null) {
                // cdk-ctab:SPIN_MULTIPLICITY not accessible by can access via Enum API although
                // a little brittle
                if (spin.name().equals(""DivalentSinglet""))
                    iatom.setRadical(InchiRadical.SINGLET);
                else
                    iatom.setRadical(InchiRadical.TRIPLET);
            } else {
                iatom.setRadical(InchiRadical.TRIPLET);
            }
        } else if (count != 0) {
            throw new CDKException(""Unrecognised radical type"");
        }
    }
    // Process bonds
    for (IBond bond : atomContainer.bonds()) {
        // Assumes 2 centre bond
        InchiAtom at0 = atomMap.get(bond.getBegin());
        InchiAtom at1 = atomMap.get(bond.getEnd());
        // Get bond order
        InchiBondType order;
        Order bo = bond.getOrder();
        if (!ignore && bond.isAromatic()) {
            order = InchiBondType.ALTERN;
        } else if (bo == Order.SINGLE) {
            order = InchiBondType.SINGLE;
        } else if (bo == Order.DOUBLE) {
            order = InchiBondType.DOUBLE;
        } else if (bo == Order.TRIPLE) {
            order = InchiBondType.TRIPLE;
        } else {
            throw new CDKException(""Failed to generate InChI: Unsupported bond type"");
        }
        // Create InChI bond
        // Check for bond stereo definitions
        IBond.Stereo display = bond.getStereo();
        final InchiBondStereo iDisplay;
        switch(display) {
            case UP:
                iDisplay = InchiBondStereo.SINGLE_1UP;
                break;
            case UP_INVERTED:
                iDisplay = InchiBondStereo.SINGLE_2UP;
                break;
            case DOWN:
                iDisplay = InchiBondStereo.SINGLE_1DOWN;
                break;
            case DOWN_INVERTED:
                iDisplay = InchiBondStereo.SINGLE_2DOWN;
                break;
            case UP_OR_DOWN:
                iDisplay = InchiBondStereo.SINGLE_1EITHER;
                break;
            case UP_OR_DOWN_INVERTED:
                iDisplay = InchiBondStereo.SINGLE_2EITHER;
                break;
            case E_OR_Z:
                iDisplay = InchiBondStereo.DOUBLE_EITHER;
                break;
            default:
                iDisplay = InchiBondStereo.NONE;
                break;
        }
        /*
            TODO: old code would set single/double either if no display?
             */
        InchiBond ibond = new InchiBond(at0, at1, order, iDisplay);
        input.addBond(ibond);
    }
    // Process tetrahedral stereo elements
    for (IStereoElement stereoElem : atomContainer.stereoElements()) {
        if (stereoElem instanceof ITetrahedralChirality) {
            ITetrahedralChirality chirality = (ITetrahedralChirality) stereoElem;
            IAtom[] surroundingAtoms = chirality.getLigands();
            Stereo stereoType = chirality.getStereo();
            InchiAtom atC = atomMap.get(chirality.getChiralAtom());
            InchiAtom at0 = atomMap.get(surroundingAtoms[0]);
            InchiAtom at1 = atomMap.get(surroundingAtoms[1]);
            InchiAtom at2 = atomMap.get(surroundingAtoms[2]);
            InchiAtom at3 = atomMap.get(surroundingAtoms[3]);
            InchiStereoParity p;
            if (stereoType == Stereo.ANTI_CLOCKWISE) {
                p = InchiStereoParity.ODD;
            } else if (stereoType == Stereo.CLOCKWISE) {
                p = InchiStereoParity.EVEN;
            } else {
                throw new CDKException(""Unknown tetrahedral chirality"");
            }
            InchiStereo jniStereo = InchiStereo.createTetrahedralStereo(atC, at0, at1, at2, at3, p);
            input.addStereo(jniStereo);
        } else if (stereoElem instanceof IDoubleBondStereochemistry) {
            IDoubleBondStereochemistry dbStereo = (IDoubleBondStereochemistry) stereoElem;
            IBond[] surroundingBonds = dbStereo.getBonds();
            if (surroundingBonds[0] == null || surroundingBonds[1] == null)
                throw new CDKException(""Cannot generate an InChI with incomplete double bond info"");
            org.openscience.cdk.interfaces.IDoubleBondStereochemistry.Conformation stereoType = dbStereo.getStereo();
            IBond stereoBond = dbStereo.getStereoBond();
            InchiAtom at0 = null;
            InchiAtom at1 = null;
            InchiAtom at2 = null;
            InchiAtom at3 = null;
            // TODO: I should check for two atom bonds... or maybe that should happen when you
            // create a double bond stereochemistry
            if (stereoBond.contains(surroundingBonds[0].getBegin())) {
                // first atom is A
                at1 = atomMap.get(surroundingBonds[0].getBegin());
                at0 = atomMap.get(surroundingBonds[0].getEnd());
            } else {
                // first atom is X
                at0 = atomMap.get(surroundingBonds[0].getBegin());
                at1 = atomMap.get(surroundingBonds[0].getEnd());
            }
            if (stereoBond.contains(surroundingBonds[1].getBegin())) {
                // first atom is B
                at2 = atomMap.get(surroundingBonds[1].getBegin());
                at3 = atomMap.get(surroundingBonds[1].getEnd());
            } else {
                // first atom is Y
                at2 = atomMap.get(surroundingBonds[1].getEnd());
                at3 = atomMap.get(surroundingBonds[1].getBegin());
            }
            InchiStereoParity p = InchiStereoParity.UNKNOWN;
            if (stereoType == org.openscience.cdk.interfaces.IDoubleBondStereochemistry.Conformation.TOGETHER) {
                p = InchiStereoParity.ODD;
            } else if (stereoType == org.openscience.cdk.interfaces.IDoubleBondStereochemistry.Conformation.OPPOSITE) {
                p = InchiStereoParity.EVEN;
            } else {
                throw new CDKException(""Unknown double bond stereochemistry"");
            }
            input.addStereo(InchiStereo.createDoubleBondStereo(at0, at1, at2, at3, p));
        } else if (stereoElem instanceof ExtendedTetrahedral) {
            ExtendedTetrahedral extendedTetrahedral = (ExtendedTetrahedral) stereoElem;
            Stereo winding = extendedTetrahedral.winding();
            // The periphals (p<i>) and terminals (t<i>) are refering to
            // the following atoms. The focus (f) is also shown.
            // 
            // p0          p2
            // \          /
            // t0 = f = t1
            // /         \
            // p1         p3
            IAtom focus = extendedTetrahedral.getFocus();
            IAtom[] terminals = extendedTetrahedral.findTerminalAtoms(atomContainer);
            IAtom[] peripherals = extendedTetrahedral.peripherals();
            // InChI only supports length 2
            if (ExtendedTetrahedral.getLength(atomContainer, focus) > 2)
                continue;
            // InChI API is particualar about the input, each terminal atom
            // needs to be present in the list of neighbors and they must
            // be at index 1 and 2 (i.e. in the middle). This is true even
            // of explict atoms. For the implicit atoms, the terminals may
            // be in the peripherals allready and so we correct the winding
            // and reposition as needed.
            List<IBond> t0Bonds = onlySingleBonded(atomContainer.getConnectedBondsList(terminals[0]));
            List<IBond> t1Bonds = onlySingleBonded(atomContainer.getConnectedBondsList(terminals[1]));
            // first if there are two explicit atoms we need to replace one
            // with the terminal atom - the configuration does not change
            if (t0Bonds.size() == 2) {
                IAtom replace = t0Bonds.remove(0).getOther(terminals[0]);
                for (int i = 0; i < peripherals.length; i++) if (replace == peripherals[i])
                    peripherals[i] = terminals[0];
            }
            if (t1Bonds.size() == 2) {
                IAtom replace = t1Bonds.remove(0).getOther(terminals[1]);
                for (int i = 0; i < peripherals.length; i++) if (replace == peripherals[i])
                    peripherals[i] = terminals[1];
            }
            // the neighbor attached to each terminal atom that we will
            // define the configuration of
            IAtom t0Neighbor = t0Bonds.get(0).getOther(terminals[0]);
            IAtom t1Neighbor = t1Bonds.get(0).getOther(terminals[1]);
            // we now need to move all the atoms into the correct positions
            // everytime we exchange atoms the configuration inverts
            for (int i = 0; i < peripherals.length; i++) {
                if (i != 0 && t0Neighbor.equals(peripherals[i])) {
                    swap(peripherals, i, 0);
                    winding = winding.invert();
                } else if (i != 1 && terminals[0].equals(peripherals[i])) {
                    swap(peripherals, i, 1);
                    winding = winding.invert();
                } else if (i != 2 && terminals[1].equals(peripherals[i])) {
                    swap(peripherals, i, 2);
                    winding = winding.invert();
                } else if (i != 3 && t1Neighbor.equals(peripherals[i])) {
                    swap(peripherals, i, 3);
                    winding = winding.invert();
                }
            }
            InchiStereoParity parity = InchiStereoParity.UNKNOWN;
            if (winding == Stereo.ANTI_CLOCKWISE)
                parity = InchiStereoParity.ODD;
            else if (winding == Stereo.CLOCKWISE)
                parity = InchiStereoParity.EVEN;
            else
                throw new CDKException(""Unknown extended tetrahedral chirality"");
            input.addStereo(InchiStereo.createAllenalStereo(atomMap.get(focus), atomMap.get(peripherals[0]), atomMap.get(peripherals[1]), atomMap.get(peripherals[2]), atomMap.get(peripherals[3]), parity));
        }
    }
    output = JnaInchi.toInchi(input, options);
}","private void generateInchiFromCDKAtomContainer(IAtomContainer atomContainer, boolean ignore) throws CDKException{
    this.atomContainer = atomContainer;
    Iterator<IAtom> atoms = atomContainer.atoms().iterator();
    // Check for 3d coordinates
    boolean all3d = true;
    boolean all2d = true;
    while (atoms.hasNext()) {
        IAtom atom = (IAtom) atoms.next();
        if (atom.getPoint3d() == null) {
            all3d = false;
        }
        if (atom.getPoint2d() == null) {
            all2d = false;
        }
    }
    Map<IAtom, InchiAtom> atomMap = new HashMap<IAtom, InchiAtom>();
    atoms = atomContainer.atoms().iterator();
    while (atoms.hasNext()) {
        IAtom atom = atoms.next();
        // Get coordinates
        // Use 3d if possible, otherwise 2d or none
        double x, y, z;
        if (all3d) {
            Point3d p = atom.getPoint3d();
            x = p.x;
            y = p.y;
            z = p.z;
        } else if (all2d) {
            Point2d p = atom.getPoint2d();
            x = p.x;
            y = p.y;
            z = 0.0;
        } else {
            x = 0.0;
            y = 0.0;
            z = 0.0;
        }
        // Chemical element symbol
        String el = atom.getSymbol();
        // Generate InChI atom
        InchiAtom iatom = new InchiAtom(el, x, y, z);
        input.addAtom(iatom);
        atomMap.put(atom, iatom);
        // Check if charged
        int charge = atom.getFormalCharge();
        if (charge != 0) {
            iatom.setCharge(charge);
        }
        // Check whether isotopic
        Integer isotopeNumber = atom.getMassNumber();
        if (isotopeNumber != null) {
            iatom.setIsotopicMass(isotopeNumber);
        }
        // Check for implicit hydrogens
        // atom.getHydrogenCount() returns number of implict hydrogens, not
        // total number
        // Ref: Posting to cdk-devel list by Egon Willighagen 2005-09-17
        Integer implicitH = atom.getImplicitHydrogenCount();
        // set implicit hydrogen count, -1 tells the inchi to determine it
        iatom.setImplicitHydrogen(implicitH != null ? implicitH : -1);
        // Check if radical
        int count = atomContainer.getConnectedSingleElectronsCount(atom);
        if (count == 1) {
            iatom.setRadical(InchiRadical.DOUBLET);
        } else if (count == 2) {
            Enum spin = atom.getProperty(CDKConstants.SPIN_MULTIPLICITY);
            if (spin != null) {
                // cdk-ctab:SPIN_MULTIPLICITY not accessible by can access via Enum API although
                // a little brittle
                if (spin.name().equals(""DivalentSinglet""))
                    iatom.setRadical(InchiRadical.SINGLET);
                else
                    iatom.setRadical(InchiRadical.TRIPLET);
            } else {
                iatom.setRadical(InchiRadical.TRIPLET);
            }
        } else if (count != 0) {
            throw new CDKException(""Unrecognised radical type"");
        }
    }
    // Process bonds
    for (IBond bond : atomContainer.bonds()) {
        // Assumes 2 centre bond
        InchiAtom at0 = atomMap.get(bond.getBegin());
        InchiAtom at1 = atomMap.get(bond.getEnd());
        // Get bond order
        InchiBondType order;
        Order bo = bond.getOrder();
        if (!ignore && bond.isAromatic()) {
            order = InchiBondType.ALTERN;
        } else if (bo == Order.SINGLE) {
            order = InchiBondType.SINGLE;
        } else if (bo == Order.DOUBLE) {
            order = InchiBondType.DOUBLE;
        } else if (bo == Order.TRIPLE) {
            order = InchiBondType.TRIPLE;
        } else {
            throw new CDKException(""Failed to generate InChI: Unsupported bond type"");
        }
        // Create InChI bond
        // Check for bond stereo definitions
        IBond.Stereo display = bond.getStereo();
        final InchiBondStereo iDisplay;
        switch(display) {
            case UP:
                iDisplay = InchiBondStereo.SINGLE_1UP;
                break;
            case UP_INVERTED:
                iDisplay = InchiBondStereo.SINGLE_2UP;
                break;
            case DOWN:
                iDisplay = InchiBondStereo.SINGLE_1DOWN;
                break;
            case DOWN_INVERTED:
                iDisplay = InchiBondStereo.SINGLE_2DOWN;
                break;
            case UP_OR_DOWN:
                iDisplay = InchiBondStereo.SINGLE_1EITHER;
                break;
            case UP_OR_DOWN_INVERTED:
                iDisplay = InchiBondStereo.SINGLE_2EITHER;
                break;
            case E_OR_Z:
                iDisplay = InchiBondStereo.DOUBLE_EITHER;
                break;
            default:
                iDisplay = InchiBondStereo.NONE;
                break;
        }
        /*
            TODO: old code would set single/double either if no display?
             */
        InchiBond ibond = new InchiBond(at0, at1, order, iDisplay);
        input.addBond(ibond);
    }
    // Process tetrahedral stereo elements
    for (IStereoElement stereoElem : atomContainer.stereoElements()) {
        if (stereoElem instanceof ITetrahedralChirality) {
            ITetrahedralChirality chirality = (ITetrahedralChirality) stereoElem;
            IAtom[] surroundingAtoms = chirality.getLigands();
            Stereo stereoType = chirality.getStereo();
            InchiAtom atC = atomMap.get(chirality.getChiralAtom());
            InchiAtom at0 = atomMap.get(surroundingAtoms[0]);
            InchiAtom at1 = atomMap.get(surroundingAtoms[1]);
            InchiAtom at2 = atomMap.get(surroundingAtoms[2]);
            InchiAtom at3 = atomMap.get(surroundingAtoms[3]);
            InchiStereoParity p;
            if (stereoType == Stereo.ANTI_CLOCKWISE) {
                p = InchiStereoParity.ODD;
            } else if (stereoType == Stereo.CLOCKWISE) {
                p = InchiStereoParity.EVEN;
            } else {
                throw new CDKException(""Unknown tetrahedral chirality"");
            }
            InchiStereo jniStereo = InchiStereo.createTetrahedralStereo(atC, at0, at1, at2, at3, p);
            input.addStereo(jniStereo);
        } else if (stereoElem instanceof IDoubleBondStereochemistry) {
            IDoubleBondStereochemistry dbStereo = (IDoubleBondStereochemistry) stereoElem;
            IBond[] surroundingBonds = dbStereo.getBonds();
            if (surroundingBonds[0] == null || surroundingBonds[1] == null)
                throw new CDKException(""Cannot generate an InChI with incomplete double bond info"");
            org.openscience.cdk.interfaces.IDoubleBondStereochemistry.Conformation stereoType = dbStereo.getStereo();
            IBond stereoBond = dbStereo.getStereoBond();
            InchiAtom at0 = null;
            InchiAtom at1 = null;
            InchiAtom at2 = null;
            InchiAtom at3 = null;
            // TODO: I should check for two atom bonds... or maybe that should happen when you
            // create a double bond stereochemistry
            if (stereoBond.contains(surroundingBonds[0].getBegin())) {
                // first atom is A
                at1 = atomMap.get(surroundingBonds[0].getBegin());
                at0 = atomMap.get(surroundingBonds[0].getEnd());
            } else {
                // first atom is X
                at0 = atomMap.get(surroundingBonds[0].getBegin());
                at1 = atomMap.get(surroundingBonds[0].getEnd());
            }
            if (stereoBond.contains(surroundingBonds[1].getBegin())) {
                // first atom is B
                at2 = atomMap.get(surroundingBonds[1].getBegin());
                at3 = atomMap.get(surroundingBonds[1].getEnd());
            } else {
                // first atom is Y
                at2 = atomMap.get(surroundingBonds[1].getEnd());
                at3 = atomMap.get(surroundingBonds[1].getBegin());
            }
            InchiStereoParity p = InchiStereoParity.UNKNOWN;
            if (stereoType == org.openscience.cdk.interfaces.IDoubleBondStereochemistry.Conformation.TOGETHER) {
                p = InchiStereoParity.ODD;
            } else if (stereoType == org.openscience.cdk.interfaces.IDoubleBondStereochemistry.Conformation.OPPOSITE) {
                p = InchiStereoParity.EVEN;
            } else {
                throw new CDKException(""Unknown double bond stereochemistry"");
            }
            input.addStereo(InchiStereo.createDoubleBondStereo(at0, at1, at2, at3, p));
        } else if (stereoElem instanceof ExtendedTetrahedral) {
            ExtendedTetrahedral extendedTetrahedral = (ExtendedTetrahedral) stereoElem;
            Stereo winding = extendedTetrahedral.winding();
            // The periphals (p<i>) and terminals (t<i>) are refering to
            // the following atoms. The focus (f) is also shown.
            // 
            // p0          p2
            // \          /
            // t0 = f = t1
            // /         \
            // p1         p3
            IAtom focus = extendedTetrahedral.getFocus();
            IAtom[] terminals = extendedTetrahedral.findTerminalAtoms(atomContainer);
            IAtom[] peripherals = extendedTetrahedral.peripherals();
            // InChI only supports length 2
            if (ExtendedTetrahedral.getLength(atomContainer, focus) > 2)
                continue;
            // InChI API is particualar about the input, each terminal atom
            // needs to be present in the list of neighbors and they must
            // be at index 1 and 2 (i.e. in the middle). This is true even
            // of explict atoms. For the implicit atoms, the terminals may
            // be in the peripherals allready and so we correct the winding
            // and reposition as needed.
            List<IBond> t0Bonds = onlySingleBonded(atomContainer.getConnectedBondsList(terminals[0]));
            List<IBond> t1Bonds = onlySingleBonded(atomContainer.getConnectedBondsList(terminals[1]));
            // first if there are two explicit atoms we need to replace one
            // with the terminal atom - the configuration does not change
            if (t0Bonds.size() == 2) {
                IAtom replace = t0Bonds.remove(0).getOther(terminals[0]);
                for (int i = 0; i < peripherals.length; i++) if (replace == peripherals[i])
                    peripherals[i] = terminals[0];
            }
            if (t1Bonds.size() == 2) {
                IAtom replace = t1Bonds.remove(0).getOther(terminals[1]);
                for (int i = 0; i < peripherals.length; i++) if (replace == peripherals[i])
                    peripherals[i] = terminals[1];
            }
            // the neighbor attached to each terminal atom that we will
            // define the configuration of
            IAtom t0Neighbor = t0Bonds.get(0).getOther(terminals[0]);
            IAtom t1Neighbor = t1Bonds.get(0).getOther(terminals[1]);
            // we now need to move all the atoms into the correct positions
            // everytime we exchange atoms the configuration inverts
            for (int i = 0; i < peripherals.length; i++) {
                if (i != 0 && t0Neighbor.equals(peripherals[i])) {
                    swap(peripherals, i, 0);
                    winding = winding.invert();
                } else if (i != 1 && terminals[0].equals(peripherals[i])) {
                    swap(peripherals, i, 1);
                    winding = winding.invert();
                } else if (i != 2 && terminals[1].equals(peripherals[i])) {
                    swap(peripherals, i, 2);
                    winding = winding.invert();
                } else if (i != 3 && t1Neighbor.equals(peripherals[i])) {
                    swap(peripherals, i, 3);
                    winding = winding.invert();
                }
            }
            InchiStereoParity parity = InchiStereoParity.UNKNOWN;
            if (winding == Stereo.ANTI_CLOCKWISE)
                parity = InchiStereoParity.ODD;
            else if (winding == Stereo.CLOCKWISE)
                parity = InchiStereoParity.EVEN;
            else
                throw new CDKException(""Unknown extended tetrahedral chirality"");
            input.addStereo(InchiStereo.createAllenalStereo(atomMap.get(focus), atomMap.get(peripherals[0]), atomMap.get(peripherals[1]), atomMap.get(peripherals[2]), atomMap.get(peripherals[3]), parity));
        }
    }
    output = JnaInchi.toInchi(input, options);
}","/**
     * <p>Reads atoms, bonds etc from atom container and converts to format
     * InChI library requires, then places call for the library to generate
     * the InChI.
     *
     * @param atomContainer AtomContainer to generate InChI for.
     * @param ignore Ignore aromatic bonds
     * @throws CDKException
     */","('generateInchiFromCDKAtomContainer', {'INSTRUCTION': {'covered': 664, 'missed': 104}, 'BRANCH': {'covered': 85, 'missed': 23}, 'LINE': {'covered': 147, 'missed': 24}, 'COMPLEXITY': {'covered': 37, 'missed': 21}, 'METHOD': {'covered': 1, 'missed': 0}})",1831.0,"  <p>Reads atoms, bonds etc from atom container and converts to format  InChI library requires, then places call for the library to generate  the InChI.",30.0,"['When reading atoms, bonds etc from atom container, places call for the library to generate the InChI.', 'When reading atoms, bonds etc from atom container, places call for the library to generate the In chI.', 'When reading atoms, bonds etc from atom container, places call for the library to generate InChI.']"
1126,cdk,org/openscience/cdk/io/PDBReader.java,/storage/pdb/src/main/java/org/openscience/cdk/io/PDBReader.java,readChemFile,204-498,"/**
     * Read a <code>ChemFile</code> from a file in PDB format. The molecules
     * in the file are stored as <code>BioPolymer</code>s in the
     * <code>ChemFile</code>. The residues are the monomers of the
     * <code>BioPolymer</code>, and their names are the concatenation of the
     * residue, chain id, and the sequence number. Separate chains (denoted by
     * TER records) are stored as separate <code>BioPolymer</code> molecules.
     *
     * <p>Connectivity information is not currently read.
     *
     * @return The ChemFile that was read from the PDB file.
     */
private IChemFile readChemFile(IChemFile oFile){
    IChemSequence oSeq = oFile.getBuilder().newInstance(IChemSequence.class);
    IChemModel oModel = oFile.getBuilder().newInstance(IChemModel.class);
    IAtomContainerSet oSet = oFile.getBuilder().newInstance(IAtomContainerSet.class);
    String cCol;
    PDBAtom oAtom;
    PDBPolymer oBP = new PDBPolymer();
    IAtomContainer molecularStructure = oFile.getBuilder().newInstance(IAtomContainer.class);
    StringBuffer cResidue;
    String oObj;
    IMonomer oMonomer;
    String cRead = """";
    char chain = 'A';
    IStrand oStrand;
    int lineLength = 0;
    boolean isProteinStructure = false;
    atomNumberMap = new Hashtable<Integer, IAtom>();
    if (readConnect.isSet()) {
        bondsFromConnectRecords = new ArrayList<IBond>();
    }
    try {
        do {
            cRead = _oInput.readLine();
            logger.debug(""Read line: "", cRead);
            if (cRead != null) {
                lineLength = cRead.length();
                if (lineLength < 6) {
                    cRead = cRead + ""      "";
                }
                cCol = cRead.substring(0, 6);
                if (""SEQRES"".equalsIgnoreCase(cCol)) {
                    isProteinStructure = true;
                } else if (""ATOM  "".equalsIgnoreCase(cCol)) {
                    oAtom = readAtom(cRead, lineLength);
                    if (isProteinStructure) {
                        cResidue = new StringBuffer(8);
                        oObj = oAtom.getResName();
                        if (oObj != null) {
                            cResidue = cResidue.append(oObj.trim());
                        }
                        oObj = oAtom.getChainID();
                        if (oObj != null) {
                            cResidue = cResidue.append(String.valueOf(chain));
                        }
                        oObj = oAtom.getResSeq();
                        if (oObj != null) {
                            cResidue = cResidue.append(oObj.trim());
                        }
                        String strandName = oAtom.getChainID();
                        if (strandName == null || strandName.length() == 0) {
                            strandName = String.valueOf(chain);
                        }
                        oStrand = oBP.getStrand(strandName);
                        if (oStrand == null) {
                            oStrand = new PDBStrand();
                            oStrand.setStrandName(strandName);
                            oStrand.setID(String.valueOf(chain));
                        }
                        oMonomer = oBP.getMonomer(cResidue.toString(), String.valueOf(chain));
                        if (oMonomer == null) {
                            PDBMonomer monomer = new PDBMonomer();
                            monomer.setMonomerName(cResidue.toString());
                            monomer.setMonomerType(oAtom.getResName());
                            monomer.setChainID(oAtom.getChainID());
                            monomer.setICode(oAtom.getICode());
                            monomer.setResSeq(oAtom.getResSeq());
                            oMonomer = monomer;
                        }
                        oBP.addAtom(oAtom, oMonomer, oStrand);
                    } else {
                        molecularStructure.addAtom(oAtom);
                    }
                    if (readConnect.isSet() && atomNumberMap.put(oAtom.getSerial(), oAtom) != null) {
                        logger.warn(""Duplicate serial ID found for atom: "", oAtom);
                    }
                    logger.debug(""Added ATOM: "", oAtom);
                } else if (""HETATM"".equalsIgnoreCase(cCol)) {
                    oAtom = readAtom(cRead, lineLength);
                    oAtom.setHetAtom(true);
                    if (isProteinStructure) {
                        oBP.addAtom(oAtom);
                    } else {
                        molecularStructure.addAtom(oAtom);
                    }
                    if (atomNumberMap.put(oAtom.getSerial(), oAtom) != null) {
                        logger.warn(""Duplicate serial ID found for atom: "", oAtom);
                    }
                    logger.debug(""Added HETATM: "", oAtom);
                } else if (""TER   "".equalsIgnoreCase(cCol)) {
                    chain++;
                    oStrand = new PDBStrand();
                    oStrand.setStrandName(String.valueOf(chain));
                    logger.debug(""Added new STRAND"");
                } else if (""END   "".equalsIgnoreCase(cCol)) {
                    atomNumberMap.clear();
                    if (isProteinStructure) {
                        oSet.addAtomContainer(oBP);
                        if (useRebondTool.isSet()) {
                            try {
                                if (!createBondsWithRebondTool(oBP)) {
                                    logger.info(""Bonds could not be created using the RebondTool when PDB file was read."");
                                    oBP.removeAllBonds();
                                }
                            } catch (Exception exception) {
                                logger.info(""Bonds could not be created when PDB file was read."");
                                logger.debug(exception);
                            }
                        }
                    } else {
                        if (useRebondTool.isSet())
                            createBondsWithRebondTool(molecularStructure);
                        oSet.addAtomContainer(molecularStructure);
                    }
                } else if (cCol.equals(""MODEL "")) {
                    if (isProteinStructure) {
                        if (oBP.getAtomCount() > 0) {
                            oSet.addAtomContainer(oBP);
                            oModel.setMoleculeSet(oSet);
                            oSeq.addChemModel(oModel);
                            oBP = new PDBPolymer();
                            oModel = oFile.getBuilder().newInstance(IChemModel.class);
                            oSet = oFile.getBuilder().newInstance(IAtomContainerSet.class);
                            atomNumberMap.clear();
                        }
                    } else {
                        if (molecularStructure.getAtomCount() > 0) {
                            oSet.addAtomContainer(molecularStructure);
                            oModel.setMoleculeSet(oSet);
                            oSeq.addChemModel(oModel);
                            molecularStructure = oFile.getBuilder().newInstance(IAtomContainer.class);
                            oModel = oFile.getBuilder().newInstance(IChemModel.class);
                            oSet = oFile.getBuilder().newInstance(IAtomContainerSet.class);
                        }
                    }
                } else if (""REMARK"".equalsIgnoreCase(cCol)) {
                    Object comment = oFile.getProperty(CDKConstants.COMMENT);
                    if (comment == null) {
                        comment = """";
                    }
                    if (lineLength > 12) {
                        comment = comment.toString() + cRead.substring(11).trim() + ""\n"";
                        oFile.setProperty(CDKConstants.COMMENT, comment);
                    } else {
                        logger.warn(""REMARK line found without any comment!"");
                    }
                } else if (""COMPND"".equalsIgnoreCase(cCol)) {
                    String title = cRead.substring(10).trim();
                    oFile.setProperty(CDKConstants.TITLE, title);
                } else if (readConnect.isSet() && ""CONECT"".equalsIgnoreCase(cCol)) {
                    cRead.trim();
                    if (cRead.length() < 16) {
                        logger.debug(""Skipping unexpected empty CONECT line! : "", cRead);
                    } else {
                        int lineIndex = 6;
                        int atomFromNumber = -1;
                        int atomToNumber = -1;
                        IAtomContainer molecule = (isProteinStructure) ? oBP : molecularStructure;
                        while (lineIndex + 5 <= cRead.length()) {
                            String part = cRead.substring(lineIndex, lineIndex + 5).trim();
                            if (atomFromNumber == -1) {
                                try {
                                    atomFromNumber = Integer.parseInt(part);
                                } catch (NumberFormatException nfe) {
                                }
                            } else {
                                try {
                                    atomToNumber = Integer.parseInt(part);
                                } catch (NumberFormatException nfe) {
                                    atomToNumber = -1;
                                }
                                if (atomFromNumber != -1 && atomToNumber != -1) {
                                    addBond(molecule, atomFromNumber, atomToNumber);
                                    logger.debug(""Bonded "" + atomFromNumber + "" with "" + atomToNumber);
                                }
                            }
                            lineIndex += 5;
                        }
                    }
                } else if (""HELIX "".equalsIgnoreCase(cCol)) {
                    PDBStructure structure = new PDBStructure();
                    structure.setStructureType(PDBStructure.HELIX);
                    structure.setStartChainID(cRead.charAt(19));
                    structure.setStartSequenceNumber(Integer.parseInt(cRead.substring(21, 25).trim()));
                    structure.setStartInsertionCode(cRead.charAt(25));
                    structure.setEndChainID(cRead.charAt(31));
                    structure.setEndSequenceNumber(Integer.parseInt(cRead.substring(33, 37).trim()));
                    structure.setEndInsertionCode(cRead.charAt(37));
                    oBP.addStructure(structure);
                } else if (""SHEET "".equalsIgnoreCase(cCol)) {
                    PDBStructure structure = new PDBStructure();
                    structure.setStructureType(PDBStructure.SHEET);
                    structure.setStartChainID(cRead.charAt(21));
                    structure.setStartSequenceNumber(Integer.parseInt(cRead.substring(22, 26).trim()));
                    structure.setStartInsertionCode(cRead.charAt(26));
                    structure.setEndChainID(cRead.charAt(32));
                    structure.setEndSequenceNumber(Integer.parseInt(cRead.substring(33, 37).trim()));
                    structure.setEndInsertionCode(cRead.charAt(37));
                    oBP.addStructure(structure);
                } else if (""TURN  "".equalsIgnoreCase(cCol)) {
                    PDBStructure structure = new PDBStructure();
                    structure.setStructureType(PDBStructure.TURN);
                    structure.setStartChainID(cRead.charAt(19));
                    structure.setStartSequenceNumber(Integer.parseInt(cRead.substring(20, 24).trim()));
                    structure.setStartInsertionCode(cRead.charAt(24));
                    structure.setEndChainID(cRead.charAt(30));
                    structure.setEndSequenceNumber(Integer.parseInt(cRead.substring(31, 35).trim()));
                    structure.setEndInsertionCode(cRead.charAt(35));
                    oBP.addStructure(structure);
                }
            }
        } while (_oInput.ready() && (cRead != null));
    } catch (IOException | IllegalArgumentException | CDKException e) {
        logger.error(""Found a problem at line:"");
        logger.error(cRead);
        logger.error(""01234567890123456789012345678901234567890123456789012345678901234567890123456789"");
        logger.error(""          1         2         3         4         5         6         7         "");
        logger.error(""  error: "" + e.getMessage());
        logger.debug(e);
        e.printStackTrace();
    }
    try {
        _oInput.close();
    } catch (Exception e) {
        logger.debug(e);
    }
    oModel.setMoleculeSet(oSet);
    oSeq.addChemModel(oModel);
    oFile.addChemSequence(oSeq);
    return oFile;
}","private IChemFile readChemFile(IChemFile oFile){
    IChemSequence oSeq = oFile.getBuilder().newInstance(IChemSequence.class);
    IChemModel oModel = oFile.getBuilder().newInstance(IChemModel.class);
    IAtomContainerSet oSet = oFile.getBuilder().newInstance(IAtomContainerSet.class);
    String cCol;
    PDBAtom oAtom;
    PDBPolymer oBP = new PDBPolymer();
    IAtomContainer molecularStructure = oFile.getBuilder().newInstance(IAtomContainer.class);
    StringBuffer cResidue;
    String oObj;
    IMonomer oMonomer;
    String cRead = """";
    char chain = 'A';
    IStrand oStrand;
    int lineLength = 0;
    boolean isProteinStructure = false;
    atomNumberMap = new Hashtable<Integer, IAtom>();
    if (readConnect.isSet()) {
        bondsFromConnectRecords = new ArrayList<IBond>();
    }
    try {
        do {
            cRead = _oInput.readLine();
            logger.debug(""Read line: "", cRead);
            if (cRead != null) {
                lineLength = cRead.length();
                if (lineLength < 6) {
                    cRead = cRead + ""      "";
                }
                cCol = cRead.substring(0, 6);
                if (""SEQRES"".equalsIgnoreCase(cCol)) {
                    isProteinStructure = true;
                } else if (""ATOM  "".equalsIgnoreCase(cCol)) {
                    oAtom = readAtom(cRead, lineLength);
                    if (isProteinStructure) {
                        cResidue = new StringBuffer(8);
                        oObj = oAtom.getResName();
                        if (oObj != null) {
                            cResidue = cResidue.append(oObj.trim());
                        }
                        oObj = oAtom.getChainID();
                        if (oObj != null) {
                            cResidue = cResidue.append(String.valueOf(chain));
                        }
                        oObj = oAtom.getResSeq();
                        if (oObj != null) {
                            cResidue = cResidue.append(oObj.trim());
                        }
                        String strandName = oAtom.getChainID();
                        if (strandName == null || strandName.length() == 0) {
                            strandName = String.valueOf(chain);
                        }
                        oStrand = oBP.getStrand(strandName);
                        if (oStrand == null) {
                            oStrand = new PDBStrand();
                            oStrand.setStrandName(strandName);
                            oStrand.setID(String.valueOf(chain));
                        }
                        oMonomer = oBP.getMonomer(cResidue.toString(), String.valueOf(chain));
                        if (oMonomer == null) {
                            PDBMonomer monomer = new PDBMonomer();
                            monomer.setMonomerName(cResidue.toString());
                            monomer.setMonomerType(oAtom.getResName());
                            monomer.setChainID(oAtom.getChainID());
                            monomer.setICode(oAtom.getICode());
                            monomer.setResSeq(oAtom.getResSeq());
                            oMonomer = monomer;
                        }
                        oBP.addAtom(oAtom, oMonomer, oStrand);
                    } else {
                        molecularStructure.addAtom(oAtom);
                    }
                    if (readConnect.isSet() && atomNumberMap.put(oAtom.getSerial(), oAtom) != null) {
                        logger.warn(""Duplicate serial ID found for atom: "", oAtom);
                    }
                    logger.debug(""Added ATOM: "", oAtom);
                } else if (""HETATM"".equalsIgnoreCase(cCol)) {
                    oAtom = readAtom(cRead, lineLength);
                    oAtom.setHetAtom(true);
                    if (isProteinStructure) {
                        oBP.addAtom(oAtom);
                    } else {
                        molecularStructure.addAtom(oAtom);
                    }
                    if (atomNumberMap.put(oAtom.getSerial(), oAtom) != null) {
                        logger.warn(""Duplicate serial ID found for atom: "", oAtom);
                    }
                    logger.debug(""Added HETATM: "", oAtom);
                } else if (""TER   "".equalsIgnoreCase(cCol)) {
                    chain++;
                    oStrand = new PDBStrand();
                    oStrand.setStrandName(String.valueOf(chain));
                    logger.debug(""Added new STRAND"");
                } else if (""END   "".equalsIgnoreCase(cCol)) {
                    atomNumberMap.clear();
                    if (isProteinStructure) {
                        oSet.addAtomContainer(oBP);
                        if (useRebondTool.isSet()) {
                            try {
                                if (!createBondsWithRebondTool(oBP)) {
                                    logger.info(""Bonds could not be created using the RebondTool when PDB file was read."");
                                    oBP.removeAllBonds();
                                }
                            } catch (Exception exception) {
                                logger.info(""Bonds could not be created when PDB file was read."");
                                logger.debug(exception);
                            }
                        }
                    } else {
                        if (useRebondTool.isSet())
                            createBondsWithRebondTool(molecularStructure);
                        oSet.addAtomContainer(molecularStructure);
                    }
                } else if (cCol.equals(""MODEL "")) {
                    if (isProteinStructure) {
                        if (oBP.getAtomCount() > 0) {
                            oSet.addAtomContainer(oBP);
                            oModel.setMoleculeSet(oSet);
                            oSeq.addChemModel(oModel);
                            oBP = new PDBPolymer();
                            oModel = oFile.getBuilder().newInstance(IChemModel.class);
                            oSet = oFile.getBuilder().newInstance(IAtomContainerSet.class);
                            atomNumberMap.clear();
                        }
                    } else {
                        if (molecularStructure.getAtomCount() > 0) {
                            oSet.addAtomContainer(molecularStructure);
                            oModel.setMoleculeSet(oSet);
                            oSeq.addChemModel(oModel);
                            molecularStructure = oFile.getBuilder().newInstance(IAtomContainer.class);
                            oModel = oFile.getBuilder().newInstance(IChemModel.class);
                            oSet = oFile.getBuilder().newInstance(IAtomContainerSet.class);
                        }
                    }
                } else if (""REMARK"".equalsIgnoreCase(cCol)) {
                    Object comment = oFile.getProperty(CDKConstants.COMMENT);
                    if (comment == null) {
                        comment = """";
                    }
                    if (lineLength > 12) {
                        comment = comment.toString() + cRead.substring(11).trim() + ""\n"";
                        oFile.setProperty(CDKConstants.COMMENT, comment);
                    } else {
                        logger.warn(""REMARK line found without any comment!"");
                    }
                } else if (""COMPND"".equalsIgnoreCase(cCol)) {
                    String title = cRead.substring(10).trim();
                    oFile.setProperty(CDKConstants.TITLE, title);
                } else if (readConnect.isSet() && ""CONECT"".equalsIgnoreCase(cCol)) {
                    cRead.trim();
                    if (cRead.length() < 16) {
                        logger.debug(""Skipping unexpected empty CONECT line! : "", cRead);
                    } else {
                        int lineIndex = 6;
                        int atomFromNumber = -1;
                        int atomToNumber = -1;
                        IAtomContainer molecule = (isProteinStructure) ? oBP : molecularStructure;
                        while (lineIndex + 5 <= cRead.length()) {
                            String part = cRead.substring(lineIndex, lineIndex + 5).trim();
                            if (atomFromNumber == -1) {
                                try {
                                    atomFromNumber = Integer.parseInt(part);
                                } catch (NumberFormatException nfe) {
                                }
                            } else {
                                try {
                                    atomToNumber = Integer.parseInt(part);
                                } catch (NumberFormatException nfe) {
                                    atomToNumber = -1;
                                }
                                if (atomFromNumber != -1 && atomToNumber != -1) {
                                    addBond(molecule, atomFromNumber, atomToNumber);
                                    logger.debug(""Bonded "" + atomFromNumber + "" with "" + atomToNumber);
                                }
                            }
                            lineIndex += 5;
                        }
                    }
                } else if (""HELIX "".equalsIgnoreCase(cCol)) {
                    PDBStructure structure = new PDBStructure();
                    structure.setStructureType(PDBStructure.HELIX);
                    structure.setStartChainID(cRead.charAt(19));
                    structure.setStartSequenceNumber(Integer.parseInt(cRead.substring(21, 25).trim()));
                    structure.setStartInsertionCode(cRead.charAt(25));
                    structure.setEndChainID(cRead.charAt(31));
                    structure.setEndSequenceNumber(Integer.parseInt(cRead.substring(33, 37).trim()));
                    structure.setEndInsertionCode(cRead.charAt(37));
                    oBP.addStructure(structure);
                } else if (""SHEET "".equalsIgnoreCase(cCol)) {
                    PDBStructure structure = new PDBStructure();
                    structure.setStructureType(PDBStructure.SHEET);
                    structure.setStartChainID(cRead.charAt(21));
                    structure.setStartSequenceNumber(Integer.parseInt(cRead.substring(22, 26).trim()));
                    structure.setStartInsertionCode(cRead.charAt(26));
                    structure.setEndChainID(cRead.charAt(32));
                    structure.setEndSequenceNumber(Integer.parseInt(cRead.substring(33, 37).trim()));
                    structure.setEndInsertionCode(cRead.charAt(37));
                    oBP.addStructure(structure);
                } else if (""TURN  "".equalsIgnoreCase(cCol)) {
                    PDBStructure structure = new PDBStructure();
                    structure.setStructureType(PDBStructure.TURN);
                    structure.setStartChainID(cRead.charAt(19));
                    structure.setStartSequenceNumber(Integer.parseInt(cRead.substring(20, 24).trim()));
                    structure.setStartInsertionCode(cRead.charAt(24));
                    structure.setEndChainID(cRead.charAt(30));
                    structure.setEndSequenceNumber(Integer.parseInt(cRead.substring(31, 35).trim()));
                    structure.setEndInsertionCode(cRead.charAt(35));
                    oBP.addStructure(structure);
                }
            }
        } while (_oInput.ready() && (cRead != null));
    } catch (IOException | IllegalArgumentException | CDKException e) {
        logger.error(""Found a problem at line:"");
        logger.error(cRead);
        logger.error(""01234567890123456789012345678901234567890123456789012345678901234567890123456789"");
        logger.error(""          1         2         3         4         5         6         7         "");
        logger.error(""  error: "" + e.getMessage());
        logger.debug(e);
        e.printStackTrace();
    }
    try {
        _oInput.close();
    } catch (Exception e) {
        logger.debug(e);
    }
    oModel.setMoleculeSet(oSet);
    oSeq.addChemModel(oModel);
    oFile.addChemSequence(oSeq);
    return oFile;
}","/**
     * Read a <code>ChemFile</code> from a file in PDB format. The molecules
     * in the file are stored as <code>BioPolymer</code>s in the
     * <code>ChemFile</code>. The residues are the monomers of the
     * <code>BioPolymer</code>, and their names are the concatenation of the
     * residue, chain id, and the sequence number. Separate chains (denoted by
     * TER records) are stored as separate <code>BioPolymer</code> molecules.
     *
     * <p>Connectivity information is not currently read.
     *
     * @return The ChemFile that was read from the PDB file.
     */","('readChemFile', {'INSTRUCTION': {'covered': 656, 'missed': 159}, 'BRANCH': {'covered': 68, 'missed': 22}, 'LINE': {'covered': 148, 'missed': 38}, 'COMPLEXITY': {'covered': 28, 'missed': 18}, 'METHOD': {'covered': 1, 'missed': 0}})",1847.0,  Read a <code>ChemFile</code> from a file in PDB format.,16.0,"['From a file in PDB format, read a code>ChemFile/code>.', 'From a file in PDB format, you can read code>ChemFile/code>.', 'From a file in PDB format, you can read a code>ChemFile/code>.']"
1127,cdk,org/openscience/cdk/io/MDLV2000Reader.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Reader.java,readPropertiesFast,880-1442,"/**
     * Reads the property block from the {@code input} setting the values in the
     * container.
     *
     * @param input     input resource
     * @param container the structure with atoms / bonds present
     * @param nAtoms    the number of atoms in the atoms block
     * @throws IOException low-level IO error
     */
 void readPropertiesFast(final BufferedReader input, final IAtomContainer container, final int nAtoms) throws IOException, CDKException{
    String line;
    int offset = container.getAtomCount() - nAtoms;
    Map<Integer, Sgroup> sgroups = new LinkedHashMap<>();
    LINES: while ((line = input.readLine()) != null) {
        int index, count, lnOffset;
        Sgroup sgroup;
        int length = line.length();
        final PropertyKey key = PropertyKey.of(line);
        switch(key) {
            case ATOM_ALIAS:
                index = readMolfileInt(line, 3) - 1;
                final String label = input.readLine();
                if (label == null)
                    return;
                label(container, offset + index, label);
                break;
            case ATOM_VALUE:
                index = readMolfileInt(line, 3) - 1;
                final String comment = line.substring(7);
                container.getAtom(offset + index).setProperty(CDKConstants.COMMENT, comment);
                break;
            case GROUP_ABBREVIATION:
                final String group = input.readLine();
                if (group == null)
                    return;
                break;
            case LEGACY_ATOM_LIST:
                index = readUInt(line, 0, 3) - 1;
                {
                    boolean negate = line.charAt(3) == 'T' || line.charAt(4) == 'T';
                    Expr expr = new Expr(Expr.Type.TRUE);
                    StringBuilder sb = new StringBuilder();
                    for (int i = 11; i < line.length(); i += 4) {
                        int atomicNumber = readUInt(line, i, 3);
                        expr.or(new Expr(Expr.Type.ELEMENT, atomicNumber));
                    }
                    if (negate)
                        expr.negate();
                    IAtom atom = container.getAtom(index);
                    if (AtomRef.deref(atom) instanceof QueryAtom) {
                        QueryAtom ref = (QueryAtom) AtomRef.deref(atom);
                        ref.setExpression(expr);
                    } else {
                        QueryAtom queryAtom = new QueryAtom(expr);
                        queryAtom.setPoint2d(atom.getPoint2d());
                        queryAtom.setPoint3d(atom.getPoint3d());
                        container.setAtom(index, queryAtom);
                    }
                }
                break;
            case M_ALS:
                index = readUInt(line, 7, 3) - 1;
                {
                    boolean negate = line.charAt(13) == 'T' || line.charAt(14) == 'T';
                    Expr expr = new Expr(Expr.Type.TRUE);
                    StringBuilder sb = new StringBuilder();
                    for (int i = 16; i < line.length(); i++) {
                        if (line.charAt(i) != ' ') {
                            sb.append(line.charAt(i));
                        } else if (sb.length() != 0) {
                            int elem = Elements.ofString(sb.toString()).number();
                            if (elem != 0)
                                expr.or(new Expr(Expr.Type.ELEMENT, elem));
                            sb.setLength(0);
                        }
                    }
                    if (sb.length() != 0) {
                        int elem = Elements.ofString(sb.toString()).number();
                        if (elem != 0)
                            expr.or(new Expr(Expr.Type.ELEMENT, elem));
                    }
                    if (negate)
                        expr.negate();
                    IAtom atom = container.getAtom(index);
                    if (AtomRef.deref(atom) instanceof QueryAtom) {
                        QueryAtom ref = (QueryAtom) AtomRef.deref(atom);
                        ref.setExpression(expr);
                    } else {
                        QueryAtom queryAtom = new QueryAtom(expr);
                        queryAtom.setPoint2d(atom.getPoint2d());
                        queryAtom.setPoint3d(atom.getPoint3d());
                        container.setAtom(index, queryAtom);
                    }
                }
                break;
            case M_CHG:
                count = readUInt(line, 6, 3);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    index = readMolfileInt(line, st) - 1;
                    int charge = readMolfileInt(line, st + 4);
                    container.getAtom(offset + index).setFormalCharge(charge);
                }
                break;
            case M_ISO:
                count = readUInt(line, 6, 3);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    index = readMolfileInt(line, st) - 1;
                    int mass = readMolfileInt(line, st + 4);
                    if (mass < 0)
                        handleError(""Absolute mass number should be >= 0, "" + line);
                    else
                        container.getAtom(offset + index).setMassNumber(mass);
                }
                break;
            case M_RAD:
                count = readUInt(line, 6, 3);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    index = readMolfileInt(line, st) - 1;
                    int value = readMolfileInt(line, st + 4);
                    SPIN_MULTIPLICITY multiplicity = SPIN_MULTIPLICITY.ofValue(value);
                    container.getAtom(offset + index).setProperty(CDKConstants.SPIN_MULTIPLICITY, multiplicity);
                    for (int e = 0; e < multiplicity.getSingleElectrons(); e++) container.addSingleElectron(offset + index);
                }
                break;
            case M_RGP:
                count = readUInt(line, 6, 3);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    index = readMolfileInt(line, st) - 1;
                    int number = readMolfileInt(line, st + 4);
                    label(container, offset + index, ""R"" + number);
                }
                break;
            case M_ZZC:
                if (mode == Mode.STRICT) {
                    throw new CDKException(""Atom property ZZC is illegal in STRICT mode"");
                }
                index = readMolfileInt(line, 7) - 1;
                String atomLabel = line.substring(11);
                container.getAtom(offset + index).setProperty(CDKConstants.ACDLABS_LABEL, atomLabel);
                break;
            case M_STY:
                count = readMolfileInt(line, 6);
                for (int i = 0; i < count; i++) {
                    lnOffset = 10 + (i * 8);
                    index = readMolfileInt(line, lnOffset);
                    if (mode == Mode.STRICT && sgroups.containsKey(index))
                        handleError(""STY line must appear before any other line that supplies Sgroup information"");
                    sgroup = new Sgroup();
                    sgroups.put(index, sgroup);
                    SgroupType type = SgroupType.parseCtabKey(line.substring(lnOffset + 4, lnOffset + 7));
                    if (type != null)
                        sgroup.setType(type);
                }
                break;
            case M_SST:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    if (mode == Mode.STRICT && sgroup.getType() != SgroupType.CtabCopolymer)
                        handleError(""SST (Sgroup Subtype) specified for a non co-polymer group"");
                    String sst = line.substring(st + 4, st + 7);
                    if (mode == Mode.STRICT && !(""ALT"".equals(sst) || ""RAN"".equals(sst) || ""BLO"".equals(sst)))
                        handleError(""Invalid sgroup subtype: "" + sst + "" expected (ALT, RAN, or BLO)"");
                    sgroup.putValue(SgroupKey.CtabSubType, sst);
                }
                break;
            case M_SAL:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                count = readMolfileInt(line, 10);
                for (int i = 0, st = 14; i < count && st + 3 <= length; i++, st += 4) {
                    index = readMolfileInt(line, st) - 1;
                    sgroup.addAtom(container.getAtom(offset + index));
                }
                break;
            case M_SBL:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                count = readMolfileInt(line, 10);
                for (int i = 0, st = 14; i < count && st + 3 <= length; i++, st += 4) {
                    index = readMolfileInt(line, st) - 1;
                    sgroup.addBond(container.getBond(offset + index));
                }
                break;
            case M_SPL:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 6 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    sgroup.addParent(ensureSgroup(sgroups, readMolfileInt(line, st + 4)));
                }
                break;
            case M_SCN:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 6 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    String con = line.substring(st + 4, Math.min(length, st + 7)).trim();
                    if (mode == Mode.STRICT && !(""HH"".equals(con) || ""HT"".equals(con) || ""EU"".equals(con)))
                        handleError(""Unknown SCN type (expected: HH, HT, or EU) was "" + con);
                    sgroup.putValue(SgroupKey.CtabConnectivity, con);
                }
                break;
            case M_SDI:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                count = readMolfileInt(line, 10);
                assert count == 4;
                sgroup.addBracket(new SgroupBracket(readMDLCoordinate(line, 13), readMDLCoordinate(line, 23), readMDLCoordinate(line, 33), readMDLCoordinate(line, 43)));
                break;
            case M_SMT:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                sgroup.putValue(SgroupKey.CtabSubScript, line.substring(11).trim());
                break;
            case M_SBT:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    sgroup.putValue(SgroupKey.CtabBracketStyle, readMolfileInt(line, st + 4));
                }
                break;
            case M_SDS:
                if (""EXP"".equals(line.substring(7, 10))) {
                    count = readMolfileInt(line, 10);
                    for (int i = 0, st = 14; i < count && st + 3 <= length; i++, st += 4) {
                        sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                        sgroup.putValue(SgroupKey.CtabExpansion, true);
                    }
                } else if (mode == Mode.STRICT) {
                    handleError(""Expected EXP to follow SDS tag"");
                }
                break;
            case M_SPA:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                count = readMolfileInt(line, 10);
                Collection<IAtom> parentAtomList = sgroup.getValue(SgroupKey.CtabParentAtomList);
                if (parentAtomList == null) {
                    sgroup.putValue(SgroupKey.CtabParentAtomList, parentAtomList = new HashSet<IAtom>());
                }
                for (int i = 0, st = 14; i < count && st + 3 <= length; i++, st += 4) {
                    index = readMolfileInt(line, st) - 1;
                    parentAtomList.add(container.getAtom(offset + index));
                }
                break;
            case M_SNC:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    sgroup.putValue(SgroupKey.CtabComponentNumber, readMolfileInt(line, st + 4));
                }
                break;
            case M_SDT:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                if (length < 11)
                    break;
                String name = line.substring(11, Math.min(41, length)).trim();
                sgroup.putValue(SgroupKey.DataFieldName, name);
                if (length < 41)
                    break;
                String fmt = line.substring(41, Math.min(43, length)).trim();
                if (fmt.length() == 1 && fmt.charAt(0) != 'F' && fmt.charAt(0) != 'N' && fmt.charAt(0) != 'T')
                    handleError(""Invalid Data Sgroup field format: "" + fmt);
                if (!fmt.isEmpty())
                    sgroup.putValue(SgroupKey.DataFieldFormat, fmt);
                if (length < 43)
                    break;
                String units = line.substring(43, Math.min(63, length)).trim();
                if (!units.isEmpty())
                    sgroup.putValue(SgroupKey.DataFieldUnits, units);
                break;
            case M_SDD:
                break;
            case M_SCD:
            case M_SED:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                String data = line.substring(11, Math.min(79, length));
                String curr = sgroup.getValue(SgroupKey.Data);
                if (curr != null)
                    data = curr + data;
                sgroup.putValue(SgroupKey.Data, data);
                break;
            case M_END:
                break LINES;
        }
    }
    for (IAtom atom : container.atoms()) {
        if (atom.getMassNumber() != null && atom.getMassNumber() < 0) {
            handleError(""Unstable use of mass delta on "" + atom.getSymbol() + "" please use M  ISO"");
            atom.setMassNumber(null);
        }
    }
    if (!sgroups.isEmpty()) {
        List<Sgroup> sgroupOrgList = new ArrayList<>(sgroups.values());
        List<Sgroup> sgroupCpyList = new ArrayList<>(sgroupOrgList.size());
        for (int i = 0; i < sgroupOrgList.size(); i++) {
            Sgroup cpy = sgroupOrgList.get(i).downcast();
            sgroupCpyList.add(cpy);
        }
        for (int i = 0; i < sgroupOrgList.size(); i++) {
            Sgroup newSgroup = sgroupCpyList.get(i);
            Set<Sgroup> oldParents = new HashSet<>(newSgroup.getParents());
            newSgroup.removeParents(oldParents);
            for (Sgroup parent : oldParents) {
                newSgroup.addParent(sgroupCpyList.get(sgroupOrgList.indexOf(parent)));
            }
        }
        container.setProperty(CDKConstants.CTAB_SGROUPS, sgroupCpyList);
    }
}","void readPropertiesFast(final BufferedReader input, final IAtomContainer container, final int nAtoms) throws IOException, CDKException{
    String line;
    int offset = container.getAtomCount() - nAtoms;
    Map<Integer, Sgroup> sgroups = new LinkedHashMap<>();
    LINES: while ((line = input.readLine()) != null) {
        int index, count, lnOffset;
        Sgroup sgroup;
        int length = line.length();
        final PropertyKey key = PropertyKey.of(line);
        switch(key) {
            case ATOM_ALIAS:
                index = readMolfileInt(line, 3) - 1;
                final String label = input.readLine();
                if (label == null)
                    return;
                label(container, offset + index, label);
                break;
            case ATOM_VALUE:
                index = readMolfileInt(line, 3) - 1;
                final String comment = line.substring(7);
                container.getAtom(offset + index).setProperty(CDKConstants.COMMENT, comment);
                break;
            case GROUP_ABBREVIATION:
                final String group = input.readLine();
                if (group == null)
                    return;
                break;
            case LEGACY_ATOM_LIST:
                index = readUInt(line, 0, 3) - 1;
                {
                    boolean negate = line.charAt(3) == 'T' || line.charAt(4) == 'T';
                    Expr expr = new Expr(Expr.Type.TRUE);
                    StringBuilder sb = new StringBuilder();
                    for (int i = 11; i < line.length(); i += 4) {
                        int atomicNumber = readUInt(line, i, 3);
                        expr.or(new Expr(Expr.Type.ELEMENT, atomicNumber));
                    }
                    if (negate)
                        expr.negate();
                    IAtom atom = container.getAtom(index);
                    if (AtomRef.deref(atom) instanceof QueryAtom) {
                        QueryAtom ref = (QueryAtom) AtomRef.deref(atom);
                        ref.setExpression(expr);
                    } else {
                        QueryAtom queryAtom = new QueryAtom(expr);
                        queryAtom.setPoint2d(atom.getPoint2d());
                        queryAtom.setPoint3d(atom.getPoint3d());
                        container.setAtom(index, queryAtom);
                    }
                }
                break;
            case M_ALS:
                index = readUInt(line, 7, 3) - 1;
                {
                    boolean negate = line.charAt(13) == 'T' || line.charAt(14) == 'T';
                    Expr expr = new Expr(Expr.Type.TRUE);
                    StringBuilder sb = new StringBuilder();
                    for (int i = 16; i < line.length(); i++) {
                        if (line.charAt(i) != ' ') {
                            sb.append(line.charAt(i));
                        } else if (sb.length() != 0) {
                            int elem = Elements.ofString(sb.toString()).number();
                            if (elem != 0)
                                expr.or(new Expr(Expr.Type.ELEMENT, elem));
                            sb.setLength(0);
                        }
                    }
                    if (sb.length() != 0) {
                        int elem = Elements.ofString(sb.toString()).number();
                        if (elem != 0)
                            expr.or(new Expr(Expr.Type.ELEMENT, elem));
                    }
                    if (negate)
                        expr.negate();
                    IAtom atom = container.getAtom(index);
                    if (AtomRef.deref(atom) instanceof QueryAtom) {
                        QueryAtom ref = (QueryAtom) AtomRef.deref(atom);
                        ref.setExpression(expr);
                    } else {
                        QueryAtom queryAtom = new QueryAtom(expr);
                        queryAtom.setPoint2d(atom.getPoint2d());
                        queryAtom.setPoint3d(atom.getPoint3d());
                        container.setAtom(index, queryAtom);
                    }
                }
                break;
            case M_CHG:
                count = readUInt(line, 6, 3);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    index = readMolfileInt(line, st) - 1;
                    int charge = readMolfileInt(line, st + 4);
                    container.getAtom(offset + index).setFormalCharge(charge);
                }
                break;
            case M_ISO:
                count = readUInt(line, 6, 3);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    index = readMolfileInt(line, st) - 1;
                    int mass = readMolfileInt(line, st + 4);
                    if (mass < 0)
                        handleError(""Absolute mass number should be >= 0, "" + line);
                    else
                        container.getAtom(offset + index).setMassNumber(mass);
                }
                break;
            case M_RAD:
                count = readUInt(line, 6, 3);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    index = readMolfileInt(line, st) - 1;
                    int value = readMolfileInt(line, st + 4);
                    SPIN_MULTIPLICITY multiplicity = SPIN_MULTIPLICITY.ofValue(value);
                    container.getAtom(offset + index).setProperty(CDKConstants.SPIN_MULTIPLICITY, multiplicity);
                    for (int e = 0; e < multiplicity.getSingleElectrons(); e++) container.addSingleElectron(offset + index);
                }
                break;
            case M_RGP:
                count = readUInt(line, 6, 3);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    index = readMolfileInt(line, st) - 1;
                    int number = readMolfileInt(line, st + 4);
                    label(container, offset + index, ""R"" + number);
                }
                break;
            case M_ZZC:
                if (mode == Mode.STRICT) {
                    throw new CDKException(""Atom property ZZC is illegal in STRICT mode"");
                }
                index = readMolfileInt(line, 7) - 1;
                String atomLabel = line.substring(11);
                container.getAtom(offset + index).setProperty(CDKConstants.ACDLABS_LABEL, atomLabel);
                break;
            case M_STY:
                count = readMolfileInt(line, 6);
                for (int i = 0; i < count; i++) {
                    lnOffset = 10 + (i * 8);
                    index = readMolfileInt(line, lnOffset);
                    if (mode == Mode.STRICT && sgroups.containsKey(index))
                        handleError(""STY line must appear before any other line that supplies Sgroup information"");
                    sgroup = new Sgroup();
                    sgroups.put(index, sgroup);
                    SgroupType type = SgroupType.parseCtabKey(line.substring(lnOffset + 4, lnOffset + 7));
                    if (type != null)
                        sgroup.setType(type);
                }
                break;
            case M_SST:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    if (mode == Mode.STRICT && sgroup.getType() != SgroupType.CtabCopolymer)
                        handleError(""SST (Sgroup Subtype) specified for a non co-polymer group"");
                    String sst = line.substring(st + 4, st + 7);
                    if (mode == Mode.STRICT && !(""ALT"".equals(sst) || ""RAN"".equals(sst) || ""BLO"".equals(sst)))
                        handleError(""Invalid sgroup subtype: "" + sst + "" expected (ALT, RAN, or BLO)"");
                    sgroup.putValue(SgroupKey.CtabSubType, sst);
                }
                break;
            case M_SAL:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                count = readMolfileInt(line, 10);
                for (int i = 0, st = 14; i < count && st + 3 <= length; i++, st += 4) {
                    index = readMolfileInt(line, st) - 1;
                    sgroup.addAtom(container.getAtom(offset + index));
                }
                break;
            case M_SBL:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                count = readMolfileInt(line, 10);
                for (int i = 0, st = 14; i < count && st + 3 <= length; i++, st += 4) {
                    index = readMolfileInt(line, st) - 1;
                    sgroup.addBond(container.getBond(offset + index));
                }
                break;
            case M_SPL:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 6 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    sgroup.addParent(ensureSgroup(sgroups, readMolfileInt(line, st + 4)));
                }
                break;
            case M_SCN:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 6 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    String con = line.substring(st + 4, Math.min(length, st + 7)).trim();
                    if (mode == Mode.STRICT && !(""HH"".equals(con) || ""HT"".equals(con) || ""EU"".equals(con)))
                        handleError(""Unknown SCN type (expected: HH, HT, or EU) was "" + con);
                    sgroup.putValue(SgroupKey.CtabConnectivity, con);
                }
                break;
            case M_SDI:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                count = readMolfileInt(line, 10);
                assert count == 4;
                sgroup.addBracket(new SgroupBracket(readMDLCoordinate(line, 13), readMDLCoordinate(line, 23), readMDLCoordinate(line, 33), readMDLCoordinate(line, 43)));
                break;
            case M_SMT:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                sgroup.putValue(SgroupKey.CtabSubScript, line.substring(11).trim());
                break;
            case M_SBT:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    sgroup.putValue(SgroupKey.CtabBracketStyle, readMolfileInt(line, st + 4));
                }
                break;
            case M_SDS:
                if (""EXP"".equals(line.substring(7, 10))) {
                    count = readMolfileInt(line, 10);
                    for (int i = 0, st = 14; i < count && st + 3 <= length; i++, st += 4) {
                        sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                        sgroup.putValue(SgroupKey.CtabExpansion, true);
                    }
                } else if (mode == Mode.STRICT) {
                    handleError(""Expected EXP to follow SDS tag"");
                }
                break;
            case M_SPA:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                count = readMolfileInt(line, 10);
                Collection<IAtom> parentAtomList = sgroup.getValue(SgroupKey.CtabParentAtomList);
                if (parentAtomList == null) {
                    sgroup.putValue(SgroupKey.CtabParentAtomList, parentAtomList = new HashSet<IAtom>());
                }
                for (int i = 0, st = 14; i < count && st + 3 <= length; i++, st += 4) {
                    index = readMolfileInt(line, st) - 1;
                    parentAtomList.add(container.getAtom(offset + index));
                }
                break;
            case M_SNC:
                count = readMolfileInt(line, 6);
                for (int i = 0, st = 10; i < count && st + 7 <= length; i++, st += 8) {
                    sgroup = ensureSgroup(sgroups, readMolfileInt(line, st));
                    sgroup.putValue(SgroupKey.CtabComponentNumber, readMolfileInt(line, st + 4));
                }
                break;
            case M_SDT:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                if (length < 11)
                    break;
                String name = line.substring(11, Math.min(41, length)).trim();
                sgroup.putValue(SgroupKey.DataFieldName, name);
                if (length < 41)
                    break;
                String fmt = line.substring(41, Math.min(43, length)).trim();
                if (fmt.length() == 1 && fmt.charAt(0) != 'F' && fmt.charAt(0) != 'N' && fmt.charAt(0) != 'T')
                    handleError(""Invalid Data Sgroup field format: "" + fmt);
                if (!fmt.isEmpty())
                    sgroup.putValue(SgroupKey.DataFieldFormat, fmt);
                if (length < 43)
                    break;
                String units = line.substring(43, Math.min(63, length)).trim();
                if (!units.isEmpty())
                    sgroup.putValue(SgroupKey.DataFieldUnits, units);
                break;
            case M_SDD:
                break;
            case M_SCD:
            case M_SED:
                sgroup = ensureSgroup(sgroups, readMolfileInt(line, 7));
                String data = line.substring(11, Math.min(79, length));
                String curr = sgroup.getValue(SgroupKey.Data);
                if (curr != null)
                    data = curr + data;
                sgroup.putValue(SgroupKey.Data, data);
                break;
            case M_END:
                break LINES;
        }
    }
    for (IAtom atom : container.atoms()) {
        if (atom.getMassNumber() != null && atom.getMassNumber() < 0) {
            handleError(""Unstable use of mass delta on "" + atom.getSymbol() + "" please use M  ISO"");
            atom.setMassNumber(null);
        }
    }
    if (!sgroups.isEmpty()) {
        List<Sgroup> sgroupOrgList = new ArrayList<>(sgroups.values());
        List<Sgroup> sgroupCpyList = new ArrayList<>(sgroupOrgList.size());
        for (int i = 0; i < sgroupOrgList.size(); i++) {
            Sgroup cpy = sgroupOrgList.get(i).downcast();
            sgroupCpyList.add(cpy);
        }
        for (int i = 0; i < sgroupOrgList.size(); i++) {
            Sgroup newSgroup = sgroupCpyList.get(i);
            Set<Sgroup> oldParents = new HashSet<>(newSgroup.getParents());
            newSgroup.removeParents(oldParents);
            for (Sgroup parent : oldParents) {
                newSgroup.addParent(sgroupCpyList.get(sgroupOrgList.indexOf(parent)));
            }
        }
        container.setProperty(CDKConstants.CTAB_SGROUPS, sgroupCpyList);
    }
}","/**
     * Reads the property block from the {@code input} setting the values in the
     * container.
     *
     * @param input     input resource
     * @param container the structure with atoms / bonds present
     * @param nAtoms    the number of atoms in the atoms block
     * @throws IOException low-level IO error
     */","('readPropertiesFast', {'INSTRUCTION': {'covered': 1184, 'missed': 129}, 'BRANCH': {'covered': 143, 'missed': 50}, 'LINE': {'covered': 225, 'missed': 18}, 'COMPLEXITY': {'covered': 66, 'missed': 44}, 'METHOD': {'covered': 1, 'missed': 0}})",2851.0,  Reads the property block from the {@code input} setting the values in the  container.,18.0,"['The property block is read from the code input.', 'The property block is read from the code input to set the values.', 'The property block is read from the @code input.']"
1128,cdk,org/openscience/cdk/io/MDLV2000Writer.java,/storage/ctab/src/main/java/org/openscience/cdk/io/MDLV2000Writer.java,writeMolecule,361-803,"/**
     * Writes a Molecule to an OutputStream in MDL sdf format.
     *
     * @param container Molecule that is written to an OutputStream
     */
public void writeMolecule(IAtomContainer container) throws Exception{
    final int dim = getNumberOfDimensions(container);
    StringBuilder line = new StringBuilder();
    Map<Integer, Integer> rgroups = null;
    Map<Integer, String> aliases = null;
    String title = container.getTitle();
    if (title == null)
        title = """";
    if (title.length() > 80)
        title = title.substring(0, 80);
    writer.write(title);
    writer.write('\n');
    writer.write(""  "");
    writer.write(getProgName());
    writer.write(new SimpleDateFormat(""MMddyyHHmm"").format(System.currentTimeMillis()));
    if (dim != 0) {
        writer.write(Integer.toString(dim));
        writer.write('D');
    }
    writer.write('\n');
    String comment = (String) container.getProperty(CDKConstants.REMARK);
    if (comment == null)
        comment = """";
    if (comment.length() > 80)
        comment = comment.substring(0, 80);
    writer.write(comment);
    writer.write('\n');
    Map<IAtom, ITetrahedralChirality> atomstereo = new HashMap<>();
    Map<IAtom, Integer> atomindex = new HashMap<>();
    for (IStereoElement element : container.stereoElements()) if (element instanceof ITetrahedralChirality)
        atomstereo.put(((ITetrahedralChirality) element).getChiralAtom(), (ITetrahedralChirality) element);
    for (IAtom atom : container.atoms()) atomindex.put(atom, atomindex.size());
    line.append(formatMDLInt(container.getAtomCount(), 3));
    line.append(formatMDLInt(container.getBondCount(), 3));
    Map<Integer, IAtom> atomLists = new LinkedHashMap<>();
    for (int f = 0; f < container.getAtomCount(); f++) {
        if (container.getAtom(f) instanceof IQueryAtom) {
            QueryAtom queryAtom = (QueryAtom) AtomRef.deref(container.getAtom(f));
            Expr expr = queryAtom.getExpression();
            if (isValidAtomListExpression(expr)) {
                atomLists.put(f, container.getAtom(f));
            }
        }
    }
    line.append(formatMDLInt(atomLists.size(), 3));
    line.append(""  0"");
    line.append(getChiralFlag(atomstereo.values()) ? ""  1"" : ""  0"");
    line.append(""  0  0  0  0  0999 V2000"");
    writer.write(line.toString());
    writer.write('\n');
    for (int f = 0; f < container.getAtomCount(); f++) {
        IAtom atom = container.getAtom(f);
        line.setLength(0);
        switch(dim) {
            case 0:
                line.append(""    0.0000    0.0000    0.0000 "");
                break;
            case 2:
                if (atom.getPoint2d() != null) {
                    line.append(formatMDLFloat((float) atom.getPoint2d().x));
                    line.append(formatMDLFloat((float) atom.getPoint2d().y));
                    line.append(""    0.0000 "");
                } else {
                    line.append(""    0.0000    0.0000    0.0000 "");
                }
                break;
            case 3:
                if (atom.getPoint3d() != null) {
                    line.append(formatMDLFloat((float) atom.getPoint3d().x));
                    line.append(formatMDLFloat((float) atom.getPoint3d().y));
                    line.append(formatMDLFloat((float) atom.getPoint3d().z)).append("" "");
                } else {
                    line.append(""    0.0000    0.0000    0.0000 "");
                }
                break;
        }
        if (container.getAtom(f) instanceof IPseudoAtom) {
            IPseudoAtom pseudoAtom = (IPseudoAtom) container.getAtom(f);
            String label = pseudoAtom.getLabel();
            if (label == null)
                label = """";
            Matcher matcher = NUMERED_R_GROUP.matcher(label);
            if (""R"".equals(pseudoAtom.getSymbol()) && !label.isEmpty() && matcher.matches()) {
                line.append(""R# "");
                if (rgroups == null) {
                    rgroups = new TreeMap<Integer, Integer>();
                }
                rgroups.put(f + 1, Integer.parseInt(matcher.group(1)));
            } else {
                if (label.length() > 3) {
                    if (aliases == null)
                        aliases = new TreeMap<Integer, String>();
                    aliases.put(f + 1, label);
                    line.append(formatMDLString(atom.getSymbol(), 3));
                } else {
                    if (!label.isEmpty())
                        line.append(formatMDLString(label, 3));
                    else
                        line.append(formatMDLString(atom.getSymbol(), 3));
                }
            }
        } else if (atomLists.containsKey(f)) {
            line.append(formatMDLString(""L"", 3));
        } else {
            line.append(formatMDLString(container.getAtom(f).getSymbol(), 3));
        }
        int[] atomprops = new int[12];
        atomprops[0] = determineIsotope(atom);
        atomprops[1] = determineCharge(container, atom);
        atomprops[2] = determineStereoParity(container, atomstereo, atomindex, atom);
        atomprops[5] = determineValence(container, atom);
        atomprops[9] = determineAtomMap(atom);
        line.append(formatMDLInt(atomprops[0], 2));
        line.append(formatMDLInt(atomprops[1], 3));
        int last = atomprops.length - 1;
        if (!writeDefaultProps.isSet()) {
            while (last >= 0) {
                if (atomprops[last] != 0)
                    break;
                last--;
            }
            if (last >= 2 && last < 5)
                last = 5;
        }
        for (int i = 2; i <= last; i++) line.append(formatMDLInt(atomprops[i], 3));
        line.append('\n');
        writer.write(line.toString());
    }
    for (IBond bond : container.bonds()) {
        line.setLength(0);
        if (bond.getAtomCount() != 2) {
            logger.warn(""Skipping bond with more/less than two atoms: "" + bond);
        } else {
            if (bond.getStereo() == IBond.Stereo.UP_INVERTED || bond.getStereo() == IBond.Stereo.DOWN_INVERTED || bond.getStereo() == IBond.Stereo.UP_OR_DOWN_INVERTED) {
                line.append(formatMDLInt(atomindex.get(bond.getEnd()) + 1, 3));
                line.append(formatMDLInt(atomindex.get(bond.getBegin()) + 1, 3));
            } else {
                line.append(formatMDLInt(atomindex.get(bond.getBegin()) + 1, 3));
                line.append(formatMDLInt(atomindex.get(bond.getEnd()) + 1, 3));
            }
            int bondType = 0;
            if (bond instanceof QueryBond) {
                QueryBond qbond = ((QueryBond) bond);
                Expr e = qbond.getExpression();
                switch(e.type()) {
                    case ALIPHATIC_ORDER:
                    case ORDER:
                        bondType = e.value();
                        break;
                    case IS_AROMATIC:
                        bondType = 4;
                        break;
                    case SINGLE_OR_DOUBLE:
                        bondType = 5;
                        break;
                    case SINGLE_OR_AROMATIC:
                        bondType = 6;
                        break;
                    case DOUBLE_OR_AROMATIC:
                        bondType = 7;
                        break;
                    case TRUE:
                        bondType = 8;
                        break;
                    case OR:
                        if (e.equals(new Expr(Expr.Type.ALIPHATIC_ORDER, 1).or(new Expr(Expr.Type.ALIPHATIC_ORDER, 2))) || e.equals(new Expr(Expr.Type.ALIPHATIC_ORDER, 2).or(new Expr(Expr.Type.ALIPHATIC_ORDER, 1))))
                            bondType = 5;
                        else if (e.equals(new Expr(Expr.Type.ALIPHATIC_ORDER, 1).or(new Expr(Expr.Type.IS_AROMATIC))) || e.equals(new Expr(Expr.Type.IS_AROMATIC).or(new Expr(Expr.Type.ALIPHATIC_ORDER, 1))))
                            bondType = 6;
                        else if (e.equals(new Expr(Expr.Type.ALIPHATIC_ORDER, 2).or(new Expr(Expr.Type.IS_AROMATIC))) || e.equals(new Expr(Expr.Type.IS_AROMATIC).or(new Expr(Expr.Type.ALIPHATIC_ORDER, 2))))
                            bondType = 6;
                        break;
                    default:
                        throw new IllegalArgumentException(""Unsupported bond type!"");
                }
            } else {
                if (bond.getOrder() != null) {
                    switch(bond.getOrder()) {
                        case SINGLE:
                        case DOUBLE:
                        case TRIPLE:
                            if (writeAromaticBondTypes.isSet() && bond.isAromatic())
                                bondType = 4;
                            else
                                bondType = bond.getOrder().numeric();
                            break;
                        case UNSET:
                            if (bond.isAromatic()) {
                                if (!writeAromaticBondTypes.isSet())
                                    throw new CDKException(""Bond at idx "" + container.indexOf(bond) + "" was an unspecific aromatic bond which should only be used for queries in Molfiles. These can be written if desired by enabling the option 'WriteAromaticBondTypes'."");
                                bondType = 4;
                            }
                            break;
                    }
                }
            }
            if (bondType == 0)
                throw new CDKException(""Bond at idx="" + container.indexOf(bond) + "" is not supported by Molfile, bond="" + bond.getOrder());
            line.append(formatMDLInt(bondType, 3));
            line.append(""  "");
            switch(bond.getStereo()) {
                case UP:
                    line.append(""1"");
                    break;
                case UP_INVERTED:
                    line.append(""1"");
                    break;
                case DOWN:
                    line.append(""6"");
                    break;
                case DOWN_INVERTED:
                    line.append(""6"");
                    break;
                case UP_OR_DOWN:
                    line.append(""4"");
                    break;
                case UP_OR_DOWN_INVERTED:
                    line.append(""4"");
                    break;
                case E_OR_Z:
                    line.append(""3"");
                    break;
                default:
                    line.append(""0"");
            }
            if (writeDefaultProps.isSet())
                line.append(""  0  0  0"");
            line.append('\n');
            writer.write(line.toString());
        }
    }
    for (int i = 0; i < container.getAtomCount(); i++) {
        IAtom atom = container.getAtom(i);
        if (atom.getProperty(CDKConstants.COMMENT) != null && atom.getProperty(CDKConstants.COMMENT) instanceof String && !((String) atom.getProperty(CDKConstants.COMMENT)).trim().equals("""")) {
            writer.write(""V  "");
            writer.write(formatMDLInt(i + 1, 3));
            writer.write("" "");
            writer.write((String) atom.getProperty(CDKConstants.COMMENT));
            writer.write('\n');
        }
    }
    for (int i = 0; i < container.getAtomCount(); i++) {
        IAtom atom = container.getAtom(i);
        Integer charge = atom.getFormalCharge();
        if (charge != null && charge != 0) {
            writer.write(""M  CHG  1 "");
            writer.write(formatMDLInt(i + 1, 3));
            writer.write("" "");
            writer.write(formatMDLInt(charge, 3));
            writer.write('\n');
        }
    }
    if (container.getSingleElectronCount() > 0) {
        Map<Integer, SPIN_MULTIPLICITY> atomIndexSpinMap = new LinkedHashMap<Integer, SPIN_MULTIPLICITY>();
        for (int i = 0; i < container.getAtomCount(); i++) {
            IAtom atom = container.getAtom(i);
            int eCount = container.getConnectedSingleElectronsCount(atom);
            switch(eCount) {
                case 0:
                    continue;
                case 1:
                    atomIndexSpinMap.put(i, SPIN_MULTIPLICITY.Monovalent);
                    break;
                case 2:
                    SPIN_MULTIPLICITY multiplicity = atom.getProperty(CDKConstants.SPIN_MULTIPLICITY);
                    if (multiplicity != null)
                        atomIndexSpinMap.put(i, multiplicity);
                    else {
                        atomIndexSpinMap.put(i, SPIN_MULTIPLICITY.DivalentSinglet);
                    }
                    break;
                default:
                    logger.debug(""Invalid number of radicals found: "" + eCount);
                    break;
            }
        }
        Iterator<Map.Entry<Integer, SPIN_MULTIPLICITY>> iterator = atomIndexSpinMap.entrySet().iterator();
        for (int i = 0; i < atomIndexSpinMap.size(); i += NN8) {
            if (atomIndexSpinMap.size() - i <= NN8) {
                writer.write(""M  RAD"" + formatMDLInt(atomIndexSpinMap.size() - i, WIDTH));
                writeRadicalPattern(iterator, 0);
            } else {
                writer.write(""M  RAD"" + formatMDLInt(NN8, WIDTH));
                writeRadicalPattern(iterator, 0);
            }
            writer.write('\n');
        }
    }
    for (int i = 0; i < container.getAtomCount(); i++) {
        IAtom atom = container.getAtom(i);
        if (!(atom instanceof IPseudoAtom)) {
            Integer atomicMass = atom.getMassNumber();
            if (!writeMajorIsotopes.isSet() && isMajorIsotope(atom))
                atomicMass = null;
            if (atomicMass != null) {
                writer.write(""M  ISO  1 "");
                writer.write(formatMDLInt(i + 1, 3));
                writer.write("" "");
                writer.write(formatMDLInt(atomicMass, 3));
                writer.write('\n');
            }
        }
    }
    if (rgroups != null) {
        StringBuilder rgpLine = new StringBuilder();
        int cnt = 0;
        for (Map.Entry<Integer, Integer> e : rgroups.entrySet()) {
            rgpLine.append(formatMDLInt(e.getKey(), 4));
            rgpLine.append(formatMDLInt(e.getValue(), 4));
            cnt++;
            if (cnt == 8) {
                rgpLine.insert(0, ""M  RGP"" + formatMDLInt(cnt, 3));
                writer.write(rgpLine.toString());
                writer.write('\n');
                rgpLine = new StringBuilder();
                cnt = 0;
            }
        }
        if (cnt != 0) {
            rgpLine.insert(0, ""M  RGP"" + formatMDLInt(cnt, 3));
            writer.write(rgpLine.toString());
            writer.write('\n');
        }
    }
    if (aliases != null) {
        for (Map.Entry<Integer, String> e : aliases.entrySet()) {
            writer.write(""A"" + formatMDLInt(e.getKey(), 5));
            writer.write('\n');
            String label = e.getValue();
            if (label.length() > 70)
                label = label.substring(0, 70);
            writer.write(label);
            writer.write('\n');
        }
    }
    writeAtomLists(atomLists, writer);
    writeSgroups(container, writer, atomindex);
    writer.write(""M  END"");
    writer.write('\n');
    writer.flush();
}","public void writeMolecule(IAtomContainer container) throws Exception{
    final int dim = getNumberOfDimensions(container);
    StringBuilder line = new StringBuilder();
    Map<Integer, Integer> rgroups = null;
    Map<Integer, String> aliases = null;
    String title = container.getTitle();
    if (title == null)
        title = """";
    if (title.length() > 80)
        title = title.substring(0, 80);
    writer.write(title);
    writer.write('\n');
    writer.write(""  "");
    writer.write(getProgName());
    writer.write(new SimpleDateFormat(""MMddyyHHmm"").format(System.currentTimeMillis()));
    if (dim != 0) {
        writer.write(Integer.toString(dim));
        writer.write('D');
    }
    writer.write('\n');
    String comment = (String) container.getProperty(CDKConstants.REMARK);
    if (comment == null)
        comment = """";
    if (comment.length() > 80)
        comment = comment.substring(0, 80);
    writer.write(comment);
    writer.write('\n');
    Map<IAtom, ITetrahedralChirality> atomstereo = new HashMap<>();
    Map<IAtom, Integer> atomindex = new HashMap<>();
    for (IStereoElement element : container.stereoElements()) if (element instanceof ITetrahedralChirality)
        atomstereo.put(((ITetrahedralChirality) element).getChiralAtom(), (ITetrahedralChirality) element);
    for (IAtom atom : container.atoms()) atomindex.put(atom, atomindex.size());
    line.append(formatMDLInt(container.getAtomCount(), 3));
    line.append(formatMDLInt(container.getBondCount(), 3));
    Map<Integer, IAtom> atomLists = new LinkedHashMap<>();
    for (int f = 0; f < container.getAtomCount(); f++) {
        if (container.getAtom(f) instanceof IQueryAtom) {
            QueryAtom queryAtom = (QueryAtom) AtomRef.deref(container.getAtom(f));
            Expr expr = queryAtom.getExpression();
            if (isValidAtomListExpression(expr)) {
                atomLists.put(f, container.getAtom(f));
            }
        }
    }
    line.append(formatMDLInt(atomLists.size(), 3));
    line.append(""  0"");
    line.append(getChiralFlag(atomstereo.values()) ? ""  1"" : ""  0"");
    line.append(""  0  0  0  0  0999 V2000"");
    writer.write(line.toString());
    writer.write('\n');
    for (int f = 0; f < container.getAtomCount(); f++) {
        IAtom atom = container.getAtom(f);
        line.setLength(0);
        switch(dim) {
            case 0:
                line.append(""    0.0000    0.0000    0.0000 "");
                break;
            case 2:
                if (atom.getPoint2d() != null) {
                    line.append(formatMDLFloat((float) atom.getPoint2d().x));
                    line.append(formatMDLFloat((float) atom.getPoint2d().y));
                    line.append(""    0.0000 "");
                } else {
                    line.append(""    0.0000    0.0000    0.0000 "");
                }
                break;
            case 3:
                if (atom.getPoint3d() != null) {
                    line.append(formatMDLFloat((float) atom.getPoint3d().x));
                    line.append(formatMDLFloat((float) atom.getPoint3d().y));
                    line.append(formatMDLFloat((float) atom.getPoint3d().z)).append("" "");
                } else {
                    line.append(""    0.0000    0.0000    0.0000 "");
                }
                break;
        }
        if (container.getAtom(f) instanceof IPseudoAtom) {
            IPseudoAtom pseudoAtom = (IPseudoAtom) container.getAtom(f);
            String label = pseudoAtom.getLabel();
            if (label == null)
                label = """";
            Matcher matcher = NUMERED_R_GROUP.matcher(label);
            if (""R"".equals(pseudoAtom.getSymbol()) && !label.isEmpty() && matcher.matches()) {
                line.append(""R# "");
                if (rgroups == null) {
                    rgroups = new TreeMap<Integer, Integer>();
                }
                rgroups.put(f + 1, Integer.parseInt(matcher.group(1)));
            } else {
                if (label.length() > 3) {
                    if (aliases == null)
                        aliases = new TreeMap<Integer, String>();
                    aliases.put(f + 1, label);
                    line.append(formatMDLString(atom.getSymbol(), 3));
                } else {
                    if (!label.isEmpty())
                        line.append(formatMDLString(label, 3));
                    else
                        line.append(formatMDLString(atom.getSymbol(), 3));
                }
            }
        } else if (atomLists.containsKey(f)) {
            line.append(formatMDLString(""L"", 3));
        } else {
            line.append(formatMDLString(container.getAtom(f).getSymbol(), 3));
        }
        int[] atomprops = new int[12];
        atomprops[0] = determineIsotope(atom);
        atomprops[1] = determineCharge(container, atom);
        atomprops[2] = determineStereoParity(container, atomstereo, atomindex, atom);
        atomprops[5] = determineValence(container, atom);
        atomprops[9] = determineAtomMap(atom);
        line.append(formatMDLInt(atomprops[0], 2));
        line.append(formatMDLInt(atomprops[1], 3));
        int last = atomprops.length - 1;
        if (!writeDefaultProps.isSet()) {
            while (last >= 0) {
                if (atomprops[last] != 0)
                    break;
                last--;
            }
            if (last >= 2 && last < 5)
                last = 5;
        }
        for (int i = 2; i <= last; i++) line.append(formatMDLInt(atomprops[i], 3));
        line.append('\n');
        writer.write(line.toString());
    }
    for (IBond bond : container.bonds()) {
        line.setLength(0);
        if (bond.getAtomCount() != 2) {
            logger.warn(""Skipping bond with more/less than two atoms: "" + bond);
        } else {
            if (bond.getStereo() == IBond.Stereo.UP_INVERTED || bond.getStereo() == IBond.Stereo.DOWN_INVERTED || bond.getStereo() == IBond.Stereo.UP_OR_DOWN_INVERTED) {
                line.append(formatMDLInt(atomindex.get(bond.getEnd()) + 1, 3));
                line.append(formatMDLInt(atomindex.get(bond.getBegin()) + 1, 3));
            } else {
                line.append(formatMDLInt(atomindex.get(bond.getBegin()) + 1, 3));
                line.append(formatMDLInt(atomindex.get(bond.getEnd()) + 1, 3));
            }
            int bondType = 0;
            if (bond instanceof QueryBond) {
                QueryBond qbond = ((QueryBond) bond);
                Expr e = qbond.getExpression();
                switch(e.type()) {
                    case ALIPHATIC_ORDER:
                    case ORDER:
                        bondType = e.value();
                        break;
                    case IS_AROMATIC:
                        bondType = 4;
                        break;
                    case SINGLE_OR_DOUBLE:
                        bondType = 5;
                        break;
                    case SINGLE_OR_AROMATIC:
                        bondType = 6;
                        break;
                    case DOUBLE_OR_AROMATIC:
                        bondType = 7;
                        break;
                    case TRUE:
                        bondType = 8;
                        break;
                    case OR:
                        if (e.equals(new Expr(Expr.Type.ALIPHATIC_ORDER, 1).or(new Expr(Expr.Type.ALIPHATIC_ORDER, 2))) || e.equals(new Expr(Expr.Type.ALIPHATIC_ORDER, 2).or(new Expr(Expr.Type.ALIPHATIC_ORDER, 1))))
                            bondType = 5;
                        else if (e.equals(new Expr(Expr.Type.ALIPHATIC_ORDER, 1).or(new Expr(Expr.Type.IS_AROMATIC))) || e.equals(new Expr(Expr.Type.IS_AROMATIC).or(new Expr(Expr.Type.ALIPHATIC_ORDER, 1))))
                            bondType = 6;
                        else if (e.equals(new Expr(Expr.Type.ALIPHATIC_ORDER, 2).or(new Expr(Expr.Type.IS_AROMATIC))) || e.equals(new Expr(Expr.Type.IS_AROMATIC).or(new Expr(Expr.Type.ALIPHATIC_ORDER, 2))))
                            bondType = 6;
                        break;
                    default:
                        throw new IllegalArgumentException(""Unsupported bond type!"");
                }
            } else {
                if (bond.getOrder() != null) {
                    switch(bond.getOrder()) {
                        case SINGLE:
                        case DOUBLE:
                        case TRIPLE:
                            if (writeAromaticBondTypes.isSet() && bond.isAromatic())
                                bondType = 4;
                            else
                                bondType = bond.getOrder().numeric();
                            break;
                        case UNSET:
                            if (bond.isAromatic()) {
                                if (!writeAromaticBondTypes.isSet())
                                    throw new CDKException(""Bond at idx "" + container.indexOf(bond) + "" was an unspecific aromatic bond which should only be used for queries in Molfiles. These can be written if desired by enabling the option 'WriteAromaticBondTypes'."");
                                bondType = 4;
                            }
                            break;
                    }
                }
            }
            if (bondType == 0)
                throw new CDKException(""Bond at idx="" + container.indexOf(bond) + "" is not supported by Molfile, bond="" + bond.getOrder());
            line.append(formatMDLInt(bondType, 3));
            line.append(""  "");
            switch(bond.getStereo()) {
                case UP:
                    line.append(""1"");
                    break;
                case UP_INVERTED:
                    line.append(""1"");
                    break;
                case DOWN:
                    line.append(""6"");
                    break;
                case DOWN_INVERTED:
                    line.append(""6"");
                    break;
                case UP_OR_DOWN:
                    line.append(""4"");
                    break;
                case UP_OR_DOWN_INVERTED:
                    line.append(""4"");
                    break;
                case E_OR_Z:
                    line.append(""3"");
                    break;
                default:
                    line.append(""0"");
            }
            if (writeDefaultProps.isSet())
                line.append(""  0  0  0"");
            line.append('\n');
            writer.write(line.toString());
        }
    }
    for (int i = 0; i < container.getAtomCount(); i++) {
        IAtom atom = container.getAtom(i);
        if (atom.getProperty(CDKConstants.COMMENT) != null && atom.getProperty(CDKConstants.COMMENT) instanceof String && !((String) atom.getProperty(CDKConstants.COMMENT)).trim().equals("""")) {
            writer.write(""V  "");
            writer.write(formatMDLInt(i + 1, 3));
            writer.write("" "");
            writer.write((String) atom.getProperty(CDKConstants.COMMENT));
            writer.write('\n');
        }
    }
    for (int i = 0; i < container.getAtomCount(); i++) {
        IAtom atom = container.getAtom(i);
        Integer charge = atom.getFormalCharge();
        if (charge != null && charge != 0) {
            writer.write(""M  CHG  1 "");
            writer.write(formatMDLInt(i + 1, 3));
            writer.write("" "");
            writer.write(formatMDLInt(charge, 3));
            writer.write('\n');
        }
    }
    if (container.getSingleElectronCount() > 0) {
        Map<Integer, SPIN_MULTIPLICITY> atomIndexSpinMap = new LinkedHashMap<Integer, SPIN_MULTIPLICITY>();
        for (int i = 0; i < container.getAtomCount(); i++) {
            IAtom atom = container.getAtom(i);
            int eCount = container.getConnectedSingleElectronsCount(atom);
            switch(eCount) {
                case 0:
                    continue;
                case 1:
                    atomIndexSpinMap.put(i, SPIN_MULTIPLICITY.Monovalent);
                    break;
                case 2:
                    SPIN_MULTIPLICITY multiplicity = atom.getProperty(CDKConstants.SPIN_MULTIPLICITY);
                    if (multiplicity != null)
                        atomIndexSpinMap.put(i, multiplicity);
                    else {
                        atomIndexSpinMap.put(i, SPIN_MULTIPLICITY.DivalentSinglet);
                    }
                    break;
                default:
                    logger.debug(""Invalid number of radicals found: "" + eCount);
                    break;
            }
        }
        Iterator<Map.Entry<Integer, SPIN_MULTIPLICITY>> iterator = atomIndexSpinMap.entrySet().iterator();
        for (int i = 0; i < atomIndexSpinMap.size(); i += NN8) {
            if (atomIndexSpinMap.size() - i <= NN8) {
                writer.write(""M  RAD"" + formatMDLInt(atomIndexSpinMap.size() - i, WIDTH));
                writeRadicalPattern(iterator, 0);
            } else {
                writer.write(""M  RAD"" + formatMDLInt(NN8, WIDTH));
                writeRadicalPattern(iterator, 0);
            }
            writer.write('\n');
        }
    }
    for (int i = 0; i < container.getAtomCount(); i++) {
        IAtom atom = container.getAtom(i);
        if (!(atom instanceof IPseudoAtom)) {
            Integer atomicMass = atom.getMassNumber();
            if (!writeMajorIsotopes.isSet() && isMajorIsotope(atom))
                atomicMass = null;
            if (atomicMass != null) {
                writer.write(""M  ISO  1 "");
                writer.write(formatMDLInt(i + 1, 3));
                writer.write("" "");
                writer.write(formatMDLInt(atomicMass, 3));
                writer.write('\n');
            }
        }
    }
    if (rgroups != null) {
        StringBuilder rgpLine = new StringBuilder();
        int cnt = 0;
        for (Map.Entry<Integer, Integer> e : rgroups.entrySet()) {
            rgpLine.append(formatMDLInt(e.getKey(), 4));
            rgpLine.append(formatMDLInt(e.getValue(), 4));
            cnt++;
            if (cnt == 8) {
                rgpLine.insert(0, ""M  RGP"" + formatMDLInt(cnt, 3));
                writer.write(rgpLine.toString());
                writer.write('\n');
                rgpLine = new StringBuilder();
                cnt = 0;
            }
        }
        if (cnt != 0) {
            rgpLine.insert(0, ""M  RGP"" + formatMDLInt(cnt, 3));
            writer.write(rgpLine.toString());
            writer.write('\n');
        }
    }
    if (aliases != null) {
        for (Map.Entry<Integer, String> e : aliases.entrySet()) {
            writer.write(""A"" + formatMDLInt(e.getKey(), 5));
            writer.write('\n');
            String label = e.getValue();
            if (label.length() > 70)
                label = label.substring(0, 70);
            writer.write(label);
            writer.write('\n');
        }
    }
    writeAtomLists(atomLists, writer);
    writeSgroups(container, writer, atomindex);
    writer.write(""M  END"");
    writer.write('\n');
    writer.flush();
}","/**
     * Writes a Molecule to an OutputStream in MDL sdf format.
     *
     * @param container Molecule that is written to an OutputStream
     */","('writeMolecule', {'INSTRUCTION': {'covered': 1172, 'missed': 195}, 'BRANCH': {'covered': 130, 'missed': 45}, 'LINE': {'covered': 229, 'missed': 33}, 'COMPLEXITY': {'covered': 58, 'missed': 39}, 'METHOD': {'covered': 1, 'missed': 0}})",2943.0,  Writes a Molecule to an OutputStream in MDL sdf format.,11.0,"['A molecule is written to an output stream.', 'A Molecule is written to an OutputStream in the MDL format.', 'A Molecule is written to an OutputStream.']"
